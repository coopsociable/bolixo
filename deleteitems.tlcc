/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	This program deletes stuff in the database while maintaining some integrity
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <tlmplib.h>
#include <tlmpsql.h>
#include <string>
#include <vector>
#include <set>
#include "bolixo.m"
#define DEFINE_TBFTYPE
#include "bolixo.h"

using namespace std;

static bool deleteitems_notin (const vector<bool> &items, unsigned id)
{
	return id >= items.size() || !items[id];
}
static void deleteitems_insert (vector<bool> &items, const char *id)
{
	unsigned itemid = atoi(id);
	if (items.size() < itemid){
		items.resize(itemid+1000000);
	}
	items[itemid] = true;
}
/*
	Collect all ids in table dirs_content and files
*/
<mod>
static void deleteitems_getids (vector<bool> &itemids, bool from_dirs_content, bool from_files)
{
	glocal vector<bool> *itemids = &itemids;
	itemids.clear();
	if (from_dirs_content){
		// Retrieve all used ids
		<call sql_query>("select itemid from dirs_content");
		<f onerow>
			deleteitems_insert (*glocal.itemids,row[0]);
		</f>
		</call>
	}
	if (from_files){
		<call sql_query>("select id from files");
		<f onerow>
			deleteitems_insert (*glocal.itemids,row[0]);
		</f>
		</call>
	}
}
</mod>
static bool verbose = false;
static bool doit = false;
// Delete unused entries in table ids
<mod>
static void deleteitems_table_ids(vector<bool> &itemids)
{
	glocal vector<bool> *itemids = &itemids;
	<call sql_query>("select id from ids");
	<f onerow>
		unsigned id = atoi(row[0]);
		if (deleteitems_notin(*glocal.itemids,id)){
			if (verbose){
				printf ("Itemid %5u must go\n",id);
			}
			if (doit){
				if (sql_action("delete from ids where id=%u",id)==-1){
					tlmp_error ("Delete fail in table ids, aborting: %s\n",query_getdefaultdb()->error());
					exit (-1);
				}
			}
		}
	</f>
	</call>
}
</mod>
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool oldmsgs = false;
	glocal bool integrity = false;
	glocal const char *data_socket = "/var/lib/mysql/mysql.sock";
	glocal const char *data_dbserv = "localhost";
	glocal const char *data_dbname = "files";
	glocal const char *data_dbuser = NULL;

	static const char *tb[]={"bolixo","tlmpsql",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tb);
	<f init>
		setproginfo ("deleteitems",VERSION
			,MSG_U(I_DELETEITEMS
			,"Delete items in the bolixo database."));
		setarg ('o',"oldmsgs",MSG_U(O_OLDMSGS,"Delete old short messages"),glocal.oldmsgs,false);
		setarg ('I',"integrity",MSG_U(O_INTEGRITY,"Perform garbage collection"),glocal.integrity,false);
		setarg (' ',"doit",MSG_U(O_DOIT,"Perform the deletion, not just a test"),doit,false);
		setgrouparg (MSG_R(I_DATABASE));
		setarg (' ',"data_dbserv","Database server",glocal.data_dbserv,false);
		setarg (' ',"data_dbname","Database name",glocal.data_dbname,false);
		setarg (' ',"data_dbuser","Database user",glocal.data_dbuser,true);
		setarg (' ',"data_socket","Database unix socket",glocal.data_socket,false);
		setgrouparg(MSG_R(I_MISC));
		setarg ('v',"verbose",MSG_U(O_VERBOPER,"Verbose operation"),verbose,false);
		
	</f>
	<f main_noarg>
		int ret = -1;
		if (!doit) verbose = true;	// Probably a test
		const char *passwd = getenv("DELETEITEMS_PWD");
		if (passwd == NULL){
			tlmp_error ("Can't get database password from environment, aborting\n");
			exit (-1);
		}
		query_setdefaultdb (glocal.data_dbserv,glocal.data_dbname,glocal.data_dbuser,passwd);
		query_getdefaultdb()->setunixpath(glocal.data_socket);
		if (glocal.integrity){
			glocal vector<bool> userids;
			glocal vector<bool> itemids;
			// Find all userids
			<call sql_query>("select userid from id2name");
			<f onerow>
				// Avoid negative userids
				if (row[0][0] == '-') return;
				deleteitems_insert (glocal.userids,row[0]);
			</f>
			</call>
			// Delete directory entries pointing to deleted/invalid userid
			<call sql_query>("select dirid,itemid,ids.ownerid,dirs_content.name,dirs_content.modified,files.filetype"
				" from dirs_content join ids on dirs_content.itemid=ids.id"
				" left join files on files.id=dirs_content.itemid and files.modified=dirs_content.modified");
			<f onerow>
				unsigned dirid = atoi(row[0]);
				unsigned itemid = atoi(row[1]);
				unsigned ownerid = atoi(row[2]);
				const char *name = row[3];
				const char *modified = row[4];
				const char *filetype = row[5] == nullptr ? "NULL" : tbftype[atoi(row[5])];
				if (deleteitems_notin(glocal.userids,ownerid)){
					if (verbose){
						printf ("directory %5u item %5u ownerid %5u name %-30s modified %s filetype=%s must go\n"
							,dirid,itemid,ownerid,name,modified,filetype);
					}
					if (doit){
						if (sql_action("delete from dirs_content where dirid=%u and itemid=%u and modified='%s'"
							,dirid,itemid,modified)==-1){
							tlmp_error ("Delete fail in table dirs_content, aborting: %s\n",query_getdefaultdb()->error());
							exit (-1);
						}
					}
				}
			</f>
			</call>
			// Delete files entries pointing to deleted/invalid userid
			<call sql_query>("select files.id,ids.ownerid,modified,filetype,content is null"
				" from files join ids on files.id=ids.id");
			<f onerow>
				unsigned ownerid = atoi(row[1]);
				if (deleteitems_notin(glocal.userids,ownerid)){
					unsigned fileid = atoi(row[0]);
					const char *modified = row[2];
					const char *filetype = tbftype[atoi(row[3])];
					bool content_is_null = atoi(row[4]);
					if (verbose){
						printf ("file %5u ownerid %5u modified %s filetype=%s content_is_null %d must go\n"
							,fileid,ownerid,modified,filetype,content_is_null);
						if (content_is_null){
							printf ("Content file %u-%s must go\n",fileid,modified);
						}
					}
					if (doit){
						if (sql_action("delete from files where id=%u and modified='%s'"
							,fileid,modified)==-1){
							tlmp_error ("Delete fail in table files, aborting: %s\n",query_getdefaultdb()->error());
							exit (-1);
						}
						if (content_is_null){
							// We must delete the file content in /var/lib/bolixo
							string path = string_f("/var/lib/bolixo/%u-%s",fileid,modified);
							for (auto &c:path) if (c == ' ') c='-';
							if (unlink(path.c_str())==-1){
								tlmp_error ("Can't delete content file %s (%s)\n",path.c_str(),strerror(errno));
								exit (-1);
							}
						}
					}
				}
			</f>
			</call>
			

			deleteitems_getids(glocal.itemids,true,true);
			deleteitems_table_ids(glocal.itemids);
			// Delete dirs_content entries where dirid has no entry in ids
			// This case happen when we delete an itemid of dirs_content pointing to a deleted userid
			// dirid=parent_dir,itemid=dir1
			// We end up with many lines like this
			// dirid=dir1, ... where dir1 has no entry in ids
			<call sql_query>("select dirid from dirs_content where dirid != 0");
			<f onerow>
				unsigned id = atoi(row[0]);
				if (deleteitems_notin(glocal.itemids,id)){
					if (verbose){
						printf ("Dirid %5u must go\n",id);
					}
					if (doit){
						if (sql_action("delete from dirs_content where dirid=%u",id)==-1){
							tlmp_error ("Delete fail in table dirs_content, aborting: %s\n",query_getdefaultdb()->error());
							exit (-1);
						}
					}
				}
			</f>
			</call>

			// Delete orphan files entries (no directory entry reference them)
			/*
				*** There is a flaw here. If a file is has multiple versions and only one version
				and not all versions are referenced, the following code won't do anything. It will
				keep all versions. This happens becauses we only check if the itemid is referenced,
				not the combination itemid,modified.
			*/
			// First, Retrieve (again) all used referenced itemids
			deleteitems_getids(glocal.itemids,true,false);
			glocal bool deleted_orphan = false;
			<call sql_query>("select id,modified,content is null from files");
			<f onerow>
				unsigned fileid = atoi(row[0]);
				if (deleteitems_notin(glocal.itemids,fileid)){
					if (verbose){
						printf ("Orphan file %5u must go\n",fileid);
					}
					if (doit){
						glocal.deleted_orphan = true;
						if (sql_action("delete from files where id=%u",fileid)==-1){
							tlmp_error ("Delete fail in table files, aborting: %s\n",query_getdefaultdb()->error());
							exit (-1);
						}
						bool content_is_null = atoi(row[2]);
						if (content_is_null){
							const char *modified = row[1];
							// We must delete the file content in /var/lib/bolixo
							string path = string_f("/var/lib/bolixo/%u-%s",fileid,modified);
							for (auto &c:path) if (c == ' ') c='-';
							if (unlink(path.c_str())==-1){
								tlmp_error ("Can't delete content file %s (%s)\n",path.c_str(),strerror(errno));
								exit (-1);
							}
						}
					}
				}
			</f>
			</call>
			if (glocal.deleted_orphan){
				// Another cleanup pass
				deleteitems_getids(glocal.itemids,true,true);
				deleteitems_table_ids(glocal.itemids);
			}

			// Delete all files in /var/lib/bolixo connected to unused itemid
			<call walkfs>("/var/lib/bolixo");
			<f onefile>
				unsigned id = atoi(basename);
				if (deleteitems_notin(glocal.itemids,id)){
					if (verbose){
						printf ("Content file %s must go\n",basename);
					}
					if (doit){
						if (unlink(path)==-1){
							tlmp_error ("Can't delete content file %s (%s)\n",path,strerror(errno));
							exit (-1);
						}
					}
				}
			</f>
			</call>
			// Other table just related to userid
			set<unsigned> group_ids;
			set<unsigned> group_list_ids;
			struct TABLESPEC { const char *table; const char *field; set<unsigned> *collect;} tables[]={
				{"contact_requests","userid",nullptr},
				{"contact_requests","reqid",nullptr},
				{"interests","userid",nullptr},
				{"interests_remote","userid",nullptr},
				{"marks","userid",nullptr},
				{"userinfo","userid",nullptr},
				{"group_members","userid",nullptr},
				{"groups","ownerid",&group_ids},
				{"group_lists","ownerid",&group_list_ids}
				};
			for (auto const &table:tables){
				glocal const char *table = table.table;
				glocal const char *field = table.field;
				glocal set<unsigned> *collect = table.collect;
				glocal set<unsigned> done;	// Avoid repetition
								// Another solution would be to put unique in the SQL statement
								// but it would put too much work on the server.
				<call sql_query>("select %s%s from %s",table.field
					,table.collect == nullptr ? "" : ",id"
					,table.table);
				<f onerow>
					unsigned id = atoi(row[0]);
					if (deleteitems_notin(glocal.userids,id)){
						if (glocal.collect != nullptr) glocal.collect->insert(atoi(row[1]));
 						if (glocal.done.insert(id).second){
							if (verbose){
								printf ("Table %s: %s %5u must go\n",glocal.table,glocal.field,id);
							}
							if (doit){
								if (sql_action("delete from %s where %s=%u",glocal.table,glocal.field,id)==-1){
									tlmp_error ("Delete fail in table %s, aborting: %s\n"
										,glocal.table,query_getdefaultdb()->error());
									exit (-1);
								}
							}
						}
					}
				</f>
				</call>
			}
			// Some groups and group_lists have vanished
			// We must delete all records related to them in group_members and group_list_members
			for (auto const &table:tables){
				if (table.collect != nullptr){
					for (auto &u:*table.collect){
						if (verbose){
							printf ("delete %s %u\n",table.table,u);
						}
						if (doit){
							if (sql_action("delete from %s where id=%u",table.table,u)==-1){
								tlmp_error ("Delete fail in table %s, aborting: %s\n"
									,table.table,query_getdefaultdb()->error());
								exit (-1);
							}
						}
					}
				}
			}
		}
		return ret;
	</f>
	<f main>
		int ret = -1;
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

