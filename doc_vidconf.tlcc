/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <map>
#include <dialog.h>
#include <tlmplib.h>
#include <openssl/hmac.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "documentd_menu.h"
#include "bolixo.m"
#include <map>

using namespace std;

struct WEBRTC{
	bool first = false;
	string description;
	vector<string> candidates;
	bool sent = false;
	void clear(){
		description.clear();
		candidates.clear();
		sent = false;
	}
	string send() {
		string ret;
		ret = string_f("VIDC_setdesc('%s');\n",documentd_escape(description).c_str());
		for (auto &c:candidates){
			ret += string_f("VIDC_setcand('%s');\n",documentd_escape(c).c_str());
		}
		sent = true;
		return ret;
	}
};
	


class VIDCONF: public GAME{
	std::string message;
	std::string define_styles(bool mobile);
	std::string define_functions(const DOC_CONTEXT &ctx, bool mobile);
	std::string draw_board (bool mobile, unsigned docnum, std::string &script);
	map<string,WEBRTC> webrtcs;
	struct {	// Only one connection may request stats at a time
			// only used by bofs. At some point, it may be part
			// of the user interface to help debug issues.
		string connectid;	// Connection ID having done a getstats
		int nbreq=0;		// Number of getstats sent (number of connected users)
	} stats;
public:
	VIDCONF();
	const char *getclass() const{
		return "VIDC";
	}
	void save(DOC_WRITER &w, bool save_session_info);
	void load(DOC_READER &r, std::string &msg);
	void exec (const char *var, const char *val, const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res
		, std::vector<USERS_NOTIFIES> &unotifies);
};

GAME_P make_VIDCONF()
{
	return make_shared<VIDCONF>();
}

#include "proto/documentd_vidconf.protoh"
#include "proto/documentd_vidconf.protoch"


VIDCONF::VIDCONF()
{
	resetgame();
}

void VIDCONF::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_vidconf_header (&w,revision);
	vector<VIDCONF_CHAT> schat;
	documentd_copychat (schat,chat);
	documentd_vidconf_chat(&w,schat);
}
<mod>
void VIDCONF::load(DOC_READER &r, std::string &msg)
{
	glocal revision;
	glocal msg;
	glocal chat;
	chat.clear();
	<call documentd_vidconf>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f chat>
		for (auto l:lines) glocal.chat.emplace_back(l.time,l.line);
	</f>
	<f invalid>
		glocal.msg = "Invalid format for vidconf file";
	</f>
	</call>
}
</mod>

string VIDCONF::define_styles(bool mobile)
{
	string lines;
	return lines;
}
static string turn_secret;
<mod>
string VIDCONF::define_functions(const DOC_CONTEXT &ctx, bool mobile)
{
	// The secret for authentication with the TURN server comes from a config file. It is read once as needed
	static bool turn_secret_done = false;
	if (!turn_secret_done){
		turn_secret_done = true;
		<call loadfile>("/etc/bolixo/vidconf.secret",true);
		<f oneline>
			if (line[0] != '0' && line[0] != '#' && turn_secret.size()==0) turn_secret = line;
			return 0;
		</f>
		</call>
		//tlmp_warning ("turn secret = :%s:",turn_secret.c_str());
		if (turn_secret.size()==0){
			tlmp_error ("Empty secret for video conference");
		}
	}
	string lines = 
		"const b64tobin = (b64Data) => {\n"
		"\tconst byteCharacters = atob(b64Data);\n"
		"\tconst buf = new ArrayBuffer(byteCharacters.length);\n"
		"\tconst bytes = new Uint8Array(buf);\n"
		"\tconsole.log ('buf.byteLength=',buf.byteLength);\n"
		"\tfor (let i = 0; i < byteCharacters.length; i++) {\n"
		"\t\tbytes[i] = byteCharacters.charCodeAt(i);\n"
		"\t}\n"
		"\treturn buf;\n"
		"}\n"
		"var vidc_chunks=[];\n"
		"var sourcebuffer=null;\n"
		"function vidc_add(chunk) {\n"
		"\tvar bchunk=b64tobin(chunk);\n"
		"\tif (vidc_chunks.length > 0 || sourcebuffer.updating){\n"
		"\t\tvidc_chunks.push(bchunk);\n"
		"\t}else{\n"
		"\t\tsourcebuffer.appendBuffer(bchunk);\n"
		"\t}\n"
		"}\n"
		;
	lines += "function VIDC_updmsg(color,msg){\n";
	lines += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
	lines += "\tif (elm != null){\n";
	lines += "\t\telm.style.color=color;\n";
	lines += "\t\telm.innerHTML=msg;\n";
	lines += "\t}\n";
	lines += "}\n";
	// The temporary user holds a timestamp, good for 600 seconds.
	string tempuser = string_f("%ld:%s",time(nullptr)+600,ctx.username);
	string temppass;
	{
		unsigned char res[SHA_DIGEST_LENGTH];
		unsigned res_len = SHA_DIGEST_LENGTH;
		temppass = base64_encode((const char *)HMAC(EVP_sha1()
			,(const unsigned char*) turn_secret.c_str(),turn_secret.size()
			,(const unsigned char*) tempuser.c_str(),tempuser.size()
			,res,&res_len),res_len);
	}
	// tlmp_warning ("tempuser :%s: temppass :%s:",tempuser.c_str(),temppass.c_str());
	lines +=
		"var notesocket_cmd='webrtcstart:';\n"
		"const config = {\n"
		"\ticeServers: ["
		"{urls: 'stun:'+location.hostname + ':3478'},";
	lines += string_f("{urls: 'turn:'+location.hostname + ':3478', username: '%s',credential: '%s'},",tempuser.c_str(),temppass.c_str());
	lines +=
		"]};\n"
		"const pc = new RTCPeerConnection(config);\n"
		"const constraints = { audio: true, video: true };\n";


	lines +=
		"var selfVideo = null;\n"
		"var started = false;\n"
	 	"var polite = null;\n"
		"function VIDC_setpolite(pol){\n"
		"\tpolite = pol;\n"
		"\tconsole.log ('polite='+polite);\n"
		"\tif (!started){\n"
		"\t\tstarted = true;\n"
		"\t\tconsole.log ('start webrtc');\n"
		"\t\tstart();\n"
		"\t}\n"
		"}\n"
		"async function start() {\n"
		"\ttry {\n"
		"\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n"
		"\t\tfor (const track of stream.getTracks()) {\n"
		"\t\t\t	pc.addTrack(track, stream);\n"
		"\t\t}\n";
	lines += string_f("\tselfVideo = document.getElementById('vidc-%s');\n",gameid.c_str());
	lines +=
		"\t\tselfVideo.srcObject = stream;\n"
		"\t} catch (err) {\n"
		"\t\tconsole.error(err);\n"
		"\t}\n"
		"}\n"

		"pc.ontrack = ({ track, streams }) => {\n"
		"\ttrack.onunmute = () => {\n"
		"\t\tselfVideo.srcObject = streams[0];\n"
		"\t};\n"
		"};\n"

		"let makingOffer = false;\n"
		"pc.onnegotiationneeded = async () => {\n"
		"\ttry {\n"
		"\t\tmakingOffer = true;\n"
		"\t\tawait pc.setLocalDescription();\n"
		"\t\tconsole.log ('Send localDescription');\n"
		"\t\tnotesocket.send('description:'+JSON.stringify(pc.localDescription,null,0));\n"
		"\t} catch (err) {\n"
		"\t\tconsole.error(err);\n"
		"\t} finally {\n"
		"\t\tmakingOffer = false;\n"
		"\t}\n"
		"};\n"

		"pc.onicecandidate = ({ candidate }) => {\n"
		"\tconsole.log ('Send Candidate');\n"
		"\t//console.log (JSON.stringify(candidate,null,0));\n"
		"\tnotesocket.send ('candidate:'+JSON.stringify(candidate,null,0));\n"
		"};\n"

		"let ignoreOffer = false;\n"
		"async function receiveoffer ({ data: { description, candidate } }) {\n"
		"\ttry {\n"
		"\t\tif (description) {\n"
		"\t\t\tconst offerCollision = description.type === 'offer'\n"
		"\t\t\t\t&& (makingOffer || pc.signalingState !== 'stable');\n"
		"\t\t\t	ignoreOffer = !polite && offerCollision;\n"
		"\t\t\tif (ignoreOffer) {\n"
		"\t\t\t\treturn;\n"
		"\t\t\t}\n"
		"\t\t\tawait pc.setRemoteDescription(description);\n"
		"\t\t\tif (description.type === 'offer') {\n"
		"\t\t\t\tawait pc.setLocalDescription();\n"
		"\t\t\t\tnotesocket.send ('description:'+JSON.stringify(pc.localDescription,null,0));\n"
		"\t\t\t\tconsole.log ('offer send localDescription');\n"
		"\t\t\t}\n"
		"\t\t} else if (candidate) {\n"
		"\t\t\ttry {\n"
		"\t\t\t\tawait pc.addIceCandidate(candidate);\n"
		"\t\t\t} catch (err) {\n"
		"\t\t\t\tif (!ignoreOffer) {\n"
		"\t\t\t\t\tthrow err;\n"
		"\t\t\t\t}\n"
		"\t\t\t}\n"
		"\t\t}\n"
		"\t} catch (err) {\n"
		"\t\tconsole.error(err);\n"
		"\t}\n"
		"};\n"

		"function VIDC_setdesc(description){\n"
		"\tconsole.log ('receive description');\n"
		"\treceiveoffer({data: {description: JSON.parse(description), candidate: null}});\n"
		"}\n"

		"function VIDC_setcand(candidate){\n"
		"\tconsole.log ('receive candidate');\n"
		"\treceiveoffer({data: {description: null, candidate: JSON.parse(candidate)}});\n"
		"}\n"

		"function VIDC_getstats(){\n"
		"\tpc.getStats(null).then((stats) => {\n"
		"\tvar res = '';\n"
		"\tstats.forEach((rep) => { res += JSON.stringify(rep,null,0)+ '\\r'; });\n"
		"\tnotesocket.send('stats:'+res);\n"
		"\t});\n"
		"}\n";
	return lines;
}
</mod>
string VIDCONF::draw_board(
	bool mobile,
	unsigned docnum,
	string &script)
{
	string lines;
	lines += string_f("<video id='vidc-%s' autoplay width=100%% height=100%%>\n",gameid.c_str());
	lines += "Your browser does not support the video tag.\n";
	lines += "</video>\n";

	#if 0
	script += string_f("const videoTag = document.getElementById('vidc-%s');\n",gameid.c_str());
	script +=
		"const myMediaSource = new MediaSource();\n"
		"const url = URL.createObjectURL(myMediaSource);\n"
		"myMediaSource.addEventListener('sourceopen', sourceOpen);\n"
		"videoTag.src = url;\n"
		"function sourceOpen(){\n"
		//"\tvideoTag.play();\n"
		"\tconsole.log('sourceopen state='+this.readyState); // open\n"
		"\tconst mtype = 'video/mp4; codecs=\"avc1.64001e, mp4a.40.2,avc1.4d401e\"';\n"
		"\tif (MediaSource.isTypeSupported(mtype)){\n"
		"\t\tconsole.log('mp4 codec supported');\n"
		"\t}else{\n"
		"\t\tconsole.log('mp4 codec not supported');\n"
		"\t}\n"
		"\tsourcebuffer = this.addSourceBuffer(mtype);\n"
		"\tconst curMode = sourcebuffer.mode;\n"
		"\tif (curMode === 'segments') {\n"
		"\t\tsourcebuffer.mode = 'sequence';\n"
		"\t}\n"
		"\tconsole.log ('sourcebuffer.mode='+sourcebuffer.mode);\n"
		"\tsourcebuffer.addEventListener('update', function() {\n"
		"\t\tconsole.log ('update');\n"
		"\t\tif(vidc_chunks.length > 0){\n"
		"\t\t\tsourcebuffer.appendBuffer(vidc_chunks.shift());\n"
		"\t\t}\n"
		"\t\t});\n"
		"\tsourcebuffer.addEventListener('updateend', function() {\n"
		"\t\tconsole.log ('updateend');\n"
		"\t});\n"
		"\tsourcebuffer.addEventListener('error', function(e) {\n"
		"\t\tconsole.log ('buffer error');\n"
		"\t\tconsole.log(e);\n"	
		"\t});\n"
		"\tvideoTag.addEventListener('play', function() {\n"
		"\t\tconsole.log ('play');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('playing', function() {\n"
		"\t\tconsole.log ('playing');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('waiting', function() {\n"
		"\t\tconsole.log ('waiting');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('stalled', function() {\n"
		"\t\tconsole.log ('stalled');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('progress', function() {\n"
		"\t\tconsole.log ('progress');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('timeupdate', function() {\n"
		"\t\tconsole.log ('timeupdate');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('seeking', function() {\n"
		"\t\tconsole.log ('seeking');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('seeked', function() {\n"
		"\t\tconsole.log ('seeked');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('loadeddata', function() {\n"
		"\t\tconsole.log ('loadeddata');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('loadedmetadata', function() {\n"
		"\t\tconsole.log ('loadedmetadata');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('error', function(e) {\n"
		"\t\tconsole.log ('videotag error');\n"
		"\t\tconsole.log (e);\n"
		"\t}, false);\n"
		"}\n"
		;
	#endif
	return lines;
}

<mod>
void VIDCONF::exec (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res,
	vector<USERS_NOTIFIES> &unotifies)
{
	string error,status,api_error;
	bool clear_status_ok = true;	// We send a clear status line except when processing webrtc request
	setactivity();
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	notify_var.val = string_f("vidconf_cur_gameid='%s';\n",gameid.c_str());
	size_t notify_init_size = notify_var.val.size();	// Do not send notification if there is only the variable declaration in it
								// See the end of this function.
	if (is_eq(var,REQ_PRINT)){
		if (is_any_of(val,"","full")){
			VARVAL v;
			glocal VIDCONF *doc = this;
			<call doc_layout>(val,this,ctx,sp,"vidconf",false,v);
			<f styles>
				return glocal.doc->define_styles(sp.mobile);
			</f>
			<f functions>
				return glocal.doc->define_functions(ctx,sp.mobile);
			</f>
			<f menu_bar>
				#define BUTTON_CONFIG	0
				VIDEO_MENU menu(specs);
				documentd_bar_button (lines,BUTTON_CONFIG,menu.svg_config,specs,false,"");
			</f>
			<f content>
				return glocal.doc->draw_board(sp.mobile,ctx.docnum,script);
			</f>
			</call>
			res.emplace_back(move(v));
		}
	}else if (is_eq(var,REQ_FUNCTIONS)){
		VARVAL var;
		var.var = VAR_DEFSCRIPT;
		var.val = define_functions (ctx,sp.mobile);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_STYLES)){
		VARVAL var;
		var.var = VAR_STYLES;
		var.val += define_styles(sp.mobile);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_REGION)){
		// For embedding
		VARVAL var,var_script;
		var.var = VAR_CONTENT;
		var_script.var = VAR_DEFSCRIPT;
		var.val = draw_board(sp.mobile,ctx.docnum,var_script.val);
		res.emplace_back(move(var));
		res.emplace_back(move(var_script));
	}else if (is_eq(var,REQ_CHAT)){
		appendchat(val,notify_var.val,res);
	}else if (is_eq(var,REQ_GETFIELDS)){
		VARVAL var;
		var.var = VAR_FIELDS;
		if (is_eq(val,DIALOG_VIDCONF_CONFIG)){
		}
		res.emplace_back(var);
	}else if (is_eq(var,REQ_FOCUS)){
		// Nothing to do
	}else if (ctx.maywrite){
		USERS_NOTIFIES others;	// Messages sent to other users
		USERS_NOTIFIES wstats;	// Messages sent to the connection having done the getstats request
		for (auto &n:notification_fds){
			//tlmp_warning ("count=%d/%zu n.second.connectid %s ctx.connectid %s",count,notification_fds.size(),n.second.connectid.c_str(),ctx.connectid);
			if (!is_eq(n.second.connectid,ctx.connectid)){
				others.connections.push_back(n.first);
			}
			if (is_eq(n.second.connectid,stats.connectid)){
				wstats.connections.push_back(n.first);
			}
		}
		if (wstats.connections.size()==0) stats.connectid.clear();	// The connection stats.connectid is gone
		if (webrtcs.size() == 0) webrtcs[ctx.username].first = true;
		WEBRTC &webrtc = webrtcs[ctx.username];
		if (is_eq(var,"append")){
			others.val = string_f("vidc_add('%s');\n",val);
		}else if (is_eq(var,"webrtcstart")){
			clear_status_ok = false;
			VARVAL var;
			var.var = VAR_SCRIPT;
			var.val = string_f("VIDC_setpolite(%s);\n",webrtc.first ? "true" : "false");
			res.emplace_back(move(var));
			webrtc.clear();		// Remove all information from previous sessions
		}else if (is_eq(var,"description")){
			clear_status_ok = false;
			webrtc.description = val;
			if (webrtc.sent){
				// New description
				others.val = string_f("VIDC_setdesc('%s');\n",documentd_escape(val).c_str());
			}
		}else if (is_eq(var,"candidate")){
			clear_status_ok = false;
			webrtc.candidates.push_back(val);
			tlmp_warning ("webrtc.sent=%d user=%s candidate=%s",webrtc.sent,ctx.username,val);
			if (webrtc.sent){
				// More candidates
				others.val = string_f("VIDC_setcand('%s');\n",documentd_escape(val).c_str());
			}else if (is_eq(val,"null")){
				tlmp_warning ("webrtc.send() -> %s %zu connections",ctx.username,others.connections.size());
				others.val = webrtc.send();
			}
		}else if (is_eq(var,"getstats")){
			// Request stats from all video conference users
			stats.nbreq = others.connections.size();
			if (stats.nbreq > 0){
				stats.connectid = ctx.connectid;
				others.val = "VIDC_getstats();\n";
			}else{
				VARVAL var;
				var.var = VAR_SCRIPT;
				var.val = string_f("stats %s\nendstats\n",MSG_U(E_NOUSERSINCONF,"No users in conference"));
				res.emplace_back(move(var));
			}	
		}else if (is_eq(var,"stats")){
			tlmp_warning ("stats from %s: %s",ctx.username,val);
			if (wstats.connections.size() > 0){
				wstats.val = string_f("stats %s %s\n",ctx.username,val);
				stats.nbreq--;
				if (stats.nbreq == 0){
					wstats.val += "endstats\n";
					stats.connectid.clear();
				}
			}
		}else{
			api_error = MSG_U(E_IVLAPICOMMAND,"Invalid API command");
		}
		if (others.val.size() > 0) unotifies.emplace_back(move(others));
		if (wstats.val.size() > 0) unotifies.emplace_back(move(wstats));
	}else{
		tlmp_error ("var=%s\n",var);
		error = MSG_R(E_READONLY);
	}
	if (notify_var.val.size() > notify_init_size) res.emplace_back(move(notify_var));
	if (api_error.size() > 0){
		VARVAL var;
		var.var = VAR_ERROR;
		var.val = move(api_error);
		res.emplace_back(move(var));
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else if (clear_status_ok){
		update_msg(false,"&nbsp;","white",res);
	}
}
</mod>
