/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <map>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "documentd_menu.h"
#include "bolixo.m"

using namespace std;


class VIDCONF: public GAME{
	std::string message;
	std::string define_styles(bool mobile);
	std::string define_functions(bool mobile);
	std::string draw_board (bool mobile, unsigned docnum, std::string &script);
public:
	VIDCONF();
	const char *getclass() const{
		return "VIDC";
	}
	void save(DOC_WRITER &w, bool save_session_info);
	void load(DOC_READER &r, std::string &msg);
	void exec (const char *var, const char *val, const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res);
};

GAME_P make_VIDCONF()
{
	return make_shared<VIDCONF>();
}

#include "proto/documentd_vidconf.protoh"
#include "proto/documentd_vidconf.protoch"


VIDCONF::VIDCONF()
{
	resetgame();
}

void VIDCONF::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_vidconf_header (&w,revision);
	vector<VIDCONF_CHAT> schat;
	documentd_copychat (schat,chat);
	documentd_vidconf_chat(&w,schat);
}
<mod>
void VIDCONF::load(DOC_READER &r, std::string &msg)
{
	glocal revision;
	glocal msg;
	glocal chat;
	chat.clear();
	<call documentd_vidconf>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f chat>
		for (auto l:lines) glocal.chat.emplace_back(l.time,l.line);
	</f>
	<f invalid>
		glocal.msg = "Invalid format for vidconf file";
	</f>
	</call>
}
</mod>

string VIDCONF::define_styles(bool mobile)
{
	string lines;
	return lines;
}
string VIDCONF::define_functions(bool mobile)
{
	string lines = 
		"const b64tobin = (b64Data) => {\n"
		"\tconst byteCharacters = atob(b64Data);\n"
		"\tconst buf = new ArrayBuffer(byteCharacters.length);\n"
		"\tconst bytes = new Uint8Array(buf);\n"
		"\tconsole.log ('buf.byteLength=',buf.byteLength);\n"
		"\tfor (let i = 0; i < byteCharacters.length; i++) {\n"
		"\t\tbytes[i] = byteCharacters.charCodeAt(i);\n"
		"\t}\n"
		"\treturn buf;\n"
		"}\n"
		"var vidc_chunks=[];\n"
		"var sourcebuffer=null;\n"
		"function vidc_add(chunk) {\n"
		"\tvar bchunk=b64tobin(chunk);\n"
		"\tif (vidc_chunks.length > 0 || sourcebuffer.updating){\n"
		"\t\tvidc_chunks.push(bchunk);\n"
		"\t}else{\n"
		"\t\tsourcebuffer.appendBuffer(bchunk);\n"
		"\t}\n"
		"}\n"
		;
	lines += "function VIDC_updmsg(color,msg){\n";
	lines += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
	lines += "\tif (elm != null){\n";
	lines += "\t\telm.style.color=color;\n";
	lines += "\t\telm.innerHTML=msg;\n";
	lines += "\t}\n";
	lines += "}\n";
	return lines;
}
string VIDCONF::draw_board(
	bool mobile,
	unsigned docnum,
	string &script)
{
	string lines;
	lines += string_f("<video id='vidc-%s' width=100%% height=100%% controls>\n",gameid.c_str());
	lines += "Your browser does not support the video tag.\n";
	lines += "</video>\n";

	script += string_f("const videoTag = document.getElementById('vidc-%s');\n",gameid.c_str());
	script +=
		"const myMediaSource = new MediaSource();\n"
		"const url = URL.createObjectURL(myMediaSource);\n"
		"myMediaSource.addEventListener('sourceopen', sourceOpen);\n"
		"videoTag.src = url;\n"
		"function sourceOpen(){\n"
		//"\tvideoTag.play();\n"
		"\tconsole.log('sourceopen state='+this.readyState); // open\n"
		"\tconst mtype = 'video/mp4; codecs=\"avc1.64001e, mp4a.40.2,avc1.4d401e\"';\n"
		"\tif (MediaSource.isTypeSupported(mtype)){\n"
		"\t\tconsole.log('mp4 codec supported');\n"
		"\t}else{\n"
		"\t\tconsole.log('mp4 codec not supported');\n"
		"\t}\n"
		"\tsourcebuffer = this.addSourceBuffer(mtype);\n"
		"\tconst curMode = sourcebuffer.mode;\n"
		"\tif (curMode === 'segments') {\n"
		"\t\tsourcebuffer.mode = 'sequence';\n"
		"\t}\n"
		"\tconsole.log ('sourcebuffer.mode='+sourcebuffer.mode);\n"
		"\tsourcebuffer.addEventListener('update', function() {\n"
		"\t\tconsole.log ('update');\n"
		"\t\tif(vidc_chunks.length > 0){\n"
		"\t\t\tsourcebuffer.appendBuffer(vidc_chunks.shift());\n"
		"\t\t}\n"
		"\t\t});\n"
		"\tsourcebuffer.addEventListener('updateend', function() {\n"
		"\t\tconsole.log ('updateend');\n"
		"\t});\n"
		"\tsourcebuffer.addEventListener('error', function(e) {\n"
		"\t\tconsole.log ('buffer error');\n"
		"\t\tconsole.log(e);\n"	
		"\t});\n"
		"\tvideoTag.addEventListener('play', function() {\n"
		"\t\tconsole.log ('play');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('playing', function() {\n"
		"\t\tconsole.log ('playing');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('waiting', function() {\n"
		"\t\tconsole.log ('waiting');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('stalled', function() {\n"
		"\t\tconsole.log ('stalled');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('progress', function() {\n"
		"\t\tconsole.log ('progress');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('timeupdate', function() {\n"
		"\t\tconsole.log ('timeupdate');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('seeking', function() {\n"
		"\t\tconsole.log ('seeking');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('seeked', function() {\n"
		"\t\tconsole.log ('seeked');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('loadeddata', function() {\n"
		"\t\tconsole.log ('loadeddata');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('loadedmetadata', function() {\n"
		"\t\tconsole.log ('loadedmetadata');\n"
		"\t}, false);\n"
		"\tvideoTag.addEventListener('error', function(e) {\n"
		"\t\tconsole.log ('videotag error');\n"
		"\t\tconsole.log (e);\n"
		"\t}, false);\n"
		"}\n"
		;
	return lines;
}

<mod>
void VIDCONF::exec (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	string error,status,api_error;
	setactivity();
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	notify_var.val = string_f("vidconf_cur_gameid='%s';\n",gameid.c_str());
	if (is_eq(var,REQ_PRINT)){
		if (is_any_of(val,"","full")){
			VARVAL v;
			glocal VIDCONF *doc = this;
			<call doc_layout>(val,this,ctx,sp,v);
			<f styles>
				return glocal.doc->define_styles(sp.mobile);
			</f>
			<f functions>
				return glocal.doc->define_functions(sp.mobile);
			</f>
			<f menu_bar>
				#define BUTTON_CONFIG	0
				VIDEO_MENU menu(specs);
				documentd_bar_button (lines,BUTTON_CONFIG,menu.svg_config,specs,false,"");
			</f>
			<f content>
				return glocal.doc->draw_board(sp.mobile,ctx.docnum,script);
			</f>
			</call>
			res.emplace_back(move(v));
		}
	}else if (is_eq(var,REQ_FUNCTIONS)){
		VARVAL var;
		var.var = VAR_DEFSCRIPT;
		var.val = define_functions (sp.mobile);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_STYLES)){
		VARVAL var;
		var.var = VAR_STYLES;
		var.val += define_styles(sp.mobile);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_REGION)){
		// For embedding
		VARVAL var,var_script;
		var.var = VAR_CONTENT;
		var_script.var = VAR_DEFSCRIPT;
		var.val = draw_board(sp.mobile,ctx.docnum,var_script.val);
		res.emplace_back(move(var));
		res.emplace_back(move(var_script));
	}else if (is_eq(var,REQ_CHAT)){
		appendchat(val,notify_var.val,res);
	}else if (is_eq(var,REQ_GETFIELDS)){
		VARVAL var;
		var.var = VAR_FIELDS;
		if (is_eq(val,DIALOG_VIDCONF_CONFIG)){
		}
		res.emplace_back(var);
	}else if (is_eq(var,REQ_FOCUS)){
		// Nothing to do
	}else if (ctx.maywrite){
		if (is_eq(var,"append")){
			notify_var.val += string_f("vidc_add('%s');\n",val);
		}else{
			api_error = MSG_R(E_IVLAPICOMMAND);
		}
	}else{
		tlmp_error ("var=%s\n",var);
		error = MSG_R(E_READONLY);
	}
	if (notify_var.val.size() > 0) res.emplace_back(move(notify_var));
	if (api_error.size() > 0){
		VARVAL var;
		var.var = VAR_ERROR;
		var.val = move(api_error);
		res.emplace_back(move(var));
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else{
		update_msg(false,"&nbsp;","white",res);
	}
}
</mod>
