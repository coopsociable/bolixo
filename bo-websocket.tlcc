/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Listen on a socket
*/
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <signal.h>
#include <syslog.h>
#include <dialog.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <string>
#include <set>
#include "helper.h"
#include "instrument.h"
#include "bolixo.h"


using namespace std;

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

struct HANDLE_INFO: public ARRAY_OBJ{
	REQUEST_INFO req;
	CONNECT_TYPE type = TYPE_NONE;
};
#define bo_websocket_control_rep_pause_NEEDED
#define bo_websocket_control_rep_resume_NEEDED
#define bo_websocket_control_rep_test_NEEDED
#include "proto/bo-websocket_control.protoh"
#define bo_sessiond_client_getsessioninfo_NOTNEED
#define bo_sessiond_client_delnotify_NOTNEED
#define bo_sessiond_client_test_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#define bo_sessiond_client_setnotify_NOTNEED
#define bo_sessiond_client_waitevent_ASYNC
#include "proto/bo-sessiond_client.protoch"
#define bod_client_login_NOTNEED
#define bod_client_logout_NOTNEED
#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED
#define bod_client_createsession_NOTNEED
#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_delfile_NOTNEED
#define bod_client_undelete_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED
#define bod_client_readfile_bob_NOTNEED
#define bod_client_readmore_NOTNEED
#define bod_client_mkdir_NOTNEED
#define bod_client_rmdir_NOTNEED
#define bod_client_listdir_NOTNEED
#define bod_client_stat_NOTNEED
#define bod_client_set_access_NOTNEED
#define bod_client_markview_NOTNEED
#define bod_client_create_group_list_NOTNEED
#define bod_client_create_group_NOTNEED
#define bod_client_set_group_NOTNEED
#define bod_client_set_member_NOTNEED
#define bod_client_set_members_NOTNEED
#define bod_client_set_list_desc_NOTNEED
#define bod_client_set_group_desc_NOTNEED
#define bod_client_delete_list_NOTNEED
#define bod_client_delete_group_NOTNEED
#define bod_client_list_lists_NOTNEED
#define bod_client_list_groups_NOTNEED
#define bod_client_create_project_dir_NOTNEED
#define bod_client_list_contacts_NOTNEED
#define bod_client_list_inboxes_NOTNEED
#define bod_client_list_msgs_NOTNEED
#define bod_client_sendmsg_NOTNEED
#define bod_client_sendmsg_project_NOTNEED
#define bod_client_replymsg_NOTNEED
#define bod_client_replymsg_project_NOTNEED
#define bod_client_sendattach_NOTNEED
#define bod_client_verifysign_NOTNEED
#define bod_client_getpubkey_NOTNEED
#define bod_client_registernode_NOTNEED
#define bod_client_remotelogin_NOTNEED
#define bod_client_remotepass_NOTNEED
#define bod_client_remote_interest_set_NOTNEED
#define bod_client_remote_interest_unset_NOTNEED
#define bod_client_nodelogin_NOTNEED
#define bod_client_nodepass_NOTNEED
#define bod_client_sendtalk_anon_NOTNEED
#define bod_client_sendtalk_NOTNEED
#define bod_client_sendtalk_file_NOTNEED
#define bod_client_list_talk_NOTNEED
#define bod_client_contact_request_NOTNEED
#define bod_client_contact_manage_NOTNEED
#define bod_client_contact_list_NOTNEED
#define bod_client_contact_remove_NOTNEED
#define bod_client_config_read_NOTNEED
#define bod_client_config_write_NOTNEED
#define bod_client_set_notification_NOTNEED
#define bod_client_get_notification_NOTNEED
#define bod_client_public_checkuser_NOTNEED
#define bod_client_public_listdir_NOTNEED
#define bod_client_public_readfile_NOTNEED
#define bod_client_public_list_talk_NOTNEED
#define bod_client_form_savevar_NOTNEED
#define bod_client_form_readvar_NOTNEED
#define bod_client_form_deletevar_NOTNEED
#define bod_client_form_deleteall_NOTNEED
#define bod_client_interest_set_NOTNEED
#define bod_client_interest_unset_NOTNEED
#define bod_client_interest_list_NOTNEED
#define bod_client_interest_check_NOTNEED
#define bod_client_systempubkey_NOTNEED
#define bod_client_systemsign_NOTNEED
#define bod_client_info_read_NOTNEED
#define bod_client_info_write_NOTNEED
#define bod_client_waitevent_ASYNC
#include "proto/bod_client.protoch"
/*
        Read the secret used to communicate with internal service
*/
<mod>
string util_readsecret()
{
	glocal string ret;
	<call loadfile>("/etc/secret",true);
	<f oneline>
		glocal.ret = line;
		return 0;
	</f>
	</call>
	return glocal.ret;
}
</mod>

enum class WORKER_COMMAND{
	REQ_NONE,
	REQ_END,
	REQ_PAUSE,	// The worker disconnect from sessiond and bod and stop processing user request
	REQ_RESUME,	// Allow processing again
	REQ_TEST	// Check if the worker is working
};

struct WORKER_REQUEST{
	WORKER_COMMAND cmd;
};
enum class WORKER_REPLY{
	REPLY_OK
};
struct WORKER_RESULT{
	WORKER_REPLY ret;
};

static void bo_websocket_send (_F_TCPSERVER_V1 *c, int fd, unsigned opcode, PARAM_STRING msg)
{
	size_t lenmsg = strlen(msg.ptr);
	size_t lenframe = 2+2+lenmsg;
	char buf[lenframe];
	buf[0] = 128+opcode;
	char *ptbuf=buf+2;
	if (lenmsg <= 125){
		buf[1] = (char)lenmsg;
		ptbuf = buf+2;
		lenframe = 2 + lenmsg;
	}else if (lenmsg < 65536){
		buf[1] = 126;
		buf[2] = (lenmsg >> 8) &0xff;
		buf[3] = lenmsg & 0xff;
		ptbuf = buf+4;
	}else{
		tlmp_error ("bo_websocket_send lenmsg=%lu not supported",lenmsg);
		return;
	}
	memcpy (ptbuf,msg.ptr,lenmsg);
	c->sendto (fd,buf,lenframe);
}
#define _TLMP_bo_websocket

struct _F_bo_websocket{
	_F_TCPSERVER_V1 *tcp=nullptr;
	int fd = -1;
	void send (PARAM_STRING msg){
		bo_websocket_send (tcp,fd,1,msg);
	}
	#define _F_bo_websocket_commands(name) void name commands(const vector<string> &cmds, CONNECT_INFO &con_bod, CONNECT_INFO &con_sessiond, \
		const char *session, const char *gameid, const DOC_UI_SPECS &sp, bool &endserver)
	virtual _F_bo_websocket_commands( )=0;
	#define _F_bo_websocket_waitnote(name) void name waitnote(CONNECT_INFO &con_sessiond, const char *session, int &sequence, const set<string> &project_notifications, bool gamewaiting, bool &endserver)
	virtual _F_bo_websocket_waitnote( )=0;
	#define _F_bo_websocket_waitnote_call(name) int name waitnote_call(CONNECT_INFO &con_sessiond, const char *session, int &sequence, bool &endserver)
	virtual _F_bo_websocket_waitnote_call( )=0;
	#define _F_bo_websocket_waitevent_call(name) int name waitevent_call(CONNECT_INFO &con_waitevent, const char *session, const char *gameid, int &gamesequence, bool &endserver)
	virtual _F_bo_websocket_waitevent_call( )=0;
	#define _F_bo_websocket_waitevent(name) void name waitevent(CONNECT_INFO &con_waitevent, const char *session, const char *gameid, int &gamesequence, bool &endserver)
	virtual _F_bo_websocket_waitevent( )=0;
};

/*
	Extract the list of tabs in section projects.
	The strings will be formatted as a notification id.
*/
static void webtab_init (const vector<SNAMEVAL_receive> &vals, set<string> &notifications)
{
	for (auto &s:vals){
		const char *pt;
		if (is_start_any_of(s.sname,pt,"Projects:2:")){
			string note = string_f("Projects:%s",pt);
			//tlmp_warning ("add notifications: %s",note.c_str());
			notifications.insert(note);
		}
	}
}
static unsigned idle_delay=5*60;
<mod>
static void bo_websocket (_F_bo_websocket &c, int fd, int waitfd, CONNECT_INFO &con_bod, CONNECT_INFO &con_sessiond, CONNECT_INFO &con_waitevent, bool paused)
{
	glocal int waitfd = waitfd;
	glocal int fd = fd;
	glocal c;
	glocal con_bod;
	glocal con_sessiond;
	glocal con_waitevent;
	glocal STREAMP_BUF buf;
	glocal bool header_seen = false;
	glocal string acceptkey;
	glocal string session;
	glocal vector<string> messages;
	glocal unsigned nbping = 0;	// number of ping sent without an answer
	glocal time_t lastactivity = time(nullptr);
	glocal string gameid;
	glocal DOC_UI_SPECS sp;
	glocal int sequence = -1;
	glocal int sessionfd = -1;
	glocal int gamesequence = -1;
	glocal int waiteventfd = -1;
	glocal set<string> project_notifications;
	c.fd = fd;
	<obj TCPSERVER s>();
	<f newclient>
	</f>
	<f endclient>
		endserver = true;
	</f>
	<f idle>
		unsigned diff = time(nullptr) - glocal.lastactivity;
		if (diff > idle_delay){
			if (glocal.nbping > 2) endserver = true;
			tlmp_warning ("idle since=%d diff=%u ping sent nbping=%u gameid=%s",since,diff,glocal.nbping,glocal.gameid.c_str());
			bo_websocket_send (this,glocal.fd,9,"hello");
		}
	</f>
	<f receive>
		glocal endserver;
		glocal line;
		glocal info;
		glocal.c.tcp = this;
		if (0) {
			<call savefile>("/tmp/log",true);
			<f dowrite>
				fprintf(fout,"receive [%d] header_seen=%d len=%u %s\n",getpid(),glocal.header_seen,glocal.info.linelen,glocal.line);
				return 0;
			</f>
			</call>
		}
		if (no == glocal.waitfd){
			if (info.linelen == sizeof(WORKER_REQUEST)){
				auto *req = (const WORKER_REQUEST*)line;
				if (req->cmd == WORKER_COMMAND::REQ_END){
					endserver = true;
				}else{
					if (req->cmd == WORKER_COMMAND::REQ_PAUSE){
						glocal.con_bod.close();
						if (glocal.sessionfd != -1){
							glocal.con_sessiond.close();
							closeclient (glocal.sessionfd);
							glocal.sessionfd = -1;
						}
						if (glocal.waiteventfd != -1){
							glocal.con_waitevent.close();
							closeclient (glocal.waiteventfd);
							glocal.waiteventfd = -1;
						}
						setlisten (glocal.fd,false);
					}else if (req->cmd == WORKER_COMMAND::REQ_RESUME){
						if (glocal.sequence != -1){
							glocal.c.waitnote_call(glocal.con_sessiond, glocal.session.c_str(),glocal.sequence, endserver);
							glocal.sessionfd = glocal.con_sessiond.fd;
							glocal.TCPSERVER.inject(glocal.sessionfd,nullptr);
							glocal.TCPSERVER.setmonitormode(glocal.sessionfd,true);
						}
						if (glocal.gamesequence != -1){
							glocal.c.waitevent_call(glocal.con_waitevent, glocal.session.c_str(),glocal.gameid.c_str(),glocal.gamesequence, endserver);
							glocal.waiteventfd = glocal.con_waitevent.fd;
							glocal.TCPSERVER.inject(glocal.waiteventfd,nullptr);
							glocal.TCPSERVER.setmonitormode(glocal.waiteventfd,true);
						}
						setlisten (glocal.fd,true);
					}
					WORKER_RESULT rep;
					rep.ret = WORKER_REPLY::REPLY_OK;
					send (&rep,sizeof(rep));
				}
			}else{
				tlmp_error ("Invalid packet size for worker request");
			}
		}else if (no == glocal.sessionfd){
			glocal.c.waitnote(glocal.con_sessiond, glocal.session.c_str(),glocal.sequence, glocal.project_notifications
				,glocal.gamesequence!=-1,endserver);
			// We are always calling back sessiond to wait for more events.
			if (!glocal.endserver) glocal.c.waitnote_call(glocal.con_sessiond, glocal.session.c_str(),glocal.sequence, endserver);
		}else if (no == glocal.waiteventfd){
			glocal.c.waitevent(glocal.con_waitevent, glocal.session.c_str(),glocal.gameid.c_str(),glocal.gamesequence, endserver);
			// We are always calling back bod to wait for more events.
			if (!glocal.endserver) glocal.c.waitevent_call(glocal.con_waitevent, glocal.session.c_str(),glocal.gameid.c_str(),glocal.gamesequence, endserver);
		}else if (!glocal.header_seen){
			const char *pt;
			if (is_start_any_ofnc(line,pt,"Sec-WebSocket-Key:")){
				pt = str_skip(pt);
				string webkey = pt;
				string tmp = webkey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
				unsigned char* sha_str = SHA1(reinterpret_cast<const unsigned char*>(tmp.c_str()), tmp.length(), nullptr);
				glocal.acceptkey = base64_encode(reinterpret_cast<const char*>(sha_str), 20);
				// tlmp_warning ("WEBKEY=%s acceptkey=%s\n",webkey.c_str(),glocal.acceptkey.c_str());
			}else if (is_start_any_ofnc(line,pt,"Cookie:")){
				vector<string> cookies;
				str_splitline(pt,' ',cookies);
				if (cookies.size() > 0){
					for (auto &c:cookies){
						const char *val;
						if (is_start_any_of(c,val,"session=")){
							glocal.session = val;
							break;
						}
					}
					if (glocal.session.size() == 0){
						tlmp_warning ("No session received");
						endserver = true;
					}else{
						<call bo_sessiond_client_getsessioninfovars>(glocal.con_sessiond,glocal.session);
						<f ok>
							if (internal_error || !success){
								tlmp_warning ("Invalid session");
								glocal.endserver = true;
							}else{
								for (auto &var:vars){
									if (strcmp(var.name,"webtabs")==0){
										// We extract the list of tabs in the session. We will use this to
										// decide if we send notification for documents. Se <f waitnote> below
										webtab_init (var.vals,glocal.project_notifications);
										break;
									}
								}
								// tlmp_warning ("Valid session");
							}
						</f>
						</call>
					}
				}else{
					tlmp_warning ("No cookie, ending");
					endserver = true;
				}
			}else if (line[0] == '\0'){
				if (glocal.session.size() == 0){
					tlmp_warning ("No session received");
					endserver = true;
				}else{
					// tlmp_warning ("session=%s",glocal.session.c_str());
					glocal.header_seen = true;
					sendf ("HTTP/1.1 101 Switching Protocols\r\n"
						"Upgrade: websocket\r\n"
						"Connection: Upgrade\r\n"
						"Sec-WebSocket-Accept: %s\r\n"
						"\r\n"
						,glocal.acceptkey.c_str());
					setrawmode(true);
				}
			}
		}else{
			glocal.lastactivity = time(nullptr);
			<call streamp_do>(glocal.buf,line,info.linelen);
			<f process>
				int ret = 0;
				const unsigned char *line = (const unsigned char *)buf;
				if (len > 4){
					bool fin = (line[0] &0x80) != 0;
					if (!fin){
						tlmp_error ("fin != %d",fin);
						glocal.endserver = true;
						return 0;
					}
					unsigned opcode = line[0] &0xf;
					if (opcode == 8){	// Close
						glocal.endserver = true;
					}else{
						bool mask = (line[1]&0x80)!=0;
						unsigned len1 = line[1] &0x7f;
						unsigned data_len = len1;
						int frame_len = 2 + len1; 
						const unsigned char *data = line+2;
						const unsigned char *maskb = line+2;
						if (len1 == 126){
							data_len = (line[2]<<8)+line[3];
							frame_len = 2 + 2 + data_len; 
							data = line + 4;
							maskb = line + 4;
						}
						if (mask){
							frame_len += 4;
							data += 4;
						}
						if (frame_len <= len){
							ret = frame_len;
							string msg;
							//FILE *fout = fopen ("/tmp/log","a");
							//fprintf (fout,"data:");
							for (unsigned i=0; i<data_len; i++){
								char carac = (char)(data[i] ^ maskb[i%4]);
								msg += carac;
								//fprintf (fout,"%c",carac);
							}
							//fprintf (fout,"\n");
							//fclose (fout);
							if (opcode == 9){	//
								tlmp_warning ("ping msg=%s",msg.c_str());
								bo_websocket_send(&glocal.TCPSERVER,glocal.fd,10,msg);
							}else if (opcode == 10){	//
								tlmp_warning ("pong msg=%s",msg.c_str());
								glocal.nbping = 0;
							}else{
								glocal.messages.emplace_back(move(msg));
							}
						}
					}
				}
				return ret;
			</f>
			</call>
			// for (auto &m:glocal.messages) tlmp_warning ("msg=%s",m.c_str());
			// At the start of a session, we receive a sequence number and a gameid.
			// After that, we receive line like this "verb: arguments"
			while (glocal.messages.size() > 0){
				const char *pt;
				auto p = glocal.messages.begin();
				if (is_start_any_of(*p,pt,"gameid=")){
					vector<string> tb;
					if (str_splitlineq(pt,tb)!=7){
						tlmp_warning ("Invalid gameid spec: %s",p->c_str());
						bo_websocket_send (&glocal.TCPSERVER,no,1,"callrefresh();");
						endserver = true;
					}else{
						// Remove quotes around the gameid
						auto &tb0 = tb[0];
						if (tb0[0] == '"') tb0 = tb0.substr(1);
						size_t last = tb0.size();
						if (last > 0){
							last--;
							if (tb0[last] == '"') tb0.resize(last);
						}
						glocal.gameid = tb0;
						glocal.sp.width = atoi(tb[1].c_str());
						glocal.sp.height = atoi(tb[2].c_str());
						glocal.sp.content_width = atoi(tb[3].c_str());
						glocal.sp.content_height = atoi(tb[4].c_str());
						glocal.sp.mobile = atoi(tb[5].c_str()) != 0;
						glocal.sp.fontsize = atoi(tb[6].c_str());
					}
					//tlmp_warning ("gameid:%s",glocal.gameid.c_str());
					glocal.messages.erase (p);
				}else if (is_start_any_of(*p,pt,"sequence=")){
					// We had to wait until we received the sequence number before doing the first
					// call to sessiond.
					// After that, every success completed call is followed by a new one (see above)
					glocal.sequence = atoi(pt);
					if (glocal.sessionfd == -1){
						glocal.c.waitnote_call(glocal.con_sessiond, glocal.session.c_str(),glocal.sequence, endserver);
						glocal.sessionfd = glocal.con_sessiond.fd;
						glocal.TCPSERVER.inject(glocal.sessionfd,nullptr);
						glocal.TCPSERVER.setmonitormode(glocal.sessionfd,true);
					}
					glocal.messages.erase (p);
				}else if (is_start_any_of(*p,pt,"gamesequence=")){
					// We had to wait until we received the sequence number before doing the first
					// waitevent call to bod.
					// After that, every success completed call is followed by a new one (see above)
					glocal.gamesequence = atoi(pt);
tlmp_warning ("gamesequence=%d",glocal.gamesequence);
					if (glocal.waiteventfd == -1){
						glocal.c.waitevent_call(glocal.con_waitevent, glocal.session.c_str(),glocal.gameid.c_str(),glocal.gamesequence, endserver);
						glocal.waiteventfd = glocal.con_waitevent.fd;
						glocal.TCPSERVER.inject(glocal.waiteventfd,nullptr);
						glocal.TCPSERVER.setmonitormode(glocal.waiteventfd,true);
					}
					glocal.messages.erase (p);
				}else if (glocal.gameid.size() > 0){
					glocal.c.commands(glocal.messages,glocal.con_bod,glocal.con_sessiond,glocal.session.c_str(),glocal.gameid.c_str(),glocal.sp,endserver);
					break;
				}else{
					tlmp_error ("bo_websocket_game: gameid or sequence not set, ending: messages.size()=%lu message[0]=%s"
						,glocal.messages.size(),glocal.messages[0].c_str());
					endserver = true;
					break;
				}
			}
			glocal.messages.clear();
		}
	</f>
	</obj>
	s.inject(fd,nullptr);
	if (paused) s.setlisten(fd,false);
	s.inject(waitfd,nullptr);
	s.setrawmode (waitfd,true);
	s.set_idle_timeout(60);
	s.loop();
}
</mod>

<mod>
static void bo_websocket_game (int fd, int waitfd, CONNECT_INFO &con_bod, CONNECT_INFO &con_sessiond, CONNECT_INFO &con_waitevent, bool paused)
{
	<call bo_websocket>(fd,waitfd,con_bod,con_sessiond,con_waitevent,paused);
	<f waitnote_call>
		int ret = bo_sessiond_client_waitevent_SEND(con_sessiond,session,sequence);
		return ret;
	</f>
	<f waitnote>
		glocal endserver;
		glocal sequence;
		glocal project_notifications;
		glocal gamewaiting;
		<call bo_sessiond_client_waitevent>(con_sessiond);
		<f ok>
			if (!success){
				glocal.endserver = true;
				return;
			}
			//tlmp_warning ("waitnote content=%s",content);
			// Any event starting with profile: turn the 3 bars menu orange
			string buf;
			if (is_start_any_of(content,NONEED,"profile:")){
				buf += string_f ("var e = document.getElementById('rectdotmenu');\n");
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('fill', 'orange');\n";
				buf += "}\n";
			}
			// Any event starting with talks or projects turn the main talks and projects tab orange
			const char *pt;
			if (is_start_any_of(content,pt,"talks","Projects")){
				string tmp(content,pt-content);
				if (tmp != "Projects" || glocal.project_notifications.count(content) > 0){ 
					buf += string_f ("var e = document.getElementById('tabrect%s');\n",tmp.c_str());
					buf += "if (e!=null){\n";
					buf += "\te.setAttribute('fill', 'orange');\n";
					buf += string_f("\ttabcolor['tabrect%s'] = 'orange';\n",tmp.c_str());
					buf += "}\n";
				}
			}
			// Notitication /projects/....
			// are used to send update scripts to all listener. This will go away
			// as all listener used the gamesequence system (bod_client_waitevent).
			bool not_project = !is_start_any_of(content,NONEED,"/projects/");
			if (not_project){
				// Now we turn the subtab orange
				buf += string_f ("var e = document.getElementById('tabrect%s');\n",content);
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('fill', 'orange');\n";
				buf += string_f("\ttabcolor['tabrect%s'] = 'orange';\n",content);
				buf += "}\n";
				// And the X in the subtab
				buf += string_f ("e = document.getElementById('tabsrect%s');\n",content);
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('fill', 'orange');\n";
				buf += "}\n";
			}
			// Turn the table entry in the webtable orange
			if (is_start_any_of(content,pt,"talks")){
				buf += string_f ("var e = document.getElementById('talktbl%s');\n",pt);
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('bgcolor', 'orange');\n";
				buf += "}\n";
				pt++;
				buf += string_f ("var e = document.getElementById('hid-talk=%s');\n",pt);
				buf += "if (e!=null){\n";
				buf += "\te.style.color = 'blue';\n";
				buf += string_f ("\tvar num = parseInt(e.innerHTML,10)+%u;\n",sequence-glocal.sequence);
				buf += "\te.innerHTML = num + e.innerHTML.replace(/[0-9]/g, '');\n";
				buf += "}\n";
				buf += string_f ("var e = document.getElementById('hidsvg-talk=%s');\n",pt);
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('fill', 'orange');\n";
				buf += "}\n";
			}
			if (strcmp(content,"main")==0){
				buf += "var e = document.getElementById('hid-follow');\n";
				buf += "if (e!=null){\n";
				buf += "\tconsole.log ('found hidfollow');\n";
				buf += "\te.style.color = 'blue';\n";
				buf += "\tvar num = parseInt(e.innerHTML,10)+1;\n";
				buf += "\te.innerHTML = '' + num + e.innerHTML.replace(/[0-9]/g, '');\n";
				buf += "}\n";
				buf += "var e = document.getElementById('hidsvg-follow');\n";
				buf += "if (e!=null){\n";
				buf += "\te.setAttribute('fill', 'orange');\n";
				buf += "}\n";
			}
			if (not_project){
				buf += "if (document.hidden && document.title[0] != '[') document.title = '[' + document.title + ']';\n";
			}
			if (!glocal.gamewaiting){
				if (script[0] != '\0') buf += script;
			}
			buf += string_f("sequence=%u;\n",sequence);
			glocal.bo_websocket.send (buf);
			glocal.sequence = sequence;
		</f>
		</call>
	</f>
	<f waitevent_call>
		int ret = bod_client_waitevent_SEND(con_waitevent,session,gameid,gamesequence);
		return ret;
	</f>
	<f waitevent>
		glocal gamesequence;
		<call bod_client_waitevent>(con_waitevent);
		<f ok>
			if (success){
				glocal.gamesequence = sequence;
				string buf(script);
				buf += string_f("gamesequence=%u;\n",sequence);
				glocal.bo_websocket.send (buf);
			}
		</f>
		</call>
	</f>
	<f commands>
		vector<VARVAL> steps;
		for (auto &a:cmds){
			vector<string> tb;
			// Command goes like this: command:arguments ...
			const char *pta = a.c_str();
			const char *pt = strchr(pta,':');
			if (pt != nullptr){
				VARVAL var;
				var.var = string (pta,pt-pta);
				var.val = pt+1;
				steps.push_back(var);
			}
		}
		if (steps.size() > 0){
			//for (auto m:cmds) tlmp_warning ("m=%s",m.c_str());
			<call bod_client_playstep>(con_bod,session,"",gameid,steps,sp);
			<f ok>
				if (success){
					for (auto &r:res){
						if (is_any_of(r.var,"notify","script")){
							glocal.bo_websocket.send (r.val);
						}else if (strcmp(r.var,"refresh")==0){
							glocal.bo_websocket.send ("callrefresh();");
						}
					}
				}else{
					tlmp_warning ("success false");
				}
			</f>
			</call>
		}
	</f>
	</call>
}
</mod>

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *port = "/var/run/websocket.sock";
	glocal const char *control = "/var/run/websocket-control.sock";
	glocal const char *user = "apache";
	glocal const char *user_control = "bolixo";
	glocal bool daemon = false;
	glocal const char *pidfile = "/var/run/bo-websocket.pid";
	glocal const char *bodsock = "/dev/bod.sock";
	glocal const char *sessiondsock = "/dev/sessiond.sock";
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("bo-websocket",VERSION,"websocet for documents/games protocol and notifications");
		setarg ('c',"control","Unix socket for bo-websocket-control",glocal.control,false);
		setarg ('C',"port","Unix socket for bo-websocket",glocal.port,false);
		setgrouparg ("Misc.");
		setarg (' ',"sessiondsock","Port to reach the bo-sessiond server",glocal.sessiondsock,false);
		setarg (' ',"bodsock","Port to reach the bod server",glocal.bodsock,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"user-control","Owner of the websocket-control socket",glocal.user_control,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		struct REQUEST{
			int caller;
			WORKER_COMMAND cmd;
			REQUEST(int _caller, WORKER_COMMAND _cmd){
				caller = _caller;
				cmd = _cmd;
			}
		};
		glocal vector<REQUEST> requests;
		glocal bool paused = false;
		glocal unsigned expect_replies = 0;
		glocal vector<int> workers;
		glocal CONNECT_INFO con_bod;
		glocal CONNECT_INFO con_sessiond;
		glocal CONNECT_INFO con_waitevent;
		glocal.con_bod.port = glocal.bodsock;
		glocal.con_sessiond.port = glocal.sessiondsock;
		glocal.con_bod.secret = util_readsecret();
		glocal.con_sessiond.secret = glocal.con_bod.secret;
		glocal.con_waitevent.secret = glocal.con_bod.secret;
		glocal.con_waitevent.port = glocal.bodsock;
		int ret = -1;
		signal (SIGCHLD,SIG_IGN);
		<obj TCPSERVER s>(string_f("unix:%s",glocal.port),10);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			const char *port = info.port;
			const char *pt;	
			if (is_start_any_of (port,pt,"unix:")){
				port = pt;
			}
			if (string_cmp(port,glocal.control)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(port,glocal.port)==0){
				int tb[2];
				if (socketpair(AF_UNIX,SOCK_STREAM,PF_UNIX,tb)==-1){
				}else{
					pid_t pid = fork();
					if (pid == 0){
						close (tb[0]);
						bo_websocket_game(no,tb[1],glocal.con_bod,glocal.con_sessiond,glocal.con_waitevent,glocal.paused);
						_exit (0);
					}else if (pid == (pid_t)-1){
						close (tb[0]);
						close (tb[1]);
						tlmp_error ("Can't fork (%s)",strerror(errno));
					}else{
						close (tb[1]);
						HANDLE_INFO *nn = new HANDLE_INFO;
						nn->type = TYPE_WORKER;
						inject (tb[0],nn);
						glocal.workers.push_back(tb[0]);
						endclient = true;
					}
				}
			}
			
		</f>
		<f endclient>
			HANDLE_INFO *n = (HANDLE_INFO*)info.data;
			if (n->type == TYPE_WORKER){
				for (auto p=glocal.workers.begin(); p != glocal.workers.end(); p++){
					if (*p == no){
						glocal.workers.erase(p);
						break;
					}
				}
			}
			for (auto &r:glocal.requests) if (no == r.caller) r.caller = -1;
		</f>
		<f receive>
			<obj OBJECTSUB sub>();
			<f exec>
				while (glocal.expect_replies == 0 && glocal.requests.size() > 0){
					auto first = glocal.requests.begin();
					if (first->caller == -1){
						glocal.requests.erase(first);
					}else{
						WORKER_REQUEST req;
						req.cmd = first->cmd;
						glocal.expect_replies = glocal.workers.size();
						for (auto fd:glocal.workers){
							glocal.TCPSERVER.sendto(fd,&req,sizeof(req));
						}
						break;
					}
				}
			</f>
			</obj>
			glocal OBJECTSUB *ptsub = &sub;
			HANDLE_INFO *n = (HANDLE_INFO*)info.data;
			if (n->type == TYPE_CONTROL){
				<call bo_websocket_control>(this,n->req,line, info.linelen,endserver, endclient, no,n);
				<f status>
					vector<string> tb;
					instrument_status(tb);
					tb.push_back(string_f("workers: %lu",glocal.workers.size()));
					tb.push_back(string_f("paused: %d",glocal.paused));
					tb.push_back(string_f("expect-replies: %u",glocal.expect_replies));
					static const char *tbcmd[]={"none","end","pause","resume","test"};
					const char *running = "none";
					unsigned pending = 0;
					if (glocal.requests.size() > 0){
						running = tbcmd[(unsigned)glocal.requests[0].cmd];
						pending = glocal.requests.size()-1;
					}
					tb.push_back(string_f("worker-command: running=%s pending=%u",running,pending));
					rep_status (tb);
				</f>
				<f quit>
					endserver = true;
				</f>
				<f debug>	// on:b
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f test>	// ok:b
					if (glocal.workers.size() > 0){
						glocal.requests.emplace_back(no,WORKER_COMMAND::REQ_TEST);
						glocal.ptsub->exec();
					}else{
						rep_test (true,0,glocal.paused);
					}
				</f>
				<f instrument>	// on:b
					toggle_instrument_file(on);
				</f>
				<f disconnectworkers>
					WORKER_REQUEST req;
					req.cmd = WORKER_COMMAND::REQ_END;
					for (auto fd:glocal.workers){
						glocal.TCPSERVER.sendto(fd,&req,sizeof(req));
					}
				</f>
				<f pause>
					// Note that new connection (new workers) will be started in paused mode
					glocal.paused = true;
					if (glocal.workers.size() == 0){
						rep_pause(true);
					}else{
						glocal.requests.emplace_back(no,WORKER_COMMAND::REQ_PAUSE);
						glocal.ptsub->exec();
						// We do reply when receiving answers from all workers.
					}
				</f>
				<f resume>
					glocal.paused = false;
					if (glocal.workers.size() == 0){
						rep_resume(true);
					}else{
						glocal.requests.emplace_back(no,WORKER_COMMAND::REQ_RESUME);
						glocal.ptsub->exec();
						// We do reply when receiving answers from all workers.
					}
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>

			}else if (n->type == TYPE_CLIENT){
				// Not possible
			}else if (n->type == TYPE_WORKER){
				if (glocal.expect_replies > 0){
					glocal.expect_replies--;
					/*
						We have received all replies for the current request.
						So we reply.
						At the end, we submit another request using ptsub->exec();
						if the caller of the next request has quit, or if there are no workers anymore
						then ptsub->exec() won't do much and expect_replies will be 0.
						This explains the while loop.
					*/
					while (glocal.expect_replies == 0 && glocal.requests.size() > 0){
						auto first = glocal.requests.begin();
						if (first->caller != -1){
							if (first->cmd == WORKER_COMMAND::REQ_PAUSE){
								bo_websocket_control_rep_pause (first->caller,true);
							}else if (first->cmd == WORKER_COMMAND::REQ_RESUME){
								bo_websocket_control_rep_resume (first->caller,true);
							}else if (first->cmd == WORKER_COMMAND::REQ_TEST){
								bo_websocket_control_rep_test (first->caller,true
									,glocal.workers.size(),glocal.paused);
							}
							glocal.requests.erase(first);
							glocal.ptsub->exec();	// Check if there is another request pending
						}
					}
				}else{
					tlmp_error ("Unexpected reply from worker, ignored");
				}
			}	
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user_control)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			chmod (glocal.port,0666);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			open_instrument_file();
			s.setrawmode(true);
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

