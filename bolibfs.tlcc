/*
	This provides a library to help build filesystem type services
	on top of a bolixo document.
*/
#pragma implementation
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <misc.h>
#include <dialog.h>
#include <tlmpnet.h>
#include <tlmplib.h>
#include "bolixo.h"
#include "bolibfs.h"
#include "bolixo.m"

PUBLIC BOLIBNODE::BOLIBNODE(
	const char *_name,
	const char *_uuid,
	const char *_type,
	const char *_modif)
{
	name = _name;
	uuid = _uuid;
	type = _type;
	modif = _modif;
}

PUBLIC void BOLIBNODES::add(BOLIBNODE *n)
{
	ARRAY::add(n);
}
PUBLIC void BOLIBNODES::add(
	const char *_name,
	const char *_uuid,
	const char *_type,
	const char *_modif)
{
	add (new BOLIBNODE(_name,_uuid,_type,_modif));
}

<mod>
PUBLIC void BOLIBNODES::sort_by_name()
{
	<call sort>(*this);
	<f cmp>
		BOLIBNODE *n1 = (BOLIBNODE*)o1;
		BOLIBNODE *n2 = (BOLIBNODE*)o2;
		return n1->name.icmp(n2->name);
	</f>
	</call>
}
</mod>


#ifndef PROTO_EXCL
_F_bolibfs_relation(_F_bolibfs::){}
_F_bolibfs_node(_F_bolibfs::){}
#endif

<mod>
int bolibfs (_F_bolibfs &c, int fd)
{
	glocal int ret = -1;
	glocal BOXML_READER reader;
	glocal _F_bolibfs *c = &c;
	<call tcpconnect>(fd,10);
	<f oneline>
		// fprintf (stderr,"bolibfs :%s:\n",line);
		if (strcmp(line,"</bolixo>")==0){
			<call boxml>(glocal.reader);
			<f node>
				glocal.c->node (name,descr,image,modif,uuid,owner,type,end);
			</f>
			</call>
			end = true;
			glocal.ret = 0;
		}else if (strncmp(line,"<?xml",5)==0){
			glocal.reader.append (line);
		}else if (glocal.reader.reading()){
			glocal.reader.append (line);
		}else if (strcmp(line,C_DOCCHANGED)!=0){
			tlmp_error (MSG_U(E_LSFAILED,"Echec de la commande: %s\n"),line);
			glocal.ret = -1;
			end = true;
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>


#define _TLMP_bowalk

struct _F_bowalk{
	#define _F_bowalk_node(n) void n node(const char *name,\
		const char *image,\
		const char *modif, \
		const char *uuid, \
		const char *owner, \
		const char *type, \
		bool &end)
	virtual _F_bowalk_node( );
	#define _F_bowalk_relation(n) void n relation(int docownerid, \
		const char *owner, \
		const char *uuid1, \
		const char *uuid2, \
		const char *relate, \
		const char *descr, \
		const char *modif, \
		const char *type, \
		const char *altname, \
		char orderpol, \
		unsigned int orderkey, \
		bool &end)
	virtual _F_bowalk_relation( );
};

#ifndef PROTO_EXCL
_F_bowalk_relation(_F_bowalk::){}
_F_bowalk_node(_F_bowalk::){}
#endif

/*
	Parse a path, find the uuid of the last part of the path and
	the child of this node.

	Return -1 if not found or some error.
*/
<mod>
static int bowalk(
	_F_bowalk &c,
	BOLIBFS &cont,
	const char *dir,
	bool getnodes,		// Call the node functag for each child
	SSTRING &uuid)		// Will contain the UUID of the last node in the
						// directory path
{
	glocal _F_bowalk *c = &c;
	glocal int ret = -1;
	glocal SSTRING uuid;
	glocal bool found = false;
	SSTRINGS tb;
	str_splitline (dir,'/',tb);
	for (int i=0; i < tb.size(); i++){
		glocal bool collect = i==tb.size()-1;
		if (glocal.collect){
			uuid = glocal.uuid;
			if (!getnodes){
				glocal.ret = 0;
				break;
			}
		}
		int ok;
		glocal const char *name = NULL;
		if (!glocal.collect) glocal.name = tb.getitem(i+1)->get();
		if (glocal.uuid.is_empty()){
			ok = cont.send (C_GETROOT,"\n");
		}else{
			BOXMLENC enc;
			ok = cont.send (C_GETCHILD,"%s\n",enc.enc(glocal.uuid));
		}
		glocal.found = false;
		// fprintf (stderr,"DIR %d :%s: ok=%d uuid=%s\n",i,glocal.name,ok,glocal.uuid.get());
		if (ok != -1){
			<call bolibfs>(cont.getfd());
			<f node>
				if (glocal.collect){
					glocal.ret = 0;
					glocal.c->node (name,image,modif,uuid,owner,type,end);
				}else if (strcmp(name,glocal.name)==0){
					// fprintf (stderr,"trouve uuid %s\n",uuid);
					glocal.uuid = uuid;
					glocal.found = true;
				}
			</f>
			</call>
		}
	}
	return glocal.ret;
}
</mod>



class BOLIBFS_PRIVATE{
public:
	SSTRING server;
	SSTRING port;
	SSTRING user;
	SSTRING passwd;
	SSTRING document;
	int fd;			// Connection handle;
	BOLIBFS_PRIVATE(){
		fd = -1;
	}
	~BOLIBFS_PRIVATE(){
		close (fd);
	}
};


PUBLIC BOLIBFS::BOLIBFS(
	const char *server,
	const char *port,
	const char *user,
	const char *passwd,
	const char *document)
{
	priv = new BOLIBFS_PRIVATE;
	setserver (server);
	setport (port);
	setuser (user);
	setpasswd (passwd);
	setdocument (document);
}

PUBLIC BOLIBFS::BOLIBFS()
{
	priv = new BOLIBFS_PRIVATE;
}

PUBLIC void BOLIBFS::setserver (const char *server)
{
	priv->server = server;
}
PUBLIC void BOLIBFS::setport (const char *port)
{
	priv->port = port;
}
PUBLIC void BOLIBFS::setuser (const char *user)
{
	priv->user = user;
}
PUBLIC void BOLIBFS::setpasswd (const char *passwd)
{
	priv->passwd = passwd;
}
PUBLIC void BOLIBFS::setdocument (const char *document)
{
	priv->document = document;
}

PUBLIC BOLIBFS::~BOLIBFS()
{
	delete priv;
}

PUBLIC bool BOLIBFS::is_connected() const
{
	return priv->fd != -1;
}

PUBLIC int BOLIBFS::send (const char *command,const char *ctl, ...)
{
	int ret = -1;
	if (priv->fd != -1){
		va_list list;
		va_start (list,ctl);
		char buf[1000];
		int len = vsnprintf (buf,sizeof(buf)-1,ctl,list);
		va_end (list);
		int lencmd = strlen(command);
		if (write (priv->fd,command,lencmd)==lencmd
			&& write (priv->fd," ",1)==1
			&& write (priv->fd,buf,len) == len){
			ret = 0;
		}
	}
	return ret;
}

PUBLIC int BOLIBFS::getfd()
{
	return priv->fd;
}

<mod>
PUBLIC int BOLIBFS::connect(SSTRING &errmsg)
{
	priv->fd = bomisc_connect (priv->server.get(),priv->port.get()
		,priv->user.get(),priv->passwd.get(),priv->document.get(),errmsg);
	return priv->fd;
}
</mod>

/*
	Check if a directory path exist
*/
<mod>
PUBLIC bool BOLIBFS::maycd(const char *dir)
{
	SSTRING uuid;
	<call bowalk>(*this,dir,false,uuid);
	</call>
	return uuid.is_filled();
}
</mod>

<mod>
PUBLIC int BOLIBFS::ls(const char *dir, BOLIBNODES &files)
{
	glocal BOLIBNODES *files = &files;
	SSTRING uuid;
	<call bowalk>(*this,dir,true,uuid);
	<f node>
		glocal.files->add (name,uuid,type,modif);
	</f>
	</call>
	return files.getnb();
}
</mod>

<mod>
PUBLIC int BOLIBFS::read(const char *dir, SSTRING &data)
{
	glocal int ret = -1;
	glocal SSTRING *data = &data;
	SSTRING uuid;
	<call bowalk>(*this,dir,false,uuid);
	</call>
	if (uuid.is_filled()){
		BOXMLENC enc;
		send (C_GETNODE,"%s\n",enc.enc(uuid));
		<call bolibfs>(getfd());
		<f node>
			glocal.ret = 0;
			glocal.data->setfrom(descr);
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

