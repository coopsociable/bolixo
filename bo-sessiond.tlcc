/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Manage web session ID
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <syslog.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <string>
#include <set>
#include <tlmpnet.h>
#include <tlmpsql.h>
#include <trlitool.h>
#include "instrument.h"

static DEBUG_KEY D_PROTO ("proto","Protocol information");
enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_ADMIN };

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	int no;
	std::string host;
	REQUEST_INFO req;
	HANDLE_INFO(){
		no = -1;
		type = TYPE_NONE;
	}
};

#include "proto/bo-sessiond_control.protoh"
#include "proto/bo-sessiond_client.protoh"
#include "proto/bo-sessiond_admin.protoh"
#include "proto/session_log.protoch"
#include "proto/session_log.protoh"

using namespace std;

struct VARIABLE{
	string name;
	string val;
	VARIABLE (PARAM_STRING _name, PARAM_STRING _val){
		name = _name.ptr;
		val  = _val.ptr;
	}
};

struct SESSION_INFO{
	unsigned userid;
	string userid_str;
	string name;
	string email;
	string lang;
	unsigned char dateformat;
	unsigned char timezone;
	bool admin;
	vector<VAR> vars;
	struct {
		time_t lastvisit;
		unsigned nbacc;
	} stats;
	SESSION_INFO(){
		userid = (unsigned)-1;
		stats.lastvisit = time(NULL);
		stats.nbacc = 0;
		admin = false;
		dateformat = 0;
		timezone = 0;
	}
	SESSION_INFO (unsigned _userid,
		const string &_userid_str,
		const char *_name,
		const char *_email,
		const char *_lang,
		bool _admin,
		unsigned _dateformat,
		unsigned _timezone){
		userid = _userid;
		userid_str = _userid_str;
		name = _name;
		email = _email;
		lang = _lang;
		admin = _admin;
		dateformat = _dateformat;
		timezone = _timezone;
		stats.lastvisit = time(NULL);
		stats.nbacc=1;
	}
};

static const char *VAR_NOTIFIES = "notifies";

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal int noproc = 1;
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *admin_secretfile = "/etc/bolixo/secrets.admin";
	glocal const char *bind = "0.0.0.0";
	glocal const char *port = "9200";
	glocal const char *control = "/var/run/bo-sessiond.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *pidfile = "/var/run/bo-sessiond.pid";
	glocal vector<string> variables;

	glocal.ret = <call tlmpprogram>(argc,argv,"tlmpsql");
	<f init>
		setproginfo ("bo-sessiond",VERSION,"Manage web sessions");
		setgrouparg ("Networking");
		setarg ('b',"bindaddr","Bind to this address (TCP)",glocal.bind,false);
		setarg ('p',"tcpport","Listen for command on this TCP port",glocal.port,false);
		setarg ('c',"control","Unix socket for bo-sessiond",glocal.control,false);
		setarg (' ',"variable","Supported web variable",glocal.variables,false);
		setgrouparg ("Misc.");
		setarg (' ',"admin-secrets","File holding admin secrets for communication",glocal.admin_secretfile,false);
		setarg (' ',"client-secrets","File holding client secrets for communication",glocal.client_secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
	</f>
	<f showerror>
		glocal const char *msg = msg;
		<call savefile>("/tmp/err.log",true);
		<f dowrite>
			fprintf (fout,"%s\n",glocal.msg);
			return 0;
		</f>
		</call>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		glocal set<string> vars;
		glocal map<string,SESSION_INFO> sessions;
		glocal map<string,string> admin_secrets;
		glocal map<string,string> client_secrets;
		glocal unsigned long nbrequest_admin = 0;
		glocal unsigned long nbrequest_client = 0;
		glocal unsigned long nbsessions_created = 0;
		glocal CONNECT_INFO con;
		glocal string controlport = string_f("unix:%s",glocal.control);
		string clientport = string_f ("unix:/tmp/sessiond-client-%s.sock",glocal.port);
		string adminport = string_f ("unix:/tmp/sessiond-admin-%s.sock",glocal.port);
		fdpass_readsecrets (glocal.admin_secretfile,glocal.admin_secrets);
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		int ret = -1;
		for (auto s:glocal.variables) glocal.vars.insert(s);
		{
			FILE *fin = fopen ("/tmp/sessions.log","r");
			if (fin != NULL){
				<call session_log>(fin);
				<f session>
					SESSION_INFO sess(userid, userid_str, name, email, lang, admin, dateformat,0);
					sess.stats.lastvisit = lastvisit;
					sess.stats.nbacc = nbacc;
					for (auto &v:vars) sess.vars.push_back(v);
					glocal.sessions[session] = sess;
					
				</f>
				<f invalid>
					tlmp_error ("Invalid entry, reading sessions.log\n");
				</f>
				</call>
				fclose (fin);
			}
		}
		<obj TCPSERVER s>(glocal.bind,clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else{
				settcpnodelay(true);
				char addr[20];
				const char *fromstr = addr;
				if (strncmp(info.port,"unix:",5)==0){
					fromstr = info.port;
				}else{
					ipnum_ip2a (from,addr);
				}
				n->host = fromstr;
				n->req.secret = fdpass_findsecret (glocal.client_secrets,fromstr);
				if (n->req.secret.size() > 0){
					n->type = TYPE_CLIENT;
				}else{
					n->req.secret = fdpass_findsecret (glocal.admin_secrets,fromstr);
					if (n->req.secret.size() > 0){
						n->type = TYPE_ADMIN;
					}else{
						tlmp_error ("Rejected connexion from IP %s\n",fromstr);
						endclient = true;
					}
				}
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request","admin request"};
			ERROR_PREFIX prefix ("%s: host %s secret %s:",tbtype[c->type],c->host.c_str(),c->req.secret.c_str());
			if (c->type == TYPE_CONTROL){
				<call bo_sessiond_control>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					tb.push_back(string_f ("nbsessions=%lu",glocal.sessions.size()));
					unsigned long nbanon = 0;
					unsigned long nbadmin = 0;
					for (auto &x:glocal.sessions){
						if (x.second.userid ==(unsigned)-1) nbanon++;
						if (x.second.admin) nbadmin++;
					}
					tb.push_back(string_f ("nbanon=%lu",nbanon));
					tb.push_back(string_f ("nbadmin=%lu",nbadmin));
					tb.push_back(string_f ("nbsesssions_created=%lu",glocal.nbsessions_created));
					tb.push_back(string_f ("nbrequest_admin=%lu",glocal.nbrequest_admin));
					tb.push_back(string_f ("nbrequest_client=%lu",glocal.nbrequest_client));
					rep_status(tb);
				</f>
				<f quit>
					<call savefile>("/tmp/sessions.log",false);
					<f dowrite>
						for (auto &s:glocal.sessions){
							session_log_session(fout,s.first,s.second.userid,s.second.userid_str
								,s.second.name,s.second.email,s.second.lang,s.second.admin
								,s.second.dateformat
								,s.second.stats.lastvisit,s.second.stats.nbacc,s.second.vars);
						}
						return 0;
					</f>
					</call>
					endserver = true;
				</f>
				<f listsessions>
					unsigned pos = 0;
					unsigned end = offset+nb-1;
					vector<string> tb;
					tb.push_back(string_f("listsessions %u -> %u",offset,end));
					for (auto &it:glocal.sessions){
						if (pos >end){
							break;
						}else if (pos >= offset){
							DATEASC datetime;
							fdpass_asctime (it.second.stats.lastvisit,datetime);
							string tmp;
							if (strncasecmp(it.second.userid_str.c_str(),"http://",7)==0
								|| strncasecmp(it.second.userid_str.c_str(),"https://",8)==0){
								const char *status = "unknown";
								if (it.second.userid == (unsigned)-1){
									status = "logged";
								}else if (it.second.userid == (unsigned)-2){
									status = "login";
								}
								tmp = string_f ("%07u: %s %s-%s %s %s %s %u %u %d %s",pos,it.first.c_str()
									,status,it.second.userid_str.c_str(),it.second.name.c_str(),it.second.email.c_str()
									,datetime.buf,it.second.stats.nbacc
									,it.second.userid,it.second.admin,it.second.lang.c_str());
							}else if (it.second.userid==(unsigned)-1){
								tmp = string_f ("%07u: %s anonymous %s %u",pos,it.first.c_str()
									,datetime.buf,it.second.stats.nbacc);
							}else{
								tmp = string_f ("%07u: %s %d-%s %s %s %s %u %u %d %s %u %u",pos,it.first.c_str()
									,it.second.userid,it.second.userid_str.c_str(),it.second.name.c_str(),it.second.email.c_str()
									,datetime.buf,it.second.stats.nbacc
									,it.second.userid,it.second.admin,it.second.lang.c_str()
									,it.second.dateformat,it.second.timezone);
							}
							tb.push_back(tmp);
							for (auto &v:it.second.vars){
								tmp = string_f("\t%s:[",v.name.c_str());
								bool geometry = v.name == "geometry";
								for (auto &vv:v.vals){
									if (geometry && vv.sname == "id") tmp += "\n\t";
									tmp += string_f (" %s=%s",vv.sname.c_str(),vv.sval.c_str());
								}
								tmp += "]";
								tb.push_back(tmp);
							}
						}
						pos++;
					}
					rep_listsessions(tb);
				</f>
				<f resetnotifies>
					for (auto &it:glocal.sessions){
						for (auto &v:it.second.vars){
							if (v.name == "notifies"){
								v.vals.clear();
							}
						}
					}
				</f>
				<f stuffsessions>
					time_t t = time(NULL);
					for (unsigned i=0; i<nb; i++){
						char tmp[100];
						snprintf (tmp,sizeof(tmp)-1,"%010lu-%010u-%010u-a",t,i,i);
						glocal.sessions[tmp] = SESSION_INFO();
					}
					rep_stuffsessions(glocal.sessions.size());
				</f>
				<f eraseold>
					unsigned deletedanon = 0;
					unsigned deleteduser = 0;
					unsigned deletedadmin = 0;
					time_t oldtime = time(NULL)-nbseconds;
					for (auto it=glocal.sessions.begin(); it!= glocal.sessions.end(); ){
						auto next = it;
						next++;
						if (it->second.stats.lastvisit < oldtime){
							if (it->second.userid == (unsigned)-1){
								if (anonymous){
									next = glocal.sessions.erase(it);
									deletedanon++;
								}
							}else if (it->second.admin){
								if (adminuser){
									next = glocal.sessions.erase(it);
									deleteduser++;
								}
							}else{
								if (normaluser){
									next = glocal.sessions.erase(it);
									deletedadmin++;
								}
							}
						}
						it = next;
					}
					rep_eraseold(deletedanon,deleteduser,deletedadmin);
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f invalid>
					tlmp_error ("Control: Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>

			}else if (c->type == TYPE_CLIENT){
				glocal.nbrequest_client++;
				<call bo_sessiond_client>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
				<f getsessioninfo>
					auto it = glocal.sessions.find(sessionid);
					if (it != glocal.sessions.end()){
						it->second.stats.lastvisit = time(NULL);
						it->second.stats.nbacc++;
						rep_getsessioninfo(true,it->second.name,it->second.lang,it->second.dateformat,it->second.admin,it->second.userid);
					}else{
						rep_getsessioninfo(false,"","",0,false,0);
					}
				</f>
				<f getsessioninfovars>
					auto it = glocal.sessions.find(sessionid);
					if (it != glocal.sessions.end()){
						it->second.stats.lastvisit = time(NULL);
						it->second.stats.nbacc++;
						rep_getsessioninfovars(true,it->second.name,it->second.lang,it->second.dateformat,it->second.admin,it->second.userid,it->second.vars);
					}else{
						vector<VAR> vars;
						rep_getsessioninfovars(false,"","",0,false,0,vars);
					}
				</f>
				<f setvar>
					string msg;
					bool success = false;
					if (glocal.vars.count(var.name)==0){
						msg = "unknown variable";
					}else{
						auto it = glocal.sessions.find(sessionid);
						if (it != glocal.sessions.end()){
							bool found = false;
							for (auto &v:it->second.vars){
								if (v.name == var.name){
									v.vals.clear();
									for (auto &vv:var.vals){
										SNAMEVAL vals;
										vals.sname = vv.sname;
										vals.sval = vv.sval;
										v.vals.push_back(vals);
									}
									found = true;
									success = true;
									msg = "Variable updated";
									break;
								}
							}
							if (!found){
								it->second.vars.push_back(var);
								msg = "Variable added";
								success = true;
							}
						}else{
							msg = "invalid session";
						}
					}
					rep_setvar (success,msg);
				</f>
				<f delnotify>
					bool success = false;
					string msg;
					auto it = glocal.sessions.find(sessionid);
					if (it == glocal.sessions.end()){
						msg = "Invalid sessionid";
					}else{
						for (auto &v:it->second.vars){
							if (v.name == VAR_NOTIFIES){
								unsigned pos=0;
								for (auto &vv:v.vals){
									if (vv.sname == name){
										v.vals.erase(v.vals.begin()+pos);
										break;
									}
									pos++;
								}
								break;
							}
						}
						success = true;
					}
					rep_delnotify(success,msg);
				</f>
				<f test>
					rep_test (true);
				</f>
				<f invalid>
					tlmp_error ("Client: Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_ADMIN){
				glocal.nbrequest_admin++;
				<call bo_sessiond_admin>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
				<f getsessioninfo>
					auto it = glocal.sessions.find(sessionid);
					if (it != glocal.sessions.end()){
						it->second.stats.lastvisit = time(NULL);
						it->second.stats.nbacc++;
						rep_getsessioninfo(true,it->second.name.c_str(),it->second.email.c_str(),it->second.lang,it->second.admin,it->second.userid);
					}else{
						rep_getsessioninfo(false,"","",0,false,0);
					}
				</f>
				<f getsession>
					auto it = glocal.sessions.find(sessionid);
					if (it != glocal.sessions.end()){
						rep_getsession(true,it->second.userid,it->second.userid_str.c_str(),it->second.admin,it->second.lang);
					}else{
						rep_getsession(false,0,"",false,"");
					}
				</f>
				<f setsession>
					auto it = glocal.sessions.find(sessionid);
					if (it == glocal.sessions.end()){
						tlmp_error ("setsession: %s does not exist\n",sessionid);
					}else{
						it->second = SESSION_INFO(userid,userid_str,name,email,lang,admin,dateformat,timezone);
						VAR var;
						var.name = VAR_NOTIFIES;
						for (auto n:notifies){
							SNAMEVAL val;
							val.sname = n;
							var.vals.push_back(val);
						}
						it->second.vars.push_back(var);
					}
				</f>
				<f setlang>
					auto it = glocal.sessions.find(sessionid);
					if (it == glocal.sessions.end()){
						tlmp_error ("setsession: %s does not exist\n",sessionid);
					}else{
						it->second.lang = lang;
						it->second.dateformat = dateformat;
						// Update all sessions for this user
						for (auto &s:glocal.sessions){
							if (s.second.userid==it->second.userid){
								s.second.lang = lang;
								s.second.dateformat = dateformat;
								s.second.timezone = timezone;
							}
						}
					}
				</f>
				<f setnotify>
					// Assigned a notification to a list of userids
					for (auto userid:userids){
						for (auto &s:glocal.sessions){
							if (s.second.userid==userid){
								bool found_var = false;
								for (auto &var:s.second.vars){
									if (var.name == VAR_NOTIFIES){
										found_var = true;
										bool found = false;
										for (auto &v:var.vals){
											if (v.sname == name){
												found = true;
												break;
											}
										}
										if (!found){
											SNAMEVAL val;
											val.sname = name;
											var.vals.push_back(val);
										}
										break;
									}
								}
								if (!found_var){
									VAR var;
									var.name = VAR_NOTIFIES;
									SNAMEVAL val;
									val.sname = name;
									var.vals.push_back(val);
									s.second.vars.push_back(var);
								}
							}
							// A user may be connected using several devices
							// so no break.
						}
					}
				</f>
				<f deletesession>
					auto it = glocal.sessions.find(sessionid);
					if (it != glocal.sessions.end()){
						glocal.sessions.erase(it);
					}else{
						tlmp_error ("deletesession: unknown sessionid %s\n",sessionid);
					}
				</f>
				<f deletesessions>
					vector<string> sessionids;
					for (auto &it:glocal.sessions){
						if (it.second.userid==userid) sessionids.push_back(it.first);
					}
					for (auto &it:sessionids){
						auto s = glocal.sessions.find(it);
						if (s != glocal.sessions.end()){
							glocal.sessions.erase(s);
						}
					}
				</f>
				<f createsession>
					auto it = glocal.sessions.find(sessionid);
					if (it == glocal.sessions.end()){
						glocal.nbsessions_created++;
						glocal.sessions[sessionid]=SESSION_INFO();
					}else{
						tlmp_error ("createsession: %s already exists\n",sessionid);
					}
				</f>
				<f test>
					rep_test (true);
				</f>
				<f invalid>
					tlmp_error ("Admin: Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}
		if (s.listen (NULL,adminport)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			chmod (clientport.c_str()+5,0666);
			chmod (adminport.c_str()+5,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

