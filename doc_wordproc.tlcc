#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

using namespace std;

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER> users;
	for (auto &p:prefs){
		WORDPROC_USER user;
		user.name = p.first;
		user.line = p.second.cursor.line;
		user.column = p.second.cursor.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		users.emplace_back(user);
	}
	documentd_wordproc_users (&w,users);
	documentd_wordproc_lines (&w,lines);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f lines>
		for (auto &l:lines) glocal.lines.push_back(l);
	</f>
	<f invalid>
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
	prefs.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}

#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		size_t sizecar = utf8_codepoint_size(*p);
		while (sizecar > 0 && p != line.end()){
			p++;
			sizecar--;
		}
		ret++;	
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		size_t sizecar = utf8_codepoint_size(*p);
		while (sizecar > 0 && p != line.end()){
			p++;
			sizecar--;
			ret++;
		}
		pos--;
	}
	if (pos == 0){
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
static string wordproc_formatline(
	const string &line,
	map<string,WORD_USERPREF> &prefs,
	unsigned noline)
{
	string ret = string_f("%02u-",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	for (auto &p:prefs){
		if (p.second.maywrite && p.second.cursor.line == noline) cursors.emplace_back(p.second.cursor.column,p.second.insertmode);
	}
	if (cursors.size() > 0){
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors[0].column;
		unsigned cursor_no = 0;
		unsigned pos=0;
		for (auto p=line.begin(); p!=line.end(); ){
			auto c = *p;
			if (pos == column){
				const char *cursor=cursors[cursor_no].insertmode
					? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
				ret += cursor;
			}
			if (c == ' '){
				ret += "&nbsp;";
				p++;
			}else{
				size_t sizecar = utf8_codepoint_size(c);
				while (sizecar > 0 && p != line.end()){
					ret += *p++;
					sizecar--;
				}
			}
			if (pos == column){
				ret += "</span>";
				cursor_no++;
				if (cursor_no < cursors.size()){
					column = cursors[cursor_no].column;
				}
			}
			pos++;
		}
		if (pos <= column){
			while (cursor_no < cursors.size()){
				column = cursors[cursor_no].column;
				while (pos < column){
					pos++;
					ret += "&nbsp;";
				}
				const char *cursor=cursors[cursor_no].insertmode
					? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
				ret += string(cursor) + "&nbsp;</span>";
				cursor_no++;
			}
		}
	}else{
		for (auto c:line){
			if (c == ' '){
				ret += "&nbsp;";
			}else{
				ret += c;
			}
		}
	}
	return ret;
}

/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (vector<unsigned> &updlines, WORD_USERPREF &pref)
{
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line];
		unsigned len = wordproc_linelen(l);
		if (len > pref.cursor.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar > 0){
				l = l.substr(0,pos) + l.substr(pos+sizecar);
			}
		}else{
			unsigned nextline = pref.cursor.line+1;
			if (lines.size() > nextline){
				// We are at the end of the line, or further.
				// So we merge the previous line here.
				// First we grow the line
				while (len < pref.cursor.column){
					l += ' ';
					len++;
				}
				l += lines[nextline];
				lines.erase(lines.begin()+nextline);
				for (unsigned l=nextline; l<lines.size()+1; l++) updlines.push_back(l);
			}
		}
		updlines.push_back(pref.cursor.line);
	}
}
void WORDPROC::vmove (
	int move,
	unsigned visible_lines,		// How many <div> sent
	unsigned lastline,		// last line partially visible
	WORD_USERPREF &pref,
	VARVAL &script_var,
	vector<unsigned> &updlines)
{
	if (move < 0 && abs(move) > pref.cursor.line) move = -pref.cursor.line;
	unsigned nextline = pref.cursor.line + move;
	if (nextline < pref.offset){
tlmp_warning ("vmove offset=%u visible_lines=%u lastline=%u",pref.offset,visible_lines,lastline);
		pref.offset--;
		js_find_loop_start (script_var.val,"text","div");
		// Remove last div
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(pref.offset);
		updlines.push_back(pref.offset+1);
	}else if (nextline >= pref.offset + lastline){
		pref.offset++;
		js_find_loop_start (script_var.val,"text","div");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(last_line-1);
		updlines.push_back(last_line);
	}else{
		updlines.push_back(pref.cursor.line);
		updlines.push_back(nextline);
	}
	pref.cursor.line = nextline;
}
void WORDPROC::update_lines (string &script, vector<unsigned> &updlines)
{
	for (auto l:updlines){
		string id=string_f("l%u",l);
		static string empty;
		string &line = l < lines.size() ? lines[l] : empty;
		js_find_loop_set(script,"text","div",id,"innerHTML"
			,wordproc_formatline(line,prefs,l).c_str());
	}
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	setactivity();
	auto &pref = prefs[username];
	pref.maywrite = maywrite;
	unsigned visible_lines = sp.content_height/sp.fontsize + 10;
	visible_lines = 50;
tlmp_warning ("visible_lines=%u content_height=%u fontsize=%u",visible_lines,sp.content_height,sp.fontsize);
	if (strcmp(var,"print")==0){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &l:lines){
				if (line == pref.cursor.line){
					if (l.size() > pref.cursor.column){
						v.val += l.substr(0,pref.cursor.column) + cursor + l.substr(pref.cursor.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.cursor.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			unsigned width = sp.content_width;
			VARVAL v;
			v.var = VAR_CONTENT;
			// event.location==1 tells if this is the left shift/alt key or right. We are not using it now
			v.val += "<script>\n";
			// Function find the last visible line on screen
			v.val += "function getlastline(){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tvar elms = elm.getElementsByTagName('div');\n";
			//v.val += "\tconsole.log('getlastline length='+elms.length);\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar srect = elms[i].getBoundingClientRect();\n";
			//v.val += "\t\tconsole.log('i='+i+' rect.bottom='+rect.bottom+' srect.bottom='+srect.bottom);\n";
			v.val += "\t\tif (rect.bottom < srect.bottom){\n";
			v.val += "\t\t\treturn i;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Function called when the user click
			v.val += "function gameselect(event){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar elms = elm.getElementsByTagName('div');\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar rect = elms[i].getBoundingClientRect();\n";
			v.val += "\t\tif (event.clientY >= rect.top && event.clientY < rect.bottom){\n";
			v.val += "\t\t\tgameaction('select:'+i+' '+(event.clientX-rect.left)+' '+(event.clientY-rect.top)+' '+getlastline());\n";
			v.val += "\t\t\tbreak;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "}\n";
			// Function called when the user uses the keyboard
			v.val += "function gamepress(event){\n";
			v.val += "\tconsole.log ('key='+event.key+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey);\n";
			v.val += "\tconsole.log ('code='+event.code);\n";
			v.val += string_f("\tgameaction('kbd:'+event.code + ' ' + event.key+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey+' '+getlastline());\n");
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "</script>\n";
			// Buttons line
			v.val += "<div id=tab_form>\n";
			v.val += "Buttons";
			v.val += "</div>\n";
			// Document
			v.val += "<div class=webtable id=doc_wordproc style='display:flex; flex-flow:row;'>\n";
			v.val += string_f("<div id='text-%s' onkeydown=gamepress(event) onclick=gameselect(event)"
				" tabindex=0 style='flex:0 0 auto; overflow: hidden; margin-right:%u; width:%u'>\n",gameid.c_str(),10,width);
			unsigned line = 0;
			if (pref.offset < lines.size()){
				for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
					auto &l = *p;
					unsigned doc_line = line+pref.offset;
					v.val += string_f("<div id=l%u>%s</div>\n",doc_line
						,wordproc_formatline(l,prefs,doc_line).c_str());
					line++;
				}
			}
			for (; line<visible_lines; line++){
				static string empty;
				unsigned doc_line = line+pref.offset;
				v.val += string_f("<div id=l%u>%s</div>\n",doc_line
					,wordproc_formatline(empty,prefs,doc_line).c_str());
			}
			v.val += "</div>\n";
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += "&nbsp;";
			#if 0
				// Trick to make the document window shorter
				for (int i=0; i<25; i++) v.val += "allo<br>\n";
			#endif
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else{
		struct {
			bool ctrl = false;
			bool shift = false;
			bool alt = false;
		} mod;
		unsigned lastline = 1000;
		if (strcmp(var,"kbd")==0){
			if (is_start_any_of(var,NONEED,"kbd")){
				vector<string> tb;
				int n = str_splitline(val,' ',tb);
				tlmp_warning ("n=%d val=%s",n,val);
				if (n == 5 && is_any_of(tb[0],"Space")){
					var = "insertchar";
					val = " ";
					lastline = atoi(tb[4].c_str());
				}else if (n != 6){
					// Do nothing
				}else{
					lastline = atoi(tb[5].c_str());
					mod.alt = tb[2] == "true";
					mod.ctrl = tb[3] == "true";
					mod.shift = tb[4] == "true";
					const char *tb0 = tb[0].c_str();
					const char *tb1 = tb[1].c_str();
					if (is_any_of(tb0,"Enter","NumpadEnter")){
						var = "break";
					}else if (is_any_of(tb0,"NumpadDecimal")){
						if (tb[1] == "Delete"){
							var = "deletechar";
						}else{
							var = "insertchar";
							val = tb1;
						}
					}else if (is_start_any_of(tb0,NONEED,"Numpad")){
						if (tb[1].size()==1){
							var = "insertchar";
							val = tb1;
						}else if (strcmp(tb1,"Home")==0){
							var = "home";
						}else if (strcmp(tb1,"End")==0){
							var = "end";
						}else if (strcmp(tb1,"ArrowLeft")==0){
							var = "hmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowRight")==0){
							var = "hmove";
							val = "1";
						}else if (strcmp(tb1,"ArrowUp")==0){
							var = "vmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowDown")==0){
							var = "vmove";
							val = "1";
						}else if (strcmp(tb1,"Insert")==0){
							var = "insertmode";
						}else if (strcmp(tb1,"PageUp")==0){
							var = "pageup";
						}else if (strcmp(tb1,"PageDown")==0){
							var = "pagedown";
						}
					}else if (is_start_any_of(tb0,NONEED,"Key","Digit","Slash")){
						var = "insertchar";
						val = tb1;
					}else if (is_any_of(tb0,"Insert")){
						var = "insertmode";
					}else if (is_any_of(tb0,"Delete")){
						var = "deletechar";
					}else if (is_any_of(tb0,"Home")){
						var = "home";
					}else if (is_any_of(tb0,"End")){
						var = "end";
					}else if (is_any_of(tb0,"ArrowUp")){
						var = "vmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowDown")){
						var = "vmove";
						val = "1";
					}else if (is_any_of(tb0,"ArrowLeft")){
						var = "hmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowRight")){
						var = "hmove";
						val = "1";
					}else if (is_any_of(tb0,"Backspace")){
						var = "backspace";
					}else if (is_any_of(tb0,"PageUp")){
						var = "pageup";
					}else if (is_any_of(tb0,"PageDown")){
						var = "pagedown";
					}
				}
				tlmp_warning ("kbd: var=%s val=%s lastline=%u",var,val,lastline);
			}
		}
		if (maywrite){
			VARVAL notify_var;
			notify_var.var = VAR_NOTIFY;
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
			vector<unsigned> notify_lines;	// Lines to update using NOTIFY (To all)
			if (strcmp(var,"insertmode")==0){
				pref.insertmode = !pref.insertmode;
				notify_lines.push_back(pref.cursor.line);
			}else if (strcmp(var,"insertchar")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				string &l = lines[pref.cursor.line];
				while (wordproc_linelen(l) < pref.cursor.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				l.insert(pos,val);
				pref.cursor.column ++;
				notify_lines.push_back(pref.cursor.line);
			}else if (strcmp(var,"break")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				string &l = lines[pref.cursor.line];
				auto nextline = lines.begin() + (pref.cursor.line+1);
				if (wordproc_linelen(l) > pref.cursor.column){
					unsigned pos = wordproc_jump2col(l,pref.cursor.column);
					lines.insert(nextline,l.substr(pos));
					lines[pref.cursor.line].resize(pos);
				}else{
					lines.insert(nextline,"");	
				}
				for (unsigned l=pref.cursor.line; l<lines.size(); l++) notify_lines.push_back(l);
				pref.cursor.line++;
				pref.cursor.column=0;
			}else if (strcmp(var,"backspace")==0){
				notify_lines.push_back(pref.cursor.line);
				// We start by moving the cursor back one character if possible.
				// If we are at the start of a line, we go at the end of the previous line.
				// We do a deletechar after that
				if (pref.cursor.column > 0){
					pref.cursor.column--;
					deletechar(notify_lines,pref);
				}else if (pref.cursor.line > 0){
					pref.cursor.line--;
					pref.cursor.column=0;
					if (lines.size() > pref.cursor.line){
						string &l = lines[pref.cursor.line];
						unsigned len = wordproc_linelen(l);
						pref.cursor.column = len;
					}
					notify_lines.push_back(pref.cursor.line);
					deletechar(notify_lines,pref);
				}
			}else if (strcmp(var,"deletechar")==0){
				deletechar(notify_lines,pref);
			}else if (strcmp(var,"voffset")==0){
				// Change page up or down
				int move = atoi(val);
				if (move > 0){
					pref.offset += move;
				}else{
					if ((unsigned)-move > pref.offset){
						pref.offset = 0;
					}else{
						pref.offset += move;
					}
				}
			}else if (strcmp(var,"vmove")==0){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.cursor.line;
				vmove (move,visible_lines,lastline,pref,script_var,script_lines);
				if (current_line != pref.cursor.line){
					notify_lines.push_back(current_line);
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"pageup")==0 || strcmp(var,"pagedown")==0){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				if (new_offset < 0) new_offset = 0;
				if ((unsigned)new_offset != pref.offset){
					int offline = pref.cursor.line - pref.offset;
					if (offline < 0) offline = 0;
					js_find_loop_start (script_var.val,"text","div");
					// Remove all div
					script_var.val += "\telm.innerHTML='';\n";
					// Add new ones
					script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
					script_var.val += "\t\tvar newElement = document.createElement('div');\n";
					script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
					script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
					script_var.val += "\t\tnewElement.innerHTML = '';\n";
					script_var.val += "\t\telm.insertBefore(newElement,null);\n";
					script_var.val += "\t}\n";
					js_find_loop_end (script_var.val);
					for (unsigned i=0; i<visible_lines; i++) script_lines.push_back(new_offset+i);
					notify_lines.push_back(pref.cursor.line);
					if (pref.cursor.line < (unsigned)new_offset
						|| pref.cursor.line >= new_offset + lastline){
						pref.cursor.line = new_offset+offline;
					}
					notify_lines.push_back(pref.cursor.line);
					pref.offset = new_offset;
				}
			}else if (strcmp(var,"hmove")==0){
				int move = atoi(val);
				if (move < 0){
					if (pref.cursor.column == 0){
						if (pref.cursor.line > 0){
							notify_lines.push_back(pref.cursor.line);
							vmove (-1,visible_lines,lastline,pref,script_var,script_lines);
							if (lines.size() > pref.cursor.line){
								pref.cursor.column = wordproc_linelen(lines[pref.cursor.line]);
							}
							notify_lines.push_back(pref.cursor.line);
						}
							
					}else{
						if (pref.cursor.line < lines.size() && mod.ctrl){
							// skip word back
							auto &line = lines[pref.cursor.line];
							unsigned len = wordproc_linelen(line);
							if (pref.cursor.column > len){
								pref.cursor.column = len;
							}else{
								// First, skip spaces
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] != ' ') break;
									pref.cursor.column--;
								}
								// Then skip word
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] == ' ') break;
									pref.cursor.column--;
								}
							}
						}else{
							pref.cursor.column += move;
						}
						notify_lines.push_back(pref.cursor.line);
					}
				}else{
					if (pref.cursor.line < lines.size() && mod.ctrl){
						// skip word
						auto &line = lines[pref.cursor.line];
						unsigned len = wordproc_linelen(line);
						if (pref.cursor.column >= len){
							pref.cursor.column++;
						}else{
							// First, skip spaces
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] != ' ') break;
								pref.cursor.column++;
							}
							// Then skip word
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] == ' ') break;
								pref.cursor.column++;
							}
						}
					}else{
						pref.cursor.column += move;
					}
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"home")==0){
				if (pref.cursor.column != 0){
					pref.cursor.column = 0;
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"end")==0){
				unsigned column  = pref.cursor.column;
				if (lines.size() > pref.cursor.line){
					column = wordproc_linelen(lines[pref.cursor.line]);
				}else{
					column = 0;
				}
				if (column != pref.cursor.column){
					pref.cursor.column = column;
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"select")==0){
				vector<string> tb;
				tlmp_warning ("select=%s",val);
				int n = str_splitline(val,' ',tb);
				if (n == 4){
					unsigned noline = atoi(tb[0].c_str());
					if (noline < visible_lines){
						unsigned newline = pref.offset + noline;
						if (newline != pref.cursor.line){
							notify_lines.push_back(pref.cursor.line);
							pref.cursor.line = newline;
						}
						// We have to figure out where 
						if (pref.cursor.line < lines.size()){
							unsigned xcoor = atoi(tb[1].c_str());
							auto &line = lines[pref.cursor.line];
							unsigned len = wordproc_linelen(line);
							unsigned xpos = 0;
							for (unsigned i=0; i<len; i++){
								// We have to compute the length of every character in the line
								#if 0
								size_t sizecar;
								unsigned pos = wordproc_jump2col(line,i,sizecar);
								#endif
								// assume a fixed length for now
								unsigned width=10;
								xpos += width;
								if (xpos  > xcoor){
									pref.cursor.column = i;
									break;
								}
							}
						}
						notify_lines.push_back(pref.cursor.line);
					}
				}
			}
			update_lines (notify_var.val,notify_lines);
			update_lines (script_var.val,script_lines);
			res.emplace_back(script_var);
			res.emplace_back(notify_var);
			setmodified(username);
		}else{
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> updlines;	// Lines to update using NOTIFY
			if (strcmp(var,"vmove")==0){
				// Vertical arrows are producing scrolls in read only mode.
				int move = atoi(val);
				if (move < 0){
					pref.cursor.line = pref.offset;
				}else{
					pref.cursor.line = pref.offset + visible_lines - 1;
				}
				vmove (move,visible_lines,lastline,pref,script_var,updlines);
			}else{
				documentd_error (res,MSG_R(E_READONLY));
			}
			update_lines (script_var.val,updlines);
			res.emplace_back(script_var);
		}
	}
}

