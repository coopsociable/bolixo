/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

#define documentd_wordproc_lines_NOTNEED
#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

using namespace std;

static float para_fontsize=1;
static unsigned displaylen_call=0;
static unsigned wordproc_displaylen (PARAM_STRING txt, unsigned fontsize)
{
	displaylen_call++;
	unsigned ret = 10*strlen(txt.ptr);
	if (fontsize > 0){
		ret = documentd_displaylen (txt.ptr,fontsize,para_fontsize);
	}
	//tlmp_warning ("displaylen :%s: fontsize=%u ret=%u",txt.ptr,fontsize,ret);
	return ret;
}
#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}

#define CAR_START_EFFECT	11		
#define CAR_END_EFFECT		12
#define CAR_END2_EFFECT		13	// This is like END, except the cursor moves over it
#					// This is useful to stop expanding an effect while entering character
#define CAR_BREAK		14
#define EFFECT_BOLD	"b"
#define EFFECT_ITALIC	"i"
#define EFFECT_UNDERLINE "u"
#define EFFECT_SUP	"S"
#define EFFECT_SUB	"s"
#define EFFECT_FONT1	"F"

struct WORDCHUNK{
	string txt;
	unsigned len = 0;
	unsigned txtlen = 0;
	WORD_EFFECTS_STATE effects;
	WORDCHUNK(
		const char *_txt,	// Start of chunk
		unsigned _strlen,	// Length of chunk in bytes
		unsigned _txtlen,	// Length of chunk in UTF-8 character
		const WORD_EFFECTS_STATE &_effects,	// Current effects applied to the chunk
		unsigned fontsize)	// Browser default font size
		:txt(_txt,_strlen), txtlen(_txtlen), effects(_effects){
		len = wordproc_displaylen(txt,fontsize);
	}
	string startstr (unsigned nbchar){
		const char *start = txt.c_str();
		const char *pt = start;
		while (nbchar > 0 && *pt != '\0'){
			size_t sizecar = utf8_codepoint_size(*pt);
			pt += sizecar;
			nbchar--;
		}
		return txt.substr(0,pt-start);
	}
};
	
	

struct WORDINFO{
	vector<WORDCHUNK> chunks;	// A word may have different font attributes, so is cut in chunks
	unsigned len;			// In pixel
	unsigned txtlen;		// strlen(txt);
	WORDINFO(){
		len = 0;
		txtlen = 0;
	}
	void addchunk (const char *txt, unsigned _strlen, unsigned _txtlen, const WORD_EFFECTS_STATE &effects, unsigned fontsize){
		if (_txtlen > 0){
			txtlen += _txtlen;
			WORDCHUNK chunk(txt,_strlen, _txtlen,effects,fontsize);
			len += chunk.len;
			chunks.emplace_back(move(chunk));
		}
	}
	void reset(){
		chunks.clear();
		len = 0;
		txtlen = 0;
	}
	void remove_first_space(unsigned fontsize){
		if (chunks.size() > 0){
			auto &c = chunks[0];
			if (c.txt[0] == ' '){
				// Remove the space for the first word
				c.txt = c.txt.substr(1);
				c.txtlen--;
				txtlen--;
				unsigned space_width = wordproc_displaylen(" ",fontsize);
				c.len -= space_width;
				len -= space_width;
			}
		}
	}
};
class PARAGRAPH{
public:
	vector<WORDINFO> words;		// The paragraph is decomposed into words
	vector<vector<WORDINFO>> lines;	// Then the words are put together in lines
	vector<unsigned> line_cursors;	// character cursor position in each line, produced by locate_cursor()
	vector<unsigned> line_homes;	// character cursor (paragraph) position of the start of each line
	vector<unsigned> line_ends;	// character cursor (paragraph) position of the end of each line
	vector<unsigned> line_heights;	// Height in pixel of each paragraph lines
	unsigned fontsize=0;
	void addline (unsigned line_start, unsigned line_end, unsigned height);
	unsigned cursor_pos=0;		// Cursor position inside the line in pixel
public:
	PARAGRAPH();
	PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void init(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor);
	void locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline);
	void locate_pixel(unsigned x_pos, unsigned y_pos);
	unsigned get_para_cursor (unsigned noline);
	unsigned get_para_home (unsigned noline);
	unsigned get_para_end (unsigned noline);
	unsigned get_line_cursor (unsigned noline);
	unsigned get_nblines() const{
		return lines.size();
	}
	unsigned get_cursor_xpos() const {
		return cursor_pos;
	}
};

PARAGRAPH::PARAGRAPH()
{
}
PARAGRAPH::PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	init (txt,width,_fontsize);
}
/*
	Add the specification of one line in the paragraph
*/
void PARAGRAPH::addline (unsigned word_start, unsigned word_end, unsigned height)
{
	vector<WORDINFO> line;
	unsigned charlen = 0;
	//unsigned breaklen = 0;
	for (unsigned i=word_start; i<word_end; i++){
		auto &w = words[i];
		line.push_back(w);
		charlen += w.txtlen;
		//if (w.txtlen == 0) breaklen=1;	// CAR_BREAK
	}
	lines.emplace_back(move(line));
	unsigned homepos = 0;
	unsigned last_end = line_ends.size();
	if (last_end > 0) homepos = line_ends[last_end-1]+1;
	line_ends.push_back(homepos+charlen);
	line_homes.push_back(homepos);
	line_heights.push_back(height+2);	// 2 pixel between lines of a paragraph
}

void PARAGRAPH::init(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	fontsize = _fontsize;
	words.clear();
	lines.clear();	
	line_homes.clear();
	line_ends.clear();
	line_heights.clear();

	const char *pt = txt.ptr;
	WORDINFO word;
	stack<WORD_EFFECTS_STATE> effects;
	WORD_EFFECTS_STATE state;
	while (*pt != '\0'){
		// A word is composed of spaces at the start and then non spaces
		// Only the first space is used to split word. The other are turned into &nbsp; at format time, so are part of the word
		// The user entered extra space, so they are kept in the format.
		const char *start = pt;
		unsigned txtlen=0;	// UTF-8 character len
		bool word_start = true;	// Spaces are accepted only at word start
		while (*pt != '\0'){
			if (*pt == ' '){
				if (!word_start) break;
				txtlen++;
				pt++;
			}else if (*pt == CAR_START_EFFECT){
				word.addchunk (start,pt-start,txtlen,state,fontsize);
				pt++;
				const char *effect = pt;
				while (*pt != '\0' && *pt != ';') pt++;
				if (is_start_any_of(effect,NONEED,EFFECT_BOLD)){
					state.bold = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_ITALIC)){
					state.italic = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_UNDERLINE)){
					state.underline = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_SUB)){
					state.sub = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_SUP)){
					state.sup = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_FONT1)){
					state.font1 = true;
				}
				while (*pt != ';') pt++;
				if (*pt == ';') pt++;
				effects.push(state);
				start = pt;
				txtlen = 0;
			}else if (is_any_of(*pt,CAR_END_EFFECT,CAR_END2_EFFECT)){
				word.addchunk (start,pt-start,pt-start,state,fontsize);
				state = effects.top();
				effects.pop();
				pt++;
				start = pt;
				txtlen = 0;
			}else if (*pt == CAR_BREAK){
				// This ends the line
				word.addchunk (start,pt-start,txtlen,state,fontsize);
				words.emplace_back(move(word));
				word.reset();
				// After the loop, the emplace_back will add an empty word (no chunks).
				// This will be used to detect BREAK later when building paragraph.
				pt++;
				start = pt;
				txtlen = 0;
				break;
			}else{
				// Non space character
				word_start = false;
				size_t sizecar = utf8_codepoint_size(*pt);
				pt+=sizecar;
				txtlen++;
			}
		}
		word.addchunk (start,pt-start,txtlen,state,fontsize);
		words.emplace_back(move(word));
		word.reset();
	}

	unsigned offset = 0;
	unsigned wordnum = 1;
	while (wordnum < words.size()){
		// We assemble a line made of words until its width is larger than the div width.
		auto &wo = words[offset];
		wo.remove_first_space(fontsize);
		unsigned linelen = wo.len;
		for (unsigned i=offset+1; i<=wordnum; i++) linelen += words[i].len;
		//htmlprintf ("linelen=%u width=%u lines.size()=%lu<br>\n",linelen,width,lines.size());
		bool empty_word = words[wordnum].len==0;// CAR_BREAK
		if (linelen < width && !empty_word){
			wordnum++;
		}else{
			if (empty_word) wordnum++;
			addline (offset,wordnum,fontsize);
			offset = wordnum;
		}
	}
	{
		addline (offset,words.size(),fontsize);
	}
}
/*
	Find the coordinate of a linear cursor (character offset in a paragraph): line, and pixel offset
*/
void PARAGRAPH::locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor)
{
	// The cursor represent a linear position into a paragraph
	// Now that the text is splitted in lines, we will find the line the cursor belongs,
	// then the offset in that line, and then, a pixel position in that line.
	noline = 0;
	line_cursors.clear();
	unsigned last_line = lines.size()-1;
	for (unsigned i=0; i<lines.size(); i++){
		auto &line = lines[i];
		unsigned homepos = line_homes[i];
		unsigned endpos = i<last_line ? line_homes[i+1] : line_ends[i];
		if (para_cursor < endpos
			|| i==last_line){
			noline = i;
			line_cursor = para_cursor - homepos;
			unsigned offset_cursor = 0;
			cursor_pos=0;		// Cursor position inside the line in pixel
			for (auto &w:line){
				if (offset_cursor == line_cursor){
					para_cursor = 0;
					break;
				}else{
					for (auto &c:w.chunks){
						unsigned next_offset = offset_cursor + c.txtlen;
						if (next_offset > line_cursor){
							// Ok the cursor is in that word
							string tmp = c.startstr(line_cursor-offset_cursor);
							//printf ("last chunk :%s: para_cursor %u offset_cursor %u\n",tmp.c_str(),para_cursor,offset_cursor);
							cursor_pos += wordproc_displaylen(tmp,fontsize);
							para_cursor = 0;
							break;
						}
						cursor_pos += c.len;
						offset_cursor = next_offset;
					}
					if (para_cursor == 0) break;
				}
			}
			break;
		}
	}
	if (para_cursor > 0){
		unsigned space_width = wordproc_displaylen(" ",fontsize);
		while (para_cursor > 0){
			para_cursor--;
			cursor_pos += space_width;
		}
	}
	locate_pixel (cursor_pos,0);
}
/*
	Find the corresponding cursor position in each line based on position given in pixel
*/
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline)
{
	// We know the cursor horizonl and vertical position in pixel: x_pos,y_pos
	// Now we will find the corresponding cursor position in each lines of the paragraph.
	// This will be stored in line_offsets. This is the cursor position in character.
	// We also locate the paragraph line number
	noline=0;
	unsigned y_offset = 0;
	for (auto h:line_heights){
		y_offset += h;
		tlmp_warning ("noline=%u y_offset=%u y_pos=%u",noline,y_offset,y_pos);
		if (y_offset > y_pos) break;
		noline++;
	}
	line_cursors.clear();
	for (auto &l:lines){
		unsigned pixel_offset = 0;
		unsigned offset = 0;
		for (auto &w:l){
			unsigned next_pixel_offset = pixel_offset + w.len;
			if (next_pixel_offset > x_pos){
				// The cursor is located in that word.
				for (auto &c:w.chunks){
					unsigned next_chunk_pixel = pixel_offset + c.len;
					if (next_chunk_pixel > x_pos){
						const char *s = c.txt.c_str();
						string tmp;
						unsigned target_pos = x_pos - pixel_offset;
						while (*s != '\0'){
							size_t sizecar = utf8_codepoint_size(*s);
							while (sizecar > 0 && *s != '\0'){
								tmp += *s++;
								sizecar--;
							}
							#if 0
							htmlprintf ("line=%lu tmp=:%s: offset=%u target_pos=%u dlen=%u<br>\n"
								,line_cursors.size(),tmp.c_str(),offset,target_pos,wordproc_displaylen(tmp,fontsize));
							#endif
							if (wordproc_displaylen(tmp,fontsize) > target_pos) break;
							offset++;
						}
						break;
					}
					pixel_offset = next_chunk_pixel;
					offset += c.txtlen;
				}
				break;
			}
			pixel_offset = next_pixel_offset;
			offset += w.txtlen;
		}
		line_cursors.push_back(offset);
	}
}
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos)
{
	unsigned paraline;
	locate_pixel (x_pos,y_pos,paraline);
}
unsigned PARAGRAPH::get_para_home (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_homes.size()){
		return line_homes[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_end (unsigned noline)
{
	unsigned ret = 0;
	//tlmp_warning ("get_para_end noline=%u line_ends.size()=%lu",noline,line_ends.size());
	if (noline < line_ends.size()){
		//tlmp_warning ("end=%u",line_ends[noline]);
		return line_ends[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()){
		return line_homes[noline] + line_cursors[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_line_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()) ret = line_cursors[noline];
	return ret;
}

void wordproc_testparagraph(const char *line, unsigned width, unsigned fontsize, unsigned para_cursor)
{
	PARAGRAPH para (line,width,fontsize);
	unsigned noline,line_cursor;
	para.locate_cursor(para_cursor,noline,line_cursor);
	printf ("para_cursor=%u -> noline=%u line_cursor=%u cursor_xpos=%u\n",para_cursor,noline,line_cursor,para.get_cursor_xpos());
	for (unsigned i=0; i<para.lines.size(); i++){
		auto &l = para.lines[i];
		unsigned txtlen=0;
		unsigned len = 0;
		for (auto &w:l){
			txtlen += w.txtlen;
			len += w.len;
		}
		printf ("line %u [h=%u,e=%u,c=%u,%u,%u]:",i,para.get_para_home(i),para.get_para_end(i),para.get_para_cursor(i),txtlen,len);
		len = 0;
		for (auto &w:l){
			printf ("[%u,%u](",w.txtlen,w.len);
			for (auto &c:w.chunks){
				printf ("%u,%u,%s ",c.txtlen,c.len,c.txt.c_str());
				len += c.len;
			}
			printf (") ");
		}
		printf ("\n");
		printf ("len=%u\n",len);
	}
}

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER> users;
	for (auto &p:prefs){
		WORDPROC_USER user;
		user.name = p.first;
		user.line = p.second.cursor.line;
		user.column = p.second.cursor.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		users.emplace_back(user);
	}
	documentd_wordproc_users (&w,users);
	vector<WORDPROC_PARA_V2> paras;
	for (auto &l:lines){
		WORDPROC_PARA_V2 para;
		para.listtype = l.listtype;
		para.title_level = l.get_paragraph_type();
		para.line_spec = l.get_paragraph_spec();
		para.tab_level = l.tab_level;
		para.line = l.line;
		paras.emplace_back(para);
	}
	documentd_wordproc_lines_v2 (&w,paras);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	glocal gameid;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f lines>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(line.is_image() ? 30 : 0);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f lines_v2>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(l.line_spec);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f invalid>
		tlmp_error ("Invalid command while loading document %s: %s",glocal.gameid.c_str(),msg);
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
	prefs.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}


static string::const_iterator wordproc_skipeffect(const string &line, string::const_iterator p)
{
	p++;
	while (p != line.end()){
		if (*p == ';'){
			p++;
			break;
		}else{
			p++;
		}
	}
	return p;
}
/*
	Walk a string from 0 to pos and fill the stack of active effects
*/
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects, string &last_effect)
{
	auto end = line.begin() + pos;
	for (auto p=line.begin(); p<end; ){
		if (*p == CAR_START_EFFECT){
			string effect;
			p++;
			while (p != line.end()){
				if (*p == ';'){
					p++;
					break;
				}else{
					effect += *p++;
				}
			}
			effects.push_back(effect);
			last_effect.clear();
		}else{
			if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
				if (effects.size() == 0){
					tlmp_warning ("END_EFFECT seen in doc, no active effect");
				}else{
					last_effect = effects.back();
					effects.pop_back();
				}
			}else{
				last_effect.clear();
			}
			p++;
		}
		
	}
}
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects)
{
	string last;
	wordproc_current_effects (line,pos,effects,last);
}
/*
	Remove dead effect sequences.
	A dead effect is an effect applied to an empty content.
	So it looks like CAR_START_EFFECT effect_string ; CAR_END2_EFFECT.
	A dead effect is not reachable by the end user.

	Note that an empty effect ended by CAR_END_EFFECT is still reachable by the end user.
	The user moves the cursor until one button in the button bar is highlited.
*/
static void wordproc_remove_dead_effects(string &l)
{
	for (unsigned i=0; i<l.size(); i++){
		if (l[i] == CAR_START_EFFECT){
			unsigned start = i;
			i++;
			while (l[i] != ';' && l[i] != '\0') i++;
			if (l[i] == ';'){
				i++;
				if (l[i] == CAR_END2_EFFECT){
					i++;
					l = l.erase(start,i-start);
					i=start-1;
				}
			}
		}
	}
}
/*

	If we are currently at the end of this effect, we toggle the END marker (END <-> END2). This allows the user to extend
	the line by inserting character inside or outside the effect area.

	If we are currently inside this effect area, it is removed.

	If not, we just insert the effect start and stop in a line.
*/
static void wordproc_insert_effect (string &line, unsigned pos, const char *effect)
{
	vector<string> cur_effects;
	string last_effect;
	wordproc_current_effects(line,pos,cur_effects,last_effect);
	if (cur_effects.size() > 0 && cur_effects.back()==effect){
		auto p = line.begin()+pos;
		if (*p == CAR_END_EFFECT){	
			*p = CAR_END2_EFFECT;
			wordproc_remove_dead_effects(line);
		}else{
			// We remove the effect.
		}
	}else if (last_effect==effect){
		line[pos-1] = CAR_END_EFFECT;	
	}else{
		line.insert(pos,string_f("%c%s;%c",CAR_START_EFFECT,effect,CAR_END_EFFECT));
	}
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			p = wordproc_skipeffect(line,p);
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
			}
			ret++;	
		}
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
			ret++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
				ret++;
			}
			pos--;
		}
	}
	if (pos == 0){
		auto p = line.begin()+ret;
		while (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}
		if (*p == CAR_END2_EFFECT) ret++;
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	//tlmp_warning ("jump2col ret=%u ret_sizecar=%lu %d",ret,ret_sizecar,line[ret]);
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
string WORDPROC::formatline(unsigned noline)
{
	WORDPROC_LINE empty;
	const WORDPROC_LINE &para = noline < lines.size() ? lines[noline] : empty;
	auto &line = para.line;
	string ret = string_f("<div class=col><div class=onecol>%02u-</div>",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	for (auto &p:prefs){
		if (p.second.maywrite && p.second.cursor.line == noline) cursors.emplace_back(p.second.cursor.column,p.second.insertmode);
	}
	stack<string> effects;
	string closetitle,closetab;
	{
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors.size() > 0 ? cursors[0].column : (unsigned)-1;
		unsigned cursor_no = 0;
		unsigned pos=0;
		static float tb[]={1, 1.2, 1.5, 2, 2.5};
		if (para.listtype == LIST_BULLET){
			ret += string_f("<div class=bullet%u>&bull;</div><div class=tab%u-bullet>",para.tab_level,para.tab_level);
		}else if (para.listtype == LIST_NUM){
			unsigned num = 1;
			for (int i=noline-1; i >=0; i--){
				auto &l = lines[i];
				if (l.tab_level == para.tab_level && l.listtype == LIST_NUM){
					num++;
				}else if (l.tab_level <= para.tab_level){
					break;
				}
			}
			ret += string_f("<div class=bullet%u><span style=font-size:%1.2fem>%u.</span></div><div class=tab%u-bullet>"
				,para.tab_level,tb[para.get_title_level()],num,para.tab_level);
		}else if (para.listtype == LIST_CENTER){
			ret += "<div class=tab-center>";
		}else{
			ret += string_f("<div class=tab%u>",para.tab_level);
		}
		closetab = "</div>";
		bool format = true;
		if (para.is_title()){
			ret += string_f("<span style=font-size:%1.2fem;>",tb[para.get_title_level()]);
			closetitle = "</span>";
		}else if (para.is_image()){
			const char *url = str_skip(para.line.c_str());
			if (strchr(url,'<')==nullptr){
				// If the < character is there, which is illegal, we simply display the line (format=true)
				// We do some validation and if the <img tag is generated, then we set format=false
				if (cursors.size() > 0) ret += "<div class=imgcursor>";
				const char *project;
				if (is_start_any_ofnc(url,NONEED,"http://","https://")){
					ret += string_f("<img width=%u%% src=%s>",para.get_image_width(),url);
					format = false;
				}else if (is_start_any_of(gameid,project,"/projects")){
					// We are sure that gameid starts with /projects/, but we test it anyway
					// This is a file stored in the bolixo project
					// We extract the bolixo project from the gameid;
					const char *slash = strrchr(project,'/');
					if (slash != nullptr){
						// Now we have the project and sub-folder without the document name
						string path(project,slash-project);
						if (url[0] == '/'){
							auto sl = path.find(1,'/');
							if (sl != string::npos) path.resize(sl);
						}
						path += url;
						ret += string_f("<img width=%u%% src=/index.hc?webstep=5&image=/projects%s>"
							,para.get_image_width(),path.c_str());
						format = false;
					}
				}
				if (cursors.size() > 0) ret += "</div>";
			}
		}
				
		if (format){
			for (auto p=line.begin(); p!=line.end(); ){
				auto c = *p;
				if (c == CAR_START_EFFECT){
					// tlmp_warning ("Start effect");
					string effect;
					p++;
					while (p != line.end()){
						if (*p == ';'){
							p++;
							break;
						}else{
							effect += *p++;
						}
					}
					// tlmp_warning ("effect=%s",effect.c_str());
					if (effect == EFFECT_BOLD){
						ret += "<b>";
						effects.push("</b>");
					}else if (effect == EFFECT_ITALIC){
						ret += "<i>";
						effects.push("</i>");
					}else if (effect == EFFECT_UNDERLINE){
						ret += "<u>";
						effects.push("</u>");
					}else if (effect == EFFECT_SUP){
						ret += "<sup>";
						effects.push("</sup>");
					}else if (effect == EFFECT_SUB){
						ret += "<sub>";
						effects.push("</sub>");
					}else if (effect == EFFECT_FONT1){
						ret += "<span style=font-size:1.5em;>";
						effects.push("</span>");
					}
				}else if (is_any_of(c,CAR_END_EFFECT,CAR_END2_EFFECT)){
					// tlmp_warning ("effects.size()=%lu",effects.size());
					p++;
					ret += effects.top();
					effects.pop();
				}else{
					if (pos == column){
						ret += string_f("<span class=%ccursor>",cursors[cursor_no].insertmode ? 'i' : 'r');
					}
					if (c == ' '){
						// The first space is passed as is so the browser knows there are multiple words
						// The extra spaces are changed to &nbsp; so they are not skipped by the browser
						if (p == line.begin()
							|| (p > line.begin() && p[-1] == ' ')){
							ret += "&nbsp;";
						}else{
							ret += ' ';
						}
						p++;
					}else if (c == '<'){
						ret += "&lt;";
						p++;
					}else if (c == '>'){
						ret += "&gt;";
						p++;
					}else if (c == '\\'){
						ret += "&bsol;";
						p++;
					}else if (c == '\''){
						ret += "&#39;";
						p++;
					}else if (c == CAR_BREAK){
						ret += "&nbsp;";	// Place a space so the cursor is visible
									// add a <br> after the code to close the cursor <span>
						p++;
					}else{
						size_t sizecar = utf8_codepoint_size(c);
						while (sizecar > 0 && p != line.end()){
							ret += *p++;
							sizecar--;
						}
					}
					if (pos == column){
						ret += "</span>";
						cursor_no++;
						if (cursor_no < cursors.size()){
							column = cursors[cursor_no].column;
						}
					}
					pos++;
					if (c == CAR_BREAK) ret += "<br>";
				}
			}
			if (pos <= column){
				while (cursor_no < cursors.size()){
					column = cursors[cursor_no].column;
					while (pos < column){
						pos++;
						ret += "&nbsp;";
					}
					const char *cursor=cursors[cursor_no].insertmode
						? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
					ret += string(cursor) + "&nbsp;</span>";
					cursor_no++;
				}
			}
		}
	}
	// This should not happen. Effect started on one line/paragraph must end in this paragraph.
	// Bug pending, we may end up here with unclosed effects. So we close them all here.
	while (effects.size() > 0){
		ret += effects.top();
		effects.pop();
	}
	ret += closetitle + closetab;
	ret += "</div>";
	return ret;
}
/*
	Check if the line following noline are LIST_NUM. If this is the case, the line is added to updlines
*/
static void wordproc_update_num_lines (unsigned noline, const vector<WORDPROC_LINE> &lines, set<unsigned> &updlines)
{
	if (noline < lines.size()){
		unsigned tab_level = lines[noline].tab_level;
		for (unsigned i=noline+1; i<lines.size(); i++){
			auto &l = lines[i];
			if (l.tab_level == tab_level && l.listtype == LIST_NUM){
				updlines.insert(i);
			}else if (l.tab_level <= tab_level){
				break;
			}
		}
	}
}

static void wordproc_update_button (string &script, bool &curstate, bool newstate, unsigned button_id)
{
	if (curstate != newstate){
		curstate = newstate;
		script += string_f("var button = document.getElementById('button%u');\n",button_id);
		script += "if (button != null){\n";
		script += string_f("\tbutton.style.background='%s';\n",newstate ? "lightblue" : "lightgray");
		script += "}\n";
	}
}
#define BUTTON_TITLE_PLUS	0
#define BUTTON_TITLE_LESS	1
#define BUTTON_TAB_PLUS		3
#define BUTTON_TAB_LESS		4
#define BUTTON_BULLET		5
#define BUTTON_NUMLIST		6
#define BUTTON_BOLD		7
#define BUTTON_ITALIC		8
#define BUTTON_UNDERLINE	9
#define BUTTON_SUP		10
#define BUTTON_SUB		11
#define BUTTON_CENTER		12
#define BUTTON_IMAGE		13

static void wordproc_update_buttons (string &script, WORD_USERPREF &pref, const WORD_EFFECTS_STATE &newstates)
{
	if (!pref.states_valid){
		// We invalidate all states to update all buttons.
		pref.states.bold = !newstates.bold;
		pref.states.italic = !newstates.italic;
		pref.states.underline = !newstates.underline;
		pref.states.sup = !newstates.sup;
		pref.states.sub = !newstates.sub;
		pref.states_valid = true;
	}
	wordproc_update_button (script,pref.states.bold,newstates.bold,BUTTON_BOLD);
	wordproc_update_button (script,pref.states.italic,newstates.italic,BUTTON_ITALIC);
	wordproc_update_button (script,pref.states.underline,newstates.underline,BUTTON_UNDERLINE);
	wordproc_update_button (script,pref.states.sup,newstates.sup,BUTTON_SUP);
	wordproc_update_button (script,pref.states.sub,newstates.sub,BUTTON_SUB);
}
/*
	Return true if the cursor if on a space
*/
bool WORDPROC::isspace(WORD_USERPREF &pref, bool &inside_doc)
{
	bool ret = false;
	inside_doc = false;
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line].line;
		unsigned len = wordproc_linelen(l);
		// tlmp_warning ("deletechar column=%u len=%u",pref.cursor.column,len);
		if (len > pref.cursor.column){
			inside_doc = true;
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar == 1 && l[pos] == ' ') ret = true;
		}
	}
	return ret;
}
/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (set<unsigned> &updlines, WORD_USERPREF &pref)
{
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line].line;
		unsigned len = wordproc_linelen(l);
		// tlmp_warning ("deletechar column=%u len=%u",pref.cursor.column,len);
		if (len > pref.cursor.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar > 0){
				// When positionned at the end of an effect, if the marker is
				// CAR_END_EFFECT, wordproc_jump2col() returns a pos right
				// on CAR_END_EFFECT. This way, inserted chars are inserted in the
				// effect. If it is CAR_END2_EFFECT, pos is right after, so
				// insert chars are placed after the effect.
				// When deleting a caracter, we have to delete after the effect
				// if we are positionned on CAR_END_EFFECT.
				if (l[pos] == CAR_END_EFFECT) pos++;
				l = l.substr(0,pos) + l.substr(pos+sizecar);
				// When deleting a character, we can create a dead/empty effect.
				// A dead effect is a effect in the line that can't be reached.
				// CAR_START_EFFECT effectname ; CAR_END2_EFFECT
				// An empty effect, ending with CAR_END_EFFECT is still reachable.
				// You move your cursor until you reach the effect. The button in
				// the button bar shows up.
				// But with CAR_END2_EFFECT, it is not possible. The effect just
				// ends in the line forever.
				// So we do a cleanup here.
				wordproc_remove_dead_effects(l);
				// The cleanup is also done when we use the button to turn off an effect
			}
		}else{
			unsigned nextline = pref.cursor.line+1;
			if (lines.size() > nextline && !lines[nextline].is_image()){
				// We are at the end of the line, or further.
				// So we merge the next line here.
				// First we grow the line
				while (len < pref.cursor.column){
					l += ' ';
					len++;
				}
				l += lines[nextline].line;
				lines.erase(lines.begin()+nextline);
				for (unsigned l=nextline; l<lines.size()+1; l++) updlines.insert(l);
			}
		}
		updlines.insert(pref.cursor.line);
	}
}
const unsigned bullet_width=15+5;	// width of a bullet
const unsigned tab_width=30;		// width per tab level

/*
	Initialise the PARAGRAPH layout for the current session/display.
*/
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	unsigned column,	// paragraph cursor
	const DOC_UI_SPECS_receive &sp,	// Specs of the sessions
	unsigned &para_noline)	// line in the paragraph
{
	if (noline < lines.size()){
		auto &l = lines[noline];
		unsigned bul_width = is_any_of (l.listtype,LIST_BULLET,LIST_NUM) ? bullet_width : 0;
		unsigned level_width = l.tab_level * tab_width;
		// 30 is for line numbers
		unsigned width = sp.content_width - 30 - bul_width - level_width;
		width++;	// Add one pixel, because browser really use all the space
				// another solution would be to put an >= in para.init
		//tlmp_warning ("set_para_spec content_width=%u bul_width=%u level_width=%u width=%u",sp.content_width,bul_width,level_width,width);
		para.init (l.line,width,sp.fontsize);
		unsigned line_cursor;
		para.locate_cursor (column,para_noline,line_cursor);
	}else{
		para_noline = 0;
		para.init ("",sp.content_width,sp.fontsize);
	}
}
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	const DOC_UI_SPECS_receive &sp)	// Specs of the sessions
{
	unsigned para_noline;
	set_para_spec (para,noline,0,sp,para_noline);
}
void WORDPROC::vmove (
	int move,
	unsigned visible_lines,		// How many <div> sent
	unsigned lastline,		// last line partially visible
	WORD_USERPREF &pref,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	set<unsigned> &updlines)
{
	if (pref.cursor.line < lines.size()){
		// Move inside a paragraph
		PARAGRAPH para;
		unsigned noline;
		set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
		unsigned nblines = para.get_nblines();
		unsigned x_pos = para.get_cursor_xpos();
		#if 0
		tlmp_warning ("vmove %d content_width=%u nblines=%u noline=%u line_cursor=%u column=%u"
			,move,spref.content_width,nblines,noline,line_cursor,pref.cursor.column);
		for (unsigned i=0; i<nblines; i++){
			tlmp_warning ("line %u: home=%u cursor=%u",i,para.line_homes[i],para.line_cursors[i]);
		}
		#endif
			
		updlines.insert(pref.cursor.line);
		if (move == -1){
			if (noline > 0){
				pref.cursor.column = para.get_para_cursor(noline-1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line > 0){
				set_para_spec (para,pref.cursor.line-1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(para.get_nblines()-1);
			}
		}else if (move == 1){
			if (noline < nblines -1){
				pref.cursor.column = para.get_para_cursor(noline+1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line < lines.size()-1){
				set_para_spec (para,pref.cursor.line+1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(0);
			}else{
				pref.cursor.column = para.get_para_cursor(nblines-1);
			}
		}
	}
	if (move < 0 && abs(move) > pref.cursor.line) move = -pref.cursor.line;
	unsigned nextline = pref.cursor.line + move;
	if (nextline < pref.offset){
		// tlmp_warning ("vmove offset=%u visible_lines=%u lastline=%u",pref.offset,visible_lines,lastline);
		pref.offset--;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove last div
		script_var.val += "console.log('vmove length='+elms.length);\n";
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(pref.offset);
		updlines.insert(pref.offset+1);
	}else if (nextline >= pref.offset + lastline){
		pref.offset++;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(last_line-1);
		updlines.insert(last_line);
	}else{
		updlines.insert(pref.cursor.line);
		updlines.insert(nextline);
	}
	pref.cursor.line = nextline;
}
void WORDPROC::page_up_down(
	int new_offset, 
	unsigned visible_lines,
	unsigned lastline,
	WORD_USERPREF &pref,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	set<unsigned> &notify_lines)
{
	if (new_offset < 0) new_offset = 0;
	if ((unsigned)new_offset != pref.offset){
		int offline = pref.cursor.line - pref.offset;
		if (offline < 0) offline = 0;
		js_find_loop_start (script_var.val,"text","div");
		// Remove all div
		script_var.val += "\telm.innerHTML='';\n";
		// Add new ones
		script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
		script_var.val += "\t\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
		script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
		script_var.val += "\t\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\t\tnewElement.innerHTML = '';\n";
		script_var.val += "\t\telm.insertBefore(newElement,null);\n";
		script_var.val += "\t}\n";
		js_find_loop_end (script_var.val);
		for (unsigned i=0; i<visible_lines; i++) script_lines.insert(new_offset+i);
		notify_lines.insert(pref.cursor.line);
		if (pref.cursor.line < (unsigned)new_offset
			|| pref.cursor.line >= new_offset + lastline){
			pref.cursor.line = new_offset+offline;
		}
		notify_lines.insert(pref.cursor.line);
		pref.offset = new_offset;
	}
}
void WORDPROC::update_lines (string &script, set<unsigned> &updlines)
{
	if (updlines.size() > 0){
		js_find_loop_start_class(script,"text","oneline");
		script += "\t\tfor (var i=0; i<elms.length; i++){\n";	
		script += "\t\t\tvar e=elms[i];\n";
		unsigned nol = 0;
		for (auto l:updlines){
			const char *elseverb = nol==0 ? "" : "}else ";
			string id=string_f("l%u",l);
			script += string_f("\t\t\t%sif(e.id=='l%u'){\n",elseverb,l);
			script += string_f("\t\t\t\te.innerHTML = '%s';\n",formatline(l).c_str());
			if (nol == updlines.size()-1){
				script += "\t\t\t\tbreak;\n";
				script += "\t\t\t}\n";
			}
			nol++;
		}
		script += "\t\t}\n";
		js_find_loop_end(script);
	}
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	tlmp_error ("WORDPROC::exec called");
}
void WORDPROC::execstep (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	VARVAL &notify_var,
	set<unsigned> &notify_lines,
	vector<VARVAL> &res)
{
	auto &pref = prefs[username];
	pref.maywrite = maywrite;
	unsigned visible_lines = 60;
	if (sp.content_height != 0 && sp.fontsize != 0) visible_lines = sp.content_height/sp.fontsize + 10;
	//tlmp_warning ("visible_lines=%u content_height=%u fontsize=%u",visible_lines,sp.content_height,sp.fontsize);
	// Force visible_lines to 60 because the specs are not always available, for now
	//visible_lines = 60;
	if (strcmp(var,"print")==0){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &ll:lines){
				auto &l = ll.line;
				if (line == pref.cursor.line){
					if (l.size() > pref.cursor.column){
						v.val += l.substr(0,pref.cursor.column) + cursor + l.substr(pref.cursor.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.cursor.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			unsigned width = sp.content_width;
			VARVAL v;
			v.var = VAR_CONTENT;


			{
				unsigned sp_width = width-30;	// Space for line numbers, during development
				v.val += "<style>\n";
				// Cursor insert mode
				v.val += ".icursor{\n";
				v.val += "\tbackground-color:lightgray;>";
				v.val += "}\n";
				// Cursor replace mode
				v.val += ".rcursor{\n";
				v.val += "\tbackground-color:lightpink;>";
				v.val += "}\n";

				// Border around image, when focus
				v.val += ".imgcursor{\n";
				v.val += "\tborder:2px solid lightgray;\n";
				v.val += "}\n";

				v.val += ".oneline{\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += "}\n";
				v.val += ".onecol{\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += "\twidth:30;\n";
				v.val += "}\n";

				v.val += ".oneline .col{\n";
				v.val += "\tdisplay:flex;\n";
				v.val += "\tflex-flow:row;\n";
				v.val += "\tmargin-bottom:5px;\n";
				v.val += "}\n";

				v.val += ".tab-center{\n";
				v.val += "\ttext-align:center;\n";
				v.val += "\toverflow-wrap: break-word;\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += string_f("\twidth:%u;\n",sp_width);
				v.val += "}\n";

				//unsigned offsets[]={5,tab_width-15,2*tab_width-15,3*tab_width-15};
				for (unsigned i=0; i<4; i++){
					v.val += string_f(".bullet%u{\n",i);
					v.val += "\tflex:0 1 auto;\n";
					v.val += "\twidth:10;\n";
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width+5);
					v.val += "\tmargin-right:5;\n";
					v.val += "}\n";
					v.val += string_f(".tab%u{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("\twidth:%u;\n",sp_width-i*tab_width);
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width);
					v.val += "\tfont-family:'serif';\n";
					v.val += "}\n";
					v.val += string_f(".tab%u-bullet{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("\twidth:%u;\n",sp_width-i*tab_width-bullet_width);
					v.val += "\tmargin-left:0;\n";
					v.val += "\tfont-family:'serif';\n";
					v.val += "}\n";
				}
			}
			v.val += "</style>\n";

			// event.location==1 tells if this is the left shift/alt key or right. We are not using it now
			v.val += "<script>\n";
			// Function find the last visible line on screen
			v.val += "function getlastline(){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			//v.val += "\tconsole.log('getlastline length='+elms.length);\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar srect = elms[i].getBoundingClientRect();\n";
			//v.val += "\t\tconsole.log('i='+i+' rect.bottom='+rect.bottom+' srect.bottom='+srect.bottom);\n";
			v.val += "\t\tif (rect.bottom < srect.bottom){\n";
			v.val += "\t\t\treturn i;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Function called when the user click
			v.val += "function gameselect(event){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar para= elms[i];\n";
			v.val += "\t\tvar rect = para.getBoundingClientRect();\n";
			v.val += "\t\tif (event.clientY >= rect.top && event.clientY < rect.bottom){\n";
			v.val += "\t\t\tvar divs=para.getElementsByTagName('div');\n";
			v.val += "\t\t\tvar r=divs[divs.length-1].getBoundingClientRect();\n";
			v.val += "\t\t\tgameaction(event,'select:'+i+' '+(event.clientX-r.left)+' '+(event.clientY-r.top)+' '+getlastline());\n";
			v.val += "\t\t\tbreak;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "}\n";
			// Function called when the user uses the keyboard
			v.val += "var gamekey=null;\n";
			v.val += "var gamecode=null;\n";
			v.val += "var altKey=null;\n";
			v.val += "var ctrlKey=null;\n";
			v.val += "var shiftKey=null;\n";

			v.val += "function gamepress(event){\n";
			v.val += "\tconsole.log ('press key='+event.key+' '+' code='+event.code+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey);\n";
			v.val += "\tgamekey=event.key;\n";
			v.val += "\tgamecode=event.code;\n";
			v.val += "\taltKey=event.altKey;\n";
			v.val += "\tctrlKey=event.ctrlKey;\n";
			v.val += "\tshiftKey=event.shiftKey;\n";
			//v.val += "\tif (gamecode.substring(0,3)!='Key' && gamekey != 'Dead' && gamekey != 'Process'){\n";
			v.val += "\tgameaction(event,'kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			//v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			v.val += "function funcinput(event){\n";
			v.val += "\tif (event.data == null) gamekey=event.data;\n";
			v.val += "\tgameaction(event,'kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			v.val += "\tconsole.log('kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			v.val += "function gamefalse(event){\n";
			//v.val += "\tconsole.log ('gamefalse type='+event.type+' data='+event.data);\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			// function called when the user uses the mouse wheel
			v.val += "function gamewheel(event){\n";
			//v.val += "\tconsole.log('deltaX='+event.deltaX+' deltaY='+event.deltaY);\n";
			v.val += "\tif (event.deltaY < 0){\n";
			v.val += "\t\tgameaction(event,'voffset:-1');\n";
			v.val += "\t}else{\n";
			v.val += "\t\tgameaction(event,'voffset:1');\n";
			v.val += "\t}\n";
			v.val += "}\n";
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				documentd_button_start(v.val,gameid);
				documentd_button (v.val,BUTTON_TITLE_PLUS,"T",specs,false);
				documentd_button (v.val,BUTTON_TITLE_LESS,"t",specs,false);
				documentd_button (v.val,BUTTON_BOLD,"<b>B</b>",specs,false);
				documentd_button (v.val,BUTTON_ITALIC,"<i>I</i>",specs,false);
				documentd_button (v.val,BUTTON_UNDERLINE,"<u>U</u>",specs,false);
				documentd_button (v.val,BUTTON_SUP,"A<sup>2</sup>",specs,false);
				documentd_button (v.val,BUTTON_SUB,"A<sub>2</sub>",specs,false);
				documentd_button (v.val,BUTTON_TAB_PLUS,"->",specs,false);
				documentd_button (v.val,BUTTON_TAB_LESS,"<-",specs,false);
				documentd_button (v.val,BUTTON_CENTER,"<>",specs,false);
				documentd_button (v.val,BUTTON_BULLET,"&bull;",specs,false);
				documentd_button (v.val,BUTTON_NUMLIST,"N.",specs,false);
				int w4 = specs.width/4;
				int h1 = specs.width/3;
				int h2 = 2*h1;
				string svg_image= string_f(
					"<svg width=%upx height=%upx>"
					"<path stroke='black' stroke-width=1 d='M%u,%u l%d,%d l%d,%d l%d,%d l%d,%d' fill='black'/>"
					"</svg>"
					,specs.width,specs.width
					,0,specs.width, w4,-h1, w4,h1, w4,-h2, w4,h2);
				documentd_button (v.val,BUTTON_IMAGE,svg_image,specs,false);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Document
			v.val += string_f("<div class=webtable id=%sdoc_wordproc style='display:flex; flex-flow:row;'>\n",val);
			v.val += string_f("<div id='text-%s' onkeydown='gamepress(event);return false;' oninput=funcinput(event) onclick=gameselect(event)"
				" onwheel='gamewheel(event); return false;'"
				//" contenteditable"
				" spellcheck"
				" tabindex=0 style='flex:0 0 auto; overflow: hidden; margin-right:%u; width:%u'"
				" >\n",gameid.c_str(),10,width);
			unsigned line = 0;
			if (pref.offset < lines.size()){
				for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
					unsigned doc_line = line+pref.offset;
					v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
						,formatline(doc_line).c_str());
					line++;
				}
			}
			for (; line<visible_lines; line++){
				static string empty;
				unsigned doc_line = line+pref.offset;
				v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
					,formatline(doc_line).c_str());
			}
			v.val += "</div>\n";
			v.val += "</div>\n";
			#if 0
			v.val += "<script>\n";
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionstart', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionupupdate', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionend', gamefalse);\n",gameid.c_str());
			v.val += "</script>\n";
			#endif
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += "&nbsp;";
			#if 0
				// Trick to make the document window shorter
				for (int i=0; i<25; i++) v.val += "allo<br>\n";
			#endif
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else{
		struct {
			bool ctrl = false;
			bool shift = false;
			bool alt = false;
		} mod;
		unsigned lastline = 1000;
		if (strcmp(var,"kbd")==0){
			if (is_start_any_of(var,NONEED,"kbd")){
				vector<string> tb;
				int n = str_splitline(val,' ',tb);
				//tlmp_warning ("n=%d val=%s",n,val);
				if (n == 5 && is_any_of(tb[0],"Space")){
					var = "insertchar";
					val = " ";
					lastline = atoi(tb[4].c_str());
				}else if (n != 6){
					// Do nothing
				}else{
					lastline = atoi(tb[5].c_str());
					mod.alt = tb[2] == "true";
					mod.ctrl = tb[3] == "true";
					mod.shift = tb[4] == "true";
					const char *tb0 = tb[0].c_str();
					const char *tb1 = tb[1].c_str();
					if (is_any_of(tb0,"Enter","NumpadEnter")){
						var = "break";
					}else if (is_any_of(tb0,"NumpadDecimal")){
						if (tb[1] == "Delete"){
							var = "deletechar";
						}else{
							var = "insertchar";
							val = tb1;
						}
					}else if (is_start_any_of(tb0,NONEED,"Numpad")){
						if (tb[1].size()==1){
							var = "insertchar";
							val = tb1;
						}else if (strcmp(tb1,"Home")==0){
							var = "home";
						}else if (strcmp(tb1,"End")==0){
							var = "end";
						}else if (strcmp(tb1,"ArrowLeft")==0){
							var = "hmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowRight")==0){
							var = "hmove";
							val = "1";
						}else if (strcmp(tb1,"ArrowUp")==0){
							var = "vmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowDown")==0){
							var = "vmove";
							val = "1";
						}else if (strcmp(tb1,"Insert")==0){
							var = "insertmode";
						}else if (strcmp(tb1,"PageUp")==0){
							var = "pageup";
						}else if (strcmp(tb1,"PageDown")==0){
							var = "pagedown";
						}
					}else if (is_start_any_of(tb0,NONEED,"Key","Digit","Slash","Period"
						,"Comma","Quote","Backslash","Minus","Equa","Bracket","Backquote","Semicolon")){
						var = "insertchar";
						val = tb1;
					}else if (is_any_of(tb0,"Insert")){
						var = "insertmode";
					}else if (is_any_of(tb0,"Delete")){
						var = "deletechar";
					}else if (is_any_of(tb0,"Home")){
						var = "home";
					}else if (is_any_of(tb0,"End")){
						var = "end";
					}else if (is_any_of(tb0,"ArrowUp")){
						var = "vmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowDown")){
						var = "vmove";
						val = "1";
					}else if (is_any_of(tb0,"ArrowLeft")){
						var = "hmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowRight")){
						var = "hmove";
						val = "1";
					}else if (is_any_of(tb0,"Backspace")){
						var = "backspace";
					}else if (is_any_of(tb0,"PageUp")){
						var = "pageup";
					}else if (is_any_of(tb0,"PageDown")){
						var = "pagedown";
					}
				}
				// tlmp_warning ("kbd: var=%s val=%s lastline=%u",var,val,lastline);
			}
		}
		if (maywrite){
			if (strcmp(var,"vmove")==0){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.cursor.line;
				vmove (move,visible_lines,lastline,pref,sp,script_var,script_lines);
				if (current_line != pref.cursor.line){
					notify_lines.insert(current_line);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				page_up_down(new_offset,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else if (strcmp(var,"select")==0){	// Position cursor using the mouse
				vector<string> tb;
				//tlmp_warning ("select=%s",val);
				int n = str_splitline(val,' ',tb);
				if (n == 4){
					// We receive 4 arguments: relative paragraph number, X coordinate inside the paragraph, Y coordinate
					// and lastline (last visible paragraph)
					unsigned noline = atoi(tb[0].c_str());
					if (noline < visible_lines){
						unsigned newline = pref.offset + noline;
						if (newline != pref.cursor.line){
							notify_lines.insert(pref.cursor.line);
							pref.cursor.line = newline;
						}
						// We have to figure out where 
						if (pref.cursor.line < lines.size()){
							unsigned xcoor = atoi(tb[1].c_str());
							unsigned ycoor = atoi(tb[2].c_str());
							PARAGRAPH para;
							set_para_spec (para,pref.cursor.line,sp);
							para.locate_pixel (xcoor,ycoor,noline);
							pref.cursor.column = para.get_para_cursor(noline);
						}
						notify_lines.insert(pref.cursor.line);
					}
				}
			}else if (strcmp(var,"newgame")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				unsigned uval = atoi(val);
				bool update_num_lines = false;
				auto &wl = lines[pref.cursor.line];
				auto &l = wl.line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				if (uval == BUTTON_TAB_PLUS){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (uval == BUTTON_TAB_LESS){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_PLUS){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_LESS){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_BULLET){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_NUMLIST){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_CENTER){
					if (wl.listtype == LIST_CENTER){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_CENTER;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_BOLD){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (uval == BUTTON_ITALIC){
					wordproc_insert_effect (l,pos,EFFECT_ITALIC);
				}else if (uval == BUTTON_UNDERLINE){
					wordproc_insert_effect (l,pos,EFFECT_UNDERLINE);
				}else if (uval == BUTTON_SUP){
					wordproc_insert_effect (l,pos,EFFECT_SUP);
				}else if (uval == BUTTON_SUB){
					wordproc_insert_effect (l,pos,EFFECT_SUB);
				}else if (uval == BUTTON_IMAGE){
					if (wl.is_image()){
						wl.set_image(false);
						update_num_lines = true;
					}else if (wl.std_paragraph()){
						wl.set_image(true);
						update_num_lines = true;
					}
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				setmodified(username);
				notify_lines.insert(pref.cursor.line);
				script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
			// This is a catch all for images
			// It means that all other case (other else) are not reached if the current line is an image.
			}else if (pref.cursor.line < lines.size() && lines[pref.cursor.line].is_image()){
				if (strcmp(var,"break")==0){
					unsigned cur_line = pref.cursor.line;
					if (mod.shift){
						// Append a new line just after the image
						pref.cursor.line++;
					}
					lines.insert(lines.begin()+pref.cursor.line,WORDPROC_LINE());
					for (unsigned l=cur_line; l<lines.size(); l++) notify_lines.insert(l);
					pref.cursor.column=0;
					setmodified(username);
				}else if (strcmp(var,"hmove")==0){
					int move = atoi(val);
					auto &para = lines[pref.cursor.line];
					unsigned rep = mod.ctrl ? 10 : 1;
					for (unsigned i=0; i<rep; i++){
						if (move < 0){
							para.decrease_image_width();
						}else{
							para.increase_image_width();
						}
					}
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"insertmode")==0){
				pref.insertmode = !pref.insertmode;
				notify_lines.insert(pref.cursor.line);
			}else if (strcmp(var,"insertchar")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				auto &wl = lines[pref.cursor.line];
				string &l = wl.line;
				while (wordproc_linelen(l) < pref.cursor.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				bool update_num_lines = false;
				if (strcmp(val,"b")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (strcmp(val,"f")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_FONT1);
				}else if (strcmp(val,">")==0 && mod.alt){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (strcmp(val,"<")==0 && mod.alt){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (strcmp(val,"t")==0 && mod.alt){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"T")==0 && mod.alt){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"l")==0 && mod.alt){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (strcmp(val,"L")==0 && mod.alt){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (strcmp(val,"z")==0 && mod.alt){
					if (lines.size()==1 && lines[0].line.size()==0){
						// Fill with many lines
						resetgame();
						string para;
						para = "allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<2; i++) para += " allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<100; i++) lines.push_back(string_f("line %lu:",lines.size())+para);
					}else{
						resetgame();
					}
					documentd_forcerefresh (res);
				}else{
					l.insert(pos,val);
					pref.cursor.column ++;
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.insert(pref.cursor.line);
				setmodified(username);
			}else if (strcmp(var,"break")==0){
				while (lines.size() <= pref.cursor.line) lines.emplace_back(WORDPROC_LINE());
				auto &para = lines[pref.cursor.line];
				string &l = para.line;
				auto nextline = lines.begin() + (pref.cursor.line+1);
				unsigned pos = l.size();
				if (wordproc_linelen(l) > pref.cursor.column){
					pos = wordproc_jump2col(l,pref.cursor.column);
				}
				if (mod.shift){
					// We insert a \r in the current line
					l.insert(l.begin()+pos,CAR_BREAK);
					pref.cursor.column++;
					notify_lines.insert(pref.cursor.line);
				}else{
					// We have to transport the active effects to the next line.
					// effects started after pos are simply copied
					vector<string> effects;
					wordproc_current_effects (l,pos,effects);
					WORDPROC_LINE newl;
					tlmp_warning ("break effects.size()=%lu",effects.size());
					for (auto &e:effects){
						tlmp_warning ("break insert %s",e.c_str());
						newl.line += string_f("%c%s;",CAR_START_EFFECT,e.c_str());
					}
					newl.line += l.substr(pos);
					if (para.std_paragraph()){
						newl.listtype = para.listtype;
						newl.tab_level = para.tab_level;
					}
					lines.insert(nextline,newl);
					lines[pref.cursor.line].line.resize(pos);
					for (unsigned i=0; i<effects.size(); i++) lines[pref.cursor.line].line += CAR_END_EFFECT;
					for (unsigned l=pref.cursor.line; l<lines.size(); l++) notify_lines.insert(l);
					pref.cursor.line++;
					pref.cursor.column=0;
				}
				setmodified(username);
			}else if (strcmp(var,"backspace")==0){
				notify_lines.insert(pref.cursor.line);
				// We start by moving the cursor back one character if possible.
				// If we are at the start of a line, we go at the end of the previous line.
				// We do a deletechar after that
				if (pref.cursor.column > 0){
					tlmp_warning ("backspace column=%u",pref.cursor.column);
					if (mod.ctrl){
						// backspace to the start of the word. If we are on a space, we backspace until we reach a word
						// then we backspace over the word.
						pref.cursor.column--;
						bool inside_doc;
						while (isspace(pref,inside_doc)){
							deletechar(notify_lines,pref);
							if (pref.cursor.column == 0) break;
							pref.cursor.column--;
						}
						while (1){
							bool space = isspace(pref,inside_doc);
							if (space || !inside_doc) break;
							deletechar(notify_lines,pref);
							if (pref.cursor.column == 0) break;
							pref.cursor.column--;
						}
					}else{
						pref.cursor.column--;
						deletechar(notify_lines,pref);
					}
				}else if (pref.cursor.line > 0){
					bool prec_is_image = pref.cursor.line < lines.size() && lines[pref.cursor.line-1].is_image();
					if (!prec_is_image){
						pref.cursor.line--;
						pref.cursor.column=0;
						if (lines.size() > pref.cursor.line){
							string &l = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(l);
							pref.cursor.column = len;
						}
						notify_lines.insert(pref.cursor.line);
						deletechar(notify_lines,pref);
					}
				}
				setmodified(username);
			}else if (strcmp(var,"deletechar")==0){
				if (mod.shift){
					// Delete from cursor to the end of the line
					PARAGRAPH para;
					unsigned noline;
					set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
					unsigned cursor = para.get_para_cursor(noline);
					unsigned endline = para.get_para_end(noline);
					while (cursor < endline){
						deletechar(notify_lines,pref);
						cursor++;
					}
				}else if (mod.ctrl){
					// Delete to the end of the word. If we are on a space, delete to the start of the word, then the word.
					bool inside_doc;
					while (isspace(pref,inside_doc)) deletechar(notify_lines,pref);
					while (1){
						bool space = isspace(pref,inside_doc);
						if (space || !inside_doc) break;
						deletechar(notify_lines,pref);
					}
				}else{
					deletechar(notify_lines,pref);
				}
				setmodified(username);
			}else if (strcmp(var,"voffset")==0){
				// Change page up or down
				int move = atoi(val);
tlmp_warning ("voffset move = %d offset=%u",move,pref.offset);
				if (move > 0 || pref.offset > 0){
					unsigned cur_line = pref.cursor.line;
					unsigned cur_column = pref.cursor.column;
					if (move < 0){
						pref.cursor.line = pref.offset;
					}else{
						pref.cursor.line = pref.offset + visible_lines - 1;
					}
					vmove (move,visible_lines,lastline,pref,sp,script_var,script_lines);
tlmp_warning ("apres vmove move=%d script_lines.size()=%lu",move,script_lines.size());
					pref.cursor.line = cur_line;;
					pref.cursor.column = cur_column;
				}
			}else if (strcmp(var,"hmove")==0){
				int move = atoi(val);
				if (move < 0){
					if (pref.cursor.column == 0){
						if (pref.cursor.line > 0){
							notify_lines.insert(pref.cursor.line);
							vmove (-1,visible_lines,lastline,pref,sp,script_var,script_lines);
							if (lines.size() > pref.cursor.line){
								pref.cursor.column = wordproc_linelen(lines[pref.cursor.line].line);
							}
							notify_lines.insert(pref.cursor.line);
						}
							
					}else{
						if (pref.cursor.line < lines.size() && mod.ctrl){
							// skip word back
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							if (pref.cursor.column > len){
								pref.cursor.column = len;
							}else{
								// First, skip spaces
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] != ' ') break;
									pref.cursor.column--;
								}
								// Then skip word
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] == ' ') break;
									pref.cursor.column--;
								}
							}
						}else{
							pref.cursor.column += move;
						}
						notify_lines.insert(pref.cursor.line);
					}
				}else{
					if (pref.cursor.line < lines.size() && mod.ctrl){
						// skip word
						auto &line = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(line);
						if (pref.cursor.column >= len){
							pref.cursor.column++;
						}else{
							// First, skip spaces
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] != ' ') break;
								pref.cursor.column++;
							}
							// Then skip word
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] == ' ') break;
								pref.cursor.column++;
							}
						}
					}else{
						pref.cursor.column += move;
					}
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"home")==0){	// KEY home
				if (pref.cursor.column != 0){
					PARAGRAPH para;
					unsigned noline;
					set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
					tlmp_warning ("HOME noline=%u",noline);
					pref.cursor.column = para.get_para_home(noline);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"end")==0){	// KEY end
				PARAGRAPH para;
				unsigned noline;
				set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
				unsigned column = para.get_para_end(noline);
				tlmp_warning ("END noline=%u",noline);
				if (column != pref.cursor.column){
					pref.cursor.column = column;
					notify_lines.insert(pref.cursor.line);
				}
			}
			// Update the buttons bar
			if (pref.cursor.line < lines.size()){
				auto &l = lines[pref.cursor.line].line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				vector<string> effects;
				wordproc_current_effects (l,pos,effects);
				WORD_EFFECTS_STATE newstates;
				for (auto &e:effects){
					if (e == EFFECT_BOLD){
						newstates.bold = true;
					}else if (e == EFFECT_ITALIC){
						newstates.italic = true;
					}else if (e == EFFECT_UNDERLINE){
						newstates.underline = true;
					}else if (e == EFFECT_SUP){
						newstates.sup = true;
					}else if (e == EFFECT_SUB){
						newstates.sub = true;
					}
				}
				wordproc_update_buttons (script_var.val,pref,newstates);
			}
		}else{
			if (strcmp(var,"vmove")==0){
				// Vertical arrows are producing scrolls in read only mode.
				int move = atoi(val);
				if (move < 0){
					pref.cursor.line = pref.offset;
				}else{
					pref.cursor.line = pref.offset + visible_lines - 1;
				}
				vmove (move,visible_lines,lastline,pref,sp,script_var,script_lines);
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				set<unsigned> notify_lines;
				page_up_down (new_offset,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else{
				documentd_error (res,MSG_R(E_READONLY));
			}
			res.emplace_back(script_var);
		}
	}
	if (0){
		string tmp;
		for (auto &v:res) tmp += string_f(" %s=%lu",v.var.c_str(),v.val.size());
		tlmp_warning (tmp.c_str());
	}
}
void WORDPROC::manyexec (
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	setactivity();
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	set<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	set<unsigned> notify_lines;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,session,username,maywrite,sp,script_var,script_lines,notify_var,notify_lines,res);
	}
	#if 0
	size_t script_size = script_var.val.size();
	size_t notify_size = notify_var.val.size();
	#endif
	update_lines (script_var.val,script_lines);
	update_lines (notify_var.val,notify_lines);
	#if 0
	tlmp_warning ("manyexec steps=%lu stats script_size=%lu -> %lu notify_size=%lu -> %lu script_lines=%lu notify_lines=%lu"
		,steps.size(),script_size,script_var.val.size(),notify_size,notify_var.val.size(),script_lines.size(),notify_lines.size());
	#endif
	res.emplace_back(notify_var);
	res.emplace_back(script_var);
}

