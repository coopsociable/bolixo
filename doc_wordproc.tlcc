#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

using namespace std;

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER> users;
	for (auto &p:prefs){
		WORDPROC_USER user;
		user.name = p.first;
		user.line = p.second.line;
		user.column = p.second.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		users.emplace_back(user);
	}
	documentd_wordproc_users (&w,users);
	documentd_wordproc_lines (&w,lines);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.line = u.line;
			p.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f lines>
		for (auto &l:lines) glocal.lines.push_back(l);
	</f>
	<f invalid>
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}

#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		size_t sizecar = utf8_codepoint_size(*p);
		while (sizecar > 0 && p != line.end()){
			p++;
			sizecar--;
		}
		ret++;	
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		size_t sizecar = utf8_codepoint_size(*p);
		while (sizecar > 0 && p != line.end()){
			p++;
			sizecar--;
			ret++;
		}
		pos--;
	}
	if (pos == 0){
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
static string wordproc_formatline(
	const string &line,
	map<string,WORD_USERPREF> &prefs,
	unsigned noline)
{
	string ret = string_f("%02u-",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	for (auto &p:prefs){
		if (p.second.maywrite && p.second.line == noline) cursors.emplace_back(p.second.column,p.second.insertmode);
	}
	if (cursors.size() > 0){
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors[0].column;
		unsigned cursor_no = 0;
		unsigned pos=0;
		for (auto p=line.begin(); p!=line.end(); ){
			auto c = *p;
			if (pos == column){
				const char *cursor=cursors[cursor_no].insertmode
					? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
				ret += cursor;
			}
			if (c == ' '){
				ret += "&nbsp;";
				p++;
			}else{
				size_t sizecar = utf8_codepoint_size(c);
				while (sizecar > 0 && p != line.end()){
					ret += *p++;
					sizecar--;
				}
			}
			if (pos == column){
				ret += "</span>";
				cursor_no++;
				if (cursor_no < cursors.size()){
					column = cursors[cursor_no].column;
				}
			}
			pos++;
		}
		if (pos <= column){
			while (cursor_no < cursors.size()){
				column = cursors[cursor_no].column;
				while (pos < column){
					pos++;
					ret += "&nbsp;";
				}
				const char *cursor=cursors[cursor_no].insertmode
					? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
				ret += string(cursor) + "&nbsp;</span>";
				cursor_no++;
			}
		}
	}else{
		for (auto c:line){
			if (c == ' '){
				ret += "&nbsp;";
			}else{
				ret += c;
			}
		}
	}
	return ret;
}

/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (vector<unsigned> &updlines, WORD_USERPREF &pref)
{
	if (lines.size() > pref.line){
		string &l = lines[pref.line];
		unsigned len = wordproc_linelen(l);
		if (len > pref.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.column,sizecar);
			if (sizecar > 0){
				l = l.substr(0,pos) + l.substr(pos+sizecar);
			}
		}else{
			unsigned nextline = pref.line+1;
			if (lines.size() > nextline){
				// We are at the end of the line, or further.
				// So we merge the previous line here.
				// First we grow the line
				while (len < pref.column){
					l += ' ';
					len++;
				}
				l += lines[nextline];
				lines.erase(lines.begin()+nextline);
				for (unsigned l=nextline; l<lines.size()+1; l++) updlines.push_back(l);
			}
		}
		updlines.push_back(pref.line);
	}
}
void WORDPROC::vmove (int move, unsigned visible_lines, WORD_USERPREF &pref, VARVAL &script_var, vector<unsigned> &updlines)
{
	if (move < 0 && abs(move) > pref.line) move = -pref.line;
	unsigned nextline = pref.line + move;
	if (nextline < pref.offset){
		pref.offset--;
		js_find_loop_start (script_var.val,"text","div");
		// Remove last div
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(pref.offset);
		updlines.push_back(pref.offset+1);
	}else if (nextline >= pref.offset + visible_lines){
		pref.offset++;
		js_find_loop_start (script_var.val,"text","div");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(last_line-1);
		updlines.push_back(last_line);
	}else{
		updlines.push_back(pref.line);
		updlines.push_back(nextline);
	}
	pref.line = nextline;
}
void WORDPROC::update_lines (string &script, vector<unsigned> &updlines)
{
	for (auto l:updlines){
		string id=string_f("l%u",l);
		static string empty;
		string &line = l < lines.size() ? lines[l] : empty;
		js_find_loop_set(script,"text","div",id,"innerHTML"
			,wordproc_formatline(line,prefs,l).c_str());
	}
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	setactivity();
	auto &pref = prefs[username];
	pref.maywrite = maywrite;
	unsigned visible_lines = 10;	//sp.content_height/X;
	if (strcmp(var,"print")==0){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &l:lines){
				if (line == pref.line){
					if (l.size() > pref.column){
						v.val += l.substr(0,pref.column) + cursor + l.substr(pref.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			unsigned width = sp.content_width;
			VARVAL v;
			v.var = VAR_CONTENT;
			v.val += "<script>\n";
			v.val += "function gamepress(event){\n";
			v.val += "\tconsole.log ('key='+event.key);\n";
			v.val += "\tconsole.log ('code='+event.code);\n";
			v.val += string_f("\tgameaction('kbd:'+event.code + ' ' + event.key);\n");
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "</script>\n";
			v.val += "<div class=webtable id=doc_wordproc style='display:flex; flex-flow:row;'>\n";
			v.val += string_f("<div id='text-%s' onkeydown=gamepress(event)"
				" tabindex=0 style='flex:0 0 auto; overflow: hidden; margin-right:%u; width:%u'>\n",gameid.c_str(),10,width);
			unsigned line = 0;
			if (pref.offset < lines.size()){
				for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
					auto &l = *p;
					unsigned doc_line = line+pref.offset;
					v.val += string_f("<div id=l%u>%s</div>\n",doc_line
						,wordproc_formatline(l,prefs,doc_line).c_str());
					line++;
				}
			}
			for (; line<visible_lines; line++){
				static string empty;
				unsigned doc_line = line+pref.offset;
				v.val += string_f("<div id=l%u>%s</div>\n",doc_line
					,wordproc_formatline(empty,prefs,doc_line).c_str());
			}
			v.val += "</div>\n";
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else{
		if (strcmp(var,"kbd")==0){
			if (is_start_any_of(var,NONEED,"kbd")){
				const char *pt = str_skipword(val);
				if (isspace(*pt)) pt++;
				if (is_start_any_of(val,NONEED,"Enter","NumpadEnter")){
					var = "break";
				}else if (is_start_any_of(val,NONEED,"NumpadDecimal")){
					if (strcmp(pt,"Delete")==0){
						var = "deletechar";
					}else{
						var = "insertchar";
						val = pt;
					}
				}else if (is_start_any_of(val,NONEED,"Numpad")){
					if (strlen(pt)==1){
						var = "insertchar";
						val = pt;
					}else if (strcmp(pt,"Home")==0){
						var = "home";
					}else if (strcmp(pt,"End")==0){
						var = "end";
					}else if (strcmp(pt,"ArrowLeft")==0){
						var = "hmove";
						val = "-1";
					}else if (strcmp(pt,"ArrowRight")==0){
						var = "hmove";
						val = "1";
					}else if (strcmp(pt,"ArrowUp")==0){
						var = "vmove";
						val = "-1";
					}else if (strcmp(pt,"ArrowDown")==0){
						var = "vmove";
						val = "1";
					}else if (strcmp(pt,"Insert")==0){
						var = "insertmode";
					}else if (strcmp(pt,"PageUp")==0){
						var = "pageup";
					}else if (strcmp(pt,"PageDown")==0){
						var = "pagedown";
					}
				}else if (is_start_any_of(val,NONEED,"Key","Digit","Slash")){
					var = "insertchar";
					val = pt;
				}else if (is_start_any_of(val,NONEED,"Space")){
					var = "insertchar";
					val = " ";
				}else if (is_start_any_of(val,NONEED,"Insert")){
					var = "insertmode";
				}else if (is_start_any_of(val,NONEED,"Delete")){
					var = "deletechar";
				}else if (is_start_any_of(val,NONEED,"Home")){
					var = "home";
				}else if (is_start_any_of(val,NONEED,"End")){
					var = "end";
				}else if (is_start_any_of(val,NONEED,"ArrowUp")){
					var = "vmove";
					val = "-1";
				}else if (is_start_any_of(val,NONEED,"ArrowDown")){
					var = "vmove";
					val = "1";
				}else if (is_start_any_of(val,NONEED,"ArrowLeft")){
					var = "hmove";
					val = "-1";
				}else if (is_start_any_of(val,NONEED,"ArrowRight")){
					var = "hmove";
					val = "1";
				}else if (is_start_any_of(val,NONEED,"Backspace")){
					var = "backspace";
				}else if (is_start_any_of(val,NONEED,"PageUp")){
					var = "pageup";
				}else if (is_start_any_of(val,NONEED,"PageDown")){
					var = "pagedown";
				}
				// tlmp_warning ("kbd: var=%s val=%s",var,val);
			}
		}
		if (maywrite){
			VARVAL notify_var;
			notify_var.var = VAR_NOTIFY;
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
			vector<unsigned> notify_lines;	// Lines to update using NOTIFY (To all)
			if (strcmp(var,"insertmode")==0){
				pref.insertmode = !pref.insertmode;
				notify_lines.push_back(pref.line);
			}else if (strcmp(var,"insertchar")==0){
				while (lines.size() <= pref.line) lines.push_back("");
				string &l = lines[pref.line];
				while (wordproc_linelen(l) < pref.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.column);
				l.insert(pos,val);
				pref.column ++;
				notify_lines.push_back(pref.line);
			}else if (strcmp(var,"break")==0){
				while (lines.size() <= pref.line) lines.push_back("");
				string &l = lines[pref.line];
				auto nextline = lines.begin() + (pref.line+1);
				if (wordproc_linelen(l) > pref.column){
					unsigned pos = wordproc_jump2col(l,pref.column);
					lines.insert(nextline,l.substr(pos));
					lines[pref.line].resize(pos);
				}else{
					lines.insert(nextline,"");	
				}
				for (unsigned l=pref.line; l<lines.size(); l++) notify_lines.push_back(l);
				pref.line++;
				pref.column=0;
			}else if (strcmp(var,"backspace")==0){
				notify_lines.push_back(pref.line);
				// We start by moving the cursor back one character if possible.
				// If we are at the start of a line, we go at the end of the previous line.
				// We do a deletechar after that
				if (pref.column > 0){
					pref.column--;
					deletechar(notify_lines,pref);
				}else if (pref.line > 0){
					pref.line--;
					pref.column=0;
					if (lines.size() > pref.line){
						string &l = lines[pref.line];
						unsigned len = wordproc_linelen(l);
						pref.column = len;
					}
					notify_lines.push_back(pref.line);
					deletechar(notify_lines,pref);
				}
			}else if (strcmp(var,"deletechar")==0){
				deletechar(notify_lines,pref);
			}else if (strcmp(var,"voffset")==0){
				// Change page up or down
				int move = atoi(val);
				if (move > 0){
					pref.offset += move;
				}else{
					if ((unsigned)-move > pref.offset){
						pref.offset = 0;
					}else{
						pref.offset += move;
					}
				}
			}else if (strcmp(var,"vmove")==0){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.line;
				vmove (move,visible_lines,pref,script_var,script_lines);
				if (current_line != pref.line){
					notify_lines.push_back(current_line);
					notify_lines.push_back(pref.line);
				}
			}else if (strcmp(var,"pageup")==0 || strcmp(var,"pagedown")==0){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-visible_lines : pref.offset + visible_lines;
				if (new_offset < 0) new_offset = 0;
				if ((unsigned)new_offset != pref.offset){
					js_find_loop_start (script_var.val,"text","div");
					// Remove all div
					script_var.val += "\telm.innerHTML='';\n";
					// Add new ones
					script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
					script_var.val += "\t\tvar newElement = document.createElement('div');\n";
					script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
					script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
					script_var.val += "\t\tnewElement.innerHTML = '';\n";
					script_var.val += "\t\telm.insertBefore(newElement,null);\n";
					script_var.val += "\t}\n";
					js_find_loop_end (script_var.val);
					for (unsigned i=0; i<visible_lines; i++) script_lines.push_back(new_offset+i);
					notify_lines.push_back(pref.line);
					if (pref.line < (unsigned)new_offset){
						pref.line = new_offset;
					}else if (pref.line >= new_offset + visible_lines){
						pref.line = new_offset;
					}
					notify_lines.push_back(pref.line);
					pref.offset = new_offset;
				}
			}else if (strcmp(var,"hmove")==0){
				int move = atoi(val);
				if (move < 0 && pref.column == 0){
					if (pref.line > 0){
						notify_lines.push_back(pref.line);
						vmove (-1,visible_lines,pref,script_var,script_lines);
						if (lines.size() > pref.line){
							pref.column = wordproc_linelen(lines[pref.line]);
						}
						notify_lines.push_back(pref.line);
						
					}
				}else{
					pref.column += move;
					notify_lines.push_back(pref.line);
				}
			}else if (strcmp(var,"home")==0){
				if (pref.column != 0){
					pref.column = 0;
					notify_lines.push_back(pref.line);
				}
			}else if (strcmp(var,"end")==0){
				unsigned column  = pref.column;
				if (lines.size() > pref.line){
					column = wordproc_linelen(lines[pref.line]);
				}else{
					column = 0;
				}
				if (column != pref.column){
					pref.column = column;
					notify_lines.push_back(pref.line);
				}
			}
			update_lines (notify_var.val,notify_lines);
			update_lines (script_var.val,script_lines);
			res.emplace_back(script_var);
			res.emplace_back(notify_var);
			setmodified(username);
		}else{
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> updlines;	// Lines to update using NOTIFY
			if (strcmp(var,"vmove")==0){
				// Vertical arrows are producing scrolls in read only mode.
				int move = atoi(val);
				if (move < 0){
					pref.line = pref.offset;
				}else{
					pref.line = pref.offset + visible_lines - 1;
				}
				vmove (move,visible_lines,pref,script_var,updlines);
			}else{
				documentd_error (res,MSG_R(E_READONLY));
			}
			update_lines (script_var.val,updlines);
			res.emplace_back(script_var);
		}
	}
}

