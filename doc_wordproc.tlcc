/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "documentd_menu.h"
#include "bolixo.m"


using namespace std;

struct WORD_EFFECTS_STATE{
	bool bold = false;
	bool italic = false;
	bool underline = false;
	bool sup = false;
	bool sub = false;
	bool font1 = false;
};
struct WORD_DOCPOS{
	unsigned line=0;
	unsigned column=0;
	void reset(){
		line = column = 0;
	}
	bool operator == (const WORD_DOCPOS &n) const {
		return tie(line,column) == tie(n.line,n.column);
	}
	bool operator != (const WORD_DOCPOS &n) const {
		return tie(line,column) != tie(n.line,n.column);
	}
	bool operator < (const WORD_DOCPOS &n) const {
		return tie(line,column) < tie(n.line,n.column);
	}
};
// WORDPROC user preference
struct WORD_USERPREF{
	bool maywrite=false;
	unsigned offset=0;	// First line displayed
	WORD_DOCPOS cursor;
	bool insertmode = true;
	WORD_DOCPOS mark1,mark2;	// Cut & Paste
	bool states_valid = false;	// Tell if the UI is in sync with the states variable below
	WORD_EFFECTS_STATE states;
	// Is there a block marked
	bool is_marked() const {
		return mark1 != mark2;
	}
};

enum WORDPROC_LISTTYPE { LIST_NONE, LIST_BULLET,LIST_NUM,LIST_CENTER};

class WORDPROC_LINE{	// Well, a line is a paragraph...
	unsigned char title_level=0;
	unsigned char line_spec=0;	// Used for imbeds and images
public:
	DOCUMENT_EMBED imbed;
	unsigned char tab_level=0;
	WORDPROC_LISTTYPE listtype=LIST_NONE;
	std::string line;
public:
	WORDPROC_LINE(){}
	WORDPROC_LINE(const std::string &l):line(l){}
	WORDPROC_LINE(const char *l):line(l){}
	bool is_imbed() const {
		return imbed.document.size() > 0;
	}
	bool is_image() const {
		return title_level == 10;
	}
	void set_paragraph_type(unsigned type){
		title_level = type;
	}
	unsigned get_paragraph_type() const{
		return title_level;
	}
	void set_paragraph_spec(unsigned spec){
		line_spec = spec;
	}
	unsigned get_paragraph_spec() const{
		return line_spec;
	}
	void increase_title_level(){
		if (title_level < 4) title_level++;
	}
	void decrease_title_level(){
		if (title_level > 0 && title_level < 5) title_level--;
	}
	void set_image(bool on){
		if (on){
			if (title_level == 0){
				title_level = 10;
				if (line_spec == 0) line_spec = 30;
			}
		}else if (title_level == 10){
			title_level = 0;
		}
	}
	void increase_image_width(){
		if ((is_image() || is_imbed()) && line_spec < 100) line_spec++;
	}
	void decrease_image_width(){
		if ((is_image() || is_imbed()) && line_spec > 0) line_spec--;
	}
	unsigned get_image_width() const {
		return is_image() || is_imbed() ? line_spec : 0;
	}
	const char *get_document() const{
		return imbed.document.c_str();
	}
	const char *get_region() const {
		return imbed.region.c_str();
	}
	unsigned get_docnum() const {
		return imbed.docnum;
	}
	void set_table(bool on){
		if (on){
			if (title_level == 0){
				title_level = 11;
			}
		}else if (title_level == 11){
			title_level = 0;
		}
	}
	void set_imbed (const DOCUMENT_EMBED &_imbed){
		imbed = _imbed;
		line_spec = 30;
	}
	bool is_table() const {
		return title_level == 11;
	}
	bool is_title() const {
		return title_level > 0 && title_level < 4;
	}
	bool std_paragraph() const {
		return title_level == 0;
	}
	unsigned get_title_level() const {
		return title_level < 5 ? title_level : 0;
	}
};

class WORDPROC: public GAME{
	std::vector<WORDPROC_LINE> lines;
	std::map<std::string,WORD_USERPREF> prefs;
	bool isspace(WORD_USERPREF &pref, bool &inside_doc);
	void deletechar(std::set<unsigned> &updlines, const WORD_DOCPOS &pos);
	void deletechar(std::set<unsigned> &updlines, WORD_USERPREF &pref);
	void deleteline(unsigned line, set<unsigned> &updlines);
	void vmove (int move, unsigned docnum, unsigned visible_lines, unsigned lastline, WORD_USERPREF &pref, const DOC_UI_SPECS_receive &sp, VARVAL &script_var, std::set<unsigned> &updlines);
	void page_up_down(int new_offset, unsigned docnum, unsigned visible_lines, unsigned lastline, WORD_USERPREF &pref, VARVAL &script_var,
		std::set<unsigned> &script_lines, std::set<unsigned> &notify_lines);
	void update_lines (std::string &line, std::set<unsigned> &updlines, const DOC_UI_SPECS_receive &sp);
	std::string formatline (unsigned noline, const DOC_UI_SPECS_receive &sp, std::string &script);
	void execstep (const char *var,	const char *val, const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp,
		VARVAL &script_var, std::set<unsigned> &script_lines, VARVAL &notify_var, std::set<unsigned> &notify_lines,
		std::vector<VARVAL> &res);
	void set_para_spec(class PARAGRAPH &para, unsigned noline, unsigned column, const DOC_UI_SPECS_receive &sp, unsigned &para_noline);
	void set_para_spec(class PARAGRAPH &para, unsigned noline, const DOC_UI_SPECS_receive &sp);
	void setfocus(VARVAL &script_var);
	std::string draw_text (WORD_USERPREF &pref, unsigned docnum, unsigned visible_lines, const DOC_UI_SPECS_receive &sp, bool editmode, std::string &script);
	std::string define_functions(const DOC_CONTEXT &ctx, const WORD_USERPREF &pref, unsigned width, unsigned height);
	std::string define_styles(const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp);
	void growdoc(unsigned nol);
	void set_imbed(unsigned nol, PARAM_STRING document, PARAM_STRING region, VARVAL &notify_var, set<unsigned> &notify_lines, const DOC_UI_SPECS_receive &sp);
	void delete_to_eol(const WORD_DOCPOS &cursor, const DOC_UI_SPECS_receive &sp, set<unsigned> &notify_lines);
	void delete_block (WORD_USERPREF &pref, const DOC_UI_SPECS_receive &sp, set<unsigned> &notify_lines, VARVAL &script_var);
public:
	const char *getclass() const{
		return "WORD";
	}
	void save(DOC_WRITER &w, bool save_session_info);
	void load(DOC_READER &r, std::string &msg);
	void resetgame();
	void exec (const char *var, const char *val, const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res, std::vector<USERS_NOTIFIES> &unotifies);
	void manyexec (const std::vector<VARVAL_receive> &steps, const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res, std::vector<USERS_NOTIFIES> &unotifies);
	set<DOCUMENT_EMBED> get_embed_specs() const;
	void set_embed_options (const DOCUMENT_EMBED &embed, bool not_square);
};

GAME_P make_WORDPROC()
{
	return make_shared<WORDPROC>();
}

#define documentd_wordproc_users_NOTNEED
#define documentd_wordproc_lines_NOTNEED
#define documentd_wordproc_lines_v2_NOTNEED
#define documentd_wordproc_lines_v3_NOTNEED
#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

static float para_fontsize=1;
static unsigned displaylen_call=0;
static unsigned wordproc_displaylen (PARAM_STRING txt, unsigned fontsize)
{
	displaylen_call++;
	unsigned ret = 10*strlen(txt.ptr);
	if (fontsize > 0){
		ret = documentd_displaylen (txt.ptr,fontsize,para_fontsize);
	}
	//tlmp_warning ("displaylen :%s: fontsize=%u ret=%u",txt.ptr,fontsize,ret);
	return ret;
}
#if 0
#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
#endif

#define CAR_START_EFFECT	11		
#define CAR_END_EFFECT		12
#define CAR_END2_EFFECT		13	// This is like END, except the cursor moves over it
#					// This is useful to stop expanding an effect while entering character
#define CAR_BREAK		14
#define EFFECT_BOLD	"b"
#define EFFECT_ITALIC	"i"
#define EFFECT_UNDERLINE "u"
#define EFFECT_SUP	"S"
#define EFFECT_SUB	"s"
#define EFFECT_FONT1	"F"

struct WORDCHUNK{
	string txt;
	unsigned len = 0;
	unsigned txtlen = 0;
	WORD_EFFECTS_STATE effects;
	WORDCHUNK(
		const char *_txt,	// Start of chunk
		unsigned _strlen,	// Length of chunk in bytes
		unsigned _txtlen,	// Length of chunk in UTF-8 character
		const WORD_EFFECTS_STATE &_effects,	// Current effects applied to the chunk
		unsigned fontsize)	// Browser default font size
		:txt(_txt,_strlen), txtlen(_txtlen), effects(_effects){
		len = wordproc_displaylen(txt,fontsize);
	}
	string startstr (unsigned nbchar){
		const char *start = txt.c_str();
		const char *pt = start;
		while (nbchar > 0 && *pt != '\0'){
			size_t sizecar = utf8_codepoint_size(*pt);
			pt += sizecar;
			nbchar--;
		}
		return txt.substr(0,pt-start);
	}
};
	
	

struct WORDINFO{
	vector<WORDCHUNK> chunks;	// A word may have different font attributes, so is cut in chunks
	unsigned len;			// In pixel
	unsigned txtlen;		// strlen(txt);
	WORDINFO(){
		len = 0;
		txtlen = 0;
	}
	void addchunk (const char *txt, unsigned _strlen, unsigned _txtlen, const WORD_EFFECTS_STATE &effects, unsigned fontsize){
		if (_txtlen > 0){
			txtlen += _txtlen;
			WORDCHUNK chunk(txt,_strlen, _txtlen,effects,fontsize);
			len += chunk.len;
			chunks.emplace_back(move(chunk));
		}
	}
	void reset(){
		chunks.clear();
		len = 0;
		txtlen = 0;
	}
	void remove_first_space(unsigned fontsize){
		if (chunks.size() > 0){
			auto &c = chunks[0];
			if (c.txt[0] == ' '){
				// Remove the space for the first word
				c.txt = c.txt.substr(1);
				c.txtlen--;
				txtlen--;
				unsigned space_width = wordproc_displaylen(" ",fontsize);
				c.len -= space_width;
				len -= space_width;
			}
		}
	}
};
class PARAGRAPH{
public:
	vector<WORDINFO> words;		// The paragraph is decomposed into words
	vector<vector<WORDINFO>> lines;	// Then the words are put together in lines
	vector<unsigned> line_cursors;	// character cursor position in each line, produced by locate_cursor()
	vector<unsigned> line_homes;	// character cursor (paragraph) position of the start of each line
	vector<unsigned> line_ends;	// character cursor (paragraph) position of the end of each line
	vector<unsigned> line_heights;	// Height in pixel of each paragraph lines
	unsigned fontsize=0;
	void addline (unsigned line_start, unsigned line_end, unsigned height);
	unsigned cursor_pos=0;		// Cursor position inside the line in pixel
public:
	PARAGRAPH();
	PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void init(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor);
	void locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline);
	void locate_pixel(unsigned x_pos, unsigned y_pos);
	unsigned get_para_cursor (unsigned noline);
	unsigned get_para_home (unsigned noline);
	unsigned get_para_end (unsigned noline);
	unsigned get_line_cursor (unsigned noline);
	unsigned get_nblines() const{
		return lines.size();
	}
	unsigned get_cursor_xpos() const {
		return cursor_pos;
	}
};

PARAGRAPH::PARAGRAPH()
{
}
PARAGRAPH::PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	init (txt,width,_fontsize);
}
/*
	Add the specification of one line in the paragraph
*/
void PARAGRAPH::addline (unsigned word_start, unsigned word_end, unsigned height)
{
	vector<WORDINFO> line;
	unsigned charlen = 0;
	//unsigned breaklen = 0;
	for (unsigned i=word_start; i<word_end; i++){
		auto &w = words[i];
		line.push_back(w);
		charlen += w.txtlen;
		//if (w.txtlen == 0) breaklen=1;	// CAR_BREAK
	}
	lines.emplace_back(move(line));
	unsigned homepos = 0;
	unsigned last_end = line_ends.size();
	if (last_end > 0) homepos = line_ends[last_end-1]+1;
	line_ends.push_back(homepos+charlen);
	line_homes.push_back(homepos);
	line_heights.push_back(height+2);	// 2 pixel between lines of a paragraph
}

void PARAGRAPH::init(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	fontsize = _fontsize;
	words.clear();
	lines.clear();	
	line_homes.clear();
	line_ends.clear();
	line_heights.clear();

	const char *pt = txt.ptr;
	WORDINFO word;
	stack<WORD_EFFECTS_STATE> effects;
	WORD_EFFECTS_STATE state;
	while (*pt != '\0'){
		// A word is composed of spaces at the start and then non spaces
		// Only the first space is used to split word. The other are turned into &nbsp; at format time, so are part of the word
		// The user entered extra space, so they are kept in the format.
		const char *start = pt;
		unsigned txtlen=0;	// UTF-8 character len
		bool word_start = true;	// Spaces are accepted only at word start
		while (*pt != '\0'){
			if (*pt == ' '){
				if (!word_start) break;
				txtlen++;
				pt++;
			}else if (*pt == CAR_START_EFFECT){
				word.addchunk (start,pt-start,txtlen,state,fontsize);
				pt++;
				const char *effect = pt;
				while (*pt != '\0' && *pt != ';') pt++;
				if (is_start_any_of(effect,NONEED,EFFECT_BOLD)){
					state.bold = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_ITALIC)){
					state.italic = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_UNDERLINE)){
					state.underline = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_SUB)){
					state.sub = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_SUP)){
					state.sup = true;
				}else if (is_start_any_of(effect,NONEED,EFFECT_FONT1)){
					state.font1 = true;
				}
				while (*pt != ';') pt++;
				if (*pt == ';') pt++;
				effects.push(state);
				start = pt;
				txtlen = 0;
			}else if (is_any_of(*pt,CAR_END_EFFECT,CAR_END2_EFFECT)){
				word.addchunk (start,pt-start,pt-start,state,fontsize);
				state = effects.top();
				effects.pop();
				pt++;
				start = pt;
				txtlen = 0;
			}else if (*pt == CAR_BREAK){
				// This ends the line
				word.addchunk (start,pt-start,txtlen,state,fontsize);
				if (word.chunks.size() > 0) words.emplace_back(move(word));
				word.reset();
				// After the loop, the emplace_back will add an empty word (no chunks).
				// This will be used to detect BREAK later when building paragraph.
				pt++;
				start = pt;
				txtlen = 0;
				break;
			}else{
				// Non space character
				word_start = false;
				size_t sizecar = utf8_codepoint_size(*pt);
				pt+=sizecar;
				txtlen++;
			}
		}
		word.addchunk (start,pt-start,txtlen,state,fontsize);
		words.emplace_back(move(word));
		word.reset();
	}

	unsigned offset = 0;
	unsigned wordnum = 1;
	//tlmp_warning ("words.size()=%lu\n",words.size());
	while (wordnum < words.size()){
		// We assemble a line made of words until its width is larger than the div (user interface) width.
		auto &wo = words[offset];
		wo.remove_first_space(fontsize);
		unsigned linelen = wo.len;
		for (unsigned i=offset+1; i<=wordnum; i++) linelen += words[i].len;
		bool empty_word = words[wordnum].len==0;// CAR_BREAK
		//tlmp_warning ("wordnum=%u linelen=%u width=%u lines.size()=%lu empty_word=%d\n",wordnum,linelen,width,lines.size(),empty_word);
		if (linelen < width && !empty_word){
			wordnum++;
		}else{
			if (empty_word) wordnum++;
			addline (offset,wordnum,fontsize);
			offset = wordnum;
		}
	}
	{
		addline (offset,words.size(),fontsize);
	}
}
/*
	Find the coordinate of a linear cursor (character offset in a paragraph): line, and pixel offset
*/
void PARAGRAPH::locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor)
{
	// The cursor represent a linear position into a paragraph
	// Now that the text is splitted in lines, we will find the line the cursor belongs,
	// then the offset in that line, and then, a pixel position in that line.
	noline = 0;
	line_cursors.clear();
	unsigned last_line = lines.size()-1;
	for (unsigned i=0; i<lines.size(); i++){
		auto &line = lines[i];
		unsigned homepos = line_homes[i];
		unsigned endpos = i<last_line ? line_homes[i+1] : line_ends[i];
		if (para_cursor < endpos
			|| i==last_line){
			noline = i;
			line_cursor = para_cursor - homepos;
			unsigned offset_cursor = 0;
			cursor_pos=0;		// Cursor position inside the line in pixel
			for (auto &w:line){
				if (offset_cursor == line_cursor){
					para_cursor = 0;
					break;
				}else{
					for (auto &c:w.chunks){
						unsigned next_offset = offset_cursor + c.txtlen;
						if (next_offset > line_cursor){
							// Ok the cursor is in that word
							string tmp = c.startstr(line_cursor-offset_cursor);
							//printf ("last chunk :%s: para_cursor %u offset_cursor %u\n",tmp.c_str(),para_cursor,offset_cursor);
							cursor_pos += wordproc_displaylen(tmp,fontsize);
							para_cursor = 0;
							break;
						}
						cursor_pos += c.len;
						offset_cursor = next_offset;
					}
					if (para_cursor == 0) break;
				}
			}
			break;
		}
	}
	if (para_cursor > 0){
		unsigned space_width = wordproc_displaylen(" ",fontsize);
		while (para_cursor > 0){
			para_cursor--;
			cursor_pos += space_width;
		}
	}
	locate_pixel (cursor_pos,0);
}
/*
	Find the corresponding cursor position in each line based on position given in pixel
*/
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline)
{
	// We know the cursor horizonl and vertical position in pixel: x_pos,y_pos
	// Now we will find the corresponding cursor position in each lines of the paragraph.
	// This will be stored in line_offsets. This is the cursor position in character.
	// We also locate the paragraph line number
	noline=0;
	unsigned y_offset = 0;
	for (auto h:line_heights){
		y_offset += h;
		//tlmp_warning ("noline=%u y_offset=%u y_pos=%u",noline,y_offset,y_pos);
		if (y_offset > y_pos) break;
		noline++;
	}
	line_cursors.clear();
	for (auto &l:lines){
		unsigned pixel_offset = 0;
		unsigned offset = 0;
		for (auto &w:l){
			unsigned next_pixel_offset = pixel_offset + w.len;
			if (next_pixel_offset > x_pos){
				// The cursor is located in that word.
				for (auto &c:w.chunks){
					unsigned next_chunk_pixel = pixel_offset + c.len;
					if (next_chunk_pixel > x_pos){
						const char *s = c.txt.c_str();
						string tmp;
						unsigned target_pos = x_pos - pixel_offset;
						while (*s != '\0'){
							size_t sizecar = utf8_codepoint_size(*s);
							while (sizecar > 0 && *s != '\0'){
								tmp += *s++;
								sizecar--;
							}
							#if 0
							htmlprintf ("line=%lu tmp=:%s: offset=%u target_pos=%u dlen=%u<br>\n"
								,line_cursors.size(),tmp.c_str(),offset,target_pos,wordproc_displaylen(tmp,fontsize));
							#endif
							if (wordproc_displaylen(tmp,fontsize) > target_pos) break;
							offset++;
						}
						break;
					}
					pixel_offset = next_chunk_pixel;
					offset += c.txtlen;
				}
				break;
			}
			pixel_offset = next_pixel_offset;
			offset += w.txtlen;
		}
		line_cursors.push_back(offset);
	}
}
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos)
{
	unsigned paraline;
	locate_pixel (x_pos,y_pos,paraline);
}
unsigned PARAGRAPH::get_para_home (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_homes.size()){
		return line_homes[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_end (unsigned noline)
{
	unsigned ret = 0;
	//tlmp_warning ("get_para_end noline=%u line_ends.size()=%lu",noline,line_ends.size());
	if (noline < line_ends.size()){
		//tlmp_warning ("end=%u",line_ends[noline]);
		return line_ends[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()){
		return line_homes[noline] + line_cursors[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_line_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()) ret = line_cursors[noline];
	return ret;
}

void wordproc_testparagraph(const char *line, unsigned width, unsigned fontsize, unsigned para_cursor)
{
	PARAGRAPH para (line,width,fontsize);
	unsigned noline,line_cursor;
	para.locate_cursor(para_cursor,noline,line_cursor);
	printf ("para_cursor=%u -> noline=%u line_cursor=%u cursor_xpos=%u\n",para_cursor,noline,line_cursor,para.get_cursor_xpos());
	for (unsigned i=0; i<para.lines.size(); i++){
		auto &l = para.lines[i];
		unsigned txtlen=0;
		unsigned len = 0;
		for (auto &w:l){
			txtlen += w.txtlen;
			len += w.len;
		}
		printf ("line %u [h=%u,e=%u,c=%u,%u,%u]:",i,para.get_para_home(i),para.get_para_end(i),para.get_para_cursor(i),txtlen,len);
		len = 0;
		for (auto &w:l){
			printf ("[%u,%u](",w.txtlen,w.len);
			for (auto &c:w.chunks){
				printf ("%u,%u,%s ",c.txtlen,c.len,c.txt.c_str());
				len += c.len;
			}
			printf (") ");
		}
		printf ("\n");
		printf ("len=%u\n",len);
	}
}

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER_V2> users;
	for (auto &p:prefs){
		WORDPROC_USER_V2 user;
		user.name = p.first;
		user.line = p.second.cursor.line;
		user.column = p.second.cursor.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		user.mark1_line = p.second.mark1.line;
		user.mark1_column = p.second.mark1.column;
		user.mark2_line = p.second.mark2.line;
		user.mark2_column = p.second.mark2.column;
		users.emplace_back(user);
	}
	documentd_wordproc_users_v2 (&w,users);
	vector<WORDPROC_PARA_V4> paras;
	for (auto &l:lines){
		WORDPROC_PARA_V4 para;
		para.listtype = l.listtype;
		para.title_level = l.get_paragraph_type();
		para.line_spec = l.get_paragraph_spec();
		para.tab_level = l.tab_level;
		para.line = l.line;
		para.i_document = l.imbed.document;
		para.i_region = l.imbed.region;
		para.i_docnum = l.imbed.docnum;
		paras.emplace_back(para);
	}
	documentd_wordproc_lines_v4 (&w,paras);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	glocal gameid;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f users_v2>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
			p.mark1.line = u.mark1_line;
			p.mark1.column = u.mark1_column;
			p.mark2.line = u.mark2_line;
			p.mark2.column = u.mark2_column;
		}
	</f>
	<f lines>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(line.is_image() ? 30 : 0);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f lines_v2>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(l.line_spec);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f lines_v3>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(l.line_spec);
			line.tab_level = l.tab_level;
			line.line = l.line;
			line.imbed.document = l.i_document;
			line.imbed.region = l.i_region;
			glocal.lines.push_back(line);
		}
	</f>
	<f lines_v4>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(l.line_spec);
			line.tab_level = l.tab_level;
			line.line = l.line;
			line.imbed.document = l.i_document;
			line.imbed.region = l.i_region;
			line.imbed.docnum = l.i_docnum;
			glocal.lines.push_back(line);
		}
	</f>
	<f invalid>
		tlmp_error ("Invalid command while loading document %s: %s",glocal.gameid.c_str(),msg);
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
	prefs.clear();
}

static string::const_iterator wordproc_skipeffect(const string &line, string::const_iterator p)
{
	p++;
	while (p != line.end()){
		if (*p == ';'){
			p++;
			break;
		}else{
			p++;
		}
	}
	return p;
}
/*
	Walk a string from 0 to pos and fill the stack of active effects
*/
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects, string &last_effect)
{
	auto end = line.begin() + pos;
	for (auto p=line.begin(); p<end; ){
		if (*p == CAR_START_EFFECT){
			string effect;
			p++;
			while (p != line.end()){
				if (*p == ';'){
					p++;
					break;
				}else{
					effect += *p++;
				}
			}
			effects.push_back(effect);
			last_effect.clear();
		}else{
			if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
				if (effects.size() == 0){
					tlmp_warning ("END_EFFECT seen in doc, no active effect");
				}else{
					last_effect = effects.back();
					effects.pop_back();
				}
			}else{
				last_effect.clear();
			}
			p++;
		}
		
	}
}
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects)
{
	string last;
	wordproc_current_effects (line,pos,effects,last);
}
/*
	Remove dead effect sequences.
	A dead effect is an effect applied to an empty content.
	So it looks like CAR_START_EFFECT effect_string ; CAR_END2_EFFECT.
	A dead effect is not reachable by the end user.

	Note that an empty effect ended by CAR_END_EFFECT is still reachable by the end user.
	The user moves the cursor until one button in the button bar is highlited.
*/
static void wordproc_remove_dead_effects(string &l)
{
	for (unsigned i=0; i<l.size(); i++){
		if (l[i] == CAR_START_EFFECT){
			unsigned start = i;
			i++;
			while (l[i] != ';' && l[i] != '\0') i++;
			if (l[i] == ';'){
				i++;
				if (l[i] == CAR_END2_EFFECT){
					i++;
					l = l.erase(start,i-start);
					i=start-1;
				}
			}
		}
	}
}
/*

	If we are currently at the end of this effect, we toggle the END marker (END <-> END2). This allows the user to extend
	the line by inserting character inside or outside the effect area.

	If we are currently inside this effect area, it is removed.

	If not, we just insert the effect start and stop in a line.
*/
static void wordproc_insert_effect (string &line, unsigned pos, const char *effect)
{
	vector<string> cur_effects;
	string last_effect;
	wordproc_current_effects(line,pos,cur_effects,last_effect);
	if (cur_effects.size() > 0 && cur_effects.back()==effect){
		auto p = line.begin()+pos;
		if (*p == CAR_END_EFFECT){	
			*p = CAR_END2_EFFECT;
			wordproc_remove_dead_effects(line);
		}else{
			// We remove the effect.
		}
	}else if (last_effect==effect){
		line[pos-1] = CAR_END_EFFECT;	
	}else{
		line.insert(pos,string_f("%c%s;%c",CAR_START_EFFECT,effect,CAR_END_EFFECT));
	}
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			p = wordproc_skipeffect(line,p);
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
			}
			ret++;	
		}
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
			ret++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
				ret++;
			}
			pos--;
		}
	}
	if (pos == 0){
		auto p = line.begin()+ret;
		while (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}
		if (*p == CAR_END2_EFFECT) ret++;
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	//tlmp_warning ("jump2col ret=%u ret_sizecar=%lu %d",ret,ret_sizecar,line[ret]);
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
/*
	Return the content for a line.
	If some JS script is needed to update the line, it will be written in the script parameter.
*/
string WORDPROC::formatline(unsigned noline, const DOC_UI_SPECS_receive &sp, string &script)
{
	WORDPROC_LINE empty;
	const WORDPROC_LINE &para = noline < lines.size() ? lines[noline] : empty;
	auto &line = para.line;
	string ret = string_f("<div class=col><div class=onecol>%02u-</div>",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	struct {	// Merge of the marks of all sessions
			// We want to know where the mark starts and end in the paragraph.
		unsigned start = (unsigned)-1;
		unsigned end = 0;
	} mark;
	
	for (auto &p:prefs){
		if (p.second.maywrite){
			auto &ps = p.second;
			if (ps.is_marked()){
				// tlmp_warning ("mark1=%u,%u mark2=%u,%u",ps.mark1.line,ps.mark1.column,ps.mark2.line,ps.mark2.column);
				auto f = [&mark,noline,&line](const WORD_DOCPOS &mark1, const WORD_DOCPOS &mark2){
					if (mark1.line <= noline && mark2.line >= noline){
						if (mark1.line < noline){
							mark.start = 0;
						}else if (mark1.column < mark.start){
							mark.start = mark1.column;
						}
						if (mark2.line > noline){
							mark.end = line.size();
						}else if (mark2.column > mark.end){
							mark.end = mark2.column;
						}
					}
				};
				if (ps.mark1 < ps.mark2){
					f(ps.mark1,ps.mark2);
				}else{
					f(ps.mark2,ps.mark1);
				}
			}else{
				// When a user is marking a block, the cursor is now shown.
				if (ps.cursor.line == noline) cursors.emplace_back(ps.cursor.column,ps.insertmode);
			}
		}
	}
	// tlmp_warning ("noline=%u line.size()=%lu mark.start=%u mark.end=%u",noline,line.size(),mark.start,mark.end);
	stack<string> effects;
	string closetitle,closetab;
	{
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors.size() > 0 ? cursors[0].column : (unsigned)-1;
		unsigned cursor_no = 0;
		unsigned pos=0;
		static float tb[]={1, 1.2, 1.5, 2, 2.5};
		if (para.listtype == LIST_BULLET){
			ret += string_f("<div class=bullet%u>&bull;</div><div class=tab%u-bullet>",para.tab_level,para.tab_level);
		}else if (para.listtype == LIST_NUM){
			unsigned num = 1;
			for (int i=noline-1; i >=0; i--){
				auto &l = lines[i];
				if (l.tab_level == para.tab_level && l.listtype == LIST_NUM){
					num++;
				}else if (l.tab_level <= para.tab_level){
					break;
				}
			}
			ret += string_f("<div class=bullet%u><span style=font-size:%1.2fem>%u.</span></div><div class=tab%u-bullet>"
				,para.tab_level,tb[para.get_title_level()],num,para.tab_level);
		}else if (para.listtype == LIST_CENTER){
			ret += "<div class=tab-center>";
		}else{
			ret += string_f("<div class=tab%u>",para.tab_level);
		}
		closetab = "</div>";
		bool format = true;
		if (para.is_title()){
			ret += string_f("<span style=font-size:%1.2fem;>",tb[para.get_title_level()]);
			closetitle = "</span>";
		}else if (para.is_image()){
			const char *url = str_skip(para.line.c_str());
			if (strchr(url,'<')==nullptr){
				// If the < character is there, which is illegal, we simply display the line (format=true)
				// We do some validation and if the <img tag is generated, then we set format=false
				if (cursors.size() > 0) ret += "<div class=imgcursor>";
				const char *project;
				if (is_start_any_ofnc(url,NONEED,"http://","https://")){
					ret += string_f("<img width=%u%% src=%s>",para.get_image_width(),url);
					format = false;
				}else if (is_start_any_of(gameid,project,"/projects")){
					// We are sure that gameid starts with /projects/, but we test it anyway
					// This is a file stored in the bolixo project
					// We extract the bolixo project from the gameid;
					const char *slash = strrchr(project,'/');
					if (slash != nullptr){
						// Now we have the project and sub-folder without the document name
						string path(project,slash-project);
						if (url[0] == '/'){
							auto sl = path.find(1,'/');
							if (sl != string::npos) path.resize(sl);
						}
						path += url;
						ret += string_f("<img width=%u%% src=/index.hc?webstep=5&image=/projects%s>"
							,para.get_image_width(),path.c_str());
						format = false;
					}
				}
				if (cursors.size() > 0) ret += "</div>";
			}
		}else if (para.is_imbed()){
			unsigned para_width = para.get_image_width();
			// We have to express the width and height relative to the display, using percent.
			// But it is not possible to express using CSS that you want the height equals to the width.
			// There is a trick using padding-top:100% allowing you to control the aspect ratio ... but it does not work in all cases.
			// Instead in the style defintion, we populate the variable --width and use it in the computation of the div below.
			// So the width and height are properly set and will show the same on all display (same proportion of the display).
			unsigned docnum = para.get_docnum();
			if (para.imbed.not_square){
				ret += string_f("<div id='parent%u' class=%s"
					" style='width:calc(0.%u * var(--width)); display: inline-block; position:relative;'>\n"
					,noline,cursors.size() > 0 ? "imgcursor" : "imgembed"
					,para_width);
			}else{
				ret += string_f("<div id='parent%u' class=%s"
					" style='width:calc(0.%u * var(--width)); height:calc(0.%u * var(--width));display: inline-block; position:relative;'>\n"
					,noline,cursors.size() > 0 ? "imgcursor" : "imgembed"
					,para_width,para_width);
			}	
			ret += "</div>\n";
			script += string_f("show_template('temp%u','parent%u');\n",docnum,noline);
			format = false;
		}
				
		if (format){
			for (auto p=line.begin(); p!=line.end(); ){
				auto c = *p;
				if (c == CAR_START_EFFECT){
					// tlmp_warning ("Start effect");
					string effect;
					p++;
					while (p != line.end()){
						if (*p == ';'){
							p++;
							break;
						}else{
							effect += *p++;
						}
					}
					// tlmp_warning ("effect=%s",effect.c_str());
					if (effect == EFFECT_BOLD){
						ret += "<b>";
						effects.push("</b>");
					}else if (effect == EFFECT_ITALIC){
						ret += "<i>";
						effects.push("</i>");
					}else if (effect == EFFECT_UNDERLINE){
						ret += "<u>";
						effects.push("</u>");
					}else if (effect == EFFECT_SUP){
						ret += "<sup>";
						effects.push("</sup>");
					}else if (effect == EFFECT_SUB){
						ret += "<sub>";
						effects.push("</sub>");
					}else if (effect == EFFECT_FONT1){
						ret += "<span style=font-size:1.5em;>";
						effects.push("</span>");
					}
				}else if (is_any_of(c,CAR_END_EFFECT,CAR_END2_EFFECT)){
					// tlmp_warning ("effects.size()=%lu",effects.size());
					p++;
					ret += effects.top();
					effects.pop();
				}else{
					if (pos == mark.start){
						ret += "<span class=blkmark>";
						effects.push("</span>");
					}else if (pos != 0 && pos == mark.end){
						ret += effects.top();
						effects.pop();
					}
					if (pos == column){
						ret += string_f("<span class=%ccursor>",cursors[cursor_no].insertmode ? 'i' : 'r');
					}
					if (c == ' '){
						// The first space is passed as is so the browser knows there are multiple words
						// The extra spaces are changed to &nbsp; so they are not skipped by the browser
						if (p == line.begin()
							|| (p > line.begin() && p[-1] == ' ')){
							ret += "&nbsp;";
						}else{
							ret += ' ';
						}
						p++;
					}else if (c == '<'){
						ret += "&lt;";
						p++;
					}else if (c == '>'){
						ret += "&gt;";
						p++;
					}else if (c == '\\'){
						ret += "&bsol;";
						p++;
					}else if (c == '\''){
						ret += "&#39;";
						p++;
					}else if (c == CAR_BREAK){
						ret += "&nbsp;";	// Place a space so the cursor is visible
									// add a <br> after the code to close the cursor <span>
						p++;
					}else{
						size_t sizecar = utf8_codepoint_size(c);
						while (sizecar > 0 && p != line.end()){
							ret += *p++;
							sizecar--;
						}
					}
					if (pos == column){
						ret += "</span>";
						cursor_no++;
						if (cursor_no < cursors.size()){
							column = cursors[cursor_no].column;
						}
					}
					pos++;
					if (c == CAR_BREAK) ret += "<br>";
				}
			}
			if (pos <= column){
				while (cursor_no < cursors.size()){
					column = cursors[cursor_no].column;
					while (pos < column){
						pos++;
						ret += "&nbsp;";
					}
					const char *cursor=cursors[cursor_no].insertmode
						? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
					ret += string(cursor) + "&nbsp;</span>";
					cursor_no++;
				}
			}
		}
	}
	// This should not happen. Effect started on one line/paragraph must end in this paragraph.
	// Bug pending, we may end up here with unclosed effects. So we close them all here.
	while (effects.size() > 0){
		ret += effects.top();
		effects.pop();
	}
	ret += closetitle + closetab;
	ret += "</div>";
	return ret;
}
/*
	Check if the line following noline are LIST_NUM. If this is the case, the line is added to updlines
*/
static void wordproc_update_num_lines (unsigned noline, const vector<WORDPROC_LINE> &lines, set<unsigned> &updlines)
{
	if (noline < lines.size()){
		unsigned tab_level = lines[noline].tab_level;
		for (unsigned i=noline+1; i<lines.size(); i++){
			auto &l = lines[i];
			if (l.tab_level == tab_level && l.listtype == LIST_NUM){
				updlines.insert(i);
			}else if (l.tab_level <= tab_level){
				break;
			}
		}
	}
}

static void wordproc_update_button (string &script, bool &curstate, bool newstate, unsigned button_id)
{
	if (curstate != newstate){
		curstate = newstate;
		script += string_f("var button = document.getElementById('button%u');\n",button_id);
		script += "if (button != null){\n";
		script += string_f("\tbutton.style.background='%s';\n",newstate ? "lightblue" : "lightgray");
		script += "}\n";
	}
}
#define BUTTON_TITLE_PLUS	0
#define BUTTON_TITLE_LESS	1
#define BUTTON_TAB_PLUS		3
#define BUTTON_TAB_LESS		4
#define BUTTON_BULLET		5
#define BUTTON_NUMLIST		6
#define BUTTON_BOLD		7
#define BUTTON_ITALIC		8
#define BUTTON_UNDERLINE	9
#define BUTTON_SUP		10
#define BUTTON_SUB		11
#define BUTTON_CENTER		12
#define BUTTON_IMAGE		13
#define BUTTON_IMBED		14

static void wordproc_update_buttons (string &script, WORD_USERPREF &pref, const WORD_EFFECTS_STATE &newstates)
{
	if (!pref.states_valid){
		// We invalidate all states to update all buttons.
		pref.states.bold = !newstates.bold;
		pref.states.italic = !newstates.italic;
		pref.states.underline = !newstates.underline;
		pref.states.sup = !newstates.sup;
		pref.states.sub = !newstates.sub;
		pref.states_valid = true;
	}
	wordproc_update_button (script,pref.states.bold,newstates.bold,BUTTON_BOLD);
	wordproc_update_button (script,pref.states.italic,newstates.italic,BUTTON_ITALIC);
	wordproc_update_button (script,pref.states.underline,newstates.underline,BUTTON_UNDERLINE);
	wordproc_update_button (script,pref.states.sup,newstates.sup,BUTTON_SUP);
	wordproc_update_button (script,pref.states.sub,newstates.sub,BUTTON_SUB);
}
/*
	Return true if the cursor if on a space
*/
bool WORDPROC::isspace(WORD_USERPREF &pref, bool &inside_doc)
{
	bool ret = false;
	inside_doc = false;
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line].line;
		unsigned len = wordproc_linelen(l);
		// tlmp_warning ("isspace column=%u len=%u",pref.cursor.column,len);
		if (len > pref.cursor.column){
			inside_doc = true;
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar == 1 && l[pos] == ' ') ret = true;
		}
	}
	return ret;
}
// Remove one line(paragraph) from the document
void WORDPROC::deleteline(unsigned line, set<unsigned> &updlines)
{
	if (line < lines.size()){
		lines.erase(lines.begin()+line);
		for (unsigned l=line; l<lines.size()+1; l++) updlines.insert(l);
	}
}
/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (set<unsigned> &updlines, const WORD_DOCPOS &cursor)
{
	if (lines.size() > cursor.line){
		string &l = lines[cursor.line].line;
		unsigned len = wordproc_linelen(l);
		// tlmp_warning ("deletechar column=%u len=%u",cursor.column,len);
		if (len > cursor.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,cursor.column,sizecar);
			if (sizecar > 0){
				// When positionned at the end of an effect, if the marker is
				// CAR_END_EFFECT, wordproc_jump2col() returns a pos right
				// on CAR_END_EFFECT. This way, inserted chars are inserted in the
				// effect. If it is CAR_END2_EFFECT, pos is right after, so
				// insert chars are placed after the effect.
				// When deleting a caracter, we have to delete after the effect
				// if we are positionned on CAR_END_EFFECT.
				if (l[pos] == CAR_END_EFFECT) pos++;
				l = l.substr(0,pos) + l.substr(pos+sizecar);
				// When deleting a character, we can create a dead/empty effect.
				// A dead effect is a effect in the line that can't be reached.
				// CAR_START_EFFECT effectname ; CAR_END2_EFFECT
				// An empty effect, ending with CAR_END_EFFECT is still reachable.
				// You move your cursor until you reach the effect. The button in
				// the button bar shows up.
				// But with CAR_END2_EFFECT, it is not possible. The effect just
				// ends in the line forever.
				// So we do a cleanup here.
				wordproc_remove_dead_effects(l);
				// The cleanup is also done when we use the button to turn off an effect
			}
		}else{
			unsigned nextline = cursor.line+1;
			if (lines.size() > nextline && !lines[nextline].is_image()){
				// We are at the end of the line, or further.
				// So we merge the next line here.
				// First we grow the line
				while (len < cursor.column){
					l += ' ';
					len++;
				}
				l += lines[nextline].line;
				deleteline (nextline,updlines);
			}
		}
		updlines.insert(cursor.line);
	}
}
// Delete one char at the current cursor position
void WORDPROC::deletechar (set<unsigned> &updlines, WORD_USERPREF &pref)
{
	deletechar (updlines,pref.cursor);
}
const unsigned bullet_width=15+5;	// width of a bullet
const unsigned tab_width=30;		// width per tab level

/*
	Initialise the PARAGRAPH layout for the current session/display.
*/
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	unsigned column,	// paragraph cursor
	const DOC_UI_SPECS_receive &sp,	// Specs of the sessions
	unsigned &para_noline)	// line in the paragraph
{
	if (noline < lines.size()){
		auto &l = lines[noline];
		unsigned bul_width = is_any_of (l.listtype,LIST_BULLET,LIST_NUM) ? bullet_width : 0;
		unsigned level_width = l.tab_level * tab_width;
		// 30 is for line numbers
		unsigned width = sp.content_width - 30 - bul_width - level_width;
		width++;	// Add one pixel, because browser really use all the space
				// another solution would be to put an >= in para.init
		//tlmp_warning ("set_para_spec content_width=%u bul_width=%u level_width=%u width=%u",sp.content_width,bul_width,level_width,width);
		para.init (l.line,width,sp.fontsize);
		unsigned line_cursor;
		para.locate_cursor (column,para_noline,line_cursor);
	}else{
		para_noline = 0;
		para.init ("",sp.content_width,sp.fontsize);
	}
}
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	const DOC_UI_SPECS_receive &sp)	// Specs of the sessions
{
	unsigned para_noline;
	set_para_spec (para,noline,0,sp,para_noline);
}
void WORDPROC::vmove (
	int move,
	unsigned docnum,
	unsigned visible_lines,		// How many <div> sent
	unsigned lastline,		// last line partially visible
	WORD_USERPREF &pref,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	set<unsigned> &updlines)
{
	if (pref.cursor.line < lines.size()){
		// Move inside a paragraph
		PARAGRAPH para;
		unsigned noline;
		set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
		unsigned nblines = para.get_nblines();
		unsigned x_pos = para.get_cursor_xpos();
		#if 0
		tlmp_warning ("vmove %d content_width=%u nblines=%u noline=%u line_cursor=%u column=%u"
			,move,spref.content_width,nblines,noline,line_cursor,pref.cursor.column);
		for (unsigned i=0; i<nblines; i++){
			tlmp_warning ("line %u: home=%u cursor=%u",i,para.line_homes[i],para.line_cursors[i]);
		}
		#endif
			
		updlines.insert(pref.cursor.line);
		if (move == -1){
			if (noline > 0){
				pref.cursor.column = para.get_para_cursor(noline-1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line > 0){
				set_para_spec (para,pref.cursor.line-1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(para.get_nblines()-1);
			}
		}else if (move == 1){
			if (noline < nblines -1){
				pref.cursor.column = para.get_para_cursor(noline+1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line < lines.size()-1){
				set_para_spec (para,pref.cursor.line+1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(0);
			}else{
				pref.cursor.column = para.get_para_cursor(nblines-1);
			}
		}
	}
	if (move < 0 && abs(move) > pref.cursor.line) move = -pref.cursor.line;
	unsigned nextline = pref.cursor.line + move;
	if (nextline < pref.offset){
		// tlmp_warning ("vmove offset=%u visible_lines=%u lastline=%u",pref.offset,visible_lines,lastline);
		pref.offset--;
		js_find_loop_start_class (script_var.val,"text",docnum,"oneline");
		// Remove last div
		script_var.val += "console.log('vmove length='+elms.length);\n";
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(pref.offset);
		updlines.insert(pref.offset+1);
	}else if (nextline >= pref.offset + lastline){
		pref.offset++;
		js_find_loop_start_class (script_var.val,"text",docnum,"oneline");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(last_line-1);
		updlines.insert(last_line);
	}else{
		updlines.insert(pref.cursor.line);
		updlines.insert(nextline);
	}
	pref.cursor.line = nextline;
}
void WORDPROC::page_up_down(
	int new_offset, 
	unsigned docnum,
	unsigned visible_lines,
	unsigned lastline,
	WORD_USERPREF &pref,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	set<unsigned> &notify_lines)
{
	if (new_offset < 0) new_offset = 0;
	if ((unsigned)new_offset != pref.offset){
		int offline = pref.cursor.line - pref.offset;
		if (offline < 0) offline = 0;
		js_find_loop_start (script_var.val,"text",docnum,"div");
		// Remove all div
		script_var.val += "\telm.innerHTML='';\n";
		// Add new ones
		script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
		script_var.val += "\t\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
		script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
		script_var.val += "\t\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\t\tnewElement.innerHTML = '';\n";
		script_var.val += "\t\telm.insertBefore(newElement,null);\n";
		script_var.val += "\t}\n";
		js_find_loop_end (script_var.val);
		for (unsigned i=0; i<visible_lines; i++) script_lines.insert(new_offset+i);
		notify_lines.insert(pref.cursor.line);
		if (pref.cursor.line < (unsigned)new_offset
			|| pref.cursor.line >= new_offset + lastline){
			pref.cursor.line = new_offset+offline;
		}
		notify_lines.insert(pref.cursor.line);
		pref.offset = new_offset;
	}
}
void WORDPROC::update_lines (string &script, set<unsigned> &updlines, const DOC_UI_SPECS_receive &sp)
{
	if (updlines.size() > 0){
		script += "word_loop_board(function(txt){\n";
		script += "\tvar elms = txt.getElementsByClassName('oneline');\n";
		script += "\tfor (var i=0; i<elms.length; i++){\n";	
		script += "\t\tvar e=elms[i];\n";
		unsigned nol = 0;
		for (auto l:updlines){
			const char *elseverb = nol==0 ? "" : "}else ";
			string id=string_f("l%u",l);
			script += string_f("\t\t%sif(e.id=='l%u'){\n",elseverb,l);
			string extrascript;
			script += string_f("\t\t\te.innerHTML = `%s`;\n",formatline(l,sp,extrascript).c_str());
			script += extrascript;
			if (nol == updlines.size()-1){
				script += "\t\t\tbreak;\n";
				script += "\t\t}\n";
			}
			nol++;
		}
		script += "\t}\n";
		script += "\t});\n";
	}
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res,
	std::vector<USERS_NOTIFIES> &unotifies)
{
	tlmp_error ("WORDPROC::exec called");
}
/*
	Create the gamepress javascript function
*/
void wordproc_set_gamepress(string &lines, const char *funcname, bool dummies)
{
	lines += string_f("function %s(event){\n",funcname);
	lines += "\tconsole.log ('press key='+event.key+' '+' code='+event.code+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey);\n";
	lines += "\tgamekey=event.key;\n";
	lines += "\tgamecode=event.code;\n";
	lines += "\taltKey=event.altKey;\n";
	lines += "\tctrlKey=event.ctrlKey;\n";
	lines += "\tshiftKey=event.shiftKey;\n";
	//v.val += "\tif (gamecode.substring(0,3)!='Key' && gamekey != 'Dead' && gamekey != 'Process'){\n";
	lines += "\tgameaction(event,'kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline()+' '+getlastcol());\n";
	//v.val += "\t}\n";
	lines += "\tevent.stopPropagation();\n";
	lines += "\treturn false;\n";
	lines += "}\n";
	if (dummies){
		// Define some dummy function meaningless for the caller
		lines += "function getlastline(){\n";
		lines += "\treturn 0;\n";
		lines += "}\n";
		lines += "function getlastcol(){\n";
		lines += "\treturn 0;\n";
		lines += "}\n";
	}
}

/*
	Analyse the message sent by the gamepress javascript function
*/
void wordproc_kbd (const char *val, MOD_KBD &mod, std::string &var, std::string &newval, unsigned &lastline, unsigned &lastcol)
{
	vector<string> tb;
	int n = str_splitline(val,' ',tb);
	//tlmp_warning ("n=%d val=%s",n,val);
	if (n == 6 && is_any_of(tb[0],"Space")){
		var = KBD_INSERTCHAR;
		val = " ";
		lastline = atoi(tb[4].c_str());
	}else if (n != 7){
		// Do nothing
	}else{
		lastline = atoi(tb[5].c_str());
		lastcol = atoi(tb[6].c_str());
		mod.alt = tb[2] == "true";
		mod.ctrl = tb[3] == "true";
		mod.shift = tb[4] == "true";
		const char *tb0 = tb[0].c_str();
		const char *tb1 = tb[1].c_str();
		if (is_any_of(tb0,"Enter","NumpadEnter")){
			var = KBD_BREAK;
		}else if (is_any_of(tb0,"NumpadDecimal")){
			if (tb[1] == "Delete"){
				var = KBD_DELETECHAR;
			}else{
				var = KBD_INSERTCHAR;
				val = tb1;
			}
		}else if (is_any_of(tb0,"Tab")){
			var = KBD_TAB;
		}else if (is_start_any_of(tb0,NONEED,"Numpad")){
			if (tb[1].size()==1){
				var = KBD_INSERTCHAR;
				val = tb1;
			}else if (strcmp(tb1,"Home")==0){
				var = KBD_HOME;
			}else if (strcmp(tb1,"End")==0){
				var = KBD_END;
			}else if (strcmp(tb1,"ArrowLeft")==0){
				var = KBD_HMOVE;
				val = "-1";
			}else if (strcmp(tb1,"ArrowRight")==0){
				var = KBD_HMOVE;
				val = "1";
			}else if (strcmp(tb1,"ArrowUp")==0){
				var = KBD_VMOVE;
				val = "-1";
			}else if (strcmp(tb1,"ArrowDown")==0){
				var = KBD_VMOVE;
				val = "1";
			}else if (strcmp(tb1,"Insert")==0){
				var = KBD_INSERTMODE;
			}else if (strcmp(tb1,"PageUp")==0){
				var = KBD_PAGEUP;
			}else if (strcmp(tb1,"PageDown")==0){
				var = KBD_PAGEDOWN;
			}
		}else if (is_start_any_of(tb0,NONEED,"Key","Digit","Slash","Period"
			,"Comma","Quote","Backslash","Minus","Equa","Bracket","Backquote","Semicolon")){
			var = KBD_INSERTCHAR;
			val = tb1;
		}else if (is_any_of(tb0,"Insert")){
			var = KBD_INSERTMODE;
		}else if (is_any_of(tb0,"Delete")){
			var = KBD_DELETECHAR;
		}else if (is_any_of(tb0,"Home")){
			var = KBD_HOME;
		}else if (is_any_of(tb0,"End")){
			var = KBD_END;
		}else if (is_any_of(tb0,"ArrowUp")){
			var = KBD_VMOVE;
			val = "-1";
		}else if (is_any_of(tb0,"ArrowDown")){
			var = KBD_VMOVE;
			val = "1";
		}else if (is_any_of(tb0,"ArrowLeft")){
			var = KBD_HMOVE;
			val = "-1";
		}else if (is_any_of(tb0,"ArrowRight")){
			var = KBD_HMOVE;
			val = "1";
		}else if (is_any_of(tb0,"Backspace")){
			var = KBD_BACKSPACE;
		}else if (is_any_of(tb0,"PageUp")){
			var = KBD_PAGEUP;
		}else if (is_any_of(tb0,"PageDown")){
			var = KBD_PAGEDOWN;
		}
	}
	newval = val;
	// tlmp_warning ("kbd: var=%s val=%s lastline=%u",var,val,lastline);
}
set<DOCUMENT_EMBED> WORDPROC::get_embed_specs() const
{
	set<DOCUMENT_EMBED> ret;
	for (auto &l:lines){
		const char *doc = l.get_document();
		if (doc[0] != '\0'){
			ret.insert(l.imbed);
		}
	}
	return ret;
}
void WORDPROC::set_embed_options (const DOCUMENT_EMBED &embed, bool not_square)
{
	for (auto &l:lines){
		if (l.is_imbed() && l.imbed == embed){
			l.imbed.not_square = not_square;
		}
	}
}
void WORDPROC::setfocus(VARVAL &script_var)
{
	documentd_setfocus(script_var,string_f("text-%s,0",gameid.c_str()));
}


string WORDPROC::draw_text (
	WORD_USERPREF &pref,
	unsigned docnum,
	unsigned visible_lines,
	const DOC_UI_SPECS_receive &sp,
	bool editmode,
	std::string &scripts)
{
	scripts += string_f(
		"var word_%u={\n"
		"\tgameid:'%s',docnum:%u,offset:%u\n"
		"};\n"
		"word_%u.gameselect=function(event){\n"
		"\tword_gameselect(this.gameid,this.docnum,event);\n"
		"};\n"
		,docnum
		,gameid.c_str(),docnum,pref.offset
		,docnum);
	scripts += "if (typeof word_lst == 'undefined') var word_lst=[];\n";
	scripts += string_f("word_lst.push(word_%u);\n",docnum);
	string onfuncs;
	if (editmode){
		onfuncs = string_f(" onkeydown='word_gamepress(event);return false;'"
			" oninput=word_funcinput(event)"
			" onclick=word_%u.gameselect(event)"
			" onwheel='word_gamewheel(event); return false;'"
			,docnum);
	}

	string val;
	val += string_f("<div id='text-%s,%u' %s"
		//" contenteditable"
		" spellcheck"
		" tabindex=0 style='flex:0 0 auto; overflow: hidden; width:%u'"
		" >\n",gameid.c_str(),docnum,onfuncs.c_str(),sp.content_width);
	unsigned line = 0;
	if (pref.offset < lines.size()){
		for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
			unsigned doc_line = line+pref.offset;
			string script;
			val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
				,formatline(doc_line,sp,script).c_str());
			scripts += script;
			line++;
		}
	}
	for (; line<visible_lines; line++){
		static string empty;
		unsigned doc_line = line+pref.offset;
		string script;
		val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
			,formatline(doc_line,sp,script).c_str());
		scripts += script;
	}
	val += "</div>\n";
	return val;
}
string WORDPROC::define_functions(const DOC_CONTEXT &ctx, const WORD_USERPREF &pref, unsigned width, unsigned height)
{
	string val;
	val += documentd_js_loop_function("text","word");
	// Function called when the user click
	val += "function word_gameselect(gameid,docnum,event){\n";
	val += "\tvar elm = document.getElementById('text-'+gameid+','+docnum);\n";
	val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
	val += "\tfor (var i=0; i<elms.length; i++){\n";
	val += "\t\tvar para= elms[i];\n";
	val += "\t\tvar rect = para.getBoundingClientRect();\n";
	val += "\t\tif (event.clientY >= rect.top && event.clientY < rect.bottom){\n";
	val += "\t\t\tvar divs=para.getElementsByTagName('div');\n";
	val += "\t\t\tvar r=divs[divs.length-1].getBoundingClientRect();\n";
	val += "\t\t\tgameaction(event,'select:'+i+' '+Math.floor(event.clientX-r.left)+' '+Math.floor(event.clientY-r.top)+' '+getlastline());\n";
	val += "\t\t\tbreak;\n";
	val += "\t\t}\n";
	val += "\t}\n";
	val += "}\n";
	// Function called when the user uses the keyboard
	val += "var gamekey=null;\n";
	val += "var gamecode=null;\n";
	val += "var altKey=null;\n";
	val += "var ctrlKey=null;\n";
	val += "var shiftKey=null;\n";

	wordproc_set_gamepress(val,"word_gamepress",false);
	val += "function word_funcinput(event){\n";
	val += "\tif (event.data == null) gamekey=event.data;\n";
	val += "\tgameaction(event,'kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline()+' '+getlastcol());\n";
	val += "\tconsole.log('kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
	val += "\tevent.stopPropagation();\n";
	val += "\treturn false;\n";
	val += "}\n";
	val += "function gamefalse(event){\n";
	//v.val += "\tconsole.log ('gamefalse type='+event.type+' data='+event.data);\n";
	val += "\tevent.stopPropagation();\n";
	val += "\treturn false;\n";
	val += "}\n";
	// function called when the user uses the mouse wheel
	val += "function word_gamewheel(event){\n";
	//v.val += "\tconsole.log('deltaX='+event.deltaX+' deltaY='+event.deltaY);\n";
	val += "\tif (event.deltaY < 0){\n";
	val += "\t\tgameaction(event,'voffset:-1');\n";
	val += "\t}else{\n";
	val += "\t\tgameaction(event,'voffset:1');\n";
	val += "\t}\n";
	val += "}\n";
	return val;
}
const unsigned MAX_TAB_LEVEL=8;
string WORDPROC::define_styles(const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp)
{
	string val;
	unsigned sp_width = sp.content_width-30;	// Space for line numbers, during development
	// Block mark
	val += ".blkmark{\n";
	val += "\tbackground-color:lightblue;>";
	val += "}\n";
	// Cursor insert mode
	val += ".icursor{\n";
	val += "\tbackground-color:lightgray;>";
	val += "}\n";
	// Cursor replace mode
	val += ".rcursor{\n";
	val += "\tbackground-color:lightpink;>";
	val += "}\n";

	// Border around image, when focus
	val += ".imgcursor{\n";
	val += "\tborder:2px solid lightgray;\n";
	val += "}\n";
	// Border around embed document, no focus
	val += ".imgembed{\n";
	val += "\tborder:1px solid black;\n";
	val += "}\n";

	val += ".oneline{\n";
	val += "\tflex:0 1 auto;\n";
	val += "}\n";
	val += ".onecol{\n";
	val += "\tflex:0 1 auto;\n";
	val += "\twidth:30;\n";
	val += "}\n";

	val += ".oneline .col{\n";
	val += "\tdisplay:flex;\n";
	val += "\tflex-flow:row;\n";
	val += "\tmargin-bottom:5px;\n";
	val += "}\n";

	val += ".tab-center{\n";
	val += "\ttext-align:center;\n";
	val += "\toverflow-wrap: break-word;\n";
	val += "\tflex:0 1 auto;\n";
	val += string_f("\twidth:%u;\n",sp_width);
	val += string_f("\t--width:%upx;\n",sp_width);
	val += "}\n";

	for (unsigned i=0; i<=MAX_TAB_LEVEL; i++){
		val += string_f(".bullet%u{\n",i);
		val += "\tflex:0 1 auto;\n";
		val += "\twidth:10;\n";
		unsigned i_tab_width = i*tab_width;
		val += string_f("\tmargin-left:%u;\n",i_tab_width+5);
		val += "\tmargin-right:5;\n";
		val += "}\n";
		val += string_f(".tab%u{\n",i);
		val += "\toverflow-wrap: break-word;\n";
		val += "\tflex:0 1 auto;\n";
		val += string_f("\twidth:%u;\n",sp_width-i_tab_width);
		val += string_f("\t--width:%upx;\n",sp_width-i_tab_width);
		val += string_f("\tmargin-left:%u;\n",i_tab_width);
		val += "\tfont-family:'serif';\n";
		val += "}\n";
		val += string_f(".tab%u-bullet{\n",i);
		val += "\toverflow-wrap: break-word;\n";
		val += "\tflex:0 1 auto;\n";
		val += string_f("\twidth:%u;\n",sp_width-i_tab_width-bullet_width);
		val += string_f("\t--width:%upx;\n",sp_width-i_tab_width-bullet_width);
		val += "\tmargin-left:0;\n";
		val += "\tfont-family:'serif';\n";
		val += "}\n";
	}
	return val;
}
/*
	Make sure paragraph nol exist in the document. If not, empty lines are added
*/
void WORDPROC::growdoc(unsigned nol)
{
	while (lines.size() <= nol) lines.emplace_back(WORDPROC_LINE());
}
// Assign a document/region to a paragraph
void WORDPROC::set_imbed(
	unsigned nol,
	PARAM_STRING document,
	PARAM_STRING region,
	VARVAL &notify_var,
	set<unsigned> &notify_lines,
	const DOC_UI_SPECS_receive &sp)
{
	DOCUMENT_EMBED imbed;
	imbed.document = document.ptr;
	imbed.region = region.ptr;
	// Allocate a document number. Note that the document may exist several time (same doc, same region)
	unsigned docnum = 0;
	imbed.docnum = (unsigned short)-1;
	for (auto &l:lines){
		if (l.is_imbed()){
			unsigned num = l.get_docnum();
			if (imbed.document==l.get_document() && imbed.region == l.get_region()){
				imbed.docnum = num;
				break;
			}else{
				if (num > docnum) docnum = num;
			}
		}
	}
	if (imbed.docnum == (unsigned short)-1) imbed.docnum = docnum+1;
	documentd_insert_imbed (gameid,notify_var,imbed,sp);
	growdoc(nol);
	lines[nol].set_imbed(imbed);
	notify_lines.insert(nol);
}

static void update_mark_lines (const WORD_DOCPOS &mark1, const WORD_DOCPOS &mark2, set<unsigned> &notify_lines)
{
	unsigned old_line = mark1.line;
	unsigned new_line = mark2.line;
	if (new_line < old_line) swap(new_line,old_line);
	for (unsigned l=old_line; l<=new_line; l++) notify_lines.insert(l);
}
/*
	Reset the cut/copy mark
*/
static void reset_mark (WORD_USERPREF &pref, set<unsigned> &notify_lines)
{
	if (pref.is_marked()){
		update_mark_lines (pref.mark1,pref.mark2,notify_lines);
	}
	pref.mark1.reset();
	pref.mark2.reset();
}
// Delete from cursor to the end of the line
void WORDPROC::delete_to_eol(
	const WORD_DOCPOS &pos,
	const DOC_UI_SPECS_receive &sp,
	set<unsigned> &notify_lines)
{
	PARAGRAPH para;
	unsigned noline;
	set_para_spec (para,pos.line,pos.column,sp,noline);
	unsigned cursor = para.get_para_cursor(noline);
	unsigned endline = para.get_para_end(noline);
	while (cursor < endline){
		deletechar(notify_lines,pos);
		cursor++;
	}
}
void WORDPROC::delete_block (
	WORD_USERPREF &pref,
	const DOC_UI_SPECS_receive &sp,
	set<unsigned> &notify_lines,
	VARVAL &script_var)
{
	if (pref.mark2 < pref.mark1) swap (pref.mark1,pref.mark2);
	pref.cursor = pref.mark1;
	// It goes line this
	// if mark1.line < mark2.line, we delete from mark1 to the end of the line.
	// Then we delete all lines between mark1.line and mark2.line.
	// Then we delete in the last line up to mark2.
	// While we do this, we update pref.mark1
	bool delete_line = pref.mark1.column == 0;
	unsigned merge_line = (unsigned)-1;	// At the end, we must merge the last line on this line.
	while (pref.mark1.line < lines.size() && pref.mark1.line < pref.mark2.line){
		if (delete_line){
			deleteline (pref.mark1.line,notify_lines);
			pref.mark2.line--;
		}else{
			merge_line = pref.mark1.line;
			auto &l = lines[pref.mark1.line].line;
			unsigned pos = wordproc_jump2col(l,pref.mark1.column);
			l = l.substr(0,pos);
			notify_lines.insert(pref.mark1.line);
			pref.mark1.line++;
			pref.mark1.column = 0;
			delete_line = true;
		}
	}
	// Now we delete between mark1 and mark2 since they are on the same line.
	if (pref.mark1.line < lines.size()){
		auto &l2 = lines[pref.mark1.line].line;
		unsigned pos2 = wordproc_jump2col(l2,pref.mark2.column);
		if (merge_line != (unsigned)-1){
			auto &l1 = lines[merge_line].line;
			l1 = l1 + l2.substr(pos2,l2.size());	
			deleteline (pref.mark1.line,notify_lines);
		}else{
			unsigned pos1 = wordproc_jump2col(l2,pref.mark1.column);
			l2 = l2.substr(0,pos1) + l2.substr(pos2,l2.size());
		}
		notify_lines.insert(pref.mark1.line);
	}
	pref.mark1.reset();
	pref.mark2.reset();
}

<mod>
void WORDPROC::execstep (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &orig_sp,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	VARVAL &notify_var,
	set<unsigned> &notify_lines,
	vector<VARVAL> &res)
{
	// We copy orig_sp because we will modify it to take care of the waiting_users_width.
	DOC_UI_SPECS_receive sp = orig_sp;
	unsigned waiting_users_width = sp.mobile ? 62 : 42;
	string api_error;
	auto &pref = prefs[ctx.username];
	pref.maywrite = ctx.maywrite;
	unsigned visible_lines = 60;
	if (sp.content_height != 0 && sp.fontsize != 0) visible_lines = sp.content_height/sp.fontsize + 10;
	//tlmp_warning ("visible_lines=%u content_height=%u fontsize=%u",visible_lines,sp.content_height,sp.fontsize);
	// Force visible_lines to 60 because the specs are not always available, for now
	//visible_lines = 60;
	if (is_eq(var,REQ_PRINT)){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &ll:lines){
				auto &l = ll.line;
				if (line == pref.cursor.line){
					if (l.size() > pref.cursor.column){
						v.val += l.substr(0,pref.cursor.column) + cursor + l.substr(pref.cursor.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.cursor.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			bool document_only = is_eq(val,"document");
			sp.content_width -= waiting_users_width;
			VARVAL v;
			v.var = VAR_CONTENT;

			//string imbed_scripts,imbed_styles;
			documentd_imbeds (this,v.val,sp);

			v.val += "<style>\n";
			v.val += define_styles(ctx,sp);
			v.val += "</style>\n";

			// event.location==1 tells if this is the left shift/alt key or right. We are not using it now
			v.val += "<script>\n";
			// Copy a template
			v.val += "function show_template(tid,pid) {\n";
			v.val += "\tvar temp = document.getElementById(tid);\n";
			v.val += "\tvar clon = temp.content.cloneNode(true);\n";
			v.val += "\tvar parent = document.getElementById(pid);\n";
			v.val += "\tparent.appendChild(clon);\n";
			v.val += "}\n";

			// Function find the last visible line on screen
			v.val += "function getlastline(){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s,%u');\n",gameid.c_str(),ctx.docnum);
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			//v.val += "\tconsole.log('getlastline length='+elms.length);\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar srect = elms[i].getBoundingClientRect();\n";
			//v.val += "\t\tconsole.log('i='+i+' rect.bottom='+rect.bottom+' srect.bottom='+srect.bottom);\n";
			v.val += "\t\tif (rect.bottom < srect.bottom){\n";
			v.val += "\t\t\treturn i;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Dummy, for columns
			v.val += "function getlastcol(){\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			v.val += define_functions(ctx,pref,sp.content_width,sp.content_height);
			v.val += "</script>\n";
			// Buttons line
			if (!document_only){
				<call button_bar>(this,sp.mobile,ctx.maywrite,v.val);
				<f draw>
					WORDPROC_MENU menu(specs);
					documentd_bar_button (lines,BUTTON_TITLE_PLUS,"T",specs,false);
					documentd_bar_button (lines,BUTTON_TITLE_LESS,"t",specs,false);
					documentd_bar_button (lines,BUTTON_BOLD,"<b>B</b>",specs,false);
					documentd_bar_button (lines,BUTTON_ITALIC,"<i>I</i>",specs,false);
					documentd_bar_button (lines,BUTTON_UNDERLINE,"<u>U</u>",specs,false);
					documentd_bar_button (lines,BUTTON_SUP,"A<sup>2</sup>",specs,false);
					documentd_bar_button (lines,BUTTON_SUB,"A<sub>2</sub>",specs,false);
					documentd_bar_button (lines,BUTTON_TAB_PLUS,"->",specs,false);
					documentd_bar_button (lines,BUTTON_TAB_LESS,"<-",specs,false);
					documentd_bar_button (lines,BUTTON_CENTER,"<>",specs,false);
					documentd_bar_button (lines,BUTTON_BULLET,"&bull;",specs,false);
					documentd_bar_button (lines,BUTTON_NUMLIST,"N.",specs,false);
					documentd_bar_button (lines,BUTTON_IMAGE,menu.svg_image,specs,false);
					documentd_bar_button (lines,BUTTON_IMBED,menu.svg_imbed,specs,false);
				</f>
				</call>
			}
			// Document
			v.val += string_f("<div class=webtable id=%sdoc_wordproc style='display:flex; flex-flow:row;'>\n",val);
			string scripts;
			if (document_only){
				WORD_USERPREF start;
				v.val += draw_text(start,ctx.docnum,lines.size(),sp,true,scripts);
			}else{
				v.val += draw_text(pref,ctx.docnum,visible_lines,sp,true,scripts);
			}
			if (!document_only) draw_waiting_users(v.val,waiting_users_width,sp.content_height,"flex:0 0 auto;");
			v.val += "</div>\n";
			if (scripts.size() > 0){
				v.val += "<script>\n";
				v.val += scripts;
				v.val += "</script>\n";
			}
			#if 0
			v.val += "<script>\n";
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionstart', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionupupdate', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionend', gamefalse);\n",gameid.c_str());
			v.val += "</script>\n";
			#endif
			if (!document_only){
				// Status line
				v.val += "<div id=tab_form>\n";
				v.val += "&nbsp;";
				#if 0
					// Trick to make the document window shorter
					for (int i=0; i<25; i++) v.val += "allo<br>\n";
				#endif
				v.val += "</div>\n";
			}
			res.emplace_back(v);
		}
	}else if (is_eq(var,"dump")){
		VARVAL var;
		var.var = "lines";
		for (auto &l:lines){
			var.val += string_f("\ntype=%u spec=%u listtype=%u tab_level=%u is_image=%d is_imbed=%d"
				,l.get_paragraph_type(),l.get_paragraph_spec(),l.listtype,l.tab_level,l.is_image(),l.is_imbed());
			if (l.is_imbed()){
				var.val += string_f("\n\timbed: document=%s region=%s docnum=%u",l.get_document(),l.get_region(),l.get_docnum());
			}
		}
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_FUNCTIONS)){
		VARVAL var;
		var.var = VAR_DEFSCRIPT;
		var.val += define_functions(ctx,pref,sp.content_width,sp.content_height);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_STYLES)){
		VARVAL var;
		var.var = VAR_STYLES;
		var.val += define_styles(ctx,sp);
		res.emplace_back(move(var));
	}else if (is_eq(var,REQ_REGION)){
		VARVAL var,var_script;
		var.var = VAR_CONTENT;
		var_script.var = VAR_DEFSCRIPT;
		var.val += draw_text(pref,ctx.docnum,visible_lines,sp,false,var_script.val);
		res.emplace_back(move(var));
		res.emplace_back(move(var_script));
	}else if (is_eq(var,REQ_GETFIELDS)){
		VARVAL var;
		var.var = VAR_FIELDS;
		if (strcmp(val,DIALOG_IMBED)==0){
			if (pref.cursor.line < lines.size()){
				auto &l = lines[pref.cursor.line];
				var.val = string_f("docid:%s\n",l.get_document());
				var.val += string_f("region:%s\n",l.get_region());
			}
		}
		res.emplace_back(var);
	}else if (is_eq(var,REQ_FOCUS)){
		setfocus(script_var);
	}else{
		sp.content_width -= waiting_users_width;
		MOD_KBD mod;
		unsigned lastline = 1000;
		string tmpvar,tmpval;
		if (is_eq(var,"kbd")){
			unsigned lastcol;
			wordproc_kbd(val,mod,tmpvar,tmpval,lastline,lastcol);
			var = tmpvar.c_str();
			val = tmpval.c_str();		
		}
		if (ctx.maywrite){
			auto old_cursor = pref.cursor;
			if (is_eq(var,KBD_VMOVE)){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.cursor.line;
				vmove (move,ctx.docnum,visible_lines,lastline,pref,sp,script_var,script_lines);
				if (current_line != pref.cursor.line){
					notify_lines.insert(current_line);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_any_of(var,KBD_PAGEUP,KBD_PAGEDOWN)){
				int new_offset = is_eq(var,KBD_PAGEUP) ? pref.offset-lastline : pref.offset + lastline;
				page_up_down(new_offset,ctx.docnum,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else if (is_eq(var,"select")){	// Position cursor using the mouse
				unsigned noline,xcoor,ycoor,lastline;
				if (splitline(val,noline,xcoor,ycoor,lastline)){
					// We receive 4 arguments: relative paragraph number, X coordinate inside the paragraph, Y coordinate
					// and lastline (last visible paragraph)
					//tlmp_warning ("select noline=%u visible_lines=%u",noline,visible_lines);
					if (noline < visible_lines){
						unsigned newline = pref.offset + noline;
						if (newline != pref.cursor.line){
							notify_lines.insert(pref.cursor.line);
							pref.cursor.line = newline;
						}
						// We have to figure out where 
						if (pref.cursor.line < lines.size()){
							PARAGRAPH para;
							set_para_spec (para,pref.cursor.line,sp);
							para.locate_pixel (xcoor,ycoor,noline);
							pref.cursor.column = para.get_para_cursor(noline);
						}
						notify_lines.insert(pref.cursor.line);
					}
				}else{
					tlmp_warning ("Invalid select: %s",val);
				}
			}else if (is_eq(var,"newgame")){
				growdoc(pref.cursor.line);
				unsigned uval = atoi(val);
				bool update_num_lines = false;
				auto &wl = lines[pref.cursor.line];
				auto &l = wl.line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				if (uval == BUTTON_TAB_PLUS){
					if (wl.tab_level < MAX_TAB_LEVEL) wl.tab_level++;
					update_num_lines = true;
				}else if (uval == BUTTON_TAB_LESS){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_PLUS){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_LESS){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_BULLET){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_NUMLIST){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_CENTER){
					if (wl.listtype == LIST_CENTER){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_CENTER;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_BOLD){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (uval == BUTTON_ITALIC){
					wordproc_insert_effect (l,pos,EFFECT_ITALIC);
				}else if (uval == BUTTON_UNDERLINE){
					wordproc_insert_effect (l,pos,EFFECT_UNDERLINE);
				}else if (uval == BUTTON_SUP){
					wordproc_insert_effect (l,pos,EFFECT_SUP);
				}else if (uval == BUTTON_SUB){
					wordproc_insert_effect (l,pos,EFFECT_SUB);
				}else if (uval == BUTTON_IMAGE){
					if (wl.is_image()){
						wl.set_image(false);
						update_num_lines = true;
					}else if (wl.std_paragraph()){
						wl.set_image(true);
						update_num_lines = true;
					}
				}else if (uval == BUTTON_IMBED){
					VARVAL var;
					var.var = VAR_DIALOG;
					var.val = DIALOG_IMBED;
					res.emplace_back(var);
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				setmodified(ctx.username);
				notify_lines.insert(pref.cursor.line);
				setfocus(script_var);
			}else if (is_eq(var,"imbed")){
				// Apply the change from the dialog
				vector<VARVAL> fields;
				documentd_parsefields(val,fields);
				string document,region;
				for (auto &f:fields){
					if (f.var == "docid"){
						document = f.val;
					}else if (f.var == "region"){
						region = f.val;
					}
				}
				set_imbed (pref.cursor.line,document,region,notify_var,notify_lines,sp);
			// This is a catch all for images
			// It means that all other case (other else) are not reached if the current line is an image.
			}else if (pref.cursor.line < lines.size()
				&& (lines[pref.cursor.line].is_image() || lines[pref.cursor.line].is_imbed())){
				if (is_eq(var,KBD_BREAK)){
					unsigned cur_line = pref.cursor.line;
					if (mod.shift){
						// Append a new line just after the image
						pref.cursor.line++;
					}
					lines.insert(lines.begin()+pref.cursor.line,WORDPROC_LINE());
					for (unsigned l=cur_line; l<lines.size(); l++) notify_lines.insert(l);
					pref.cursor.column=0;
					setmodified(ctx.username);
				}else if (is_eq(var,KBD_HMOVE)){
					int move = atoi(val);
					auto &para = lines[pref.cursor.line];
					unsigned rep = mod.ctrl ? 10 : 1;
					for (unsigned i=0; i<rep; i++){
						if (move < 0){
							para.decrease_image_width();
						}else{
							para.increase_image_width();
						}
					}
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_eq(var,KBD_INSERTMODE)){
				pref.insertmode = !pref.insertmode;
				notify_lines.insert(pref.cursor.line);
			}else if (is_eq(var,KBD_INSERTCHAR)){
				if (pref.is_marked()){
					pref.cursor = pref.mark1 < pref.mark2 ? pref.mark1 : pref.mark2;
					delete_block(pref,sp,notify_lines,script_var);
				}
				growdoc(pref.cursor.line);
				auto &wl = lines[pref.cursor.line];
				string &l = wl.line;
				while (wordproc_linelen(l) < pref.cursor.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				bool update_num_lines = false;
				if (strcmp(val,"b")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (strcmp(val,"f")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_FONT1);
				}else if (strcmp(val,">")==0 && mod.alt){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (strcmp(val,"<")==0 && mod.alt){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (strcmp(val,"t")==0 && mod.alt){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"T")==0 && mod.alt){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"l")==0 && mod.alt){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (strcmp(val,"L")==0 && mod.alt){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (is_eq(val,"c") && mod.ctrl){
					script_var.val += "navigator.clipboard.writeText('clipclip');\n";
				}else{
					l.insert(pos,val);
					pref.cursor.column ++;
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.insert(pref.cursor.line);
				setmodified(ctx.username);
			}else if (is_eq(var,KBD_BREAK)){
				growdoc(pref.cursor.line);
				auto &para = lines[pref.cursor.line];
				string &l = para.line;
				auto nextline = lines.begin() + (pref.cursor.line+1);
				unsigned pos = l.size();
				if (wordproc_linelen(l) > pref.cursor.column){
					pos = wordproc_jump2col(l,pref.cursor.column);
				}
				if (mod.shift){
					// We insert a \r in the current line
					l.insert(l.begin()+pos,CAR_BREAK);
					pref.cursor.column++;
					notify_lines.insert(pref.cursor.line);
				}else{
					// We have to transport the active effects to the next line.
					// effects started after pos are simply copied
					vector<string> effects;
					wordproc_current_effects (l,pos,effects);
					WORDPROC_LINE newl;
					tlmp_warning ("break effects.size()=%zu",effects.size());
					for (auto &e:effects){
						tlmp_warning ("break insert %s",e.c_str());
						newl.line += string_f("%c%s;",CAR_START_EFFECT,e.c_str());
					}
					newl.line += l.substr(pos);
					if (para.std_paragraph()){
						newl.listtype = para.listtype;
						newl.tab_level = para.tab_level;
					}
					lines.insert(nextline,newl);
					lines[pref.cursor.line].line.resize(pos);
					for (unsigned i=0; i<effects.size(); i++) lines[pref.cursor.line].line += CAR_END_EFFECT;
					for (unsigned l=pref.cursor.line; l<lines.size(); l++) notify_lines.insert(l);
					pref.cursor.line++;
					pref.cursor.column=0;
				}
				setmodified(ctx.username);
			}else if (is_eq(var,KBD_BACKSPACE)){
				if (pref.is_marked()){
					delete_block(pref,sp,notify_lines,script_var);
				}else{
					notify_lines.insert(pref.cursor.line);
					// We start by moving the cursor back one character if possible.
					// If we are at the start of a line, we go at the end of the previous line.
					// We do a deletechar after that
					if (pref.cursor.column > 0){
						//tlmp_warning ("backspace column=%u",pref.cursor.column);
						if (mod.ctrl){
							// backspace to the start of the word. If we are on a space, we backspace until we reach a word
							// then we backspace over the word.
							pref.cursor.column--;
							bool inside_doc;
							while (isspace(pref,inside_doc)){
								deletechar(notify_lines,pref);
								if (pref.cursor.column == 0) break;
								pref.cursor.column--;
							}
							while (1){
								bool space = isspace(pref,inside_doc);
								if (space || !inside_doc) break;
								deletechar(notify_lines,pref);
								if (pref.cursor.column == 0) break;
								pref.cursor.column--;
							}
						}else{
							pref.cursor.column--;
							deletechar(notify_lines,pref);
						}
					}else if (pref.cursor.line > 0){
						bool prec_is_image = pref.cursor.line < lines.size() && lines[pref.cursor.line-1].is_image();
						if (!prec_is_image){
							pref.cursor.line--;
							pref.cursor.column=0;
							if (lines.size() > pref.cursor.line){
								string &l = lines[pref.cursor.line].line;
								unsigned len = wordproc_linelen(l);
								pref.cursor.column = len;
							}
							notify_lines.insert(pref.cursor.line);
							deletechar(notify_lines,pref);
						}
					}
				}
				setmodified(ctx.username);
			}else if (is_eq(var,KBD_DELETECHAR)){
				if (pref.is_marked()){
					// A block is marked, we have to delete it.
					delete_block(pref,sp,notify_lines,script_var);
				}else if (mod.shift){
					delete_to_eol(pref.cursor,sp,notify_lines);
				}else if (mod.ctrl){
					// Delete to the end of the word. If we are on a space, delete to the start of the word, then the word.
					bool inside_doc;
					while (isspace(pref,inside_doc)) deletechar(notify_lines,pref);
					while (1){
						bool space = isspace(pref,inside_doc);
						if (space || !inside_doc) break;
						deletechar(notify_lines,pref);
					}
				}else{
					deletechar(notify_lines,pref);
				}
				setmodified(ctx.username);
			}else if (is_eq(var,"voffset")){
				// scroll wheel
				int move = atoi(val);
				if (move > 0 || pref.offset > 0){
					unsigned cur_line = pref.cursor.line;
					unsigned cur_column = pref.cursor.column;
					if (move < 0){
						pref.cursor.line = pref.offset;
					}else{
						pref.cursor.line = pref.offset + lastline - 1;
					}
					pref.cursor.column = 0;
					vmove (move,ctx.docnum,visible_lines,lastline,pref,sp,script_var,script_lines);
					pref.cursor.line = cur_line;;
					pref.cursor.column = cur_column;
				}
			}else if (is_eq(var,KBD_HMOVE)){
				int move = atoi(val);
				if (move < 0){
					if (pref.cursor.column == 0){
						if (pref.cursor.line > 0){
							notify_lines.insert(pref.cursor.line);
							vmove (-1,ctx.docnum,visible_lines,lastline,pref,sp,script_var,script_lines);
							if (lines.size() > pref.cursor.line){
								pref.cursor.column = wordproc_linelen(lines[pref.cursor.line].line);
							}
							notify_lines.insert(pref.cursor.line);
						}
							
					}else{
						if (pref.cursor.line < lines.size() && mod.ctrl){
							// skip word back
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							if (pref.cursor.column > len){
								pref.cursor.column = len;
							}else{
								// First, skip spaces
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] != ' ') break;
									pref.cursor.column--;
								}
								// Then skip word
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] == ' ') break;
									pref.cursor.column--;
								}
							}
						}else{
							pref.cursor.column += move;
						}
						notify_lines.insert(pref.cursor.line);
					}
				}else{
					if (pref.cursor.line < lines.size() && mod.ctrl){
						// skip word
						auto &line = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(line);
						if (pref.cursor.column >= len){
							pref.cursor.column++;
						}else{
							// First, skip spaces
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] != ' ') break;
								pref.cursor.column++;
							}
							// Then skip word
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] == ' ') break;
								pref.cursor.column++;
							}
						}
					}else{
						pref.cursor.column += move;
					}
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_eq(var,KBD_HOME)){	// KEY home
				if (pref.cursor.column != 0){
					PARAGRAPH para;
					unsigned noline;
					set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
					tlmp_warning ("HOME noline=%u",noline);
					pref.cursor.column = para.get_para_home(noline);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_eq(var,KBD_END)){	// KEY end
				PARAGRAPH para;
				unsigned noline;
				set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
				unsigned column = para.get_para_end(noline);
				tlmp_warning ("END noline=%u",noline);
				if (column != pref.cursor.column){
					pref.cursor.column = column;
					notify_lines.insert(pref.cursor.line);
				}
			// For scripting
			}else if (is_eq(var,"setline")){
				unsigned nol;
				string content;
				if (splitlineq(val,nol,content)){
					growdoc(nol);
					auto &wl = lines[nol];
					if (wl.line != content){
						wl.line = content;
						notify_lines.insert(nol);
					}
				}else{
					api_error = MSG_U(E_IVLDSETLINE,"Invalid setline request");
				}
			}else if (is_eq(var,"setlisttype")){
				unsigned nol;
				unsigned listtype;
				if (splitlineq(val,nol,limits(listtype,0u,3u))){
					growdoc(nol);
					auto &wl = lines[nol];
					if (wl.listtype != (WORDPROC_LISTTYPE)listtype){
						wl.listtype = (WORDPROC_LISTTYPE)listtype;
						notify_lines.insert(nol);
					}
				}else{
					api_error = MSG_U(E_IVLDLISTTYPE,"Invalid setlisttype request");
				}
			}else if (is_eq(var,"settablevel")){
				unsigned nol;
				unsigned tab_level;
				if (splitlineq(val,nol,limits(tab_level,0u,8u))){
					growdoc(nol);
					auto &wl = lines[nol];
					if (wl.tab_level != tab_level){
						wl.tab_level = tab_level;
						notify_lines.insert(nol);
					}
				}else{
					api_error = MSG_U(E_IVLDTABLEVEL,"Invalid settablevel request");
				}
			}else if (is_eq(var,"setimage")){
				unsigned nol;
				string image;
				if (splitlineq(val,nol,image)){
					growdoc(nol);
					auto &wl = lines[nol];
					if (!wl.is_image() || wl.line != image){
						wl.line = image;
						wl.set_image(true);
						notify_lines.insert(nol);
					}
				}else{
					api_error = MSG_U(E_IVLDSETIMAGE,"Invalid setimage request");
				}
			}else if (is_eq(var,"setimbed")){
				unsigned nol;
				string document,region;
				if (splitlineq(val,nol,document,region)){
					growdoc(nol);
					auto &wl = lines[nol];
					if (!wl.is_imbed() || document != wl.get_document() || region != wl.get_region()){
						set_imbed (nol,document,region,notify_var,notify_lines,sp);
					}
				}else{
					api_error = MSG_U(E_IVLDSETIMBED,"Invalid setimbed request");
				}
			}else if (is_eq(var,"resetgame")){
				resetgame();
			}
			// Update the buttons bar
			if (pref.cursor.line < lines.size()){
				auto &l = lines[pref.cursor.line].line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				vector<string> effects;
				wordproc_current_effects (l,pos,effects);
				WORD_EFFECTS_STATE newstates;
				for (auto &e:effects){
					if (e == EFFECT_BOLD){
						newstates.bold = true;
					}else if (e == EFFECT_ITALIC){
						newstates.italic = true;
					}else if (e == EFFECT_UNDERLINE){
						newstates.underline = true;
					}else if (e == EFFECT_SUP){
						newstates.sup = true;
					}else if (e == EFFECT_SUB){
						newstates.sub = true;
					}
				}
				wordproc_update_buttons (script_var.val,pref,newstates);
			}
			if (is_any_of(var,KBD_HMOVE,KBD_HOME,KBD_END,KBD_VMOVE,KBD_PAGEUP,KBD_PAGEDOWN)){
				if (mod.shift){
					if (!pref.is_marked()){
						pref.mark1 = old_cursor;
					}
					pref.mark2 = pref.cursor;
					// Send update to all lines between old_cursor and pref.cursor
					update_mark_lines (old_cursor,pref.cursor,notify_lines);
				}else{
					reset_mark(pref,notify_lines);
				}
			}
		}else{
			if (is_any_of(var,KBD_VMOVE,"voffset")){
				// Vertical arrows are producing scrolls in read only mode, like the wheel.
				int move = atoi(val);
				if (move < 0){
					pref.cursor.line = pref.offset;
				}else{
					pref.cursor.line = pref.offset + visible_lines - 1;
				}
				vmove (move,ctx.docnum,visible_lines,lastline,pref,sp,script_var,script_lines);
			}else if (is_any_of(var,KBD_PAGEUP,KBD_PAGEDOWN)){
				int new_offset = is_eq(var,KBD_PAGEUP) ? pref.offset-lastline : pref.offset + lastline;
				set<unsigned> notify_lines;
				page_up_down (new_offset,ctx.docnum,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else{
				documentd_error (res,MSG_R(E_READONLYDOC));
			}
			res.emplace_back(script_var);
		}
	}
	if (api_error.size() > 0){
		VARVAL var;
		var.var = VAR_ERROR;
		var.val = move(api_error);
		res.emplace_back(move(var));
	}
	if (0){
		string tmp;
		for (auto &v:res) tmp += string_f(" %s=%zu",v.var.c_str(),v.val.size());
		tlmp_warning (tmp.c_str());
	}
}
</mod>
void WORDPROC::manyexec (
	const vector<VARVAL_receive> &steps,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res,
	std::vector<USERS_NOTIFIES> &unotifies)
{
	string cur_word = string_f("word_cur_gameid='%s';\n",gameid.c_str());
	setactivity();
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	script_var.val = cur_word;
	set<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	notify_var.val = cur_word;
	set<unsigned> notify_lines;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,ctx,sp,script_var,script_lines,notify_var,notify_lines,res);
	}
	#if 0
	size_t script_size = script_var.val.size();
	size_t notify_size = notify_var.val.size();
	#endif
	update_lines (script_var.val,script_lines,sp);
	update_lines (notify_var.val,notify_lines,sp);
	#if 0
	tlmp_warning ("manyexec steps=%lu stats script_size=%lu -> %lu notify_size=%lu -> %lu script_lines=%lu notify_lines=%lu"
		,steps.size(),script_size,script_var.val.size(),notify_size,notify_var.val.size(),script_lines.size(),notify_lines.size());
	#endif
	if (notify_var.val != cur_word) res.emplace_back(move(notify_var));
	if (script_var.val != cur_word) res.emplace_back(move(script_var));
}

