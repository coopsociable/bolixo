#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

using namespace std;

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER> users;
	for (auto &p:prefs){
		WORDPROC_USER user;
		user.name = p.first;
		user.line = p.second.cursor.line;
		user.column = p.second.cursor.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		users.emplace_back(user);
	}
	documentd_wordproc_users (&w,users);
	vector<WORDPROC_PARA> paras;
	for (auto &l:lines){
		WORDPROC_PARA para;
		para.listtype = l.listtype;
		para.title_level = l.title_level;
		para.tab_level = l.tab_level;
		para.line = l.line;
		paras.emplace_back(para);
	}
	documentd_wordproc_lines (&w,paras);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	glocal gameid;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f lines>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.title_level = l.title_level;
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f invalid>
		tlmp_error ("Invalid command while loading document %s",glocal.gameid.c_str());
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
	prefs.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}

#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
#define CAR_START_EFFECT	11		
#define CAR_END_EFFECT		12
#define CAR_END2_EFFECT		13	// This is like END, except the cursor moves over it
#					// This is useful to stop expanding an effect while entering character
#define EFFECT_BOLD	"b"
#define EFFECT_ITALIC	"i"
#define EFFECT_UNDERLINE "u"
#define EFFECT_SUP	"S"
#define EFFECT_SUB	"s"
#define EFFECT_FONT1	"F"

static string::const_iterator wordproc_skipeffect(const string &line, string::const_iterator p)
{
	p++;
	while (p != line.end()){
		if (*p == ';'){
			p++;
			break;
		}else{
			p++;
		}
	}
	return p;
}
/*
	Walk a string from 0 to pos and fill the stack of active effects
*/
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects, string &last_effect)
{
	auto end = line.begin() + pos;
	for (auto p=line.begin(); p<end; ){
		if (*p == CAR_START_EFFECT){
			string effect;
			p++;
			while (p != line.end()){
				if (*p == ';'){
					p++;
					break;
				}else{
					effect += *p++;
				}
			}
			effects.push_back(effect);
			last_effect.clear();
		}else{
			if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
				if (effects.size() == 0){
					tlmp_warning ("END_EFFECT seen in doc, no active effect");
				}else{
					last_effect = effects.back();
					effects.pop_back();
				}
			}else{
				last_effect.clear();
			}
			p++;
		}
		
	}
}
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects)
{
	string last;
	wordproc_current_effects (line,pos,effects,last);
}
/*

	If we are currently at the end of this effect, we toggle the END marker (END <-> END2). This allows the user to extend
	the line by inserting character inside or outside the effect area.

	If we are currently inside this effect area, it is removed.

	If not, we just insert the effect start and stop in a line.
*/
static void wordproc_insert_effect (string &line, unsigned pos, const char *effect)
{
	vector<string> cur_effects;
	string last_effect;
	wordproc_current_effects(line,pos,cur_effects,last_effect);
tlmp_warning ("insert cur_effects.size()=%lu :%s:",cur_effects.size(),cur_effects.size() >0 ? cur_effects.back().c_str():"");
	if (cur_effects.size() > 0 && cur_effects.back()==effect){
		auto p = line.begin()+pos;
tlmp_warning ("p=%d",*p);
		if (*p == CAR_END_EFFECT){	
			*p = CAR_END2_EFFECT;
		}else{
			// We remove the effect.
		}
	}else if (last_effect==effect){
		line[pos-1] = CAR_END_EFFECT;	
	}else{
		line.insert(pos,string_f("%c%s;%c",CAR_START_EFFECT,effect,CAR_END_EFFECT));
	}
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			p = wordproc_skipeffect(line,p);
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
			}
			ret++;	
		}
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
			ret++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
				ret++;
			}
			pos--;
		}
	}
	if (pos == 0){
		auto p = line.begin()+ret;
		while (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}
		if (*p == CAR_END2_EFFECT) ret++;
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
string WORDPROC::formatline(unsigned noline)
{
	WORDPROC_LINE empty;
	const WORDPROC_LINE &para = noline < lines.size() ? lines[noline] : empty;
	auto &line = para.line;
	string ret = string_f("<div class=col><div class=onecol>%02u-</div>",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	for (auto &p:prefs){
		if (p.second.maywrite && p.second.cursor.line == noline) cursors.emplace_back(p.second.cursor.column,p.second.insertmode);
	}
	stack<string> effects;
	string closetitle,closetab;
	{
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors.size() > 0 ? cursors[0].column : (unsigned)-1;
		unsigned cursor_no = 0;
		unsigned pos=0;
		static float tb[]={1,1.2,1.5,2,2.5};
		if (para.listtype == LIST_BULLET){
			ret += string_f("<div class=bullet%u>&bull;</div><div class=tab%u-bullet>",para.tab_level,para.tab_level);
		}else if (para.listtype == LIST_NUM){
			unsigned num = 1;
			for (int i=noline-1; i >=0; i--){
				auto &l = lines[i];
				if (l.tab_level == para.tab_level && l.listtype == LIST_NUM){
					num++;
				}else if (l.tab_level <= para.tab_level){
					break;
				}
			}
			ret += string_f("<div class=bullet%u><span style=font-size:%1.2fem>%u.</span></div><div class=tab%u-bullet>"
				,para.tab_level,tb[para.title_level],num,para.tab_level);
		}else if (para.listtype == LIST_CENTER){
			ret += "<div class=tab-center>";
		}else{
			ret += string_f("<div class=tab%u>",para.tab_level);
		}
		closetab = "</div>";
		if (para.title_level > 0){
			ret += string_f("<span style=font-size:%1.2fem;>",tb[para.title_level]);
			closetitle = "</span>";
		}
				
		for (auto p=line.begin(); p!=line.end(); ){
			auto c = *p;
			if (c == CAR_START_EFFECT){
				// tlmp_warning ("Start effect");
				string effect;
				p++;
				while (p != line.end()){
					if (*p == ';'){
						p++;
						break;
					}else{
						effect += *p++;
					}
				}
				// tlmp_warning ("effect=%s",effect.c_str());
				if (effect == EFFECT_BOLD){
					ret += "<b>";
					effects.push("</b>");
				}else if (effect == EFFECT_ITALIC){
					ret += "<i>";
					effects.push("</i>");
				}else if (effect == EFFECT_UNDERLINE){
					ret += "<u>";
					effects.push("</u>");
				}else if (effect == EFFECT_SUP){
					ret += "<sup>";
					effects.push("</sup>");
				}else if (effect == EFFECT_SUB){
					ret += "<sub>";
					effects.push("</sub>");
				}else if (effect == EFFECT_FONT1){
					ret += "<span style=font-size:1.5em;>";
					effects.push("</span>");
				}
			}else if (is_any_of(c,CAR_END_EFFECT,CAR_END2_EFFECT)){
				// tlmp_warning ("effects.size()=%lu",effects.size());
				p++;
				ret += effects.top();
				effects.pop();
			}else{
				if (pos == column){
					const char *cursor=cursors[cursor_no].insertmode
						? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
					ret += cursor;
				}
				if (c == ' '){
					// The first space is passed as is so the browser knows there are multiple words
					// The extra spaces are changed to &nbsp; so they are not skipped by the browser
					if (p == line.begin()
						|| (p > line.begin() && p[-1] == ' ')){
						ret += "&nbsp;";
					}else{
						ret += ' ';
					}
					p++;
				}else if (c == '<'){
					ret += "&lt;";
					p++;
				}else if (c == '>'){
					ret += "&gt;";
					p++;
				}else if (c == '\\'){
					ret += "&bsol;";
					p++;
				}else if (c == '\''){
					ret += "&#39;";
					p++;
				}else{
					size_t sizecar = utf8_codepoint_size(c);
					while (sizecar > 0 && p != line.end()){
						ret += *p++;
						sizecar--;
					}
				}
				if (pos == column){
					ret += "</span>";
					cursor_no++;
					if (cursor_no < cursors.size()){
						column = cursors[cursor_no].column;
					}
				}
				pos++;
			}
		}
		if (pos <= column){
			while (cursor_no < cursors.size()){
				column = cursors[cursor_no].column;
				while (pos < column){
					pos++;
					ret += "&nbsp;";
				}
				const char *cursor=cursors[cursor_no].insertmode
					? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
				ret += string(cursor) + "&nbsp;</span>";
				cursor_no++;
			}
		}
	}
	ret += closetitle + closetab;
	ret += "</div>";
	return ret;
}
/*
	Check if the line following noline are LIST_NUM. If this is the case, the line is added to updlines
*/
static void wordproc_update_num_lines (unsigned noline, const vector<WORDPROC_LINE> &lines, vector<unsigned> &updlines)
{
	if (noline < lines.size()){
		unsigned tab_level = lines[noline].tab_level;
		for (unsigned i=noline+1; i<lines.size(); i++){
			auto &l = lines[i];
			if (l.tab_level == tab_level && l.listtype == LIST_NUM){
				updlines.push_back(i);
			}else if (l.tab_level <= tab_level){
				break;
			}
		}
	}
}

/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (vector<unsigned> &updlines, WORD_USERPREF &pref)
{
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line].line;
		unsigned len = wordproc_linelen(l);
		if (len > pref.cursor.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar > 0){
				l = l.substr(0,pos) + l.substr(pos+sizecar);
			}
		}else{
			unsigned nextline = pref.cursor.line+1;
			if (lines.size() > nextline){
				// We are at the end of the line, or further.
				// So we merge the previous line here.
				// First we grow the line
				while (len < pref.cursor.column){
					l += ' ';
					len++;
				}
				l += lines[nextline].line;
				lines.erase(lines.begin()+nextline);
				for (unsigned l=nextline; l<lines.size()+1; l++) updlines.push_back(l);
			}
		}
		updlines.push_back(pref.cursor.line);
	}
}
void WORDPROC::vmove (
	int move,
	unsigned visible_lines,		// How many <div> sent
	unsigned lastline,		// last line partially visible
	WORD_USERPREF &pref,
	VARVAL &script_var,
	vector<unsigned> &updlines)
{
	if (move < 0 && abs(move) > pref.cursor.line) move = -pref.cursor.line;
	unsigned nextline = pref.cursor.line + move;
	if (nextline < pref.offset){
		// tlmp_warning ("vmove offset=%u visible_lines=%u lastline=%u",pref.offset,visible_lines,lastline);
		pref.offset--;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove last div
		script_var.val += "console.log('vmove length='+elms.length);\n";
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(pref.offset);
		updlines.push_back(pref.offset+1);
	}else if (nextline >= pref.offset + lastline){
		pref.offset++;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.push_back(last_line-1);
		updlines.push_back(last_line);
	}else{
		updlines.push_back(pref.cursor.line);
		updlines.push_back(nextline);
	}
	pref.cursor.line = nextline;
}
void WORDPROC::page_up_down(
	int new_offset, 
	unsigned visible_lines,
	unsigned lastline,
	WORD_USERPREF &pref,
	VARVAL &script_var,
	vector<unsigned> &script_lines,
	vector<unsigned> &notify_lines)
{
	if (new_offset < 0) new_offset = 0;
	if ((unsigned)new_offset != pref.offset){
		int offline = pref.cursor.line - pref.offset;
		if (offline < 0) offline = 0;
		js_find_loop_start (script_var.val,"text","div");
		// Remove all div
		script_var.val += "\telm.innerHTML='';\n";
		// Add new ones
		script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
		script_var.val += "\t\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
		script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
		script_var.val += "\t\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\t\tnewElement.innerHTML = '';\n";
		script_var.val += "\t\telm.insertBefore(newElement,null);\n";
		script_var.val += "\t}\n";
		js_find_loop_end (script_var.val);
		for (unsigned i=0; i<visible_lines; i++) script_lines.push_back(new_offset+i);
		notify_lines.push_back(pref.cursor.line);
		if (pref.cursor.line < (unsigned)new_offset
			|| pref.cursor.line >= new_offset + lastline){
			pref.cursor.line = new_offset+offline;
		}
		notify_lines.push_back(pref.cursor.line);
		pref.offset = new_offset;
	}
}
void WORDPROC::update_lines (string &script, vector<unsigned> &updlines)
{
	sort (updlines.begin(),updlines.end());
	js_find_loop_start_class(script,"text","oneline");
	script += "\t\tfor (var i=0; i<elms.length; i++){\n";	
	script += "\t\t\tvar e=elms[i];\n";
	for (unsigned i=0; i<updlines.size(); i++){
		const char *elseverb = i==0 ? "" : "}else ";
		auto l = updlines[i];
		string id=string_f("l%u",l);
		script += string_f("\t\t\t%sif(e.id=='l%u'){\n",elseverb,l);
		script += string_f("\t\t\t\te.innerHTML = '%s';\n",formatline(l).c_str());
		if (i == updlines.size()-1){
			script += "\t\t\t\tbreak;\n";
			script += "\t\t\t}\n";
		}
	}
	script += "\t\t}\n";
	js_find_loop_end(script);
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	setactivity();
	auto &pref = prefs[username];
	pref.maywrite = maywrite;
	unsigned visible_lines = sp.content_height/sp.fontsize + 10;
	visible_lines = 50;
	// tlmp_warning ("visible_lines=%u content_height=%u fontsize=%u",visible_lines,sp.content_height,sp.fontsize);
	if (strcmp(var,"print")==0){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &ll:lines){
				auto &l = ll.line;
				if (line == pref.cursor.line){
					if (l.size() > pref.cursor.column){
						v.val += l.substr(0,pref.cursor.column) + cursor + l.substr(pref.cursor.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.cursor.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			unsigned width = sp.content_width;
			VARVAL v;
			v.var = VAR_CONTENT;


			{
				unsigned sp_width = width-30;	// Space for line numbers, during development
				v.val += "<style>\n";
				v.val += ".onecol, .oneline{\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += "}\n";
				v.val += ".oneline .col{\n";
				v.val += "\tdisplay:flex;\n";
				v.val += "\tflex-flow:row;\n";
				v.val += "}\n";
				v.val += ".tab-center{\n";
				v.val += "\ttext-align:center;\n";
				v.val += "\toverflow-wrap: break-word;\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += string_f("\twidth:%u;\n",sp_width);
				v.val += "}\n";

				const unsigned tab_width=30;
				const unsigned bullet_width=15+5;
				//unsigned offsets[]={5,tab_width-15,2*tab_width-15,3*tab_width-15};
				for (unsigned i=0; i<4; i++){
					v.val += string_f(".bullet%u{\n",i);
					v.val += "\tflex:0 1 auto;\n";
					v.val += "\twidth:10;\n";
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width+5);
					v.val += "\tmargin-right:5;\n";
					v.val += "}\n";
					v.val += string_f(".tab%u{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("\twidth:%u;\n",sp_width-i*tab_width);
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width);
					v.val += "}\n";
					v.val += string_f(".tab%u-bullet{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("width:%u;\n",sp_width-i*tab_width-bullet_width);
					v.val += "\tmargin-left:0;\n";
					v.val += "}\n";
				}
			}
			v.val += "</style>\n";

			// event.location==1 tells if this is the left shift/alt key or right. We are not using it now
			v.val += "<script>\n";
			// Function find the last visible line on screen
			v.val += "function getlastline(){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			//v.val += "\tconsole.log('getlastline length='+elms.length);\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar srect = elms[i].getBoundingClientRect();\n";
			//v.val += "\t\tconsole.log('i='+i+' rect.bottom='+rect.bottom+' srect.bottom='+srect.bottom);\n";
			v.val += "\t\tif (rect.bottom < srect.bottom){\n";
			v.val += "\t\t\treturn i;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Function called when the user click
			v.val += "function gameselect(event){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar para= elms[i];\n";
			v.val += "\t\tvar rect = para.getBoundingClientRect();\n";
			v.val += "\t\tif (event.clientY >= rect.top && event.clientY < rect.bottom){\n";
			v.val += "\t\t\tvar divs=para.getElementsByTagName('div');\n";
			v.val += "\t\t\tvar r=divs[divs.length-1].getBoundingClientRect();\n";
			v.val += "\t\t\tgameaction('select:'+i+' '+(event.clientX-r.left)+' '+(event.clientY-r.top)+' '+getlastline());\n";
			v.val += "\t\t\tbreak;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "}\n";
			// Function called when the user uses the keyboard
			v.val += "function gamepress(event){\n";
			v.val += "\tconsole.log ('key='+event.key+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey);\n";
			v.val += "\tconsole.log ('code='+event.code);\n";
			v.val += string_f("\tgameaction('kbd:'+event.code + ' ' + event.key+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey+' '+getlastline());\n");
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				#define BUTTON_TITLE_PLUS	0
				#define BUTTON_TITLE_LESS	1
				#define BUTTON_TAB_PLUS		3
				#define BUTTON_TAB_LESS		4
				#define BUTTON_BULLET		5
				#define BUTTON_NUMLIST		6
				#define BUTTON_BOLD		7
				#define BUTTON_ITALIC		8
				#define BUTTON_UNDERLINE	9
				#define BUTTON_SUP		10
				#define BUTTON_SUB		11
				#define BUTTON_CENTER		12
				const unsigned b_width=20;
				documentd_button_start(v.val,gameid);
				documentd_button (v.val,BUTTON_TITLE_PLUS,"T",b_width,false);
				documentd_button (v.val,BUTTON_TITLE_LESS,"t",b_width,false);
				documentd_button (v.val,BUTTON_BOLD,"<b>B</b>",b_width,false);
				documentd_button (v.val,BUTTON_ITALIC,"<i>I</i>",b_width,false);
				documentd_button (v.val,BUTTON_UNDERLINE,"<u>U</u>",b_width,false);
				documentd_button (v.val,BUTTON_SUP,"A<sup>2</sup>",b_width,false);
				documentd_button (v.val,BUTTON_SUB,"A<sub>2</sub>",b_width,false);
				documentd_button (v.val,BUTTON_TAB_PLUS,"->",b_width,false);
				documentd_button (v.val,BUTTON_TAB_LESS,"<-",b_width,false);
				documentd_button (v.val,BUTTON_CENTER,"<->",b_width,false);
				documentd_button (v.val,BUTTON_BULLET,"&bull;",b_width,false);
				documentd_button (v.val,BUTTON_NUMLIST,"N.",b_width,false);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Document
			v.val += "<div class=webtable id=doc_wordproc style='display:flex; flex-flow:row;'>\n";
			v.val += string_f("<div id='text-%s' onkeydown=gamepress(event) onclick=gameselect(event)"
				" tabindex=0 style='flex:0 0 auto; overflow: hidden; margin-right:%u; width:%u'>\n",gameid.c_str(),10,width);
			unsigned line = 0;
			if (pref.offset < lines.size()){
				for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
					unsigned doc_line = line+pref.offset;
					v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
						,formatline(doc_line).c_str());
					line++;
				}
			}
			for (; line<visible_lines; line++){
				static string empty;
				unsigned doc_line = line+pref.offset;
				v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
					,formatline(doc_line).c_str());
			}
			v.val += "</div>\n";
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += "&nbsp;";
			#if 0
				// Trick to make the document window shorter
				for (int i=0; i<25; i++) v.val += "allo<br>\n";
			#endif
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else{
		struct {
			bool ctrl = false;
			bool shift = false;
			bool alt = false;
		} mod;
		unsigned lastline = 1000;
		if (strcmp(var,"kbd")==0){
			if (is_start_any_of(var,NONEED,"kbd")){
				vector<string> tb;
				int n = str_splitline(val,' ',tb);
				//tlmp_warning ("n=%d val=%s",n,val);
				if (n == 5 && is_any_of(tb[0],"Space")){
					var = "insertchar";
					val = " ";
					lastline = atoi(tb[4].c_str());
				}else if (n != 6){
					// Do nothing
				}else{
					lastline = atoi(tb[5].c_str());
					mod.alt = tb[2] == "true";
					mod.ctrl = tb[3] == "true";
					mod.shift = tb[4] == "true";
					const char *tb0 = tb[0].c_str();
					const char *tb1 = tb[1].c_str();
					if (is_any_of(tb0,"Enter","NumpadEnter")){
						var = "break";
					}else if (is_any_of(tb0,"NumpadDecimal")){
						if (tb[1] == "Delete"){
							var = "deletechar";
						}else{
							var = "insertchar";
							val = tb1;
						}
					}else if (is_start_any_of(tb0,NONEED,"Numpad")){
						if (tb[1].size()==1){
							var = "insertchar";
							val = tb1;
						}else if (strcmp(tb1,"Home")==0){
							var = "home";
						}else if (strcmp(tb1,"End")==0){
							var = "end";
						}else if (strcmp(tb1,"ArrowLeft")==0){
							var = "hmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowRight")==0){
							var = "hmove";
							val = "1";
						}else if (strcmp(tb1,"ArrowUp")==0){
							var = "vmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowDown")==0){
							var = "vmove";
							val = "1";
						}else if (strcmp(tb1,"Insert")==0){
							var = "insertmode";
						}else if (strcmp(tb1,"PageUp")==0){
							var = "pageup";
						}else if (strcmp(tb1,"PageDown")==0){
							var = "pagedown";
						}
					}else if (is_start_any_of(tb0,NONEED,"Key","Digit","Slash","Period"
						,"Comma","Quote","Backslash","Minus","Equa","Bracket","Backquote","Semicolon")){
						var = "insertchar";
						val = tb1;
					}else if (is_any_of(tb0,"Insert")){
						var = "insertmode";
					}else if (is_any_of(tb0,"Delete")){
						var = "deletechar";
					}else if (is_any_of(tb0,"Home")){
						var = "home";
					}else if (is_any_of(tb0,"End")){
						var = "end";
					}else if (is_any_of(tb0,"ArrowUp")){
						var = "vmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowDown")){
						var = "vmove";
						val = "1";
					}else if (is_any_of(tb0,"ArrowLeft")){
						var = "hmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowRight")){
						var = "hmove";
						val = "1";
					}else if (is_any_of(tb0,"Backspace")){
						var = "backspace";
					}else if (is_any_of(tb0,"PageUp")){
						var = "pageup";
					}else if (is_any_of(tb0,"PageDown")){
						var = "pagedown";
					}
				}
				// tlmp_warning ("kbd: var=%s val=%s lastline=%u",var,val,lastline);
			}
		}
		if (maywrite){
			VARVAL notify_var;
			notify_var.var = VAR_NOTIFY;
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
			vector<unsigned> notify_lines;	// Lines to update using NOTIFY (To all)
			if (strcmp(var,"insertmode")==0){
				pref.insertmode = !pref.insertmode;
				notify_lines.push_back(pref.cursor.line);
			}else if (strcmp(var,"insertchar")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				auto &wl = lines[pref.cursor.line];
				string &l = wl.line;
				while (wordproc_linelen(l) < pref.cursor.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				bool update_num_lines = false;
				if (strcmp(val,"b")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (strcmp(val,"f")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_FONT1);
				}else if (strcmp(val,">")==0 && mod.alt){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (strcmp(val,"<")==0 && mod.alt){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (strcmp(val,"t")==0 && mod.alt){
					if (wl.title_level < 4) wl.title_level++;
					update_num_lines = true;
				}else if (strcmp(val,"T")==0 && mod.alt){
					if (wl.title_level > 0) wl.title_level--;
					update_num_lines = true;
				}else if (strcmp(val,"l")==0 && mod.alt){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (strcmp(val,"L")==0 && mod.alt){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (strcmp(val,"z")==0 && mod.alt){
					if (lines.size()==1 && lines[0].line.size()==0){
						// Fill with many lines
						resetgame();
						string para;
						para = "allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<2; i++) para += " allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<100; i++) lines.push_back(string_f("line %lu:",lines.size())+para);
					}else{
						resetgame();
					}
					documentd_forcerefresh (res);
				}else{
					l.insert(pos,val);
					pref.cursor.column ++;
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.push_back(pref.cursor.line);
			}else if (strcmp(var,"break")==0){
				while (lines.size() <= pref.cursor.line) lines.emplace_back(WORDPROC_LINE());
				auto &para = lines[pref.cursor.line];
				string &l = para.line;
				auto nextline = lines.begin() + (pref.cursor.line+1);
				unsigned pos = l.size();
				if (wordproc_linelen(l) > pref.cursor.column){
					pos = wordproc_jump2col(l,pref.cursor.column);
				}
				{
					// We have to transport the active effects to the next line.
					// effects started after pos are simply copied
					vector<string> effects;
					wordproc_current_effects (l,pos,effects);
					WORDPROC_LINE newl;
					tlmp_warning ("break effects.size()=%lu",effects.size());
					for (auto &e:effects){
						tlmp_warning ("break insert %s",e.c_str());
						newl.line += string_f("%c%s;",CAR_START_EFFECT,e.c_str());
					}
					newl.line += l.substr(pos);
					if (para.title_level == 0){
						newl.listtype = para.listtype;
						newl.tab_level = para.tab_level;
					}
					lines.insert(nextline,newl);
					lines[pref.cursor.line].line.resize(pos);
					for (unsigned i=0; i<effects.size(); i++) lines[pref.cursor.line].line += CAR_END_EFFECT;
				}
				for (unsigned l=pref.cursor.line; l<lines.size(); l++) notify_lines.push_back(l);
				pref.cursor.line++;
				pref.cursor.column=0;
			}else if (strcmp(var,"backspace")==0){
				notify_lines.push_back(pref.cursor.line);
				// We start by moving the cursor back one character if possible.
				// If we are at the start of a line, we go at the end of the previous line.
				// We do a deletechar after that
				if (pref.cursor.column > 0){
					pref.cursor.column--;
					deletechar(notify_lines,pref);
				}else if (pref.cursor.line > 0){
					pref.cursor.line--;
					pref.cursor.column=0;
					if (lines.size() > pref.cursor.line){
						string &l = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(l);
						pref.cursor.column = len;
					}
					notify_lines.push_back(pref.cursor.line);
					deletechar(notify_lines,pref);
				}
			}else if (strcmp(var,"deletechar")==0){
				deletechar(notify_lines,pref);
			}else if (strcmp(var,"voffset")==0){
				// Change page up or down
				int move = atoi(val);
				if (move > 0){
					pref.offset += move;
				}else{
					if ((unsigned)-move > pref.offset){
						pref.offset = 0;
					}else{
						pref.offset += move;
					}
				}
			}else if (strcmp(var,"vmove")==0){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.cursor.line;
				vmove (move,visible_lines,lastline,pref,script_var,script_lines);
				if (current_line != pref.cursor.line){
					notify_lines.push_back(current_line);
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				page_up_down(new_offset,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else if (strcmp(var,"hmove")==0){
				int move = atoi(val);
				if (move < 0){
					if (pref.cursor.column == 0){
						if (pref.cursor.line > 0){
							notify_lines.push_back(pref.cursor.line);
							vmove (-1,visible_lines,lastline,pref,script_var,script_lines);
							if (lines.size() > pref.cursor.line){
								pref.cursor.column = wordproc_linelen(lines[pref.cursor.line].line);
							}
							notify_lines.push_back(pref.cursor.line);
						}
							
					}else{
						if (pref.cursor.line < lines.size() && mod.ctrl){
							// skip word back
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							if (pref.cursor.column > len){
								pref.cursor.column = len;
							}else{
								// First, skip spaces
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] != ' ') break;
									pref.cursor.column--;
								}
								// Then skip word
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] == ' ') break;
									pref.cursor.column--;
								}
							}
						}else{
							pref.cursor.column += move;
						}
						notify_lines.push_back(pref.cursor.line);
					}
				}else{
					if (pref.cursor.line < lines.size() && mod.ctrl){
						// skip word
						auto &line = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(line);
						if (pref.cursor.column >= len){
							pref.cursor.column++;
						}else{
							// First, skip spaces
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] != ' ') break;
								pref.cursor.column++;
							}
							// Then skip word
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] == ' ') break;
								pref.cursor.column++;
							}
						}
					}else{
						pref.cursor.column += move;
					}
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"home")==0){
				if (pref.cursor.column != 0){
					pref.cursor.column = 0;
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"end")==0){
				unsigned column  = pref.cursor.column;
				if (lines.size() > pref.cursor.line){
					column = wordproc_linelen(lines[pref.cursor.line].line);
				}else{
					column = 0;
				}
				if (column != pref.cursor.column){
					pref.cursor.column = column;
					notify_lines.push_back(pref.cursor.line);
				}
			}else if (strcmp(var,"select")==0){
				vector<string> tb;
				//tlmp_warning ("select=%s",val);
				int n = str_splitline(val,' ',tb);
				if (n == 4){
					unsigned noline = atoi(tb[0].c_str());
					if (noline < visible_lines){
						unsigned newline = pref.offset + noline;
						if (newline != pref.cursor.line){
							notify_lines.push_back(pref.cursor.line);
							pref.cursor.line = newline;
						}
						// We have to figure out where 
						if (pref.cursor.line < lines.size()){
							unsigned xcoor = atoi(tb[1].c_str());
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							unsigned xpos = 0;
							for (unsigned i=0; i<len; i++){
								// We have to compute the length of every character in the line
								#if 0
								size_t sizecar;
								unsigned pos = wordproc_jump2col(line,i,sizecar);
								#endif
								// assume a fixed length for now
								unsigned width=10;
								xpos += width;
								if (xpos  > xcoor){
									pref.cursor.column = i;
									break;
								}
							}
						}
						notify_lines.push_back(pref.cursor.line);
					}
				}
			}else if (strcmp(var,"newgame")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				unsigned uval = atoi(val);
				bool update_num_lines = false;
				auto &wl = lines[pref.cursor.line];
				auto &l = wl.line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				if (uval == BUTTON_TAB_PLUS){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (uval == BUTTON_TAB_LESS){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_PLUS){
					if (wl.title_level < 4) wl.title_level++;
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_LESS){
					if (wl.title_level > 0) wl.title_level--;
					update_num_lines = true;
				}else if (uval == BUTTON_BULLET){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_NUMLIST){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_CENTER){
					if (wl.listtype == LIST_CENTER){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_CENTER;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_BOLD){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (uval == BUTTON_ITALIC){
					wordproc_insert_effect (l,pos,EFFECT_ITALIC);
				}else if (uval == BUTTON_UNDERLINE){
					wordproc_insert_effect (l,pos,EFFECT_UNDERLINE);
				}else if (uval == BUTTON_SUP){
					wordproc_insert_effect (l,pos,EFFECT_SUP);
				}else if (uval == BUTTON_SUB){
					wordproc_insert_effect (l,pos,EFFECT_SUB);
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.push_back(pref.cursor.line);
				script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
			}
			update_lines (notify_var.val,notify_lines);
			update_lines (script_var.val,script_lines);
			res.emplace_back(script_var);
			res.emplace_back(notify_var);
			setmodified(username);
		}else{
			VARVAL script_var;
			script_var.var = VAR_SCRIPT;
			vector<unsigned> updlines;	// Lines to update using NOTIFY
			if (strcmp(var,"vmove")==0){
				// Vertical arrows are producing scrolls in read only mode.
				int move = atoi(val);
				if (move < 0){
					pref.cursor.line = pref.offset;
				}else{
					pref.cursor.line = pref.offset + visible_lines - 1;
				}
				vmove (move,visible_lines,lastline,pref,script_var,updlines);
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				vector<unsigned> notify_lines;
				page_up_down (new_offset,visible_lines,lastline,pref,script_var,updlines,notify_lines);
			}else{
				documentd_error (res,MSG_R(E_READONLY));
			}
			update_lines (script_var.val,updlines);
			res.emplace_back(script_var);
		}
	}
	string tmp;
	for (auto &v:res) tmp += string_f(" %s=%lu",v.var.c_str(),v.val.size());
	tlmp_warning (tmp.c_str());
}

