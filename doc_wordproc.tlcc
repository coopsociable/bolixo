/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <stack>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

#define documentd_wordproc_lines_NOTNEED
#include "proto/documentd_wordproc.protoch"
#include "proto/documentd_wordproc.protoh"

using namespace std;

struct WORDINFO{
	const char *txt;
	unsigned len;	// In pixel
	unsigned txtlen;	// strlen(txt);
	WORDINFO(const char *_txt, unsigned _len){
		txt = _txt;
		len = _len;
		txtlen = strlen(txt);
	}
};
class PARAGRAPH{
	vector<string> tb;		// Will contain the paragraph splitted into words.
public:
	vector<WORDINFO> words;		// The paragraph is decomposed into words
	vector<vector<WORDINFO>> lines;	// Then the words are put together in lines
	vector<unsigned> line_cursors;	// character cursor position in each line, produced by locate_cursor()
	vector<unsigned> line_homes;	// character cursor (paragraph) position of the start of each line
	vector<unsigned> line_ends;	// character cursor (paragraph) position of the end of each line
	vector<unsigned> line_heights;	// Height in pixel of each paragraph lines
	unsigned fontsize=0;
	void addline (unsigned line_start, unsigned line_end, unsigned height);
	unsigned cursor_pos=0;		// Cursor position inside the line in pixel
public:
	PARAGRAPH();
	PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void init(PARAM_STRING txt, unsigned width, unsigned fontsize);
	void locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor);
	void locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline);
	void locate_pixel(unsigned x_pos, unsigned y_pos);
	unsigned get_para_cursor (unsigned noline);
	unsigned get_para_home (unsigned noline);
	unsigned get_para_end (unsigned noline);
	unsigned get_line_cursor (unsigned noline);
	unsigned get_nblines() const{
		return lines.size();
	}
	unsigned get_cursor_xpos() const {
		return cursor_pos;
	}
};

static float para_fontsize=1.2;
static unsigned displaylen_call=0;
static unsigned wordproc_displaylen (PARAM_STRING txt, unsigned fontsize)
{
	displaylen_call++;
	unsigned ret = 10*strlen(txt.ptr);
	if (fontsize > 0){
		ret = documentd_displaylen (txt.ptr,fontsize,para_fontsize);
	}
	//tlmp_warning ("displaylen :%s: fontsize=%u ret=%u",txt.ptr,fontsize,ret);
	return ret;
}
PARAGRAPH::PARAGRAPH()
{
}
PARAGRAPH::PARAGRAPH(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	init (txt,width,_fontsize);
}
/*
	Add the specification of one line in the paragraph
*/
void PARAGRAPH::addline (unsigned word_start, unsigned word_end, unsigned height)
{
	vector<WORDINFO> line;
	unsigned charlen = 0;
	for (unsigned i=word_start; i<word_end; i++){
		auto &w = words[i];
		line.push_back(w);
		charlen += w.txtlen;
	}
	lines.emplace_back(move(line));
	unsigned homepos = 0;
	for (unsigned i=0; i<word_start; i++) homepos += words[i].txtlen;
	line_ends.push_back(homepos+charlen+1);
	if (homepos > 0) homepos++;	// We skip the space between the last word of the previous
					// line and this line
	line_homes.push_back(homepos);
	line_heights.push_back(height);
}

void PARAGRAPH::init(PARAM_STRING txt, unsigned width, unsigned _fontsize)
{
	fontsize = _fontsize;
	tb.clear();
	words.clear();
	lines.clear();	
	line_homes.clear();
	line_ends.clear();
	line_heights.clear();
	str_splitline (txt.ptr,' ',tb);
	for (auto &w:tb){
		w.insert(w.begin(),' ');
		words.emplace_back(w.c_str(),wordproc_displaylen(w,fontsize));
	}
	unsigned offset = 0;
	unsigned wordnum = 1;
	while (wordnum < words.size()){
		// We assemble a line made of words until its width is larger than the div width.
		auto &wo = words[offset];
		if (wo.txt[0] == ' '){
			// Remove the space for the first word
			wo.txtlen--;
			wo.txt++;
			wo.len = wordproc_displaylen(wo.txt,fontsize);
		}
		unsigned linelen = wo.len;
		for (unsigned i=offset+1; i<=wordnum; i++) linelen += words[i].len;
		//htmlprintf ("linelen=%u width=%u lines.size()=%lu<br>\n",linelen,width,lines.size());
		if (linelen < width){
			wordnum++;
		}else{
			addline (offset,wordnum,fontsize);
			offset = wordnum;
		}
	}
	{
		addline (offset,words.size(),fontsize);
	}
}
/*
	Find the coordinate of a linear cursor (character offset in a paragraph): line, and pixel offset
*/
void PARAGRAPH::locate_cursor(unsigned para_cursor, unsigned &noline, unsigned &line_cursor)
{
	// The cursor represent a linear position into a paragraph
	// Now that the text is splitted in lines, we will find the line the cursor belongs,
	// then the offset in that line, and then, a pixel position in that line.
	noline = 0;
	line_cursors.clear();
	for (unsigned i=0; i<lines.size(); i++){
		auto &line = lines[i];
		size_t line_size = 0;
		for (auto &l:line) line_size += l.txtlen;
		if (para_cursor < line_size){
			noline = i;
			line_cursor = para_cursor;
			unsigned offset_cursor = 0;
			cursor_pos=0;		// Cursor position inside the line in pixel
			for (auto &w:line){
				if (offset_cursor == para_cursor){
					break;
				}else{
					unsigned next_offset = offset_cursor + w.txtlen;
					if (next_offset > para_cursor){
						// Ok the cursor is in that word
						string tmp (w.txt,para_cursor-offset_cursor);
						//htmlprintf ("last word :%s:<br>\n",tmp.c_str());
						cursor_pos += wordproc_displaylen(tmp,fontsize);
						para_cursor = 0;
						break;
					}
					cursor_pos += w.len;
					offset_cursor = next_offset;
				}
			}
			break;
		}
		para_cursor -= line_size;
	}
	if (para_cursor > 0){
		unsigned space_width = wordproc_displaylen(" ",fontsize);
		while (para_cursor > 0){
			para_cursor--;
			cursor_pos += space_width;
		}
	}
	locate_pixel (cursor_pos,0);
}
/*
	Find the corresponding cursor position in each line based on position given in pixel
*/
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos, unsigned &noline)
{
	// We know the cursor horizonl and vertical position in pixel: x_pos,y_pos
	// Now we will find the corresponding cursor position in each lines of the paragraph.
	// This will be stored in line_offsets. This is the cursor position in character.
	// We also locate the paragraph line number
	noline=0;
	unsigned y_offset = 0;
	for (auto h:line_heights){
		y_offset += h;
		if (y_offset > y_pos) break;
		noline++;
	}
	line_cursors.clear();
	for (auto &l:lines){
		unsigned pixel_offset = 0;
		unsigned offset = 0;
		for (auto &w:l){
			unsigned next_pixel_offset = pixel_offset + w.len;
			if (next_pixel_offset > x_pos){
				// The cursor is located in that word.
				const char *s = w.txt;
				string tmp;
				unsigned target_pos = x_pos - pixel_offset;
				while (*s != '\0'){
					tmp += *s++;
					#if 0
					htmlprintf ("line=%lu tmp=:%s: offset=%u target_pos=%u dlen=%u<br>\n"
						,line_cursors.size(),tmp.c_str(),offset,target_pos,wordproc_displaylen(tmp,fontsize));
					#endif
					if (wordproc_displaylen(tmp,fontsize) > target_pos) break;
					offset++;
				}
				break;
			}
			pixel_offset = next_pixel_offset;
			offset += w.txtlen;
		}
		line_cursors.push_back(offset);
	}
}
void PARAGRAPH::locate_pixel(unsigned x_pos, unsigned y_pos)
{
	unsigned paraline;
	locate_pixel (x_pos,y_pos,paraline);
}
unsigned PARAGRAPH::get_para_home (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_homes.size()){
		return line_homes[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_end (unsigned noline)
{
	unsigned ret = 0;
tlmp_warning ("get_para_end noline=%u line_ends.size()=%lu",noline,line_ends.size());
	if (noline < line_ends.size()){
tlmp_warning ("end=%u",line_ends[noline]);
		return line_ends[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_para_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()){
		return line_homes[noline] + line_cursors[noline];
	}
	return ret;
}
unsigned PARAGRAPH::get_line_cursor (unsigned noline)
{
	unsigned ret = 0;
	if (noline < line_cursors.size()) ret = line_cursors[noline];
	return ret;
}

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_wordproc_header (&w,revision);
	vector<WORDPROC_USER> users;
	for (auto &p:prefs){
		WORDPROC_USER user;
		user.name = p.first;
		user.line = p.second.cursor.line;
		user.column = p.second.cursor.column;
		user.offset = p.second.offset;
		user.insertmode = p.second.insertmode;
		users.emplace_back(user);
	}
	documentd_wordproc_users (&w,users);
	vector<WORDPROC_PARA_V2> paras;
	for (auto &l:lines){
		WORDPROC_PARA_V2 para;
		para.listtype = l.listtype;
		para.title_level = l.get_paragraph_type();
		para.line_spec = l.get_paragraph_spec();
		para.tab_level = l.tab_level;
		para.line = l.line;
		paras.emplace_back(para);
	}
	documentd_wordproc_lines_v2 (&w,paras);
}
<mod>
void WORDPROC::load(DOC_READER &r, string &msg)
{
	glocal revision;
	glocal prefs;
	glocal lines;
	glocal gameid;
	resetgame();
	prefs.clear();
	<call documentd_wordproc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f users>
		for (auto &u:users){
			WORD_USERPREF &p = glocal.prefs[u.name];
			p.cursor.line = u.line;
			p.cursor.column = u.column;
			p.offset = u.offset;
			p.insertmode = u.insertmode;
		}
	</f>
	<f lines>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(line.is_image() ? 30 : 0);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f lines_v2>
		for (auto &l:lines){
			WORDPROC_LINE line;
			line.listtype = l.listtype;
			line.set_paragraph_type(l.title_level);
			line.set_paragraph_spec(l.line_spec);
			line.tab_level = l.tab_level;
			line.line = l.line;
			glocal.lines.push_back(line);
		}
	</f>
	<f invalid>
		tlmp_error ("Invalid command while loading document %s: %s",glocal.gameid.c_str(),msg);
	</f>
	</call>
}
</mod>
void WORDPROC::resetgame()
{
	lines.clear();
	prefs.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}

#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000
static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
#define CAR_START_EFFECT	11		
#define CAR_END_EFFECT		12
#define CAR_END2_EFFECT		13	// This is like END, except the cursor moves over it
#					// This is useful to stop expanding an effect while entering character
#define EFFECT_BOLD	"b"
#define EFFECT_ITALIC	"i"
#define EFFECT_UNDERLINE "u"
#define EFFECT_SUP	"S"
#define EFFECT_SUB	"s"
#define EFFECT_FONT1	"F"

static string::const_iterator wordproc_skipeffect(const string &line, string::const_iterator p)
{
	p++;
	while (p != line.end()){
		if (*p == ';'){
			p++;
			break;
		}else{
			p++;
		}
	}
	return p;
}
/*
	Walk a string from 0 to pos and fill the stack of active effects
*/
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects, string &last_effect)
{
	auto end = line.begin() + pos;
	for (auto p=line.begin(); p<end; ){
		if (*p == CAR_START_EFFECT){
			string effect;
			p++;
			while (p != line.end()){
				if (*p == ';'){
					p++;
					break;
				}else{
					effect += *p++;
				}
			}
			effects.push_back(effect);
			last_effect.clear();
		}else{
			if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
				if (effects.size() == 0){
					tlmp_warning ("END_EFFECT seen in doc, no active effect");
				}else{
					last_effect = effects.back();
					effects.pop_back();
				}
			}else{
				last_effect.clear();
			}
			p++;
		}
		
	}
}
static void wordproc_current_effects (string &line, unsigned pos, vector<string> &effects)
{
	string last;
	wordproc_current_effects (line,pos,effects,last);
}
/*

	If we are currently at the end of this effect, we toggle the END marker (END <-> END2). This allows the user to extend
	the line by inserting character inside or outside the effect area.

	If we are currently inside this effect area, it is removed.

	If not, we just insert the effect start and stop in a line.
*/
static void wordproc_insert_effect (string &line, unsigned pos, const char *effect)
{
	vector<string> cur_effects;
	string last_effect;
	wordproc_current_effects(line,pos,cur_effects,last_effect);
tlmp_warning ("insert cur_effects.size()=%lu :%s:",cur_effects.size(),cur_effects.size() >0 ? cur_effects.back().c_str():"");
	if (cur_effects.size() > 0 && cur_effects.back()==effect){
		auto p = line.begin()+pos;
tlmp_warning ("p=%d",*p);
		if (*p == CAR_END_EFFECT){	
			*p = CAR_END2_EFFECT;
		}else{
			// We remove the effect.
		}
	}else if (last_effect==effect){
		line[pos-1] = CAR_END_EFFECT;	
	}else{
		line.insert(pos,string_f("%c%s;%c",CAR_START_EFFECT,effect,CAR_END_EFFECT));
	}
}
/*
	Return the length of a UTF8 string
*/
static unsigned wordproc_linelen (const string &line)
{
	unsigned ret = 0;
	for (auto p=line.begin(); p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			p = wordproc_skipeffect(line,p);
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
			}
			ret++;	
		}
	}
	return ret;
}
/*
	Return the offset in line corresponding to the pos UTF8 character.
	sizecar will hold the size of the character at this position.
*/
static unsigned wordproc_jump2col (const string &line, unsigned pos, size_t &ret_sizecar)
{
	unsigned ret = 0;
	for (auto p=line.begin(); pos != 0 && p!=line.end(); ){
		if (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}else if (is_any_of(*p,CAR_END_EFFECT,CAR_END2_EFFECT)){
			p++;
			ret++;
		}else{
			size_t sizecar = utf8_codepoint_size(*p);
			while (sizecar > 0 && p != line.end()){
				p++;
				sizecar--;
				ret++;
			}
			pos--;
		}
	}
	if (pos == 0){
		auto p = line.begin()+ret;
		while (*p == CAR_START_EFFECT){
			auto startp = p;
			p = wordproc_skipeffect(line,p);
			ret += p-startp;	
		}
		if (*p == CAR_END2_EFFECT) ret++;
		ret_sizecar = utf8_codepoint_size(line[ret]);
	}else{
		ret_sizecar = 0;
	}
	return ret;
}
static unsigned wordproc_jump2col (const string &line, unsigned pos)
{
	size_t sizecar;
	return wordproc_jump2col (line,pos,sizecar);
}
	
string WORDPROC::formatline(unsigned noline)
{
	WORDPROC_LINE empty;
	const WORDPROC_LINE &para = noline < lines.size() ? lines[noline] : empty;
	auto &line = para.line;
	string ret = string_f("<div class=col><div class=onecol>%02u-</div>",noline);
	struct CURSOR{
		unsigned column;
		bool insertmode;
		CURSOR(unsigned _column, bool _insertmode): column(_column), insertmode(_insertmode){}
	};
	vector<CURSOR> cursors;
	for (auto &p:prefs){
		if (p.second.maywrite && p.second.cursor.line == noline) cursors.emplace_back(p.second.cursor.column,p.second.insertmode);
	}
	stack<string> effects;
	string closetitle,closetab;
	{
		sort(cursors.begin(),cursors.end(),[](auto &c1, auto &c2){return c1.column < c2.column;});
		unsigned column = cursors.size() > 0 ? cursors[0].column : (unsigned)-1;
		unsigned cursor_no = 0;
		unsigned pos=0;
		static float tb[]={1, 1.2, 1.5, 2, 2.5};
		if (para.listtype == LIST_BULLET){
			ret += string_f("<div class=bullet%u>&bull;</div><div class=tab%u-bullet>",para.tab_level,para.tab_level);
		}else if (para.listtype == LIST_NUM){
			unsigned num = 1;
			for (int i=noline-1; i >=0; i--){
				auto &l = lines[i];
				if (l.tab_level == para.tab_level && l.listtype == LIST_NUM){
					num++;
				}else if (l.tab_level <= para.tab_level){
					break;
				}
			}
			ret += string_f("<div class=bullet%u><span style=font-size:%1.2fem>%u.</span></div><div class=tab%u-bullet>"
				,para.tab_level,tb[para.get_title_level()],num,para.tab_level);
		}else if (para.listtype == LIST_CENTER){
			ret += "<div class=tab-center>";
		}else{
			ret += string_f("<div class=tab%u>",para.tab_level);
		}
		closetab = "</div>";
		bool format = true;
		if (para.is_title()){
			ret += string_f("<span style=font-size:%1.2fem;>",tb[para.get_title_level()]);
			closetitle = "</span>";
		}else if (para.is_image()){
			const char *url = str_skip(para.line.c_str());
			if (strchr(url,'<')==nullptr){
				// If the < character is there, which is illegal, we simply display the line (format=true)
				// We do some validation and if the <img tag is generated, then we set format=false
				if (cursors.size() > 0) ret += "<div class=imgcursor>";
				const char *project;
				if (is_start_any_ofnc(url,NONEED,"http://","https://")){
					ret += string_f("<img width=%u%% src=%s>",para.get_image_width(),url);
					format = false;
				}else if (is_start_any_of(gameid,project,"/projects")){
					// We are sure that gameid starts with /projects/, but we test it anyway
					// This is a file stored in the bolixo project
					// We extract the bolixo project from the gameid;
					const char *slash = strrchr(project,'/');
					if (slash != nullptr){
						// Now we have the project and sub-folder without the document name
						string path(project,slash-project);
						if (url[0] == '/'){
							auto sl = path.find(1,'/');
							if (sl != string::npos) path.resize(sl);
						}
						path += url;
						ret += string_f("<img width=%u%% src=/index.hc?webstep=5&image=/projects%s>"
							,para.get_image_width(),path.c_str());
						format = false;
					}
				}
				if (cursors.size() > 0) ret += "</div>";
			}
		}
				
		if (format){
			for (auto p=line.begin(); p!=line.end(); ){
				auto c = *p;
				if (c == CAR_START_EFFECT){
					// tlmp_warning ("Start effect");
					string effect;
					p++;
					while (p != line.end()){
						if (*p == ';'){
							p++;
							break;
						}else{
							effect += *p++;
						}
					}
					// tlmp_warning ("effect=%s",effect.c_str());
					if (effect == EFFECT_BOLD){
						ret += "<b>";
						effects.push("</b>");
					}else if (effect == EFFECT_ITALIC){
						ret += "<i>";
						effects.push("</i>");
					}else if (effect == EFFECT_UNDERLINE){
						ret += "<u>";
						effects.push("</u>");
					}else if (effect == EFFECT_SUP){
						ret += "<sup>";
						effects.push("</sup>");
					}else if (effect == EFFECT_SUB){
						ret += "<sub>";
						effects.push("</sub>");
					}else if (effect == EFFECT_FONT1){
						ret += "<span style=font-size:1.5em;>";
						effects.push("</span>");
					}
				}else if (is_any_of(c,CAR_END_EFFECT,CAR_END2_EFFECT)){
					// tlmp_warning ("effects.size()=%lu",effects.size());
					p++;
					ret += effects.top();
					effects.pop();
				}else{
					if (pos == column){
						const char *cursor=cursors[cursor_no].insertmode
							? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
						ret += cursor;
					}
					if (c == ' '){
						// The first space is passed as is so the browser knows there are multiple words
						// The extra spaces are changed to &nbsp; so they are not skipped by the browser
						if (p == line.begin()
							|| (p > line.begin() && p[-1] == ' ')){
							ret += "&nbsp;";
						}else{
							ret += ' ';
						}
						p++;
					}else if (c == '<'){
						ret += "&lt;";
						p++;
					}else if (c == '>'){
						ret += "&gt;";
						p++;
					}else if (c == '\\'){
						ret += "&bsol;";
						p++;
					}else if (c == '\''){
						ret += "&#39;";
						p++;
					}else{
						size_t sizecar = utf8_codepoint_size(c);
						while (sizecar > 0 && p != line.end()){
							ret += *p++;
							sizecar--;
						}
					}
					if (pos == column){
						ret += "</span>";
						cursor_no++;
						if (cursor_no < cursors.size()){
							column = cursors[cursor_no].column;
						}
					}
					pos++;
				}
			}
			if (pos <= column){
				while (cursor_no < cursors.size()){
					column = cursors[cursor_no].column;
					while (pos < column){
						pos++;
						ret += "&nbsp;";
					}
					const char *cursor=cursors[cursor_no].insertmode
						? "<span style=background-color:lightgray;>" : "<span style=background-color:lightpink;>";
					ret += string(cursor) + "&nbsp;</span>";
					cursor_no++;
				}
			}
		}
	}
	ret += closetitle + closetab;
	ret += "</div>";
	return ret;
}
/*
	Check if the line following noline are LIST_NUM. If this is the case, the line is added to updlines
*/
static void wordproc_update_num_lines (unsigned noline, const vector<WORDPROC_LINE> &lines, set<unsigned> &updlines)
{
	if (noline < lines.size()){
		unsigned tab_level = lines[noline].tab_level;
		for (unsigned i=noline+1; i<lines.size(); i++){
			auto &l = lines[i];
			if (l.tab_level == tab_level && l.listtype == LIST_NUM){
				updlines.insert(i);
			}else if (l.tab_level <= tab_level){
				break;
			}
		}
	}
}

/*
	Delete the character at the cursor
*/
void WORDPROC::deletechar (set<unsigned> &updlines, WORD_USERPREF &pref)
{
	if (lines.size() > pref.cursor.line){
		string &l = lines[pref.cursor.line].line;
		unsigned len = wordproc_linelen(l);
		if (len > pref.cursor.column){
			// We are inside the line, we remove the current character
			size_t sizecar;
			unsigned pos = wordproc_jump2col(l,pref.cursor.column,sizecar);
			if (sizecar > 0){
				l = l.substr(0,pos) + l.substr(pos+sizecar);
			}
		}else{
			unsigned nextline = pref.cursor.line+1;
			if (lines.size() > nextline){
				// We are at the end of the line, or further.
				// So we merge the previous line here.
				// First we grow the line
				while (len < pref.cursor.column){
					l += ' ';
					len++;
				}
				l += lines[nextline].line;
				lines.erase(lines.begin()+nextline);
				for (unsigned l=nextline; l<lines.size()+1; l++) updlines.insert(l);
			}
		}
		updlines.insert(pref.cursor.line);
	}
}
const unsigned tab_width=30;

/*
	Initialise the PARAGRAPH layout for the current session/display.
*/
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	unsigned column,	// paragraph cursor
	const DOC_UI_SPECS_receive &sp,	// Specs of the sessions
	unsigned &para_noline)	// line in the paragraph
{
	if (noline < lines.size()){
		auto &l = lines[noline];
		//long long start = fdpass_getnow();
		//for (int i=0; i<1; i++){
			para.init (l.line,sp.content_width-l.tab_level*tab_width,sp.fontsize);
			unsigned line_cursor;
			para.locate_cursor (column,para_noline,line_cursor);
		//}
		//long long end = fdpass_getnow();
		//long long diff = end - start;
		//tlmp_warning ("set_para_spec %Ld.%06Ld",diff/1000000,diff%1000000);
	}else{
		para_noline = 0;
		para.init ("",sp.content_width,sp.fontsize);
	}
}
void WORDPROC::set_para_spec(
	PARAGRAPH &para,
	unsigned noline,	// paragraph number (entry in lines[])
	const DOC_UI_SPECS_receive &sp)	// Specs of the sessions
{
	unsigned para_noline;
	set_para_spec (para,noline,0,sp,para_noline);
}
void WORDPROC::vmove (
	int move,
	unsigned visible_lines,		// How many <div> sent
	unsigned lastline,		// last line partially visible
	WORD_USERPREF &pref,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	set<unsigned> &updlines)
{
	if (pref.cursor.line < lines.size()){
		// Move inside a paragraph
		PARAGRAPH para;
		unsigned noline;
		set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
		unsigned nblines = para.get_nblines();
		unsigned x_pos = para.get_cursor_xpos();
		#if 0
		tlmp_warning ("vmove %d content_width=%u nblines=%u noline=%u line_cursor=%u column=%u"
			,move,spref.content_width,nblines,noline,line_cursor,pref.cursor.column);
		for (unsigned i=0; i<nblines; i++){
			tlmp_warning ("line %u: home=%u cursor=%u",i,para.line_homes[i],para.line_cursors[i]);
		}
		#endif
			
		updlines.insert(pref.cursor.line);
		if (move == -1){
			if (noline > 0){
				pref.cursor.column = para.get_para_cursor(noline-1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line > 0){
				set_para_spec (para,pref.cursor.line-1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(para.get_nblines()-1);
			}
		}else if (move == 1){
			if (noline < nblines -1){
				pref.cursor.column = para.get_para_cursor(noline+1);
				//tlmp_warning ("new column = %u",pref.cursor.column);
				return;
			}else if (pref.cursor.line < lines.size()-1){
				set_para_spec (para,pref.cursor.line+1,sp);
				para.locate_pixel (x_pos,0);
				pref.cursor.column = para.get_para_cursor(0);
			}else{
				pref.cursor.column = para.get_para_cursor(nblines-1);
			}
		}
	}
	if (move < 0 && abs(move) > pref.cursor.line) move = -pref.cursor.line;
	unsigned nextline = pref.cursor.line + move;
	if (nextline < pref.offset){
		// tlmp_warning ("vmove offset=%u visible_lines=%u lastline=%u",pref.offset,visible_lines,lastline);
		pref.offset--;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove last div
		script_var.val += "console.log('vmove length='+elms.length);\n";
		script_var.val += string_f("\tvar last=elms[%u];\n",visible_lines-1);
		script_var.val += "\tlast.parentNode.removeChild(last);\n";
		// Insert one at the top
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",pref.offset);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,elms[0]);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(pref.offset);
		updlines.insert(pref.offset+1);
	}else if (nextline >= pref.offset + lastline){
		pref.offset++;
		js_find_loop_start_class (script_var.val,"text","oneline");
		// Remove first div
		script_var.val += "\tvar first=elms[0];\n";
		script_var.val += "\tfirst.parentNode.removeChild(first);\n";
		// Add one at the end
		script_var.val += "\tvar newElement = document.createElement('div');\n";
		unsigned last_line = pref.offset + visible_lines - 1;
		script_var.val += string_f("\tnewElement.setAttribute('id', 'l%u');\n",last_line);
		script_var.val += "\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\tnewElement.innerHTML = '';\n";
		script_var.val += "\telm.insertBefore(newElement,null);\n";
		js_find_loop_end (script_var.val);
		updlines.insert(last_line-1);
		updlines.insert(last_line);
	}else{
		updlines.insert(pref.cursor.line);
		updlines.insert(nextline);
	}
	pref.cursor.line = nextline;
}
void WORDPROC::page_up_down(
	int new_offset, 
	unsigned visible_lines,
	unsigned lastline,
	WORD_USERPREF &pref,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	set<unsigned> &notify_lines)
{
	if (new_offset < 0) new_offset = 0;
	if ((unsigned)new_offset != pref.offset){
		int offline = pref.cursor.line - pref.offset;
		if (offline < 0) offline = 0;
		js_find_loop_start (script_var.val,"text","div");
		// Remove all div
		script_var.val += "\telm.innerHTML='';\n";
		// Add new ones
		script_var.val += string_f("\tfor (var i=0; i<%u; i++){\n",visible_lines);
		script_var.val += "\t\tvar newElement = document.createElement('div');\n";
		script_var.val += string_f("\t\tvar id='l'+(%u+i);\n",new_offset);
		script_var.val += "\t\tnewElement.setAttribute('id', id);\n";
		script_var.val += "\t\tnewElement.setAttribute('class', 'oneline');\n";
		script_var.val += "\t\tnewElement.innerHTML = '';\n";
		script_var.val += "\t\telm.insertBefore(newElement,null);\n";
		script_var.val += "\t}\n";
		js_find_loop_end (script_var.val);
		for (unsigned i=0; i<visible_lines; i++) script_lines.insert(new_offset+i);
		notify_lines.insert(pref.cursor.line);
		if (pref.cursor.line < (unsigned)new_offset
			|| pref.cursor.line >= new_offset + lastline){
			pref.cursor.line = new_offset+offline;
		}
		notify_lines.insert(pref.cursor.line);
		pref.offset = new_offset;
	}
}
void WORDPROC::update_lines (string &script, set<unsigned> &updlines)
{
	if (updlines.size() > 0){
		js_find_loop_start_class(script,"text","oneline");
		script += "\t\tfor (var i=0; i<elms.length; i++){\n";	
		script += "\t\t\tvar e=elms[i];\n";
		unsigned nol = 0;
		for (auto l:updlines){
			const char *elseverb = nol==0 ? "" : "}else ";
			string id=string_f("l%u",l);
			script += string_f("\t\t\t%sif(e.id=='l%u'){\n",elseverb,l);
			script += string_f("\t\t\t\te.innerHTML = '%s';\n",formatline(l).c_str());
			if (nol == updlines.size()-1){
				script += "\t\t\t\tbreak;\n";
				script += "\t\t\t}\n";
			}
			nol++;
		}
		script += "\t\t}\n";
		js_find_loop_end(script);
	}
}
void WORDPROC::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	tlmp_error ("WORDPROC::exec called");
}
void WORDPROC::execstep (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	set<unsigned> &script_lines,
	VARVAL &notify_var,
	set<unsigned> &notify_lines,
	vector<VARVAL> &res)
{
	auto &pref = prefs[username];
	pref.maywrite = maywrite;
	unsigned visible_lines = 60;
	if (sp.content_height != 0 && sp.fontsize != 0) visible_lines = sp.content_height/sp.fontsize + 10;
	//tlmp_warning ("visible_lines=%u content_height=%u fontsize=%u",visible_lines,sp.content_height,sp.fontsize);
	// Force visible_lines to 60 because the specs are not always available, for now
	//visible_lines = 60;
	if (strcmp(var,"print")==0){
		if (strcmp(val,"console")==0){
			VARVAL v;
			v.var = VAR_CONTENT;
			unsigned line = 0;
			const char cursor = pref.insertmode ? '^' : '_';
			for (auto &ll:lines){
				auto &l = ll.line;
				if (line == pref.cursor.line){
					if (l.size() > pref.cursor.column){
						v.val += l.substr(0,pref.cursor.column) + cursor + l.substr(pref.cursor.column) + "|\n";
					}else{
						v.val += l;
						for (unsigned i=l.size(); i<pref.cursor.column; i++) v.val += '.';
						v.val += cursor;
						v.val += "|\n";
					}
				}else{
					v.val += l + "|\n";
				}
				line++;
			}
			res.emplace_back(v);
		}else{
			unsigned width = sp.content_width;
			VARVAL v;
			v.var = VAR_CONTENT;


			{
				unsigned sp_width = width-30;	// Space for line numbers, during development
				v.val += "<style>\n";
				v.val += ".imgcursor{\n";
				v.val += "\tborder:2px solid lightgray;\n";
				v.val += "}\n";

				v.val += ".onecol, .oneline{\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += "}\n";

				v.val += ".oneline .col{\n";
				v.val += "\tdisplay:flex;\n";
				v.val += "\tflex-flow:row;\n";
				v.val += "}\n";

				v.val += ".tab-center{\n";
				v.val += "\ttext-align:center;\n";
				v.val += "\toverflow-wrap: break-word;\n";
				v.val += "\tflex:0 1 auto;\n";
				v.val += string_f("\twidth:%u;\n",sp_width);
				v.val += "}\n";

				const unsigned bullet_width=15+5;
				//unsigned offsets[]={5,tab_width-15,2*tab_width-15,3*tab_width-15};
				for (unsigned i=0; i<4; i++){
					v.val += string_f(".bullet%u{\n",i);
					v.val += "\tflex:0 1 auto;\n";
					v.val += "\twidth:10;\n";
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width+5);
					v.val += "\tmargin-right:5;\n";
					v.val += "}\n";
					v.val += string_f(".tab%u{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("\twidth:%u;\n",sp_width-i*tab_width);
					v.val += string_f("\tmargin-left:%u;\n",i*tab_width);
					v.val += "\tfont-family:'Lucida Console';\n";
					v.val += "}\n";
					v.val += string_f(".tab%u-bullet{\n",i);
					v.val += "\toverflow-wrap: break-word;\n";
					v.val += "\tflex:0 1 auto;\n";
					v.val += string_f("\twidth:%u;\n",sp_width-i*tab_width-bullet_width);
					v.val += "\tmargin-left:0;\n";
					v.val += "\tfont-family:'Lucida Console';\n";
					v.val += "}\n";
				}
			}
			v.val += "</style>\n";

			// event.location==1 tells if this is the left shift/alt key or right. We are not using it now
			v.val += "<script>\n";
			// Function find the last visible line on screen
			v.val += "function getlastline(){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			//v.val += "\tconsole.log('getlastline length='+elms.length);\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar srect = elms[i].getBoundingClientRect();\n";
			//v.val += "\t\tconsole.log('i='+i+' rect.bottom='+rect.bottom+' srect.bottom='+srect.bottom);\n";
			v.val += "\t\tif (rect.bottom < srect.bottom){\n";
			v.val += "\t\t\treturn i;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Function called when the user click
			v.val += "function gameselect(event){\n";
			v.val += string_f("\tvar elm = document.getElementById('text-%s');\n",gameid.c_str());
			v.val += "\tvar elms = elm.getElementsByClassName('oneline');\n";
			v.val += "\tfor (var i=0; i<elms.length; i++){\n";
			v.val += "\t\tvar para= elms[i];\n";
			v.val += "\t\tvar rect = para.getBoundingClientRect();\n";
			v.val += "\t\tif (event.clientY >= rect.top && event.clientY < rect.bottom){\n";
			v.val += "\t\t\tvar divs=para.getElementsByTagName('div');\n";
			v.val += "\t\t\tvar r=divs[divs.length-1].getBoundingClientRect();\n";
			v.val += "\t\t\tgameaction('select:'+i+' '+(event.clientX-r.left)+' '+(event.clientY-r.top)+' '+getlastline());\n";
			v.val += "\t\t\tbreak;\n";
			v.val += "\t\t}\n";
			v.val += "\t}\n";
			v.val += "}\n";
			// Function called when the user uses the keyboard
			v.val += "var gamekey=null;\n";
			v.val += "var gamecode=null;\n";
			v.val += "var altKey=null;\n";
			v.val += "var ctrlKey=null;\n";
			v.val += "var shiftKey=null;\n";

			v.val += "function gamepress(event){\n";
			v.val += "\tconsole.log ('press key='+event.key+' '+' code='+event.code+' '+event.altKey+' '+event.ctrlKey+' '+event.shiftKey);\n";
			v.val += "\tgamekey=event.key;\n";
			v.val += "\tgamecode=event.code;\n";
			v.val += "\taltKey=event.altKey;\n";
			v.val += "\tctrlKey=event.ctrlKey;\n";
			v.val += "\tshiftKey=event.shiftKey;\n";
			//v.val += "\tif (gamecode.substring(0,3)!='Key' && gamekey != 'Dead' && gamekey != 'Process'){\n";
			v.val += "\tgameaction('kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			//v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			v.val += "function funcinput(event){\n";
			v.val += "\tif (event.data == null) gamekey=event.data;\n";
			v.val += "\tgameaction('kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			v.val += "\tconsole.log('kbd:'+gamecode + ' ' + gamekey+' '+altKey+' '+ctrlKey+' '+shiftKey+' '+getlastline());\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			v.val += "function gamefalse(event){\n";
			//v.val += "\tconsole.log ('gamefalse type='+event.type+' data='+event.data);\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\treturn false;\n";
			v.val += "}\n";
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				#define BUTTON_TITLE_PLUS	0
				#define BUTTON_TITLE_LESS	1
				#define BUTTON_TAB_PLUS		3
				#define BUTTON_TAB_LESS		4
				#define BUTTON_BULLET		5
				#define BUTTON_NUMLIST		6
				#define BUTTON_BOLD		7
				#define BUTTON_ITALIC		8
				#define BUTTON_UNDERLINE	9
				#define BUTTON_SUP		10
				#define BUTTON_SUB		11
				#define BUTTON_CENTER		12
				#define BUTTON_IMAGE		13
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				documentd_button_start(v.val,gameid);
				documentd_button (v.val,BUTTON_TITLE_PLUS,"T",specs,false);
				documentd_button (v.val,BUTTON_TITLE_LESS,"t",specs,false);
				documentd_button (v.val,BUTTON_BOLD,"<b>B</b>",specs,false);
				documentd_button (v.val,BUTTON_ITALIC,"<i>I</i>",specs,false);
				documentd_button (v.val,BUTTON_UNDERLINE,"<u>U</u>",specs,false);
				documentd_button (v.val,BUTTON_SUP,"A<sup>2</sup>",specs,false);
				documentd_button (v.val,BUTTON_SUB,"A<sub>2</sub>",specs,false);
				documentd_button (v.val,BUTTON_TAB_PLUS,"->",specs,false);
				documentd_button (v.val,BUTTON_TAB_LESS,"<-",specs,false);
				documentd_button (v.val,BUTTON_CENTER,"<>",specs,false);
				documentd_button (v.val,BUTTON_BULLET,"&bull;",specs,false);
				documentd_button (v.val,BUTTON_NUMLIST,"N.",specs,false);
				documentd_button (v.val,BUTTON_IMAGE,"_",specs,false);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Document
			v.val += "<div class=webtable id=doc_wordproc style='display:flex; flex-flow:row;'>\n";
			v.val += string_f("<div id='text-%s' onkeydown=gamepress(event) oninput=funcinput(event) onclick=gameselect(event)"
				//" contenteditable"
				" spellcheck"
				" tabindex=0 style='flex:0 0 auto; overflow: hidden; margin-right:%u; width:%u'"
				" style='font-family=\"Lucida Console\";'>\n",gameid.c_str(),10,width);
			unsigned line = 0;
			if (pref.offset < lines.size()){
				for (auto p=lines.begin()+pref.offset; p != lines.end() && line < visible_lines; p++){
					unsigned doc_line = line+pref.offset;
					v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
						,formatline(doc_line).c_str());
					line++;
				}
			}
			for (; line<visible_lines; line++){
				static string empty;
				unsigned doc_line = line+pref.offset;
				v.val += string_f("<div class=oneline id=l%u>%s</div>\n",doc_line
					,formatline(doc_line).c_str());
			}
			v.val += "</div>\n";
			v.val += "</div>\n";
			#if 0
			v.val += "<script>\n";
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionstart', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionupupdate', gamefalse);\n",gameid.c_str());
			v.val += string_f("document.getElementById('text-%s').addEventListener('compositionend', gamefalse);\n",gameid.c_str());
			v.val += "</script>\n";
			#endif
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += "&nbsp;";
			#if 0
				// Trick to make the document window shorter
				for (int i=0; i<25; i++) v.val += "allo<br>\n";
			#endif
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else{
		struct {
			bool ctrl = false;
			bool shift = false;
			bool alt = false;
		} mod;
		unsigned lastline = 1000;
		if (strcmp(var,"kbd")==0){
			if (is_start_any_of(var,NONEED,"kbd")){
				vector<string> tb;
				int n = str_splitline(val,' ',tb);
				//tlmp_warning ("n=%d val=%s",n,val);
				if (n == 5 && is_any_of(tb[0],"Space")){
					var = "insertchar";
					val = " ";
					lastline = atoi(tb[4].c_str());
				}else if (n != 6){
					// Do nothing
				}else{
					lastline = atoi(tb[5].c_str());
					mod.alt = tb[2] == "true";
					mod.ctrl = tb[3] == "true";
					mod.shift = tb[4] == "true";
					const char *tb0 = tb[0].c_str();
					const char *tb1 = tb[1].c_str();
					if (is_any_of(tb0,"Enter","NumpadEnter")){
						var = "break";
					}else if (is_any_of(tb0,"NumpadDecimal")){
						if (tb[1] == "Delete"){
							var = "deletechar";
						}else{
							var = "insertchar";
							val = tb1;
						}
					}else if (is_start_any_of(tb0,NONEED,"Numpad")){
						if (tb[1].size()==1){
							var = "insertchar";
							val = tb1;
						}else if (strcmp(tb1,"Home")==0){
							var = "home";
						}else if (strcmp(tb1,"End")==0){
							var = "end";
						}else if (strcmp(tb1,"ArrowLeft")==0){
							var = "hmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowRight")==0){
							var = "hmove";
							val = "1";
						}else if (strcmp(tb1,"ArrowUp")==0){
							var = "vmove";
							val = "-1";
						}else if (strcmp(tb1,"ArrowDown")==0){
							var = "vmove";
							val = "1";
						}else if (strcmp(tb1,"Insert")==0){
							var = "insertmode";
						}else if (strcmp(tb1,"PageUp")==0){
							var = "pageup";
						}else if (strcmp(tb1,"PageDown")==0){
							var = "pagedown";
						}
					}else if (is_start_any_of(tb0,NONEED,"Key","Digit","Slash","Period"
						,"Comma","Quote","Backslash","Minus","Equa","Bracket","Backquote","Semicolon")){
						var = "insertchar";
						val = tb1;
					}else if (is_any_of(tb0,"Insert")){
						var = "insertmode";
					}else if (is_any_of(tb0,"Delete")){
						var = "deletechar";
					}else if (is_any_of(tb0,"Home")){
						var = "home";
					}else if (is_any_of(tb0,"End")){
						var = "end";
					}else if (is_any_of(tb0,"ArrowUp")){
						var = "vmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowDown")){
						var = "vmove";
						val = "1";
					}else if (is_any_of(tb0,"ArrowLeft")){
						var = "hmove";
						val = "-1";
					}else if (is_any_of(tb0,"ArrowRight")){
						var = "hmove";
						val = "1";
					}else if (is_any_of(tb0,"Backspace")){
						var = "backspace";
					}else if (is_any_of(tb0,"PageUp")){
						var = "pageup";
					}else if (is_any_of(tb0,"PageDown")){
						var = "pagedown";
					}
				}
				// tlmp_warning ("kbd: var=%s val=%s lastline=%u",var,val,lastline);
			}
		}
		if (maywrite){
			if (strcmp(var,"insertmode")==0){
				pref.insertmode = !pref.insertmode;
				notify_lines.insert(pref.cursor.line);
			}else if (strcmp(var,"insertchar")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				auto &wl = lines[pref.cursor.line];
				string &l = wl.line;
				while (wordproc_linelen(l) < pref.cursor.column) l += ' ';
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				bool update_num_lines = false;
				if (strcmp(val,"b")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (strcmp(val,"f")==0 && mod.alt){
					wordproc_insert_effect (l,pos,EFFECT_FONT1);
				}else if (strcmp(val,">")==0 && mod.alt){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (strcmp(val,"<")==0 && mod.alt){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (strcmp(val,"t")==0 && mod.alt){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"T")==0 && mod.alt){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (strcmp(val,"l")==0 && mod.alt){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (strcmp(val,"L")==0 && mod.alt){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (strcmp(val,"z")==0 && mod.alt){
					if (lines.size()==1 && lines[0].line.size()==0){
						// Fill with many lines
						resetgame();
						string para;
						para = "allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<2; i++) para += " allo comment ca va le monde et toi et encore et encore et encore";
						for (unsigned i=0; i<100; i++) lines.push_back(string_f("line %lu:",lines.size())+para);
					}else{
						resetgame();
					}
					documentd_forcerefresh (res);
				}else{
					l.insert(pos,val);
					pref.cursor.column ++;
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.insert(pref.cursor.line);
			}else if (strcmp(var,"break")==0){
				while (lines.size() <= pref.cursor.line) lines.emplace_back(WORDPROC_LINE());
				auto &para = lines[pref.cursor.line];
				string &l = para.line;
				auto nextline = lines.begin() + (pref.cursor.line+1);
				unsigned pos = l.size();
				if (wordproc_linelen(l) > pref.cursor.column){
					pos = wordproc_jump2col(l,pref.cursor.column);
				}
				{
					// We have to transport the active effects to the next line.
					// effects started after pos are simply copied
					vector<string> effects;
					wordproc_current_effects (l,pos,effects);
					WORDPROC_LINE newl;
					tlmp_warning ("break effects.size()=%lu",effects.size());
					for (auto &e:effects){
						tlmp_warning ("break insert %s",e.c_str());
						newl.line += string_f("%c%s;",CAR_START_EFFECT,e.c_str());
					}
					newl.line += l.substr(pos);
					if (para.std_paragraph()){
						newl.listtype = para.listtype;
						newl.tab_level = para.tab_level;
					}
					lines.insert(nextline,newl);
					lines[pref.cursor.line].line.resize(pos);
					for (unsigned i=0; i<effects.size(); i++) lines[pref.cursor.line].line += CAR_END_EFFECT;
				}
				for (unsigned l=pref.cursor.line; l<lines.size(); l++) notify_lines.insert(l);
				pref.cursor.line++;
				pref.cursor.column=0;
			}else if (strcmp(var,"backspace")==0){
				notify_lines.insert(pref.cursor.line);
				// We start by moving the cursor back one character if possible.
				// If we are at the start of a line, we go at the end of the previous line.
				// We do a deletechar after that
				if (pref.cursor.column > 0){
					pref.cursor.column--;
					deletechar(notify_lines,pref);
				}else if (pref.cursor.line > 0){
					pref.cursor.line--;
					pref.cursor.column=0;
					if (lines.size() > pref.cursor.line){
						string &l = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(l);
						pref.cursor.column = len;
					}
					notify_lines.insert(pref.cursor.line);
					deletechar(notify_lines,pref);
				}
			}else if (strcmp(var,"deletechar")==0){
				deletechar(notify_lines,pref);
			}else if (strcmp(var,"voffset")==0){
				// Change page up or down
				int move = atoi(val);
				if (move > 0){
					pref.offset += move;
				}else{
					if ((unsigned)-move > pref.offset){
						pref.offset = 0;
					}else{
						pref.offset += move;
					}
				}
			}else if (strcmp(var,"vmove")==0){
				// Move cursor
				int move = atoi(val);
				unsigned current_line = pref.cursor.line;
				vmove (move,visible_lines,lastline,pref,sp,script_var,script_lines);
				if (current_line != pref.cursor.line){
					notify_lines.insert(current_line);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				page_up_down(new_offset,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else if (strcmp(var,"hmove")==0){
				int move = atoi(val);
				if (pref.cursor.line < lines.size() && lines[pref.cursor.line].is_image()){
					auto &para = lines[pref.cursor.line];
					unsigned rep = mod.ctrl ? 10 : 1;
					for (unsigned i=0; i<rep; i++){
						if (move < 0){
							para.decrease_image_width();
						}else{
							para.increase_image_width();
						}
					}
					notify_lines.insert(pref.cursor.line);
				}else if (move < 0){
					if (pref.cursor.column == 0){
						if (pref.cursor.line > 0){
							notify_lines.insert(pref.cursor.line);
							vmove (-1,visible_lines,lastline,pref,sp,script_var,script_lines);
							if (lines.size() > pref.cursor.line){
								pref.cursor.column = wordproc_linelen(lines[pref.cursor.line].line);
							}
							notify_lines.insert(pref.cursor.line);
						}
							
					}else{
						if (pref.cursor.line < lines.size() && mod.ctrl){
							// skip word back
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							if (pref.cursor.column > len){
								pref.cursor.column = len;
							}else{
								// First, skip spaces
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] != ' ') break;
									pref.cursor.column--;
								}
								// Then skip word
								while (pref.cursor.column > 0){
									unsigned pos = wordproc_jump2col (line, pref.cursor.column);
									if (line[pos] == ' ') break;
									pref.cursor.column--;
								}
							}
						}else{
							pref.cursor.column += move;
						}
						notify_lines.insert(pref.cursor.line);
					}
				}else{
					if (pref.cursor.line < lines.size() && mod.ctrl){
						// skip word
						auto &line = lines[pref.cursor.line].line;
						unsigned len = wordproc_linelen(line);
						if (pref.cursor.column >= len){
							pref.cursor.column++;
						}else{
							// First, skip spaces
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] != ' ') break;
								pref.cursor.column++;
							}
							// Then skip word
							while (pref.cursor.column < len){
								unsigned pos = wordproc_jump2col (line, pref.cursor.column);
								if (line[pos] == ' ') break;
								pref.cursor.column++;
							}
						}
					}else{
						pref.cursor.column += move;
					}
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"home")==0){	// KEY home
				if (pref.cursor.column != 0){
					PARAGRAPH para;
					unsigned noline;
					set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
					tlmp_warning ("HOME noline=%u",noline);
					pref.cursor.column = para.get_para_home(noline);
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"end")==0){	// KEY end
				PARAGRAPH para;
				unsigned noline;
				set_para_spec (para,pref.cursor.line,pref.cursor.column,sp,noline);
				unsigned column = para.get_para_end(noline);
				tlmp_warning ("END noline=%u",noline);
				if (column != pref.cursor.column){
					pref.cursor.column = column;
					notify_lines.insert(pref.cursor.line);
				}
			}else if (strcmp(var,"select")==0){	// Position cursor using the mouse
				vector<string> tb;
				//tlmp_warning ("select=%s",val);
				int n = str_splitline(val,' ',tb);
				if (n == 4){
					unsigned noline = atoi(tb[0].c_str());
					if (noline < visible_lines){
						unsigned newline = pref.offset + noline;
						if (newline != pref.cursor.line){
							notify_lines.insert(pref.cursor.line);
							pref.cursor.line = newline;
						}
						// We have to figure out where 
						if (pref.cursor.line < lines.size()){
							unsigned xcoor = atoi(tb[1].c_str());
							unsigned ycoor = atoi(tb[2].c_str());
							PARAGRAPH para;
							set_para_spec (para,pref.cursor.line,sp);
							para.locate_pixel (xcoor,ycoor,noline);
							pref.cursor.column = para.get_para_cursor(noline);
							#if 0
							auto &line = lines[pref.cursor.line].line;
							unsigned len = wordproc_linelen(line);
							unsigned xpos = 0;
							for (unsigned i=0; i<len; i++){
								// We have to compute the length of every character in the line
								#if 0
								size_t sizecar;
								unsigned pos = wordproc_jump2col(line,i,sizecar);
								#endif
								// assume a fixed length for now
								unsigned width=10;
								xpos += width;
								if (xpos  > xcoor){
									pref.cursor.column = i;
									break;
								}
							}
							#endif
						}
						notify_lines.insert(pref.cursor.line);
					}
				}
			}else if (strcmp(var,"newgame")==0){
				while (lines.size() <= pref.cursor.line) lines.push_back("");
				unsigned uval = atoi(val);
				bool update_num_lines = false;
				auto &wl = lines[pref.cursor.line];
				auto &l = wl.line;
				unsigned pos = wordproc_jump2col(l,pref.cursor.column);
				if (uval == BUTTON_TAB_PLUS){
					if (wl.tab_level < 4) wl.tab_level++;
					update_num_lines = true;
				}else if (uval == BUTTON_TAB_LESS){
					if (wl.tab_level > 0) wl.tab_level--;
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_PLUS){
					wl.increase_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_TITLE_LESS){
					wl.decrease_title_level();
					update_num_lines = true;
				}else if (uval == BUTTON_BULLET){
					if (wl.listtype == LIST_BULLET){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_BULLET;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_NUMLIST){
					if (wl.listtype == LIST_NUM){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_NUM;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_CENTER){
					if (wl.listtype == LIST_CENTER){
						wl.listtype = LIST_NONE;
					}else{
						wl.listtype = LIST_CENTER;
					}
					update_num_lines = true;
				}else if (uval == BUTTON_BOLD){
					wordproc_insert_effect (l,pos,EFFECT_BOLD);
				}else if (uval == BUTTON_ITALIC){
					wordproc_insert_effect (l,pos,EFFECT_ITALIC);
				}else if (uval == BUTTON_UNDERLINE){
					wordproc_insert_effect (l,pos,EFFECT_UNDERLINE);
				}else if (uval == BUTTON_SUP){
					wordproc_insert_effect (l,pos,EFFECT_SUP);
				}else if (uval == BUTTON_SUB){
					wordproc_insert_effect (l,pos,EFFECT_SUB);
				}else if (uval == BUTTON_IMAGE){
					if (wl.is_image()){
						wl.set_image(false);
						update_num_lines = true;
					}else if (wl.std_paragraph()){
						wl.set_image(true);
						update_num_lines = true;
					}
				}
				if (update_num_lines) wordproc_update_num_lines (pref.cursor.line,lines,notify_lines);
				notify_lines.insert(pref.cursor.line);
				script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
			}
			setmodified(username);
		}else{
			if (strcmp(var,"vmove")==0){
				// Vertical arrows are producing scrolls in read only mode.
				int move = atoi(val);
				if (move < 0){
					pref.cursor.line = pref.offset;
				}else{
					pref.cursor.line = pref.offset + visible_lines - 1;
				}
				vmove (move,visible_lines,lastline,pref,sp,script_var,script_lines);
			}else if (is_any_of(var,"pageup","pagedown")){
				int new_offset = strcmp(var,"pageup")==0 ? pref.offset-lastline : pref.offset + lastline;
				set<unsigned> notify_lines;
				page_up_down (new_offset,visible_lines,lastline,pref,script_var,script_lines,notify_lines);
			}else{
				documentd_error (res,MSG_R(E_READONLY));
			}
			res.emplace_back(script_var);
		}
	}
	if (0){
		string tmp;
		for (auto &v:res) tmp += string_f(" %s=%lu",v.var.c_str(),v.val.size());
		tlmp_warning (tmp.c_str());
	}
}
void WORDPROC::manyexec (
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	setactivity();
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	set<unsigned> script_lines;	// Lines to update using SCRIPT (Private to this user)
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	set<unsigned> notify_lines;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,session,username,maywrite,sp,script_var,script_lines,notify_var,notify_lines,res);
	}
	#if 0
	size_t script_size = script_var.val.size();
	size_t notify_size = notify_var.val.size();
	#endif
	update_lines (script_var.val,script_lines);
	update_lines (notify_var.val,notify_lines);
	#if 0
	tlmp_warning ("manyexec steps=%lu stats script_size=%lu -> %lu notify_size=%lu -> %lu script_lines=%lu notify_lines=%lu"
		,steps.size(),script_size,script_var.val.size(),notify_size,notify_var.val.size(),script_lines.size(),notify_lines.size());
	#endif
	res.emplace_back(notify_var);
	res.emplace_back(script_var);
}

