/*
	Command line tool to manipulate the bolixo filesystem. The program works
	like normal Linux commands. It is general. For example, it
		-can copy from bolixo to bolixo
		-bolixo to linux
		-linux to bolixo
		-linux to linux

	bofs cp ...
	bofs ls

	Further, if the program is renamed bocp (normally done using a symlink), it acts as "bofs cp"
*/
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <vector>
#include <trlitool.h>
#include "bolixo.h"

using namespace std;

#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED

#define bod_client_addfile_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_readfile_NOTNEED

#include "proto/bod_client.protoch"

#define webapi_test_NOTNEED
#define webapi_addfile_NOTNEED
#define webapi_addfile_bob_NOTNEED
#define webapi_appendfile_NOTNEED
#define webapi_delfile_NOTNEED
#define webapi_modifyfile_NOTNEED
#define webapi_modifyfile_bob_NOTNEED
#define webapi_rename_NOTNEED
#define webapi_copy_NOTNEED
#define webapi_readfile_NOTNEED
#define webapi_readfile_bob_NOTNEED
#define webapi_readmore_NOTNEED
#define webapi_mkdir_NOTNEED
#define webapi_rmdir_NOTNEED
#define webapi_set_access_NOTNEED
#define webapi_markview_NOTNEED
#include "proto/webapi.protoch"

static void bofs_maxlen (const char *s, unsigned &max_s)
{
	unsigned len = strlen(s);
	if (len > max_s) max_s = len;
}
<mod>
static string bod_createsession(CONNECT_INFO &con)
{
	glocal string ret;
	<call bod_client_createsession>(con);
	<f ok>
		glocal.ret = sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>

static void bofs_error (const char *cmd, bool internal_error, const char *msg, ...)
{
	va_list list;
	va_start (list,msg);
	char buf[1000];
	vsnprintf (buf,sizeof(buf)-1,msg,list);
	va_end (list);	
	if (internal_error){
		tlmp_error ("bofs %s: Internal/protocol error, %s\n",cmd,buf);
	}else{
		tlmp_error ("bofs %s: %s\n",cmd,buf);
	}
}

<mod>
static int bofs_login (
	CONNECT_INFO &con,
	PARAM_STRING email,
	PARAM_STRING password,
	string &sessionid)	// Session ID for the internal protocol
{
	glocal int ret = 0;
	glocal const char *email = email.ptr;
	if (con.port.size() > 0){
		sessionid = bod_createsession(con);
		<call bod_client_login>(con,sessionid,email,password);
		<f ok>
			if (!success){
				glocal.ret = -1;
				bofs_error ("login",internal_error,"login failed for %s success=%d",glocal.email,success);
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>
<mod>
static int bofs_login (
	CONNECT_HTTP_INFO &hcon,
	PARAM_STRING email,
	PARAM_STRING password,
	string &hsessionid)	// For HTTPS protocol
{
	glocal string *hsessionid = &hsessionid;
	glocal int ret = 0;
	glocal const char *email = email.ptr;
	if (hcon.host.size() > 0){
		<call webapi_login>(hcon,email,password);
		<f ok>
			if (success){
				(*glocal.hsessionid) = sessionid;
			}else{
				bofs_error ("login",internal_error,"http login failed for %s success=%d",glocal.email,success);
				glocal.ret = -1;
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>
<mod>
static void bofs_logout (CONNECT_INFO &con, const PARAM_STRING sessionid)
{
	if (con.port.size() > 0){
		<call bod_client_logout>(con,sessionid);
		<f ok>
		</f>
		</call>
	}
}
</mod>
<mod>
static void bofs_logout (CONNECT_HTTP_INFO &hcon, const PARAM_STRING hsessionid)
{
	if (hcon.host.size() > 0){
		<call webapi_logout>(hcon,hsessionid);
		<f ok>
		</f>
		</call>
	}
}
</mod>

struct CONTEXT{
	string email;
	string password;
	string sessionid;	// Session ID for the internal protocol
	string hsessionid;	// Session ID for the https protocol
	string threshold;	// Date to filter in the history of a directory or files
	CONNECT_INFO con;
	CONNECT_INFO con_sess;
	CONNECT_HTTP_INFO hcon;
	~CONTEXT(){
		if (sessionid.size()>0) bofs_logout(con,sessionid);
		if (hsessionid.size()>0) bofs_logout(hcon,hsessionid);
	}
	int login(){
		int ret = -1;
		if (sessionid.size()>0){
			ret = 0;
		}else{
			ret = bofs_login (con,email,password,sessionid);
			if (ret == -1) tlmp_error ("bod_login failed\n");
		}
		return ret;
	}
	int hlogin(){
		int ret = -1;
		if (hsessionid.size()>0){
			ret = 0;
		}else{
			ret = bofs_login (hcon,email,password,hsessionid);
			if (ret == -1) tlmp_error ("bod_login failed\n");
		}
		return ret;
	}
	bool is_internal(){
		return con.port.size() > 0;
	}
	
};

#define _TLMP_bofs_split
struct _F_bofs_split {
	#define _F_bofs_split_bo_file(x) int x bo_file(const char *path)
	virtual _F_bofs_split_bo_file( );
	#define _F_bofs_split_https_file(x) int x https_file(const char *path, const char *host, const char *port, bool use_ssl)
	virtual _F_bofs_split_https_file( );
	#define _F_bofs_split_local_file(x) int x local_file(const char *path)
	virtual _F_bofs_split_local_file( );
};

int _F_bofs_split::bo_file(const char *path)
{
	tlmp_error ("Bolixo file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::https_file(const char *path, const char *host, const char *port, bool use_ssl)
{
	tlmp_error ("Https file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::local_file(const char *path)
{
	tlmp_error ("Local file %s not processed\n",path);
	return -1;
}

static int bofs_splithttp (const char *line, string &host, string &port, string &path)
{
	int ret = -1;
	// Line starts after the //
	const char *pt = strchr(line,'/');
	if (pt != NULL){
		ret = 0;
		path = pt;
		host = string(line,pt-line);
		size_t pos = host.find(':');
		if (pos != string::npos){
			port = host.substr(pos+1);
			host = host.substr(0,pos);
		}
	}
	return ret;
}
	
	
static int bofs_split (_F_bofs_split &c, int argc, char *argv[])
{
	int ret = 0;
	for (int i=0; ret == 0 && i<argc; i++){
		const char *arg = argv[i];
		if (strncmp(arg,"bo://",5)==0){
			ret = c.bo_file (arg+4);
		}else if (strncmp(arg,"https://",8)==0){
			string host,port,path;
			if (bofs_splithttp(arg+8,host,port,path)==-1){
				ret = -1;
			}else{
				ret = c.https_file (path.c_str(),host.c_str(),port.c_str(),true);
			}
		}else if (strncmp(arg,"http://",7)==0){
			string host,port,path;
			if (bofs_splithttp(arg+7,host,port,path)==-1){
				ret = -1;
			}else{
				ret = c.https_file (path.c_str(),host.c_str(),port.c_str(),false);
			}
		}else{
			ret = c.local_file (arg);
		}
	}
	return ret;
}

<mod>
static int bofs_stat (
	CONTEXT &ctx,
	PARAM_STRING _path,
	bool is_https,
	string &parent,
	FILEINFO &file)
{
	glocal int ret = 0;
	glocal FILEINFO *file = &file;
	const char *path = _path.ptr;
	parent.clear();
	file.clear();
	if (path[0] != '/'){
		tlmp_error ("bofs_stat: Invalid path %s\n",path);
		glocal.ret = -1;
	}else if (strcmp(path,"/")==0){
		file.type = ENTRY_DIR;
	}else{
		string dir;
		string filename;
		const char *pt = strrchr(path,'/');
		if (pt == path){
			dir = "/";
			filename = path+1;
		}else{
			dir = string (path,pt-path);
			filename = pt+1;
		}
		parent = dir;
		file.name = filename;
		//tlmp_error ("bofs_stat: dir=%s file=%s\n",glocal.dir.c_str(),glocal.file.c_str());
		glocal.ret = -1;
		if (is_https){
			<call webapi_stat> (ctx.hcon,ctx.hsessionid,path,ctx.threshold);
			<f ok>
				if (success){
					glocal.ret = 0;
					(*glocal.file) = file;
				}else{
					// A missing file is not an error.
					// bofs_error ("stat",internal_error,"Can't stat bolixo file %s: %s",glocal.file->name.c_str(),msg);
				}
			</f>
			</call>
		}else{
			<call bod_client_stat> (ctx.con,ctx.sessionid,path,ctx.threshold);
			<f ok>
				if (success){
					glocal.ret = 0;
					(*glocal.file) = file;
				}else{
					// A missing file is not an error.
					// bofs_error ("stat",internal_error,"Can't stat bolixo file %s: %s",glocal.file->name.c_str(),msg);
				}
			</f>
			</call>
		}
	}
	return glocal.ret;
}
</mod>

static int bofs_stat (
	CONTEXT &ctx,
	PARAM_STRING _path,
	bool is_https,
	ENTRY_TYPE &type)
{
	FILEINFO file;
	string parent;
	int ret = bofs_stat (ctx,_path,is_https,parent,file);
	type = file.type;
	return ret;
}
static char tbtype[]={' ','_','D','F','M','C'};
static char tbftype[]={'?','T','S','I','V'};
static void bofs_printdir (bool opt_long, const vector<FILEINFO_receive> &files)
{
	if (opt_long){
		unsigned max_owner = 0;
		unsigned max_members = 0;
		unsigned max_size = 0;
		unsigned max_name = 0;
		for (int r=0; r<2; r++){
			for (auto &f:files){
				bofs_maxlen (f.owner,max_owner);
				bofs_maxlen (f.listname,max_members);
				bofs_maxlen (f.name,max_name);
				string tmp = string_f ("%u",f.size);
				if (tmp.size() > max_size) max_size = tmp.size();
				if (r==1){
					const char *listmode = f.listmode;
					if (listmode[0] == '\0') listmode = " ";
					printf ("\t%c%c   %s   %s   %*s/%-*s:%s   %*u   %-*s  %s\n"
						,tbtype[f.type],tbftype[f.file_type]
						,f.eventdate,f.modified
						,max_owner,f.owner,max_members,f.listname,listmode,max_size,f.size
						,max_name,f.name,f.title);
				}
			}
		}
	}else{
		for (auto &e:files) printf ("%s\n",e.name);
	}
}
static int bofs_printonefile (CONTEXT &ctx, bool opt_long, bool https, const char *path)
{
	int ret = 0;
	FILEINFO file;
	string parent;
	if (bofs_stat(ctx,path,https,parent,file)==-1){
		bofs_error ("ls",false,"");
		ret = -1;
	}else{
		if (opt_long){
			printf ("\t%c%c   %s   %s   %s/%s:%s   %u   %s  %s\n"
				,tbtype[file.type],tbftype[file.file_type]
				,file.eventdate.c_str(),file.modified.c_str()
				,file.owner.c_str(),file.listname.c_str(),file.listmode.c_str()
				,file.size,file.name.c_str(),file.title.c_str());
		}else{
			printf ("%s\n",file.name.c_str());
		}
	}
	return ret;
}
<mod>
static int bofs_ls (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool opt_long = false;
	glocal bool opt_history = false;
	glocal CONTEXT *ctx = &ctx;
	glocal const char *threshold = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bols",VERSION
			,"Command line tool to list bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
		setarg ('h',"long","Show all versions of files and sub-directories",glocal.opt_history,false);
		setarg ('l',"long","Long listing",glocal.opt_long,false);
		setarg ('t',"threshold","Date threshold, only older-or-equal entries are shown/used (aaaa/mm/jj-hh:mm:ss)",glocal.threshold,false);
	</f>
	<f main>
		int ret = 0;
		if (glocal.threshold != NULL) glocal.ctx->threshold = glocal.threshold;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = 0;
			glocal const char *path = path;
			glocal bool stop = false;
			unsigned offset = 0;
			if (glocal.ctx->login()!=-1){
				while (!glocal.stop){
					<call bod_client_listdir> (glocal.ctx->con,glocal.ctx->sessionid,path,glocal.ctx->threshold,glocal.opt_history,offset,500);
					<f ok>
						if (!success){
							if (internal_error){
								bofs_error ("ls",true,"");
							}else{
								glocal.ret = bofs_printonefile(*glocal.ctx,glocal.opt_long,false,glocal.path);
							}
							glocal.stop = true;
						}else{
							bofs_printdir (glocal.opt_long,files);
							glocal.stop = files.size() < 500;
						}
					</f>
					</call>
					offset += 500;
				}
			}
			return glocal.ret;
		</f>
		<f https_file>
			glocal int ret = 0;
			glocal const char *path = path;
			glocal bool stop = false;
			glocal unsigned chunk = 200;
			unsigned offset = 0;
			CONNECT_HTTP_INFO &hcon = glocal.ctx->hcon;
			hcon.host = host;
			hcon.port = port;
			hcon.use_ssl = use_ssl;
			if (glocal.ctx->hlogin()!=-1){
				while (!glocal.stop){
					<call webapi_listdir> (hcon,glocal.ctx->hsessionid,path,glocal.ctx->threshold,glocal.opt_history,offset,glocal.chunk);
					<f ok>
						if (!success){
							if (internal_error){
								bofs_error ("ls",true,"");
							}else{
								glocal.ret = bofs_printonefile(*glocal.ctx,glocal.opt_long,true,glocal.path);
							}
							glocal.stop = true;
						}else{
							bofs_printdir (glocal.opt_long,files);
							glocal.stop = files.size() < glocal.chunk;
						}
					</f>
					</call>
					offset += glocal.chunk;
				}
			}
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("ls %s %s",glocal.opt_long ? "-l" : "",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat_rest (CONTEXT &ctx, const char *handle, FILE *fin)
{
	glocal int ret = 0;
	bool more = true;
	while (more && glocal.ret == 0){
		char buf[50000];
		int len = fread (buf,1,50000,fin);
		more = len == 50000;
		<call bod_client_appendfile>(ctx.con,ctx.sessionid,handle,BOB_TYPE(buf,len,false),more);
		<f ok>
			if (!success){
				bofs_error ("cat_rest",internal_error,msg);
				glocal.ret = -1;
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat_bofile (CONTEXT &ctx, const char *path, FILE *fout)
{
	glocal int ret = 0;
	glocal FILE *fout = fout;
	glocal CONTEXT *ctx = &ctx;
	<call bod_client_readfile_bob> (ctx.con,ctx.sessionid,path,ctx.threshold);
	<f ok>
		if (!success){
			bofs_error ("cat",internal_error,msg);
			glocal.ret = -1;
		}else{
			fwrite (content.getbuffer(),1,content.getsize(),glocal.fout);
			glocal bool more = more;
			while (glocal.more){
				<call bod_client_readmore>(glocal.ctx->con,glocal.ctx->sessionid,handle);
				<f ok>
					fwrite (content.getbuffer(),1,content.getsize(),glocal.fout);
					glocal.more = more;
				</f>
				</call>
			}
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_write_bofile(CONTEXT &ctx, PARAM_STRING path, FILE *fin, const char *command)
{
	glocal const char *command = command;
	glocal int ret = 0;
	glocal CONTEXT *ctx = &ctx;
	glocal FILE *fin = fin;
	string modified;
	ENTRY_TYPE type;
	char buf[50000];
	int len = fread (buf,1,50000,fin);
	glocal bool more = len == 50000;
	if (bofs_stat(ctx,path,false,type)==-1){
		<call bod_client_addfile_bob> (ctx.con,ctx.sessionid,path,BOB_TYPE(buf,len,false),glocal.more);
		<f ok>
			if (!success){
				bofs_error (glocal.command,internal_error,msg);
				glocal.ret = -1;
			}else if (glocal.more){
				glocal.ret = bofs_cat_rest (*glocal.ctx,handle,glocal.fin);
			}
		</f>
		</call>
	}else if (!bolixo_isfile(type)){
		tlmp_error ("Can't modify %s, not a file\n",path);
	}else{ 
		<call bod_client_modifyfile_bob> (ctx.con,ctx.sessionid,path,BOB_TYPE(buf,len,false),glocal.more);
		<f ok>
			if (!success){
				bofs_error (glocal.command,internal_error,msg);
				glocal.ret = -1;
			}else if (glocal.more){
				glocal.ret = bofs_cat_rest (*glocal.ctx,handle,glocal.fin);
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal const char *pipeto = NULL;
	glocal const char *threshold = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocat",VERSION
			,"Command line tool to cat bolixo content\n"
			 "\n"
			 "bofs cat  ...\n"
			);
		setarg ('p',"pipeto","Pipe input to this file",glocal.pipeto,false);
		setarg ('t',"threshold","Date threshold, only older-or-equal entries are shown/used (aaaa/mm/jj-hh:mm:ss)",glocal.threshold,false);
	</f>
	<f main_noarg>
		int ret = -1;
		if (glocal.pipeto == NULL){
			usage();
		}else{
			char *argv[1] = {(char*)glocal.pipeto};
			ret = <call bofs_split>(1,argv);
			<f bo_file>
				return bofs_write_bofile (*glocal.ctx,path,stdin,"cat");
			</f>
			<f https_file>
				return -1;
			</f>
			<f local_file>
				return system (string_f("cat >%s",path).c_str());
			</f>
			</call>
		}
		return ret;
	</f>
	<f main>
		int ret = 0;
		if (glocal.threshold != NULL) glocal.ctx->threshold = glocal.threshold;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			return bofs_cat_bofile (*glocal.ctx,path,stdout);
		</f>
		<f https_file>
			return -1;
		</f>
		<f local_file>
			return system (string_f("cat %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
enum BO_SOURCE { BO_ENTRY, HTTPS_ENTRY, LOCAL_ENTRY};

struct BO_ARGTYPE{
	string path;
	BO_SOURCE source;
	ENTRY_TYPE type;
	BO_ARGTYPE(PARAM_STRING _path, BO_SOURCE _source, ENTRY_TYPE _type){
		path = _path.ptr;
		source = _source;
		type = _type;
	} 
};

<mod>
static int bofs_copy_file(CONTEXT &ctx, PARAM_STRING path0, BO_SOURCE src0, PARAM_STRING path1, BO_SOURCE src1)
{
	glocal CONTEXT *ctx = &ctx;
	glocal int ret = 0;
	if (src0 == src1){
		if (src0 == LOCAL_ENTRY){
			// Copying two local files
			glocal.ret = system (string_f ("cp %s %s",path0,path1).c_str());
		}else if (src0 == BO_ENTRY){
			<call bod_client_copy>(ctx.con,ctx.sessionid,path0,path1);
			<f ok>
				if (!success){
					glocal.ret = -1;
					bofs_error ("cp",internal_error,msg);
				}
			</f>
			</call>
		}else if (src0 == HTTPS_ENTRY){
			glocal.ret = -1;
		}
	}else if (src0 == LOCAL_ENTRY && src1 == BO_ENTRY){
		FILE *fin = fopen (path0.ptr,"r");
		if (fin == NULL){
			bofs_error ("cp",false,"Can't open file %s (%s)",path0,strerror(errno));
			glocal.ret = -1;
		}else{
			glocal.ret = bofs_write_bofile (*glocal.ctx,path1,fin,"cp");
			fclose (fin);
		}
	}else if (src0 == BO_ENTRY && src1 == LOCAL_ENTRY){
		glocal const char *path0 = path0.ptr;
		<call savefile>(path1,false);
		<f dowrite>
			glocal.ret = bofs_cat_bofile (*glocal.ctx,glocal.path0,fout);
			return 0;
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>
<mod>
static int bofs_checkargs (CONTEXT &ctx, int argc, char *argv[], vector<BO_ARGTYPE> &args)
{
	glocal CONTEXT *ctx = &ctx;
	glocal vector<BO_ARGTYPE> *args = &args;
	int ret = <call bofs_split>(argc,argv);
	<f https_file>
		ENTRY_TYPE type;
		bofs_stat (*glocal.ctx,path,true,type);
		glocal.args->push_back(BO_ARGTYPE(path,HTTPS_ENTRY,type));
		return 0;
	</f>
	<f bo_file>
		ENTRY_TYPE type;
		bofs_stat (*glocal.ctx,path,false,type);
		glocal.args->push_back(BO_ARGTYPE(path,BO_ENTRY,type));
		return 0;
	</f>
	<f local_file>
		struct stat64 st;
		ENTRY_TYPE type = ENTRY_NONE;
		if (stat64(path,&st)!=-1){
			if (S_ISDIR(st.st_mode)){
				type = ENTRY_DIR;
			}else if (S_ISREG(st.st_mode)){
				type = ENTRY_FILE;
			}else{
				bofs_error ("cp",false,"Unsupported file type %s",path);
				exit (-1);
			}
		}
		glocal.args->push_back(BO_ARGTYPE(path,LOCAL_ENTRY,type));
		return 0;
	</f>
	</call>
	return ret;
}
</mod>
<mod>
static int bofs_cp (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocp",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = 0;
		vector<BO_ARGTYPE> args;
		if (bofs_checkargs (*glocal.ctx, argc, argv, args)==-1){
			ret = -1;
		}else{
			size_t args_size = args.size();
			// Check if all the entries prior to the last one exist in the file systems
			bool missing_one = false;
			for (unsigned i=0; i<args_size-1; i++){
				if (args[i].type == ENTRY_NONE){
					// Entry does not exist
					missing_one = true;
					bofs_error ("cp",false,"Source file/directory %s is missing, can't continue"
						,args[i].path.c_str());
				}
			}
			if (missing_one){
				ret = -1;
			}else if (args_size < 2){
				bofs_error ("cp",false,"minimum 2 arguments");
				ret = -1;
			}else if (args[args_size-1].type == 'D'){
				// Last argument is a directory
				size_t last = args_size-1;
				const BO_SOURCE dest_source = args[last].source;
				const char *dir = args[last].path.c_str();
				for (unsigned i=0; ret != -1 && i<last; i++){
					const char *name = args[i].path.c_str();
					const char *pt = strrchr(name,'/');
					if (pt != NULL) name = pt+1;
					string dest = string_f("%s/%s",dir,name);
					if (args[i].type == 'D'){
						if (dest_source == BO_ENTRY && args[i].source == BO_ENTRY){
							glocal int ret = 0;
							<call bod_client_copy>(glocal.ctx->con,glocal.ctx->sessionid,args[i].path,dest);
							<f ok>
								if (!success){
									glocal.ret = -1;
									bofs_error ("cp",internal_error,msg);
								}
							</f>
							</call>
							ret = glocal.ret;
						}else{
							tlmp_error ("bofs cp: Can't copy directory yet\n");
							ret = -1;
						}
					}else{
						ret = bofs_copy_file (*glocal.ctx,args[i].path,args[i].source,dest,dest_source);
					}
				}
			}else if (args_size != 2){
				// Last argument is a file, problem
				bofs_error ("cp",false,"Can't copy multiple inputs onto a file");
				ret = -1;
			}else if (!bolixo_isfile(args[0].type)){
				bofs_error ("cp",false,"Can't copy a directory over a file");
				ret = -1;
			}else{
				// Ok, we copy a file onto a file
				ret = bofs_copy_file (*glocal.ctx
					,args[0].path,args[0].source
					,args[1].path,args[1].source);
			}
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_rm (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("borm",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs rm ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_delfile> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					bofs_error ("rm",internal_error,"Can't delete bolixo file %s: %s",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rm %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_mv (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomv",VERSION
			,"Command line tool to move/rename bolixo content\n"
			 "\n"
			 "bofs mv ...\n"
			);
	</f>
	<f main>
		glocal int ret = 0;
		vector<BO_ARGTYPE> args;
		if (bofs_checkargs (*glocal.ctx, argc, argv, args)==-1){
			glocal.ret = -1;
		}else{
			if (args.size() != 2){
				bofs_error ("mv",false,"Accepts only two arguments");
				glocal.ret = -1;
			}else{
				BO_SOURCE src0 = args[0].source;
				if (src0 != args[1].source){
					bofs_error ("mv",false,"Can't mv file across different filesystems");
					glocal.ret = -1;
				}else{
					const char *path0 = args[0].path.c_str();
					const char *path1 = args[1].path.c_str();
					if (src0 == LOCAL_ENTRY){
						glocal.ret = system (string_f ("mv %s %s",path0,path1).c_str());
					}else if (src0 == BO_ENTRY){
						<call bod_client_rename> (glocal.ctx->con,glocal.ctx->sessionid,path0,path1);
						<f ok>
							if (!success){
								glocal.ret = -1;
								bofs_error ("mv",internal_error,msg);
							}
						</f>
						</call>
					}else{
						glocal.ret = -1;
					}
				}
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_mkdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomkdir",VERSION
			,"Command line tool to create bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_mkdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					bofs_error ("mkdir",internal_error,"Can't create directory %s: %s",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("mkdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_rmdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bormdir",VERSION
			,"Command line tool to remove bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_rmdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					bofs_error ("rmdir",internal_error,"Can't remove directory %s: %s",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rmdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static int bofs_print_groups (CONTEXT *ctx, const char *owner, const char *onegroup, unsigned indent)
{
	glocal int ret = -1;
	glocal unsigned indent = indent;
	glocal const char *onegroup = onegroup;
	<call bod_client_list_groups> (ctx->con,ctx->sessionid,owner);
	<f ok>
		if (success){
			glocal.ret = 0;
			unsigned max_groupname = 0;
			unsigned max_user = 0;
			for (unsigned r=0; r<2; r++){
				for (unsigned i=0; i<groups.size(); i++){
					const char *groupname = groups[i];
					if (glocal.onegroup != NULL && strcmp(glocal.onegroup,groupname)!=0) continue;
					bofs_maxlen (groupname,max_groupname);
					const vector<const char *> &us = users[i];
					if (us.size() == 0){
						if (r > 0) printf ("%-*s\n",max_groupname,groupname);
					}else{
						const vector<const char *> &as = access[i];
						const vector<const char *> &rs = roles[i];
						for (unsigned j=0; j<us.size(); j++){
							bofs_maxlen (us[j],max_user); 
							if (r > 0){
								if (glocal.onegroup != NULL) groupname = "";
								printf ("%*s%-*s\t%*s\t%s\t%s\n",glocal.indent,"",max_groupname,groupname,max_user,us[j],as[j],rs[j]);
							}
							groupname = "";
						}
					}
				}
			}
		}else{
			bofs_error ("groups",internal_error,"Can't list groups: %s",msg);
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static int bofs_groups(CONTEXT &ctx, int argc, char *argv[])
{
        glocal CONTEXT *ctx = &ctx;
	glocal bool create_group_list = false;
	glocal bool create_group = false;
	glocal bool set_group = false;
	glocal bool set_member = false;

	glocal bool delete_list = false;
	glocal bool delete_group = false;

	glocal bool print_lists = false;
	glocal bool print_groups = false;

	glocal bool set_access = false;

	glocal bool create_project_dir = false;

	glocal const char *filename = NULL;
	glocal const char *listname = NULL;
	glocal const char *listmode = " ";
	glocal const char *groupname = NULL;
	glocal const char *access = "R";
	glocal const char *user = NULL;
	glocal const char *role = "";

	glocal const char *owner = "";
        int ret = <call tlmpprogram>(argc,argv);
        <f init>
		setproginfo ("bogroups",VERSION
			,"Command line tool to configure bolixo groups and group lists\n"
			 "\n"
			 "bofs groups ...\n"
			);
		setgrouparg ("Commands");
		setarg ('g',"create-group","Create a group of users",glocal.create_group,false);
		setarg ('l',"create-group-list","Create a list of groups",glocal.create_group_list,false);
		setarg ('s',"set-group","Configure a group as a member of a list",glocal.set_group,false);
		setarg ('m',"set-member","Configure a user a a member of a group",glocal.set_member,false);
		setarg ('d',"create-project-dir","Create the project directory for a list",glocal.create_project_dir,false);
		setgrouparg ("Deletion");
		setarg (' ',"delete-list","Delete one list",glocal.delete_list,false);
		setarg (' ',"delete-group","Delete one group",glocal.delete_group,false);
		setgrouparg ("Print");
		setarg (' ',"print-lists","Print the content of a list",glocal.print_lists,false);
		setarg (' ',"print-groups","Print the content of a group",glocal.print_groups,false);
		setgrouparg ("Access");
		setarg ('a',"set-access","Assign a user/list name to a file or directory",glocal.set_access,false);
		setarg ('M',"listmode","list mode override (' ','p','r','w','a')",glocal.listmode,false);
		setgrouparg ("Arguments");
		setarg ('P',"filename","File or directory path",glocal.filename,false);
		setarg ('L',"listname","List name",glocal.listname,false);
		setarg ('G',"groupname","Group name",glocal.groupname,false);
		setarg ('U',"user","User/member of a group",glocal.user,false);
		setarg ('A',"access","Access or default access",glocal.access,false);
		setarg ('R',"role","(for set-member) Activity of this member",glocal.role,false);
		setarg ('O',"owner","Apply the comand on behalf of this owner, must be admin",glocal.owner,false);
	</f>
	<f main_noarg>
		glocal int ret = -1;
		if (glocal.ctx->login()==-1){
		}else if (glocal.create_group_list){
			if (glocal.listname == NULL){
				bofs_error ("groups",false,"You must specify the list name");
			}else{
				<call bod_client_create_group_list> (glocal.ctx->con,glocal.ctx->sessionid,glocal.listname,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error, "Can't create group_list: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.create_group){
			if (glocal.groupname == NULL){
				bofs_error ("groups",false,"You must specify the group name");
			}else{
				<call bod_client_create_group> (glocal.ctx->con,glocal.ctx->sessionid,glocal.groupname,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't create group: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.set_group){
			if (glocal.listname == NULL){
				bofs_error ("groups",false,"You must specify the list name");
			}else if (glocal.groupname == NULL){
				bofs_error ("groups",false,"You must specify the group name");
			}else{
				<call bod_client_set_group> (glocal.ctx->con,glocal.ctx->sessionid,glocal.listname,glocal.groupname,glocal.access,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't assign group to a list: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.set_member){
			if (glocal.groupname == NULL){
				bofs_error ("groups",false,"You must specify the group name");
			}else{
				<call bod_client_set_member> (glocal.ctx->con,glocal.ctx->sessionid,glocal.groupname,glocal.user,glocal.access,glocal.role,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't assign user to a group: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.create_project_dir){
			if (glocal.listname == NULL){
				bofs_error ("groups",false,"You must specify the list name");
			}else{
				<call bod_client_create_project_dir>(glocal.ctx->con,glocal.ctx->sessionid,glocal.listname,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't create project directory: %s\n",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.delete_list){
			if (glocal.listname == NULL){
				bofs_error ("groups",false,"You must specify the list name");
			}else{
				<call bod_client_delete_list> (glocal.ctx->con,glocal.ctx->sessionid,glocal.listname,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't delete the list: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.delete_group){
			if (glocal.groupname == NULL){
				bofs_error ("groups",false,"You must specify the group name");
			}else{
				<call bod_client_delete_group> (glocal.ctx->con,glocal.ctx->sessionid,glocal.groupname,glocal.owner);
				<f ok>
					if (success){
						glocal.ret = 0;
					}else{
						bofs_error ("groups",internal_error,"Can't delete the group: %s",msg);
					}
				</f>
				</call>
			}
		}else if (glocal.print_lists){
			<call bod_client_list_lists> (glocal.ctx->con,glocal.ctx->sessionid,glocal.owner);
			<f ok>
				if (success){
					glocal.ret = 0;
					unsigned max_listname=0;
					unsigned max_group=0;
					for (int r=0; r<2; r++){
						for (unsigned i=0; i<lists.size(); i++){
							const char *listname = lists[i];
							bofs_maxlen (listname,max_listname);
							const vector<const char *> &gs = groups[i];
							if (gs.size() == 0){
								printf ("%s\n",listname);
							}else{
								const vector<const char *> &as = access[i];
								for (unsigned j=0; j<gs.size(); j++){
									const char *groupname = gs[j];
									bofs_maxlen (groupname,max_group);
									if (r==1){
										printf ("%-*s   %-*s   %s\n"
											,max_listname,listname,max_group,groupname,as[j]);
										glocal.ret = bofs_print_groups (glocal.ctx,glocal.owner,groupname,max_listname+max_group);
									}
									listname = "";
								}
							}
						}
					}
					glocal.ret = 0;
				}else{
					bofs_error ("groups",internal_error,"Can't list lists: %s",msg);
				}
			</f>
			</call>
		}else if (glocal.print_groups){
			glocal.ret = bofs_print_groups (glocal.ctx,glocal.owner,NULL,0);
		}else{
			tlmp_error ("One of the following option must be used:\n"
				"\t--create-group-list\n"
				"\t--creat-group\n"
				"\t--set_group\n"
				"\t--set_member\n"
				"\n"
				"\t--delete-list\n"
				"\t--delete-group\n"
				"\n"
				"\t--print-list\n"
				"\t--print-group\n"
				);
			usage();
		}
		return glocal.ret;
	</f>
	<f main>
		glocal int ret = -1;
		if (glocal.set_access){
			const char *username = glocal.user == NULL ? "" : glocal.user;
			const char *listname = glocal.listname == NULL ? "" : glocal.listname;
			for (int i=0; i<argc; i++){
				<call bod_client_set_access>(glocal.ctx->con,glocal.ctx->sessionid,argv[i],username,listname,glocal.listmode);
				<f ok>
					if (!success){
						bofs_error ("groups",internal_error,"bofs groups: %s",msg);
					}else{
						glocal.ret = 0;
					}
				</f>
				</call>
				if (glocal.ret != 0) break;
			}
		}else{
			usage();
		}
		return glocal.ret;
	</f>
	</call>
	return ret;
}
</mod>
<mod>
static int bofs_msgs (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal const char *owner = "";
	glocal bool list = false;
	glocal bool attach = false;
	glocal bool newmsg = false;
	glocal bool reply = false;
	glocal bool listmsgs = false;

	glocal vector<string> recipients;
	glocal const char *manager = NULL;
	glocal const char *project = NULL;
	glocal const char *role = "";
	glocal const char *title = "";
	glocal const char *content = NULL;
	glocal const char *msgid = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomsgs",VERSION
			,"Command line tool to access messages\n"
			 "\n"
			 "bofs msgs ...\n"
			);
		setgrouparg ("Main commands");
		setarg ('a',"attach","Add an attachment to previously sent message",glocal.attach,false);
		setarg ('l',"list","List inboxes",glocal.list,false);
		setarg ('i',"listmsgs","List messages in all inboxes",glocal.listmsgs,false);
		setarg ('n',"newmsg","Send a message",glocal.newmsg,false);
		setarg ('r',"reply","Reply to a message",glocal.reply,false);
		setgrouparg ("Options");
		setarg ('M',"manager","Manager or owner of the inbox",glocal.manager,false);
		setarg ('P',"project","Target inbox or project",glocal.project,false);
		setarg ('R',"role","Target role",glocal.role,false);
		setarg ('D',"recipient","Recipient of the message",glocal.recipients,false);

		setarg ('I',"msgid","Message ID we are replying to",glocal.msgid,false);
		setarg ('T',"title","Title of the message",glocal.title,false);
		setarg ('C',"content","body of the message",glocal.content,false);

		setarg ('O',"owner","Apply the comand on behalf of this owner, must be admin",glocal.owner,false);
	</f>
	<f main_noarg>
		glocal int ret = -1;
		if (glocal.ctx->is_internal()){
			if (glocal.ctx->login()==-1){
				tlmp_error ("login fail\n");	
			}else if (glocal.list){
				<call bod_client_list_inboxes>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner);
				<f ok>
					if (!success){
						bofs_error ("msgs",internal_error,msg);
					}else{
						unsigned max_manager=0;
						unsigned max_project=0;
						for (int r=0; r<2; r++){
							for (auto &inb:inboxes){
								bofs_maxlen (inb.manager,max_manager);
								bofs_maxlen (inb.project,max_project);
								if (r==1) printf ("%-*s  %-*s  %s\n",max_manager,inb.manager,max_project,inb.project,inb.role);
							}
						}
						glocal.ret = 0;
					}
				</f>
				</call>
			}else if (glocal.newmsg){
				if (glocal.content == NULL){
					bofs_error ("msgs",false,"Missing content");
				}else if (glocal.recipients.size() > 0){
					<call bod_client_sendmsg>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner
						,glocal.recipients,glocal.title,glocal.content);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
						}else{
							printf ("msgid: %s\n",msgid);
							glocal.ret = 0;
						}
					</f>
					</call>
				}else if (glocal.project != NULL && glocal.manager != NULL){
					<call bod_client_sendmsg_project>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner
						,glocal.manager,glocal.project,glocal.role,glocal.title,glocal.content);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
						}else{
							printf ("msgid: %s\n",msgid);
							glocal.ret = 0;
						}
					</f>
					</call>
				}else{
					bofs_error ("msgs",false,"When sending a message, you must specify manager,project or recipients");
				}
			}else if (glocal.reply){
				if (glocal.content == NULL){
					bofs_error ("msgs",false,"Missing content");
				}else if (glocal.msgid == NULL){
					bofs_error ("msgs",false,"You must specify the message ID you are replying to");
				}else if (glocal.recipients.size() > 0){
					<call bod_client_replymsg>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner
						,glocal.msgid,glocal.recipients,glocal.title,glocal.content);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
						}else{
							printf ("replyid: %s\n",replyid);
							glocal.ret = 0;
						}
					</f>
					</call>
				}else if (glocal.project != NULL && glocal.manager != NULL){
					<call bod_client_replymsg_project>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner
						,glocal.manager,glocal.project,glocal.role,glocal.msgid,glocal.title,glocal.content);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
						}else{
							printf ("replyid: %s\n",replyid);
							glocal.ret = 0;
						}
					</f>
					</call>
				}else{
					bofs_error ("msgs",false,"When sending a message, you must specify manager,project or recipients");
				}
			}else if (glocal.attach){
			}else if (glocal.listmsgs){
				glocal bool stop = false;
				glocal unsigned offset=0;
				glocal unsigned chunk=100;
				while (!glocal.stop){
					<call bod_client_list_msgs>(glocal.ctx->con,glocal.ctx->sessionid,glocal.owner,false,glocal.offset,glocal.chunk);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
							glocal.stop = true;
						}else{
							for (auto &m:messages){
								const char *markread = strcmp(m.viewed,m.submit)==0 ? "viewed" : "      ";
								printf ("%-10s %-10s %-10s %-10s %-30s %-20s %s %s\n",m.from,m.manager,m.project,m.role,m.uuid,m.submit,markread,m.title);
							}
							glocal.stop = messages.size() < glocal.chunk;
							glocal.offset += glocal.chunk;
						}
					</f>
					</call>
				}
			}else{
				usage();
			}
		}else{
			if (glocal.ctx->hlogin()==-1){
				tlmp_error ("http login fail\n");	
			}else if (glocal.list){
				<call webapi_list_inboxes>(glocal.ctx->hcon,glocal.ctx->hsessionid,glocal.owner);
				<f ok>
					if (!success){
						bofs_error ("msgs",internal_error,msg);
					}else{
						unsigned max_manager=0;
						unsigned max_project=0;
						for (int r=0; r<2; r++){
							for (auto &inb:inboxes){
								bofs_maxlen (inb.manager,max_manager);
								bofs_maxlen (inb.project,max_project);
								if (r==1) printf ("%-*s  %-*s  %s\n",max_manager,inb.manager,max_project,inb.project,inb.role);
							}
						}
						glocal.ret = 0;
					}
				</f>
				</call>
			}else if (glocal.listmsgs){
				glocal bool stop = false;
				glocal unsigned offset=0;
				glocal unsigned chunk=100;
				while (!glocal.stop){
					<call webapi_list_msgs>(glocal.ctx->hcon,glocal.ctx->hsessionid,glocal.owner,false,glocal.offset,glocal.chunk);
					<f ok>
						if (!success){
							bofs_error ("msgs",internal_error,msg);
							glocal.stop = true;
						}else{
							for (auto &m:messages){
								const char *markread = strcmp(m.viewed,m.submit)==0 ? "viewed" : "      ";
								printf ("%-10s %-10s %-10s %-10s %-30s %-20s %s %s\n",m.from,m.manager,m.project,m.role,m.uuid,m.submit,markread,m.title);
							}
							glocal.stop = messages.size() < glocal.chunk;
							glocal.offset += glocal.chunk;
						}
					</f>
					</call>
				}
			}else{
				usage();
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_misc (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal bool markview = false;
	glocal bool verifysign = false;
	glocal bool http_verifysign = false;
	glocal const char *message = NULL;
	glocal const char *nickname = NULL;
	glocal unsigned nbrep=1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomisc",VERSION
			,"Command line tool to do various things on bolixo files\n"
			 "\n"
			 "bofs misc ...\n"
			);
		setgrouparg ("Main commands");
		setarg ('m',"markview","Mark a file as viewed",glocal.markview,false);
		setarg ('v',"verifysign","Verify a message signature",glocal.verifysign,false);
		setarg ('h',"http_verifysign","Verify a message signature (webapi)",glocal.http_verifysign,false);
		setgrouparg ("(http_)verifysign arguments");
		setarg ('n',"nickname","User nickname who signed the message",glocal.nickname,false);
		setarg ('M',"message","Message to verify",glocal.message,false);
		setarg ('r',"nbrep","Number of repetition (performance test)",glocal.nbrep,false);
		setgrouparg ("Options");
	</f>
	<f main>
		glocal int ret = -1;
		if (glocal.markview){
			glocal.ret = 0;
			for (int i=0; i<argc; i++){
				<call bod_client_markview>(glocal.ctx->con,glocal.ctx->sessionid,argv[i]);
				<f ok>
					if (!success){
						bofs_error ("markview",internal_error,msg);
						glocal.ret = -1;
					}
				</f>
				</call>
				if (glocal.ret != 0) break;
			}
		}
		return glocal.ret;
	</f>
	<f main_noarg>
		glocal int ret = -1;
		if (glocal.verifysign){
			for (unsigned i=0; i<glocal.nbrep; i++){
				<call bod_client_verifysign>(glocal.ctx->con,glocal.nickname,glocal.message);
				<f ok>
					if (status == ERR_CODE_NONE) glocal.ret = 0;
					printf ("\tverifysign: status=%d %s\n",status,msg);
				</f>
				</call>
			}
		}else if (glocal.http_verifysign){
			for (unsigned i=0; i<glocal.nbrep; i++){
				<call webapi_verifysign>(glocal.ctx->hcon,glocal.nickname,glocal.message);
				<f ok>
					if (status == ERR_CODE_NONE) glocal.ret = 0;
					printf ("\thttp_verifysign: status=%d %s\n",status,msg);
				</f>
				</call>
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *user = NULL;
	glocal int nbrep=1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bofs",VERSION
			,"Command line tool to perform filesystem operations on bolixo\n"
			 "\n"
			 "\tbofs cat ...\n"
			 "\tbofs cp ...\n"
			 "\tbofs groups ...\n"
			 "\tbofs ls ...\n"
			 "\tbofs mkdir ...\n"
			 "\tbofs misc ...\n"
			 "\tbofs msgs ...\n"
			 "\tbofs mv ...\n"
			 "\tbofs rm ...\n"
			 "\tbofs rmdir ...\n"
			);
		setarg ('u',"user","Select one user from .bofs.conf",glocal.user,false);
		setarg (' ',"repeat","Repeat the operation N time (speed test)",glocal.nbrep,false);
	</f>
	<f main>
		int ret = -1;
		glocal CONTEXT ctx;
		glocal bool thisuser = false;
		<call loadfile>(string_f("%s/.bofs.conf",getenv("HOME")),true);
		<f oneline>
			int ret = 0;
			vector<string> tb;
			int n = str_splitline(line,' ',tb);
			if (n >=2){
				const char *subject = tb[0].c_str();
				if (strcmp(subject,"user:")==0){
					if (glocal.thisuser){
						ret = -1;
					}else if (glocal.user == NULL || strcmp(glocal.user,tb[1].c_str())==0){
						glocal.thisuser = true;
					}
				}else if (glocal.thisuser){
					if (strcmp(subject,"email:")==0){
						glocal.ctx.email = tb[1];
					}else if (strcmp(subject,"password:")==0){
						glocal.ctx.password = tb[1];
					}else if (strcmp(subject,"http_server:")==0){
						glocal.ctx.hcon.host = tb[1];
					}else if (strcmp(subject,"http_port:")==0){
						glocal.ctx.hcon.port = tb[1];
					}else if (strcmp(subject,"bod_socket:")==0){
						glocal.ctx.con.port = tb[1];
					}else if (strcmp(subject,"sess_socket:")==0){
						glocal.ctx.con_sess.port = tb[1];
					}else if (strcmp(subject,"bod_secret:")==0){
						glocal.ctx.con.secret = tb[1];
					}else if (strcmp(subject,"sess_secret:")==0){
						glocal.ctx.con_sess.secret = tb[1];
					}else{
						tlmp_error ("File %s, invalide keyword: %s\n",info.filename,subject);
					}
				}
			}
			return ret;
		</f>
		<f missing>
			tlmp_error ("File %s/.bofs.conf missing.\n",getenv("HOME"));
			tlmp_error ("Create this file with the following fields:\n"
				"\tuser:\n"
				"\temail:\n"
				"\tpassword:\n"
				"\tbod_socket:\n"
				"\tsess_socket:\n"
				"\tbod_secret:\n"
				"\tsess_secret:\n"
				"\thttp_server:\n"
				"\thttp_port:\n");
				exit (-1);
		</f>
		</call>
		if (!glocal.thisuser){
			tlmp_error ("No user definition found in .bofs.conf for user %s\n",glocal.user);
			exit (-1);
		}
		// if (bod_login (glocal.ctx.con,glocal.ctx.hcon,glocal.ctx.email,glocal.ctx.password,glocal.ctx.sessionid,glocal.ctx.hsessionid)!=-1){
		{
			for (int i=0; i<glocal.nbrep; i++){
				if (strcmp(argv[0],"ls")==0){
					ret = bofs_ls (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"cat")==0){
					ret = bofs_cat (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"cp")==0){
					ret = bofs_cp (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"rm")==0){
					ret = bofs_rm (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"mv")==0){
					ret = bofs_mv (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"mkdir")==0){
					ret = bofs_mkdir (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"rmdir")==0){
					ret = bofs_rmdir (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"groups")==0){
					ret = bofs_groups (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"msgs")==0){
					ret = bofs_msgs (glocal.ctx,argc,argv);
				}else if (strcmp(argv[0],"misc")==0){
					ret = bofs_misc (glocal.ctx,argc,argv);
				}else{
					tlmp_error ("Invalid command: %s\n",argv[0]);
					usage();
					exit (-1);
				}
			}
			//bod_logout (glocal.ctx.con,glocal.ctx.hcon,glocal.ctx.sessionid,glocal.ctx.hsessionid);
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

