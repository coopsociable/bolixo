/*
	Command line tool to manipulate the bolixo filesystem. The program works
	like normal Linux commands. It is general. For example, it
		-can copy from bolixo to bolixo
		-bolixo to linux
		-linux to bolixo
		-linux to linux

	bofs cp ...
	bofs ls

	Further, if the program is renamed bocp (normally done using a symlink), it acts as "bofs cp"
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <vector>
#include <fdpass.h>

using namespace std;

#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED

#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED

#include "proto/bod_client.protoch"

<mod>
static string bod_createsession(CONNECT_INFO &con)
{
	glocal string ret;
	<call bod_client_createsession>(con);
	<f ok>
		glocal.ret = sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static string bod_login (CONNECT_INFO &con, PARAM_STRING email, PARAM_STRING password)
{
	glocal string ret;
	glocal const char *email = email.ptr;
	glocal string sessionid = bod_createsession(con);
	<call bod_client_login>(con,glocal.sessionid,email,password);
	<f ok>
		if (!success) printf ("\tlogin %s success=%d sessionid=%s\n",glocal.email,success,glocal.sessionid.c_str());
		if (success) glocal.ret = glocal.sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static void bod_logout (CONNECT_INFO &con, const PARAM_STRING sessionid)
{
	<call bod_client_logout>(con,sessionid);
	<f ok>
	</f>
	</call>
}
</mod>

struct CONTEXT{
	string email;
	string password;
	string sessionid;
	CONNECT_INFO con;
	CONNECT_INFO con_sess;
};

#define _TLMP_bofs_split
struct _F_bofs_split {
	#define _F_bofs_split_bo_file(x) int x bo_file(const char *path)
	virtual _F_bofs_split_bo_file( );
	#define _F_bofs_split_https_file(x) int x https_file(const char *path)
	virtual _F_bofs_split_https_file( );
	#define _F_bofs_split_local_file(x) int x local_file(const char *path)
	virtual _F_bofs_split_local_file( );
};

int _F_bofs_split::bo_file(const char *path)
{
	tlmp_error ("Bolixo file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::https_file(const char *path)
{
	tlmp_error ("Https file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::local_file(const char *path)
{
	tlmp_error ("Local file %s not processed\n",path);
	return -1;
}

static int bofs_split (_F_bofs_split &c, int argc, char *argv[])
{
	int ret = 0;
	for (int i=0; ret == 0 && i<argc; i++){
		const char *arg = argv[i];
		if (strncmp(arg,"bo://",5)==0){
			ret = c.bo_file (arg+4);
		}else if (strncmp(arg,"https://",8)==0){
			ret = c.https_file (arg+7);
		}else{
			ret = c.local_file (arg);
		}
	}
	return ret;
}

<mod>
int bofs_ls (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool opt_long = false;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bols",VERSION
			,"Command line tool to list bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
		setarg ('l',"long","Long listing",glocal.opt_long,false);
	</f>
	<f main>
		int ret = 0;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = 0;
			<call bod_client_listdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (!success){
					tlmp_error ("ls: %s\n",msg);
					glocal.ret = -1;
				}else{
					for (unsigned i=0; i<entries.size(); i++){
						printf ("\t%c %s %s\n",types[i],modified[i],entries[i]);
					}
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f https_file>
			return -1;
		</f>
		<f local_file>
			return system (string_f("ls %s %s",glocal.opt_long ? "-l" : "",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_cat (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocat",VERSION
			,"Command line tool to cat bolixo content\n"
			 "\n"
			 "bofs cat  ...\n"
			);
	</f>
	<f main>
		int ret = 0;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = 0;
			<call bod_client_readfile_bob> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (!success){
					tlmp_error ("cat: %s\n",msg);
					glocal.ret = -1;
				}else{
					fwrite (content.getbuffer(),1,content.getsize(),stdout);
					glocal bool more = more;
					while (glocal.more){
						<call bod_client_readmore>(glocal.ctx->con,glocal.ctx->sessionid,handle);
						<f ok>
							fwrite (content.getbuffer(),1,content.getsize(),stdout);
							glocal.more = more;
						</f>
						</call>
					}
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f https_file>
			return -1;
		</f>
		<f local_file>
			return system (string_f("cat %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_cp (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocp",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			return -1;
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_rm (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("borm",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_delfile> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't delete bolixo file %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rm %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_mkdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomkdir",VERSION
			,"Command line tool to create bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_mkdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't create directory %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("mkdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_rmdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bormdir",VERSION
			,"Command line tool to remove bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_rmdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't remove directory %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rmdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>



<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/bod_client.sock";
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bofs",VERSION
			,"Command line tool to control bolixo filesystem\n"
			 "\n"
			 "bofs cat ...\n"
			 "bofs cp ...\n"
			 "bofs rm ...\n"
			 "bofs ls ...\n"
			 "bofs mkdir ...\n"
			 "bofs rmdir ...\n"
			);
		setarg ('p',"control","Unix socket to reach bod",glocal.control,false);
	</f>
	<f main>
		int ret = -1;
		glocal CONTEXT ctx;
		<call loadfile>(string_f("%s/.bofs.conf",getenv("HOME")),true);
		<f oneline>
			vector<string> tb;
			int n = str_splitline(line,' ',tb);
			if (n >=2){
				const char *subject = tb[0].c_str();
				if (strcmp(subject,"email:")==0){
					glocal.ctx.email = tb[1];
				}else if (strcmp(subject,"password:")==0){
					glocal.ctx.password = tb[1];
				}else if (strcmp(subject,"bod_socket:")==0){
					glocal.ctx.con.port = tb[1];
				}else if (strcmp(subject,"sess_socket:")==0){
					glocal.ctx.con_sess.port = tb[1];
				}else if (strcmp(subject,"bod_secret:")==0){
					glocal.ctx.con.secret = tb[1];
				}else if (strcmp(subject,"sess_secret:")==0){
					glocal.ctx.con_sess.secret = tb[1];
				}else{
					tlmp_error ("File %s, invalide keyword: %s\n",info.filename,subject);
				}
			}
			return 0;
		</f>
		</call>
		glocal.ctx.sessionid = bod_login (glocal.ctx.con,glocal.ctx.email,glocal.ctx.password);
		if (glocal.ctx.sessionid.size() > 0){
			if (strcmp(argv[0],"ls")==0){
				ret = bofs_ls (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cat")==0){
				ret = bofs_cat (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cp")==0){
				ret = bofs_cp (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rm")==0){
				ret = bofs_rm (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"mkdir")==0){
				ret = bofs_mkdir (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rmdir")==0){
				ret = bofs_rmdir (glocal.ctx,argc,argv);
			}else{
				tlmp_error ("Invalid command: %s\n",argv[0]);
				usage();
			}
			bod_logout (glocal.ctx.con,glocal.ctx.sessionid);
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

