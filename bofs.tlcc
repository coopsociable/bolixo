/*
	Command line tool to manipulate the bolixo filesystem. The program works
	like normal Linux commands. It is general. For example, it
		-can copy from bolixo to bolixo
		-bolixo to linux
		-linux to bolixo
		-linux to linux

	bofs cp ...
	bofs ls

	Further, if the program is renamed bocp (normally done using a symlink), it acts as "bofs cp"
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <vector>
#include <fdpass.h>

using namespace std;

#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED
#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_delfile_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED
#define bod_client_mkdir_NOTNEED
#define bod_client_rmdir_NOTNEED

#include "proto/bod_client.protoch"

<mod>
static string bod_createsession(CONNECT_INFO &con)
{
	glocal string ret;
	<call bod_client_createsession>(con);
	<f ok>
		glocal.ret = sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static string bod_login (CONNECT_INFO &con, PARAM_STRING email, PARAM_STRING password)
{
	glocal string ret;
	glocal const char *email = email.ptr;
	glocal string sessionid = bod_createsession(con);
	<call bod_client_login>(con,glocal.sessionid,email,password);
	<f ok>
		if (!success) printf ("\tlogin %s success=%d sessionid=%s\n",glocal.email,success,glocal.sessionid.c_str());
		if (success) glocal.ret = glocal.sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static void bod_logout (CONNECT_INFO &con, const PARAM_STRING sessionid)
{
	<call bod_client_logout>(con,sessionid);
	<f ok>
	</f>
	</call>
}
</mod>

struct CONTEXT{
	string email;
	string password;
	string sessionid;
	CONNECT_INFO con;
	CONNECT_INFO con_sess;
};

<mod>
int bofs_ls (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool opt_long = false;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bols",VERSION
			,"Command line tool to list bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
		setarg ('l',"long","Long listing",glocal.opt_long,false);
	</f>
	<f main>
		glocal int ret = 0;
		for (int i=0; glocal.ret == 0 && i<argc; i++){
			const char *arg = argv[i];
			if (strncmp(arg,"bo://",5)==0){
				<call bod_client_listdir> (glocal.ctx->con,glocal.ctx->sessionid,arg+4);
				<f ok>
					if (!success){
						tlmp_error ("ls: %s\n",msg);
						glocal.ret = -1;
					}else{
						for (unsigned i=0; i<entries.size(); i++){
							printf ("\t%c %s %s\n",types[i],modified[i],entries[i]);
						}
					}
				</f>
				</call>
			}else if (strncmp(arg,"https://",8)==0){
			}else{
				glocal.ret = system (string_f("ls %s %s",glocal.opt_long ? "-l" : "",arg).c_str());
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_cat (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocat",VERSION
			,"Command line tool to cat bolixo content\n"
			 "\n"
			 "bofs cat  ...\n"
			);
	</f>
	<f main>
		glocal int ret = 0;
		for (int i=0; glocal.ret == 0 && i<argc; i++){
			const char *arg = argv[i];
			if (strncmp(arg,"bo://",5)==0){
				<call bod_client_readfile_bob> (glocal.ctx->con,glocal.ctx->sessionid,arg+4);
				<f ok>
					if (!success){
						tlmp_error ("cat: %s\n",msg);
						glocal.ret = -1;
					}else{
						fwrite (content.getbuffer(),1,content.getsize(),stdout);
						glocal bool more = more;
						while (glocal.more){
							<call bod_client_readmore>(glocal.ctx->con,glocal.ctx->sessionid,handle);
							<f ok>
								fwrite (content.getbuffer(),1,content.getsize(),stdout);
								glocal.more = more;
							</f>
							</call>
						}
					}
				</f>
				</call>
			}else if (strncmp(arg,"https://",8)==0){
			}else{
				glocal.ret = system (string_f("cat %s",arg).c_str());
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_cp (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocp",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_rm (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("borm",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_mkdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomkdir",VERSION
			,"Command line tool to create bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
int bofs_rmdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bormdir",VERSION
			,"Command line tool to remove bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>



<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/bod_client.sock";
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bofs",VERSION
			,"Command line tool to control bolixo filesystem\n"
			 "\n"
			 "bofs cat ...\n"
			 "bofs cp ...\n"
			 "bofs rm ...\n"
			 "bofs ls ...\n"
			 "bofs mkdir ...\n"
			 "bofs rmdir ...\n"
			);
		setarg ('p',"control","Unix socket to reach bod",glocal.control,false);
	</f>
	<f main>
		int ret = -1;
		glocal CONTEXT ctx;
		<call loadfile>(string_f("%s/.bofs.conf",getenv("HOME")),true);
		<f oneline>
			vector<string> tb;
			int n = str_splitline(line,' ',tb);
			if (n >=2){
				const char *subject = tb[0].c_str();
				if (strcmp(subject,"email:")==0){
					glocal.ctx.email = tb[1];
				}else if (strcmp(subject,"password:")==0){
					glocal.ctx.password = tb[1];
				}else if (strcmp(subject,"bod_socket:")==0){
					glocal.ctx.con.port = tb[1];
				}else if (strcmp(subject,"sess_socket:")==0){
					glocal.ctx.con_sess.port = tb[1];
				}else if (strcmp(subject,"bod_secret:")==0){
					glocal.ctx.con.secret = tb[1];
				}else if (strcmp(subject,"sess_secret:")==0){
					glocal.ctx.con_sess.secret = tb[1];
				}else{
					tlmp_error ("File %s, invalide keyword: %s\n",info.filename,subject);
				}
			}
			return 0;
		</f>
		</call>
		glocal.ctx.sessionid = bod_login (glocal.ctx.con,glocal.ctx.email,glocal.ctx.password);
		if (glocal.ctx.sessionid.size() > 0){
			if (strcmp(argv[0],"ls")==0){
				ret = bofs_ls (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cat")==0){
				ret = bofs_cat (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cp")==0){
				ret = bofs_cp (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rm")==0){
				ret = bofs_rm (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"mkdir")==0){
				ret = bofs_mkdir (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rmdir")==0){
				ret = bofs_rmdir (glocal.ctx,argc,argv);
			}else{
				tlmp_error ("Invalid command: %s\n",argv[0]);
				usage();
			}
			bod_logout (glocal.ctx.con,glocal.ctx.sessionid);
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

