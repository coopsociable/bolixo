/*
	Command line tool to manipulate the bolixo filesystem. The program works
	like normal Linux commands. It is general. For example, it
		-can copy from bolixo to bolixo
		-bolixo to linux
		-linux to bolixo
		-linux to linux

	bofs cp ...
	bofs ls

	Further, if the program is renamed bocp (normally done using a symlink), it acts as "bofs cp"
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <vector>
#include <fdpass.h>

using namespace std;

#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED

#define bod_client_addfile_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_readfile_NOTNEED

#include "proto/bod_client.protoch"

<mod>
static string bod_createsession(CONNECT_INFO &con)
{
	glocal string ret;
	<call bod_client_createsession>(con);
	<f ok>
		glocal.ret = sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static string bod_login (CONNECT_INFO &con, PARAM_STRING email, PARAM_STRING password)
{
	glocal string ret;
	glocal const char *email = email.ptr;
	glocal string sessionid = bod_createsession(con);
	<call bod_client_login>(con,glocal.sessionid,email,password);
	<f ok>
		if (!success) printf ("\tlogin %s success=%d sessionid=%s\n",glocal.email,success,glocal.sessionid.c_str());
		if (success) glocal.ret = glocal.sessionid;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static void bod_logout (CONNECT_INFO &con, const PARAM_STRING sessionid)
{
	<call bod_client_logout>(con,sessionid);
	<f ok>
	</f>
	</call>
}
</mod>

struct CONTEXT{
	string email;
	string password;
	string sessionid;
	string threshold;	// Date to filter in the history of a directory or files
	CONNECT_INFO con;
	CONNECT_INFO con_sess;
};

#define _TLMP_bofs_split
struct _F_bofs_split {
	#define _F_bofs_split_bo_file(x) int x bo_file(const char *path)
	virtual _F_bofs_split_bo_file( );
	#define _F_bofs_split_https_file(x) int x https_file(const char *path)
	virtual _F_bofs_split_https_file( );
	#define _F_bofs_split_local_file(x) int x local_file(const char *path)
	virtual _F_bofs_split_local_file( );
};

int _F_bofs_split::bo_file(const char *path)
{
	tlmp_error ("Bolixo file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::https_file(const char *path)
{
	tlmp_error ("Https file %s not processed\n",path);
	return -1;
}
int _F_bofs_split::local_file(const char *path)
{
	tlmp_error ("Local file %s not processed\n",path);
	return -1;
}

static int bofs_split (_F_bofs_split &c, int argc, char *argv[])
{
	int ret = 0;
	for (int i=0; ret == 0 && i<argc; i++){
		const char *arg = argv[i];
		if (strncmp(arg,"bo://",5)==0){
			ret = c.bo_file (arg+4);
		}else if (strncmp(arg,"https://",8)==0){
			ret = c.https_file (arg+7);
		}else{
			ret = c.local_file (arg);
		}
	}
	return ret;
}

<mod>
static int bofs_stat (
	CONTEXT &ctx,
	PARAM_STRING _path,
	char &type,
	string &parent,
	string &file,
	string &modified,
	string &owner,
	unsigned &size)
{
	glocal int ret = 0;
	glocal char *type = &type;
	const char *path = _path.ptr;
	glocal string *modified = &modified;
	glocal string *owner = &owner;
	glocal unsigned *size = &size;
	size = 0;
	type = ' ';
	parent.clear();
	file.clear();
	modified.clear();
	if (path[0] != '/'){
		tlmp_error ("bofs_stat: Invalid path %s\n",path);
		glocal.ret = -1;
	}else if (strcmp(path,"/")==0){
		type = 'D';
	}else{
		glocal string dir;
		glocal string file;
		const char *pt = strrchr(path,'/');
		if (pt == path){
			glocal.dir = "/";
			glocal.file = path+1;
		}else{
			glocal.dir = string (path,pt-path);
			glocal.file = pt+1;
		}
		parent = glocal.dir;
		file = glocal.file;
		//tlmp_error ("bofs_stat: dir=%s file=%s\n",glocal.dir.c_str(),glocal.file.c_str());
		<call bod_client_listdir> (ctx.con,ctx.sessionid,glocal.dir,ctx.threshold,false);
		<f ok>
			glocal.ret = -1;
			if (success){
				for (unsigned i=0; i<entries.size(); i++){
					if (strcmp(entries[i],glocal.file.c_str())==0){
						glocal.ret = 0;
						(*glocal.type) = types[i];
						(*glocal.modified) = modified[i];
						(*glocal.owner) = owners[i];
						(*glocal.size) = sizes[i];
						break;
					}
				}
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

static int bofs_stat (CONTEXT &ctx, PARAM_STRING _path, char &type)
{
	string parent,file,modified,owner;
	unsigned size;
	return bofs_stat (ctx,_path,type,parent,file,modified,owner,size);
}
<mod>
static int bofs_ls (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool opt_long = false;
	glocal bool opt_history = false;
	glocal CONTEXT *ctx = &ctx;
	glocal const char *threshold = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bols",VERSION
			,"Command line tool to list bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
		setarg ('h',"long","Show all versions of files and sub-directories",glocal.opt_history,false);
		setarg ('l',"long","Long listing",glocal.opt_long,false);
		setarg ('t',"threshold","Date threshold, only older-or-equal entries are shown/used (aaaa/mm/jj-hh:mm:ss)",glocal.threshold,false);
	</f>
	<f main>
		int ret = 0;
		if (glocal.threshold != NULL) glocal.ctx->threshold = glocal.threshold;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = 0;
			glocal const char *path = path;
			<call bod_client_listdir> (glocal.ctx->con,glocal.ctx->sessionid,path,glocal.ctx->threshold,glocal.opt_history);
			<f ok>
				if (!success){
					char type;
					string parent, file, modified, owner;
					unsigned size;
					if (bofs_stat(*glocal.ctx,glocal.path,type,parent,file,modified,owner,size)==-1){
						tlmp_error ("ls: %s\n",msg);
						glocal.ret = -1;
					}else{
						if (glocal.opt_long){
							printf ("\t%c %s %s %u %s\n",type,modified.c_str(),owner.c_str(),size,file.c_str());
						}else{
							printf ("%s\n",file.c_str());
						}
					}
				}else{
					if (glocal.opt_long){
						for (unsigned i=0; i<entries.size(); i++){
							printf ("\t%c %s %s %u %s\n",types[i],modified[i],owners[i],sizes[i],entries[i]);
						}
					}else{
						for (auto e:entries) printf ("%s\n",e);
					}
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f https_file>
			return -1;
		</f>
		<f local_file>
			return system (string_f("ls %s %s",glocal.opt_long ? "-l" : "",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat_rest (CONTEXT &ctx, const char *handle, FILE *fin)
{
	glocal int ret = 0;
	bool more = true;
	while (more && glocal.ret == 0){
		char buf[50000];
		int len = fread (buf,1,50000,fin);
		more = len == 50000;
		<call bod_client_appendfile>(ctx.con,ctx.sessionid,handle,BOB_TYPE(buf,len,false),more);
		<f ok>
			if (!success){
				tlmp_error ("cat_rest: %s\n",msg);
				glocal.ret = -1;
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat_bofile (CONTEXT &ctx, const char *path, FILE *fout)
{
	glocal int ret = 0;
	glocal FILE *fout = fout;
	glocal CONTEXT *ctx = &ctx;
	<call bod_client_readfile_bob> (ctx.con,ctx.sessionid,path,ctx.threshold);
	<f ok>
		if (!success){
			tlmp_error ("bofs cp: %s\n",msg);
			glocal.ret = -1;
		}else{
			fwrite (content.getbuffer(),1,content.getsize(),glocal.fout);
			glocal bool more = more;
			while (glocal.more){
				<call bod_client_readmore>(glocal.ctx->con,glocal.ctx->sessionid,handle);
				<f ok>
					fwrite (content.getbuffer(),1,content.getsize(),glocal.fout);
					glocal.more = more;
				</f>
				</call>
			}
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_write_bofile(CONTEXT &ctx, PARAM_STRING path, FILE *fin)
{
	glocal int ret = 0;
	glocal CONTEXT *ctx = &ctx;
	glocal FILE *fin = fin;
	string modified;
	char type;
	char buf[50000];
	int len = fread (buf,1,50000,fin);
	glocal bool more = len == 50000;
	if (bofs_stat(ctx,path,type)==-1){
		<call bod_client_addfile_bob> (ctx.con,ctx.sessionid,path,BOB_TYPE(buf,len,false),glocal.more);
		<f ok>
			if (!success){
				tlmp_error ("cat: %s\n",msg);
				glocal.ret = -1;
			}else if (glocal.more){
				glocal.ret = bofs_cat_rest (*glocal.ctx,handle,glocal.fin);
			}
		</f>
		</call>
	}else if (type != 'F'){
		tlmp_error ("Can't modify %s, not a file\n",path);
	}else{ 
		<call bod_client_modifyfile_bob> (ctx.con,ctx.sessionid,path,BOB_TYPE(buf,len,false),glocal.more);
		<f ok>
			if (!success){
				tlmp_error ("cat: %s\n",msg);
				glocal.ret = -1;
			}else if (glocal.more){
				glocal.ret = bofs_cat_rest (*glocal.ctx,handle,glocal.fin);
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

<mod>
static int bofs_cat (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal const char *pipeto = NULL;
	glocal const char *threshold = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocat",VERSION
			,"Command line tool to cat bolixo content\n"
			 "\n"
			 "bofs cat  ...\n"
			);
		setarg ('p',"pipeto","Pipe input to this file",glocal.pipeto,false);
		setarg ('t',"threshold","Date threshold, only older-or-equal entries are shown/used (aaaa/mm/jj-hh:mm:ss)",glocal.threshold,false);
	</f>
	<f main_noarg>
		int ret = -1;
		if (glocal.pipeto == NULL){
			usage();
		}else{
			char *argv[1] = {(char*)glocal.pipeto};
			ret = <call bofs_split>(1,argv);
			<f bo_file>
				return bofs_write_bofile (*glocal.ctx,path,stdin);
			</f>
			<f https_file>
				return -1;
			</f>
			<f local_file>
				return system (string_f("cat >%s",path).c_str());
			</f>
			</call>
		}
		return ret;
	</f>
	<f main>
		int ret = 0;
		if (glocal.threshold != NULL) glocal.ctx->threshold = glocal.threshold;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			return bofs_cat_bofile (*glocal.ctx,path,stdout);
		</f>
		<f https_file>
			return -1;
		</f>
		<f local_file>
			return system (string_f("cat %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
enum BO_SOURCE { BO_ENTRY, HTTPS_ENTRY, LOCAL_ENTRY};

struct BO_ARGTYPE{
	string path;
	BO_SOURCE source;
	char type;
	BO_ARGTYPE(PARAM_STRING _path, BO_SOURCE _source, char _type){
		path = _path.ptr;
		source = _source;
		type = _type;
	} 
};

<mod>
static int bofs_copy_file(CONTEXT &ctx, PARAM_STRING path0, BO_SOURCE src0, PARAM_STRING path1, BO_SOURCE src1)
{
	glocal CONTEXT *ctx = &ctx;
	glocal int ret = 0;
	if (src0 == src1){
		if (src0 == LOCAL_ENTRY){
			// Copying two local files
			glocal.ret = system (string_f ("cp %s %s",path0,path1).c_str());
		}else if (src0 == BO_ENTRY){
			<call bod_client_copy>(ctx.con,ctx.sessionid,path0,path1);
			<f ok>
				if (!success){
					glocal.ret = -1;
					tlmp_error ("bofs cp: %s\n",msg);
				}
			</f>
			</call>
		}else if (src0 == HTTPS_ENTRY){
			glocal.ret = -1;
		}
	}else if (src0 == LOCAL_ENTRY && src1 == BO_ENTRY){
		FILE *fin = fopen (path0.ptr,"r");
		if (fin == NULL){
			tlmp_error ("bofs cp: Can't open file %s (%s)\n",path0,strerror(errno));
			glocal.ret = -1;
		}else{
			glocal.ret = bofs_write_bofile (*glocal.ctx,path1,fin);
			fclose (fin);
		}
	}else if (src0 == BO_ENTRY && src1 == LOCAL_ENTRY){
		glocal const char *path0 = path0.ptr;
		<call savefile>(path1,false);
		<f dowrite>
			glocal.ret = bofs_cat_bofile (*glocal.ctx,glocal.path0,fout);
			return 0;
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>
<mod>
static int bofs_checkargs (CONTEXT &ctx, int argc, char *argv[], vector<BO_ARGTYPE> &args)
{
	glocal CONTEXT *ctx = &ctx;
	glocal vector<BO_ARGTYPE> *args = &args;
	int ret = <call bofs_split>(argc,argv);
	<f bo_file>
		char type;
		bofs_stat (*glocal.ctx,path,type);
		glocal.args->push_back(BO_ARGTYPE(path,BO_ENTRY,type));
		return 0;
	</f>
	<f local_file>
		struct stat64 st;
		char type = ' ';
		if (stat64(path,&st)!=-1){
			if (S_ISDIR(st.st_mode)){
				type = 'D';
			}else if (S_ISREG(st.st_mode)){
				type = 'F';
			}else{
				tlmp_error ("bofs cp: Unsupported file type %s\n",path);
				exit (-1);
			}
		}
		glocal.args->push_back(BO_ARGTYPE(path,LOCAL_ENTRY,type));
		return 0;
	</f>
	</call>
	return ret;
}
</mod>
<mod>
static int bofs_cp (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bocp",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = 0;
		vector<BO_ARGTYPE> args;
		if (bofs_checkargs (*glocal.ctx, argc, argv, args)==-1){
			ret = -1;
		}else{
			size_t args_size = args.size();
			// Check if all the entries prior to the last one exist in the file systems
			bool missing_one = false;
			for (unsigned i=0; i<args_size-1; i++){
				if (args[i].type == ' '){
					// Entry does not exist
					missing_one = true;
					tlmp_error ("bofs cp: Source file/directory %s is missing, can't continue\n"
						,args[i].path.c_str());
				}
			}
			if (missing_one){
				ret = -1;
			}else if (args_size < 2){
				tlmp_error ("bofs cp: minimum 2 arguments\n");
				ret = -1;
			}else if (args[args_size-1].type == 'D'){
				// Last argument is a directory
				size_t last = args_size-1;
				const BO_SOURCE dest_source = args[last].source;
				const char *dir = args[last].path.c_str();
				for (unsigned i=0; ret != -1 && i<last; i++){
					const char *name = args[i].path.c_str();
					const char *pt = strrchr(name,'/');
					if (pt != NULL) name = pt+1;
					string dest = string_f("%s/%s",dir,name);
					if (args[i].type == 'D'){
						if (dest_source == BO_ENTRY && args[i].source == BO_ENTRY){
							glocal int ret = 0;
							<call bod_client_copy>(glocal.ctx->con,glocal.ctx->sessionid,args[i].path,dest);
							<f ok>
								if (!success){
									glocal.ret = -1;
									tlmp_error ("bofs cp: %s\n",msg);
								}
							</f>
							</call>
							ret = glocal.ret;
						}else{
							tlmp_error ("bofs cp: Can't copy directory yet\n");
							ret = -1;
						}
					}else{
						ret = bofs_copy_file (*glocal.ctx,args[i].path,args[i].source,dest,dest_source);
					}
				}
			}else if (args_size != 2){
				// Last argument is a file, problem
				tlmp_error ("bofs cp: Can't copy multiple inputs onto a file\n");
				ret = -1;
			}else if (args[0].type != 'F'){
				tlmp_error ("bofs cp: Can't copy a directory over a file\n");
				ret = -1;
			}else{
				// Ok, we copy a file onto a file
				ret = bofs_copy_file (*glocal.ctx
					,args[0].path,args[0].source
					,args[1].path,args[1].source);
			}
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_rm (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("borm",VERSION
			,"Command line tool to copy bolixo content\n"
			 "\n"
			 "bofs rm ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_delfile> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't delete bolixo file %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rm %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_mv (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomv",VERSION
			,"Command line tool to move/rename bolixo content\n"
			 "\n"
			 "bofs mv ...\n"
			);
	</f>
	<f main>
		glocal int ret = 0;
		vector<BO_ARGTYPE> args;
		if (bofs_checkargs (*glocal.ctx, argc, argv, args)==-1){
			glocal.ret = -1;
		}else{
			if (args.size() != 2){
				tlmp_error ("bofs mv: Accepts only two arguments\n");
				glocal.ret = -1;
			}else{
				BO_SOURCE src0 = args[0].source;
				if (src0 != args[1].source){
					tlmp_error ("bofs mv: Can't mv file across different filesystems\n");
					glocal.ret = -1;
				}else{
					const char *path0 = args[0].path.c_str();
					const char *path1 = args[1].path.c_str();
					if (src0 == LOCAL_ENTRY){
						glocal.ret = system (string_f ("mv %s %s",path0,path1).c_str());
					}else if (src0 == BO_ENTRY){
						<call bod_client_rename> (glocal.ctx->con,glocal.ctx->sessionid,path0,path1);
						<f ok>
							if (!success){
								glocal.ret = -1;
								tlmp_error ("bofs mv: %s\n",msg);
							}
						</f>
						</call>
					}else{
						glocal.ret = -1;
					}
				}
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_mkdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bomkdir",VERSION
			,"Command line tool to create bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_mkdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't create directory %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("mkdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>
<mod>
static int bofs_rmdir (CONTEXT &ctx, int argc, char *argv[])
{
	glocal int ret = -1;
	glocal CONTEXT *ctx = &ctx;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bormdir",VERSION
			,"Command line tool to remove bolixo directory\n"
			 "\n"
			 "bofs ls ...\n"
			);
	</f>
	<f main>
		int ret = -1;
		ret = <call bofs_split>(argc,argv);
		<f bo_file>
			glocal int ret = -1;
			glocal const char *path = path;
			<call bod_client_rmdir> (glocal.ctx->con,glocal.ctx->sessionid,path);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("Can't remove directory %s: %s\n",glocal.path,msg);
				}
			</f>
			</call>
			return glocal.ret;
		</f>
		<f local_file>
			return system (string_f("rmdir %s",path).c_str());
		</f>
		</call>
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>



<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *user = NULL;
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bofs",VERSION
			,"Command line tool to perform filesystem operations on bolixo\n"
			 "\n"
			 "\tbofs cat ...\n"
			 "\tbofs cp ...\n"
			 "\tbofs ls ...\n"
			 "\tbofs mkdir ...\n"
			 "\tbofs mv ...\n"
			 "\tbofs rm ...\n"
			 "\tbofs rmdir ...\n"
			);
		setarg ('u',"user","Select one user from .bofs.conf",glocal.user,false);
	</f>
	<f main>
		int ret = -1;
		glocal CONTEXT ctx;
		glocal bool thisuser = false;
		<call loadfile>(string_f("%s/.bofs.conf",getenv("HOME")),true);
		<f oneline>
			int ret = 0;
			vector<string> tb;
			int n = str_splitline(line,' ',tb);
			if (n >=2){
				const char *subject = tb[0].c_str();
				if (strcmp(subject,"user:")==0){
					if (glocal.thisuser){
						ret = -1;
					}else if (glocal.user == NULL || strcmp(glocal.user,tb[1].c_str())==0){
						glocal.thisuser = true;
					}
				}else if (glocal.thisuser){
					if (strcmp(subject,"email:")==0){
						glocal.ctx.email = tb[1];
					}else if (strcmp(subject,"password:")==0){
						glocal.ctx.password = tb[1];
					}else if (strcmp(subject,"bod_socket:")==0){
						glocal.ctx.con.port = tb[1];
					}else if (strcmp(subject,"sess_socket:")==0){
						glocal.ctx.con_sess.port = tb[1];
					}else if (strcmp(subject,"bod_secret:")==0){
						glocal.ctx.con.secret = tb[1];
					}else if (strcmp(subject,"sess_secret:")==0){
						glocal.ctx.con_sess.secret = tb[1];
					}else{
						tlmp_error ("File %s, invalide keyword: %s\n",info.filename,subject);
					}
				}
			}
			return ret;
		</f>
		<f missing>
			tlmp_error ("File %s/.bofs.conf missing.\n",getenv("HOME"));
			tlmp_error ("Create this file with the following fields:\n"
				"\temail:\n"
				"\tpassword:\n"
				"\tbod_socket:\n"
				"\tsess_socket:\n"
				"\tbod_secret:\n"
				"\tsess_secret:\n");
				exit (-1);
		</f>
		</call>
		glocal.ctx.sessionid = bod_login (glocal.ctx.con,glocal.ctx.email,glocal.ctx.password);
		if (glocal.ctx.sessionid.size() > 0){
			if (strcmp(argv[0],"ls")==0){
				ret = bofs_ls (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cat")==0){
				ret = bofs_cat (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"cp")==0){
				ret = bofs_cp (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rm")==0){
				ret = bofs_rm (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"mv")==0){
				ret = bofs_mv (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"mkdir")==0){
				ret = bofs_mkdir (glocal.ctx,argc,argv);
			}else if (strcmp(argv[0],"rmdir")==0){
				ret = bofs_rmdir (glocal.ctx,argc,argv);
			}else{
				tlmp_error ("Invalid command: %s\n",argv[0]);
				usage();
			}
			bod_logout (glocal.ctx.con,glocal.ctx.sessionid);
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

