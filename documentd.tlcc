/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Documents and games manager.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <translat.h>
#include <deque>
#include <memory>
#include <string>
#include "filesystem.h"
#include "bolixo.h"
#include "bolixo.m"
#define INSTRUMENT_DONOTOPEN
#include "instrument.h"
#include "helper.h"

static DEBUG_KEY D_SUDOKU("sudoku","sudoku game");

using namespace std;
static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

// Load and save may be spread over several calls
// We save the gameid to make sure
// This will be needed when loadmore is implemented
struct LOADSAVE{
	vector<string> lines;
};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	map<string,LOADSAVE> bufs;	// Used to handle save and load request from bod
					// The string is the gameid
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
class DOC_WRITER{
	FILE *fout = nullptr;
	vector<string> lines;
public:
	DOC_WRITER(){}
	DOC_WRITER(FILE *_fout): fout(_fout){
	}
	int write (const char *buf, unsigned len){
		int ret = -1;
		if (fout != nullptr){
			ret = fwrite (buf,1,len,fout);
		}else{
			FILE *f = fopen ("/tmp/save.log","a");
			fprintf (f,"%s",buf);
			fclose (f);
			lines.push_back(string(buf));
			ret = len;
		}
		return ret;
	}
	int write (const string &l){
		return write (l.c_str(),l.size());
	}
	BOB_TYPE getcontent () const {
		size_t size = 0;
		for (auto &s:lines) size += s.size();
		BOB_TYPE ret (size);
		char *buf = (char*)ret.getbuffer();
		for (auto &s:lines){
			memcpy(buf,s.c_str(),s.size());
			buf += s.size();
		}
		return ret;
	}
};

static void fflush (DOC_WRITER *){}


class DOC_READER{
public:
	FILE *fin = nullptr;
	const char *bufptr = nullptr;
	DOC_READER(FILE *_fin) : fin(_fin){}
	DOC_READER(const char *ptr) : bufptr(ptr){}
	DOC_READER(){}
};	
static char *fgets(char *s, int size, DOC_READER *r)
{
	char *ret = nullptr;
	if (r->fin != nullptr){
		ret = fgets(s,size,r->fin);
	}else if (r->bufptr != nullptr){
		const char *end = r->bufptr;
		if (*end != '\0'){
			while (*end != '\0' && *end != '\n') end++;
			int len = end - r->bufptr;
			if (len < size){
				ret = s;
				memcpy (s,r->bufptr,len);
				s[len] = '\0';
			}
			if (*end == '\n') end++;
			r->bufptr = end;
		}
	}
	return ret;
}
#include "proto/documentd_tictacto.protoh"
#include "proto/documentd_tictacto.protoch"
#include "proto/documentd_sudoku.protoh"
#include "proto/documentd_sudoku.protoch"
#include "proto/bod_client.protodef"
#include "proto/documentd_control.protoh"
#include "proto/documentd_client.protoh"

static string documentd_path (const char *name)
{
	return string_f("%s/bo-games/%s",getenv("HOME"),name);
}
static void documentd_error (vector<VARVAL> &res, PARAM_STRING s)
{
	VARVAL v;
	v.var = "error";
	v.val = s.ptr;
	res.push_back(v);
}

static void documentd_button (string &lines, unsigned command, const char *txt)
{
	lines += "&nbsp;";
	lines += string_f("<input form=\"form\" type=submit value='%s' onclick=gameaction('newgame=%u')>\n",txt,command);
}



class GAME{
	time_t modified = (time_t)0;
	time_t last_activity = time(nullptr);
	string modified_by;
public:
	void setactivity(){
		last_activity = time(nullptr);
	}
	void setactivity(time_t act){
		last_activity = act;
	}
	void setmodified(const char *_modified_by){
		modified = time(nullptr);
		modified_by = _modified_by;
	}
	void setmodified(time_t mod, const char *_modified_by){
		modified = mod;
		modified_by = _modified_by;
	}
	void resetmodified(){
		modified = (time_t)0;
		modified_by.clear();
	}
	bool is_modified() const{
		return modified != (time_t)0;
	}
	time_t get_modified() const {
		return modified;
	}
	const char *get_modified_by() const {
		return modified_by.c_str();
	}
	time_t get_last_activity() const {
		return last_activity;
	}
	virtual const char *getclass()=0;
	virtual void save(DOC_WRITER &writer, bool save_session_info)=0;
	virtual void load(DOC_READER &reader, string &msg)=0;
	virtual void resetgame() = 0;
	virtual void testwin(vector<VARVAL> &res) = 0;
	virtual void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res) = 0;
	virtual ~GAME(){};
};

using GAME_P = shared_ptr<GAME>;

<mod>
class TICTACTO: public GAME{
	bool x_is_player;
	unsigned char grid[3][3];
public:
	void save(DOC_WRITER &w, bool){
		documentd_tictacto_player(&w,x_is_player);
		unsigned row=0;
		for (auto &g:grid){
			documentd_tictacto_row(&w,row,g[0],g[1],g[2]);
			row++;
		}
	}
	void load(DOC_READER &r, string &msg){
		glocal x_is_player;
		glocal grid;
		glocal msg;
		<call documentd_tictacto>(&r);
		<f player>
			glocal.x_is_player = x_is_player;
		</f>
		<f row>
			if (rownum > 3){
				glocal.msg = string_f("Invalid row number for tictacto file: %u",rownum);
			}else{
				glocal.grid[rownum][0] = c1;
				glocal.grid[rownum][1] = c2;
				glocal.grid[rownum][2] = c3;
			}
		</f>
		<f invalid>
			glocal.msg = "Invalid format for tictacto file";
		</f>
		</call>
	}
	void resetgame(){
		x_is_player = true;
		memset (grid,0,sizeof(grid));
	}
	TICTACTO(){
		resetgame();
	}
	const char *getclass(){
		return "TICT";
	}
	void testwin(vector<VARVAL> &res){
		bool won = false;
		for (auto g:grid){
			unsigned char v = g[0];
			if (v != 0){
				bool found = true;
				for (unsigned j=1; j<3; j++){
					if (v != g[j]){
						found = false;
						break;
					}
				}
				if (found){
					won = true;
					break;
				}
			}
		}
		if (!won){
			for (unsigned i=0; i<3; i++){
				unsigned char v = grid[0][i];
				if (v != 0){
					bool found = true;
					for (unsigned j=1; j<3; j++){
						if (v != grid[j][i]){
							found = false;
							break;
						}
					}
					if (found){
						won = true;
						break;
					}
				}
			}
			if (!won){
				if (grid[0][0] != 0
					&& grid[0][0] == grid[1][1]
					&& grid[0][0] == grid[2][2]){
					won = true;
				}else if (grid[0][2] != 0
					&& grid[0][2] == grid[1][1]
					&& grid[0][2] == grid[2][0]){
					won = true;
				}
			}
		}
		if (won){
			VARVAL v;
			v.var = "result";
			v.val = "won";
			res.push_back(v);
		}
	}
	void draw_x(string &lines, unsigned x, unsigned y, unsigned len){
		const char *color = "black";
		const unsigned off = len/4;
		x += off;
		y += off;
		len -= off*2;
		lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M%u,%u L%u %u'/>\n"
			,color,x,y,x+len,y+len);
		lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M%u,%u L%u %u'/>\n"
			,color,x,y+len,x+len,y);
	}
	void draw_o(string &lines, unsigned x, unsigned y, unsigned len){
		const unsigned off = len/4;
		x += off;
		y += off;
		len -= off*2;
		lines += string_f("<circle stroke='black' stroke-width='2' fill='none' cx='%u' cy='%u' r='%u'/>\n"
			,x+len/2,y+len/2,len/2);
	}
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned win_width, unsigned win_height, vector<VARVAL> &res){
		setactivity();
		if (strcmp(var,"place")==0 && maywrite){
			bool ok = false;
			unsigned x=atoi(val);
			const char *pt = str_skipdig(val);
			const char *msg = "Invalid syntax";
			if (*pt == ','){
				pt++;
				unsigned y=atoi(pt);
				pt = str_skipdig(pt);
				if (*pt == '\0'){
					msg = "Invalid values";
					if (x < 3 && y < 3){
						unsigned char &g = grid[y][x];
						if (g == 0){
							g = x_is_player ? 1 : 2;
							x_is_player = !x_is_player;
							ok = true;
							setmodified(username);
						}else{
							msg = "Location already played";
						}
					}
				}
			}
			if (!ok){
				documentd_error (res,string_f("Invalid command %s=%s: %s",var,val,msg));
			}
		}else if (strcmp(var,"newgame")==0 && maywrite){
			resetgame();
			setmodified(username);
		}else if (strcmp(var,"print")==0){
			string lines;
			unsigned width = win_width - win_width % 4;
			//unsigned height = win_height - win_height % 3;
			unsigned w3 = width/4;
			unsigned h3 = w3;
			unsigned grid_width = w3*3;
			unsigned grid_height = grid_width;
			
			lines += "<script>\n";
			lines += "function gameplace(event){\n";
			lines += "\tvar elm = document.getElementById('gametictgrid');\n";
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('place='+Math.floor((event.clientY-rect.top)/%u)+','+Math.floor((event.clientX-rect.left)/%u));\n",h3,w3);
			lines += "}\n";
			lines += "</script>\n";
			
			lines += "<p>\n";
			lines += "<form>\n";
			lines += MSG_R(I_NEWGAME);
			documentd_button (lines,0,MSG_U(I_RESTART,"Restart"));
			lines += "</form>\n";
			lines += "<p>";
			lines += "<div>\n";
			lines += "<svg width='50px' height='200px' viewbox='0 0 50 200'>\n";
			draw_x (lines,0,0,50);
			draw_o (lines,0,100,50);
			lines += string_f("<path stroke='black' stroke-width='2' fill='none' d='M0,%u h50 v50 h-50 z'/>\n"
				,x_is_player ? 0 : 100);
			lines += "</svg>\n";
			lines += "&nbsp;&nbsp;&nbsp;";
			lines += "<a href='#' onclick=gameplace(event)>\n";
			lines += string_f("<svg id='gametictgrid' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",grid_width,grid_height,grid_width,grid_height);
			// Draw the board
			for (unsigned i=1; i<3; i++){
				lines += string_f("<path stroke='black' stroke-width='2' fill='black' d='M%u,1 L%u %u'/>\n"
					,i*w3,i*w3,grid_height);
				lines += string_f("<path stroke='black' stroke-width='2' fill='black' d='M1,%u L%u %u'/>\n"
					,i*h3,grid_width,i*h3);

			}
			// Draw the content
			for (unsigned x=0; x<3; x++){
				for (unsigned y=0; y<3; y++){
					unsigned val = grid[x][y];
					if (val == 1){
						draw_x (lines,x*h3,y*h3,h3);
					}else if (val == 2){
						draw_o (lines,x*h3,y*h3,h3);
					}
				}
			}
			lines += "</svg>\n";
			lines += "</a>\n";
			VARVAL v;
			v.var = "content";
			v.val = lines;
			res.push_back(v);
					
		}
	}
};
</mod>
struct SUDOKU_CELL{
	unsigned char visible;
	unsigned char value;
	unsigned char user_value;
	void reset(){
		visible = value = user_value = 0;
	}
	SUDOKU_CELL(){
		reset();
	}
};
class SUDOKU: public GAME{
	SUDOKU_CELL grid[9][9];	
	unsigned line,column;	// Currently selected 3x3 area
	map<string,unsigned> seldigs; // Selected digit used when setting a value
public:
	const char *getclass(){
		return "SUDO";
	}
	SUDOKU(){
		resetgame();
	}
	void save(DOC_WRITER &fout, bool save_session_info);
	void load(DOC_READER &r, string &msg);
	void resetgame();
	void testwin(vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res);
};

void SUDOKU::save (DOC_WRITER &w, bool save_session_info)
{
	if (save_session_info){
		for (auto &s:seldigs){
			documentd_sudoku_select(&w,s.first,s.second);
		}
	}
	for (auto &g:grid){
		for (auto &gg:g) documentd_sudoku_cell(&w,gg.visible,gg.value,gg.user_value);
	}
}
<mod>
void SUDOKU::load (DOC_READER &r, string &msg)
{
	glocal grid;
	glocal msg;
	glocal unsigned x=0;
	glocal unsigned y=0;
	glocal seldigs;
	resetgame();
	<call documentd_sudoku>(&r);
	<f cell>
		if (glocal.x > 8){
			glocal.msg = "Too many cells in the sodoku files";
			end  = true;
		}else{
			SUDOKU_CELL &gg = glocal.grid[glocal.x][glocal.y];
			gg.visible = visible;
			gg.value = value;
			gg.user_value = user_value;
			glocal.y = (glocal.y+1)%9;
			if (glocal.y == 0) glocal.x++;
		}
	</f>
	<f select>
		glocal.seldigs[session] = value;
	</f>
	<f invalid>
		glocal.msg = "Invalid format for sudoku file";
	</f>
	</call>
}
void SUDOKU::resetgame()
{
	line = column = 0;
	seldigs.clear();
	for (auto &g:grid){
		for (auto &gg:g){
			gg.reset();
		}
	}
}
void SUDOKU::testwin(vector<VARVAL> &res)
{
	unsigned nbok = 0;
	for (auto &g:grid){
		for (auto &gg:g){
			if (gg.visible || gg.value == gg.user_value) nbok++;
		}
	}
	if (nbok == 9*9){
		VARVAL v;
		v.var = "result";
		v.val = "won";
		res.push_back(v);
	}
}
<mod>
void SUDOKU::exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned win_width, unsigned win_height, vector<VARVAL> &res)
{
	setactivity();
	if (strcmp(var,"place")==0 && maywrite){
		unsigned lo,co,v;
		int n = sscanf(val,"%u,%u,%u",&lo,&co,&v);
		if (n == 2){
			auto &gg = grid[line*3+lo][column*3+co];
			if (gg.visible){
				documentd_error (res,"You can't set this cell");
			}else{
				// We can set a value. If it is wrong, it will show in red.
				// If you click over again, it will erase itself.
				unsigned newval = seldigs[session]+1;
				if (gg.user_value == 0){
					gg.user_value = newval;
				}else if (gg.user_value == newval){
					gg.user_value = 0;
				}
			}
			setmodified(username);
		}else{
			documentd_error (res,"Invalid place command (need 2 value)");
		}
	}else if (strcmp(var,"select")==0){
		unsigned sel = atoi(val);
		if (sel > 0 && sel < 10){
			seldigs[session] = sel-1;
			setmodified(username);
		}
	}else if (strcmp(var,"print")==0){
		string lines;
		if (strcmp(val,"console")==0){
			static const char *dashes = "\t+---+---+---+---+---+---+---+---+---+\n";	
			unsigned nol = 0;
			static const char *white = "\033[01;37m";
			static const char *green = "\033[01;32m";
			static const char *blue = "\033[01;34m";
			static const char *red = "\033[01;31m";
			static const char *bgblue = "\033[01;44m";
			static const char *normal = "\033[00m";
			for (auto &g:grid){
				if (nol % 3 == 0){
					lines += blue;
					lines += dashes;
					lines += normal;
				}else{
					lines += '\t';
					for (unsigned i=0; i<9; i++){
						if (i % 3 == 0){
							lines += blue;
						}else{
							lines += green;
						}
						lines += '+';
						lines += green;
						lines += "---";
					}
					lines += blue;
					lines += '+';
					lines += normal;
					lines += '\n';
				}
				lines += "\t";
				unsigned pos = 0;
				for (auto &gg:g){
					if (pos % 3 == 0){
						lines += blue;
						lines += '|';
					}else{
						lines += green;
						lines += '|';
					}
					lines += normal;
					if (nol / 3 == line && pos / 3 == column) lines += bgblue;
					if (gg.visible){
						lines += string_f("%s %c %s",white,gg.value+'0',normal);
					}else if (gg.user_value != 0){
						if (gg.user_value != gg.value){
							lines += red;
						}
						lines += string_f(" %c ",gg.user_value+'0');
						lines += normal;
					}else{
						lines += "   ";
					}
					lines += normal;
					pos++;
				}
				lines += blue;
				lines += "|\n";
				lines += normal;
				nol++;
			}
			lines += blue;
			lines += dashes;
			lines += normal;
		}else{
			// The layout is a square, constrained by the width
			unsigned width = win_width - win_width % 11;
			unsigned w9 = width/11;
			unsigned h9 = w9; 
			unsigned grid_width = w9*9;
			unsigned grid_height = grid_width;
			
			lines += "<script>\n";
			lines += "function gameselect(event){\n";
			lines += "\tvar elm = document.getElementById('gamesudosel');\n";
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			//lines += "\tconsole.log('target='+elm);\n";
			//lines += "\tconsole.log('target='+rect.height);\n";
			//lines += "\tconsole.log('left='+rect.left+' top='+rect.top+' bottom='+rect.bottom+' clientY='+event.clientY);\n";
			//lines += "\tconsole.log('sel='+((event.clientY-rect.top)/50+1));\n";
			lines += string_f("\tgameaction('select='+Math.floor((event.clientY-rect.top)/%u+1));\n",h9);
			lines += "}\n";
			lines += "function gameplace(event){\n";
			lines += "\tvar elm = document.getElementById('gamesudogrid');\n";
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('place='+Math.floor((event.clientY-rect.top)/%u)+','+Math.floor((event.clientX-rect.left)/%u));\n",h9,w9);
			lines += "}\n";
			lines += "</script>\n";
			
			lines += "<p>\n";
			lines += "<form>\n";
			lines += MSG_U(I_NEWGAME,"New game");
			documentd_button (lines,0,MSG_U(I_SIMPLE,"Simple"));
			documentd_button (lines,1,MSG_U(I_EASY,"Easy"));
			documentd_button (lines,2,MSG_U(I_INTERMEDIATE,"Intermediate"));
			documentd_button (lines,3,MSG_U(I_EXPERT,"Expert"));
			lines += "</form>\n";
			lines += "<p>";
			lines += "<div>\n";
			lines += "<a href='#' onclick=gameselect(event)>\n";
			lines += string_f("<svg id='gamesudosel' width='%upx' height='%upx' viewbox='0 0 30 270'>\n",w9,grid_height);
			unsigned seldig = seldigs[session];
			for (unsigned i=0; i<9; i++){
				lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M1,%u H29 v29 H1 Z'/>\n",i==seldig ? "pink" : "white"
					,i*30);
				lines += string_f("<text x='10' y='%u' style='stroke:%s;fill:%s;font-size:20;font-family: Times New Roman;'>%u</text>\n",i*30+20,"black","black",i+1);
			}
			lines += "</svg>\n";
			lines += "</a>";
			lines += "&nbsp;&nbsp;&nbsp;";
			lines += "<a href='#' onclick=gameplace(event)>\n";
			lines += string_f("<svg id='gamesudogrid' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",grid_width,grid_height,grid_width,grid_height);
			lines += string_f("<path stroke='green' stroke-width='2' fill='white' d='M1 1 H %u V %u H 1 Z'/>\n",grid_width-1,grid_height-1);
			unsigned line = 0;
			for (auto &g:grid){
				lines += string_f("<path stroke=%s stroke-width=1 d='M0,%u H %u'/>\n",line%3==0 ? "green" : "lightgray"
					,h9*line,grid_width);
				unsigned col = 0;
				for (auto &&gg:g){
					lines += string_f("<path stroke=%s stroke-width=1 d='M%u,0 V %u'/>\n",col%3==0 ? "green" : "lightgray"
						,w9*col,grid_height);
					if (gg.visible || gg.user_value != 0){
						const char *color = "gray";
						unsigned value = gg.value;
						if (!gg.visible){
							color = "black";
							value = gg.user_value;
							if (gg.user_value != gg.value) color = "red";
						}
						lines += string_f("<text X='%u' Y='%u' style='stroke:%s;fill:%s;font-size:24;font-family: Times New Roman;'>%u</text>\n",w9*col+w9/3,h9*line+2*h9/3
							,color,color,value);
					}
					col++;
				}
				line++;
			}
			lines += "</svg>\n";
			lines += "</a>\n";
			lines += "</div>\n";
		}
		VARVAL v;
		v.var = "content";
		v.val = lines;
		res.push_back(v);
	}else if (strcmp(var,"newgame")==0 && maywrite){
		glocal SUDOKU_CELL (*grid)[9][9] = &grid;
		unsigned difficulty = atoi(val);
		if (difficulty > 3){
			documentd_error (res,"Difficulty from 0 to 3");
		}else{
			static const char *tbdiff[]={"simple", "easy", "intermediate", "expert"};
			<call walkpopen>(string_f("qqwing --generate 1 --compact --solution --difficulty %s",tbdiff[difficulty]),10);
			<f oneline>
				debug_printf (D_SUDOKU,"read qqwing %s\n",line);
				if (noline < 9){
					auto &g = (*glocal.grid)[noline];
					for (unsigned i=0; i<9; i++){
						char car = line[i];
						auto &gg = g[i];
						gg.reset();
						if (car != '.'){
							gg.visible = 1;
							gg.value = car - '0';
						}
					}
				}
				if (noline >= 10 && noline < 19){
					auto &g = (*glocal.grid)[noline-10];
					for (unsigned i=0; i<9; i++){
						g[i].value = line[i]-'0';
					}				
				}
				return 0;
			</f>
			<f oneerr>
				tlmp_error ("sudoku command=%s line=%s\n",command,line);
				return 0;
			</f>
			</call>
			setmodified(username);
		}
	}else{
		tlmp_error ("sudoku invalid command %s\n",var);
	}
}
</mod>

class WORDPROC: public GAME{
	vector<string> lines;
public:
	const char *getclass(){
		return "WORD";
	}
	void save(DOC_WRITER &w, bool save_session_info);
	void load(DOC_READER &r, string &msg);
	void resetgame();
	void testwin(vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res);
};

void WORDPROC::save(DOC_WRITER &w, bool save_session_info)
{
}
void WORDPROC::load(DOC_READER &r, string &msg)
{
}
void WORDPROC::resetgame()
{
	lines.clear();
}
void WORDPROC::testwin(vector<VARVAL> &res)
{
}
void WORDPROC::exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res)
{
}
class CHECKERS: public GAME{
	unsigned char grid[8][8];
public:
	const char *getclass(){
		return "CHEC";
	}
	void save(DOC_WRITER &w, bool save_session_info);
	void load(DOC_READER &r, string &msg);
	void resetgame();
	void testwin(vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res);
};

void CHECKERS::save(DOC_WRITER &w, bool save_session_info)
{
	#if 0
	for (auto &g:grid){
		for (auto &gg:g){
			fprintf (fout," %u",gg);
		}
		fprintf (fout,"\n");
	}
	#endif
}
void CHECKERS::load(DOC_READER &r, string &msg)
{
	#if 0
	resetgame();
	for (auto &g:grid){
		unsigned v[8];
		if (fscanf(fin,"%u %u %u %u %u %u %u %u\n",&v[0],&v[1],&v[2],&v[3],&v[4],&v[5],&v[6],&v[7])==8){
			for (unsigned i=0; i<8; i++) g[i] = v[i];
		}
	}
	#endif
}
void CHECKERS::resetgame()
{
	for (auto &g:grid) for (auto &gg:g) gg=0;
	for (unsigned i=0; i<3; i++){
		unsigned start = (i+1)&1;
		for (unsigned j=start; j<8; j+=2){
			grid[i][j] = 1;
		}
		unsigned ii=5+i;
		start = i&1;
		for (unsigned j=start; j<8; j+=2){
			grid[ii][j] = 2;
		}
	}
}
void CHECKERS::testwin(vector<VARVAL> &res)
{
}

static const char *cnv (const char *val, unsigned &posx, unsigned &posy)
{
	val = str_skip(val);
	if (islower(*val)){
		posy = *val - 'a';
	}else if (isupper(*val)){
		posy = *val - 'A';
	}
	posx = 8-atoi(val+1);
	return val+2;
}
		
void CHECKERS::exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned width, unsigned height, vector<VARVAL> &res)
{
	if (strcmp(var,"print")==0){
		string lines;
		//static const char *white = "\033[01;37m";
		//static const char *green = "\033[01;32m";
		//static const char *blue = "\033[01;34m";
		//static const char *red = "\033[01;31m";
		static const char *bgblue = "\033[01;44m";
		static const char *bggreen = "\033[01;42m";
		static const char *bgred = "\033[01;41m";
		static const char *bgblack = "\033[01;40m";
		static const char *normal = "\033[00m";
		static const char *tbcolor[]={bgblack,bgblue};
		unsigned nol = 0;
		for (auto &g:grid){
			static const char *tbl[]={
				"%s    %s  %s    ",
				"%s  %s      %s  ",
				"%s %s        %s ",
				"%s  %s      %s  ",
				"%s    %s  %s    ",
				//"%s          ",
			};
			for (unsigned i=0; i<5; i++){
				unsigned color = nol & 1;
				if (i == 2){
					lines += string_f("\t%d ",8-nol);
				}else{
					lines += "\t  ";
				}
				for (auto &gg:g){
					const char *bg = tbcolor[color];
					color = (color+1)&1;
					const char *bg1 = "";
					if (gg == 0){
						bg1 = bg;
					}else if (gg == 1){
						bg1 = bgred;
					}else if (gg == 2){
						bg1 = bggreen;
					}
					lines += string_f(tbl[i],bg,bg1,bg);
				}
				lines += normal;
				lines += '\n';
			}
			nol++;
		}	
		lines += "\t  ";
		for (unsigned i=0; i<8; i++) lines += string_f("    %c     ",i+'A');
		lines += '\n';
		VARVAL v;
		v.var = "content";
		v.val = lines;
		res.push_back(v);
	}else if (strcmp(var,"place")==0){
		unsigned fromx,fromy,tox,toy;
		const char *pt = cnv(val,fromx,fromy);
		cnv(pt,tox,toy);
		// printf ("from = %u %u to %u %u\n",fromx,fromy,tox,toy);
		unsigned char value = grid[fromx][fromy];
		if (value == 0){
			documentd_error (res,"Invalid move");
		}else if (grid[tox][toy] != 0){
			documentd_error (res,"Destination used");
		}else{
			grid[fromx][fromy] = 0;
			grid[tox][toy] = value;
		}
		setmodified (username);
	}
}


static bool documentd_playstep (
	map<string,GAME_P> &games,
	const char *gameid,
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	unsigned width,
	unsigned height,
	vector<VARVAL> &res,
	string &msg,
	bool &unknown)
{
	bool success = false;
	unknown = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		success = true;
		for (auto &v:steps){
			g->second->exec(v.var,v.val,session,username,maywrite,width,height,res);
		}
		g->second->testwin(res);
	}else{
		msg = "Unknown game id";
		unknown = true;
	}
	return success;
}

static GAME_P documentd_newgame(const char *type, string &msg)
{
	GAME_P p = nullptr;
	if (strncmp(type,"boBOTICT",8)==0){
		p = make_shared<TICTACTO>();
	}else if (strncmp(type,"boBOSUDO",8)==0){
		p = make_shared<SUDOKU>();
	}else if (strncmp(type,"boBOWORD",8)==0){
		p = make_shared<WORDPROC>();
	}else if (strncmp(type,"boBOCHEC",8)==0){
		p = make_shared<CHECKERS>();
	}else{
		msg = "Unknown game or document type";
	}
	return p;
}

static bool documentd_startgame(
	map<string,GAME_P> &games,
	const char *gamename,
	const char *gameid,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		msg = "Game already exist";
	}else{
		GAME_P p = documentd_newgame(gamename,msg);
		if (p != nullptr){
			games[gameid] = p;
			p->resetgame();
			ret = true;
		}
	}
	return ret;
}
static bool documentd_endgame (
	map<string,GAME_P> &games,
	const char *gameid,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		ret = true;
		games.erase (g);
	}else{
		msg = "Unknown game id";
	}
	return ret;
}

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/documentd.sock";
	glocal const char *clientsock = "/tmp/documentd_client.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *pidfile = "/var/run/documentd.pid";
	glocal const char *hostname = NULL;

	translat_setlang ("eng,fr");
	static const char *tbdic[]={"bolixo",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("documentd",VERSION,"Process document content");
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for documentd-control",glocal.control,false);
		setarg ('C',"clientsock","Unix socket for documentd-client",glocal.clientsock,false);
		setgrouparg ("Misc.");
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
		setarg (' ',"client-secrets","File holding client secrets for communication",glocal.client_secretfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		int ret = -1;
		glocal map<string,GAME_P> games;
		glocal unsigned messages_sent = 0;
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal string clientport = string_f("unix:%s",glocal.clientsock);
		glocal map<string,string> client_secrets;
		glocal pid_t pid = (pid_t)-1;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		signal (SIGCHLD,SIG_IGN);
		<obj TCPSERVER s>(glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(info.port,glocal.clientport)==0){
				n->req.secret = fdpass_findsecret (glocal.client_secrets,info.port);
				n->type = TYPE_CLIENT;
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call documentd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					instrument_status(tb);
					for (auto g:glocal.games){
						DATEASC act,mod;
						fdpass_asctime(g.second->get_last_activity(),act);
						if (g.second->is_modified()) fdpass_asctime(g.second->get_modified(),mod);
						tb.push_back(string_f("gameid: %s last_activity=%s modified=%s modified_by=%s",g.first.c_str()
							,act.buf,mod.buf,g.second->get_modified_by()));
					}
					rep_status(tb);
				</f>
				<f instrument>
					toggle_instrument_file(on);
				</f>
				<f quit>
					// Save all games/documents in a file
					unsigned num=0;
					for (auto &g:glocal.games){
						glocal GAME_P game = g.second;
						glocal const char *gameid = g.first.c_str();
						<call savefile>(string_f("/tmp/game.%u",num),false);
						<f dowrite>
							fprintf (fout,"%s\nmodified=%lu\nmodified_by=%s\nactivity=%lu\nboBO%s\n"
								,glocal.gameid,glocal.game->get_modified()
								,glocal.game->get_modified_by()
								,glocal.game->get_last_activity()
								,glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
						num++;
					}
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					bool success = documentd_endgame(glocal.games,gameid,msg);
					rep_endgame (success,msg);
				</f>
				<f resetgame>	// gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						success = true;
						g->second->resetgame();
					}else{
						msg = "Unknown game id";
					}
					rep_endgame (success,msg);
				</f>
				<f playstep>	// gameid steps:U{VARVAL}v width:u height:u = success:b msg res:U{VARVAL}v
					vector<VARVAL> res;
					string msg;
					bool unknown;
					bool success = documentd_playstep (glocal.games,gameid,steps,"sessadmin","admin",true,1000,1000,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f save> // gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal GAME_P game = g->second;
						success = true;
						<call savefile>(documentd_path(gameid),false);
						<f dowrite>
							fprintf (fout,"boBO%s\n",glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
					}else{
						msg = "Unknown game id";
					}
					rep_save(success,msg);
				</f>
				<f load> // gameid = success:b msg 
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal.games.erase (g);
					}
					string tmp = documentd_path(gameid);
					FILE *fin = fopen (tmp.c_str(),"r");
					if (fin == NULL){
						msg = "Gameid file does not exist";
					}else{
						char buf[100];
						if (fgets(buf,sizeof(buf)-1,fin)!=NULL){
							GAME_P p = documentd_newgame(buf,msg);
							if (p != NULL){
								glocal.games[gameid] = p;
								DOC_READER doc(fin);
								p->load (doc,msg);
								success = msg.size() == 0 ? true : false;
							}
						}
						fclose (fin);
					}
					rep_save(success,msg);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_CLIENT){
				<call documentd_client>(this,c->req,line,info.linelen, endserver, endclient,no,c);
				<f test>
					rep_test(true);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_endgame(glocal.games,gameid,msg);
					rep_endgame (success,msg);
				</f>
				<f playstep>
					vector<VARVAL> res;
					string msg;
					translat_selectlang(lang);
					bool unknown;
					bool success = documentd_playstep (glocal.games,gameid,steps,session,username,maywrite,width,height,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f save>
					string msg;
					BOB_TYPE content;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						GAME_P game = g->second;
						DOC_WRITER doc;
						doc.write (string_f("boBO%s\n",game->getclass()));
						game->save(doc,false);
						content = doc.getcontent();
						game->resetmodified();
					}else{
						msg = "Unknown game id";
					}
					if (msg.size() > 0){
						content.clear();
						rep_save(false,msg,content,false);
					}else{
						rep_save (true,"",content,false);
					}
				</f>
				<f savemore>
					BOB_TYPE content;
					rep_savemore (false,"Not inplemented",content,false);
				</f>
				<f load>
					string msg;
					auto g = glocal.games.find(gameid);
					const char *type = (const char *)content.getbuffer();
					GAME_P game = nullptr;
					if (g != glocal.games.end()){
						game = g->second;
					}else{
						game = documentd_newgame(type,msg);
					}
					if (game != nullptr){
						glocal.games[gameid] = game;
						DOC_READER doc(type+9);
						game->load(doc,msg);
					}
					if (msg.size() > 0){
						rep_load (false,msg);
					}else{
						rep_load (true,"");
					}
				</f>
				<f loadmore>
				</f>
				<f is_modified> // gameid = success:b msg modified:b
					bool modified = false;
					const char *modified_by = "";
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						modified = g->second->is_modified();
						modified_by = g->second->get_modified_by();
					}else{
						msg = "Unknown document";
					}
					if (msg.size() > 0){
						rep_is_modified(false,msg,false,"");
					}else{
						rep_is_modified(true,"",modified,modified_by);
					}
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			// Load saved games/documents
			if (file_type("/tmp/game.0")==0){
				<call walkfs>("/tmp");
				<f onefile>
					if (strncmp(basename,"game.",5)==0){
						FILE *fin = fopen (path,"r");
						if (fin == nullptr){
							tlmp_error ("Can't open saved game %s (%s)\n",path,strerror(errno));
						}else{
							char buf1[1000],buf2[1000];
							if (fgets(buf1,sizeof(buf1)-1,fin)!=nullptr
								&& fgets(buf2,sizeof(buf2)-1,fin)!=nullptr){
								strip_end (buf1);
								const char *pt;
								time_t mod = 0;
								if (is_start_any_of(buf2,pt,"modified=")){
									mod = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								string mod_by;
								if (is_start_any_of(buf2,pt,"modified_by=")){
									mod_by = pt;
									strip_end (mod_by);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								time_t act = 0;
								if (is_start_any_of(buf2,pt,"activity=")){
									act = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								strip_end (buf2);
								string msg;
								if (!documentd_startgame(glocal.games,buf2,buf1,msg)){
									tlmp_error ("Can't initialise game %s/%s (%s)\n",buf1,buf2,msg.c_str());
								}else{
									DOC_READER doc(fin);
									auto g = glocal.games[buf1];
									g->load(doc,msg);
									g->setmodified(mod,mod_by.c_str());
									g->setactivity(act);
								}
							}
							fclose (fin);
						}
						unlink (path);
					}
				</f>
				</call>
			}
			chmod (glocal.clientsock,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			open_instrument_file();
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

