/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Documents and games manager.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <translat.h>
#include <deque>
#include <memory>
#include <string>
#include "filesystem.h"
#include "bolixo.h"
#include "bolixo.m"
#define INSTRUMENT_DONOTOPEN
#include "instrument.h"
#include "helper.h"
#include "documentd.h"


using namespace std;
static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

// Load and save may be spread over several calls
// We save the gameid to make sure
// This will be needed when loadmore is implemented
struct LOADSAVE{
	vector<string> lines;
};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	map<string,LOADSAVE> bufs;	// Used to handle save and load request from bod
					// The string is the gameid
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
DOC_WRITER::DOC_WRITER(FILE *_fout): fout(_fout)
{
}
int DOC_WRITER::write (const char *buf, unsigned len)
{
	int ret = -1;
	if (fout != nullptr){
		ret = fwrite (buf,1,len,fout);
	}else{
		FILE *f = fopen ("/tmp/save.log","a");
		fprintf (f,"%s",buf);
		fclose (f);
		lines.push_back(string(buf,len));
		ret = len;
	}
	return ret;
}
int DOC_WRITER::write (const string &l)
{
	return write (l.c_str(),l.size());
}
BOB_TYPE DOC_WRITER::getcontent () const
{
	size_t size = 0;
	for (auto &s:lines) size += s.size();
	BOB_TYPE ret (size);
	char *buf = (char*)ret.getbuffer();
	for (auto &s:lines){
		memcpy(buf,s.c_str(),s.size());
		buf += s.size();
	}
	return ret;
}

void fflush (DOC_WRITER *){}


char *fgets(char *s, int size, DOC_READER *r)
{
	char *ret = nullptr;
	if (r->fin != nullptr){
		ret = fgets(s,size,r->fin);
	}else if (r->bufptr != nullptr){
		const char *end = r->bufptr;
		if (*end != '\0'){
			while (*end != '\0' && *end != '\n') end++;
			int len = end - r->bufptr;
			if (len < size){
				ret = s;
				memcpy (s,r->bufptr,len);
				s[len] = '\0';
			}
			if (*end == '\n') end++;
			r->bufptr = end;
		}
	}
	return ret;
}
#include "proto/bod_client.protodef"
#include "proto/documentd_control.protoh"
#include "proto/documentd_client.protoh"

static string documentd_path (const char *name)
{
	return string_f("%s/bo-games/%s",getenv("HOME"),name);
}
void documentd_error (vector<VARVAL> &res, PARAM_STRING s)
{
	VARVAL v;
	v.var = VAR_ERROR;
	v.val = s.ptr;
	res.push_back(v);
}
void documentd_forcerefresh (vector<VARVAL> &res)
{
	VARVAL v;
	v.var = VAR_REFRESH;
	res.push_back(v);
}
void documentd_setchanges (vector<VARVAL> &res)
{
	VARVAL v;
	v.var = VAR_CHANGES;
	res.push_back(v);
}

/*
	Escape ' in a stringh
*/
string documentd_escape(PARAM_STRING msg)
{
	string tmp;
	const char *pt = msg.ptr;
	while (*pt != '\0'){
		if (*pt == '\''){
			tmp += '\\';
		}
		tmp += *pt++;
	}
	return tmp;
}
void documentd_button_start(string &lines, const string &gameid)
{
	lines += string_f("<div id='buttons-%s' style='display:flex; flex-flow:row;'>\n",gameid.c_str());
}
void documentd_button_end(string &lines)
{
	lines += "</div>\n";
}
void documentd_button_label (string &lines, PARAM_STRING txt)
{
	lines += string_f("<div style='flex:0 1 auto;'>%s</div>\n",txt.ptr);
}
void documentd_button (string &lines, unsigned command, PARAM_STRING txt, bool highlit)
{
	lines += "&nbsp;";
	lines += string_f("<div class=button id=button%u onclick=gameaction('newgame:%u')"
		" style='background-color:%s;flex:0 1 auto; border-radius:4px; text-align:center; border:1px solid black;"
		" padding-left:5; padding-right:5;  margin-left:5; margin-top:2; margin-bottom:2;'>%s</div>\n"
		,command,command,highlit ? "lightblue" : "lightgray",txt.ptr);
}
void documentd_button (string &lines, unsigned command, PARAM_STRING txt, const DOC_BUTTON_SPECS &specs, bool highlit)
{
	lines += "&nbsp;";
	lines += string_f("<div class=button id=button%u onclick=gameaction('newgame:%u')"
		" style='background-color:%s;flex:0 1 auto; border-radius:%upx; width:%u; text-align:center; border:1px solid black; margin-left:%u; margin-top:%u; margin-bottom:%u;'>%s</div>\n"
		,command,command,highlit ? "lightblue" : "lightgray"
		,specs.radius,specs.width,specs.margin_left,specs.margin_top,specs.margin_bottom,txt.ptr);
}

using GAME_P = shared_ptr<GAME>;


void GAME::manyexec (
	const std::vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	for (auto &v:steps){
		exec(v.var,v.val,session,username,maywrite,sp,res);
	}
}

static bool documentd_playstep (
	map<string,GAME_P> &games,
	const char *gameid,
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res,
	string &msg,
	bool &unknown)
{
	bool success = false;
	unknown = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		success = true;
		g->second->manyexec(steps,session,username,maywrite,sp,res);
		g->second->testwin(res);
	}else{
		msg = "Unknown game id";
		unknown = true;
	}
	return success;
}

static GAME_P documentd_newgame(const char *type, const char *gameid, string &msg)
{
	GAME_P p = nullptr;
	if (strncmp(type,"boBOTICT",8)==0){
		p = make_shared<TICTACTO>();
	}else if (strncmp(type,"boBOSUDO",8)==0){
		p = make_shared<SUDOKU>();
	}else if (strncmp(type,"boBOWORD",8)==0){
		p = make_shared<WORDPROC>();
	}else if (strncmp(type,"boBOCHEC",8)==0){
		p = make_shared<CHECKERS>();
	}else if (strncmp(type,"boBOCHES",8)==0){
		p = make_shared<CHESS>();
	}else{
		msg = "Unknown game or document type";
	}
	if (p != nullptr) p->setgameid(gameid);
	return p;
}

static bool documentd_startgame(
	map<string,GAME_P> &games,
	const char *gamename,
	const char *gameid,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		msg = "Game already exist";
	}else{
		GAME_P p = documentd_newgame(gamename,gameid,msg);
		if (p != nullptr){
			games[gameid] = p;
			p->resetgame();
			ret = true;
		}
	}
	return ret;
}
static bool documentd_endgame (
	map<string,GAME_P> &games,
	const char *gameid,
	unsigned revision,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		if (g->second->get_revision() != revision){
			msg = "Revision mismatch";
		}else{
			ret = true;
			games.erase (g);
		}
	}else{
		msg = "Unknown game id";
	}
	return ret;
}

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/documentd.sock";
	glocal const char *clientsock = "/tmp/documentd_client.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *pidfile = "/var/run/documentd.pid";
	glocal const char *hostname = NULL;

	translat_setlang ("eng,fr");
	static const char *tbdic[]={"bolixo",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("documentd",VERSION,"Process document content");
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for documentd-control",glocal.control,false);
		setarg ('C',"clientsock","Unix socket for documentd-client",glocal.clientsock,false);
		setgrouparg ("Misc.");
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
		setarg (' ',"client-secrets","File holding client secrets for communication",glocal.client_secretfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main>
		// This is used for testing/debug
		void wordproc_testparagraph (const char *line, unsigned width, unsigned fontsize, unsigned para_cursor);
		if (strcmp(argv[0],"testparagraph")==0){
			if (argc > 1){
				for (int i=1; i<argc; i++){
					const char *arg = argv[i];
					printf ("----%s\n",arg);
					for (unsigned col=0; col<15; col++){
						wordproc_testparagraph(arg,300,14,col);
					}
				}
			}else{
				for (auto s:{
					"1234\013b;BOLD\014abcd",
					//"1234\016abcd",
					//"this is a short line",
					//"this is a short paragraph using a much longer line that is talking about nothing useful and even more"
					}){
					printf ("----%s\n",s);
					for (unsigned col=0; col<15; col++){
						wordproc_testparagraph(s,300,14,col);
					}
				}
			}
		}
		return 0;
	</f>
	<f main_noarg>
		int ret = -1;
		glocal map<string,GAME_P> games;
		glocal unsigned messages_sent = 0;
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal string clientport = string_f("unix:%s",glocal.clientsock);
		glocal map<string,string> client_secrets;
		glocal pid_t pid = (pid_t)-1;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		signal (SIGCHLD,SIG_IGN);
		<obj TCPSERVER s>(glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(info.port,glocal.clientport)==0){
				n->req.secret = fdpass_findsecret (glocal.client_secrets,info.port);
				n->type = TYPE_CLIENT;
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call documentd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					instrument_status(tb);
					for (auto g:glocal.games){
						DATEASC act,mod;
						fdpass_asctime(g.second->get_last_activity(),act);
						if (g.second->is_modified()) fdpass_asctime(g.second->get_modified(),mod);
						tb.push_back(string_f("gameid: %s last_activity=%s modified=%s modified_by=%s revision=%u",g.first.c_str()
							,act.buf,mod.buf,g.second->get_modified_by(),g.second->get_revision()));
					}
					rep_status(tb);
				</f>
				<f listgames>
					vector<GAMESTAT> stats;
					for (auto g:glocal.games){
						GAMESTAT st;
						st.gameid = g.first;
						st.modified = g.second->is_modified() ? g.second->get_modified() : 0;
						st.modified_by = g.second->get_modified_by();
						st.last_activity = g.second->get_last_activity();
						st.revision = g.second->get_revision();
						stats.emplace_back(st);
					}
					rep_listgames(stats);
				</f>
				<f instrument>
					toggle_instrument_file(on);
				</f>
				<f quit>
					// Save all games/documents in a file
					unsigned num=0;
					for (auto &g:glocal.games){
						glocal GAME_P game = g.second;
						glocal const char *gameid = g.first.c_str();
						<call savefile>(string_f("/tmp/game.%u",num),false);
						<f dowrite>
							fprintf (fout,"%s\nmodified=%lu\nmodified_by=%s\nactivity=%lu\nboBO%s\n"
								,glocal.gameid,glocal.game->get_modified()
								,glocal.game->get_modified_by()
								,glocal.game->get_last_activity()
								,glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
						num++;
					}
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f endgames>
					glocal.games.clear();
				</f>
				<f resetgame>	// gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						success = true;
						g->second->resetgame();
					}else{
						msg = "Unknown game id";
					}
					rep_resetgame (success,msg);
				</f>
				<f playstep>	// gameid steps:U{VARVAL}v width:u height:u = success:b msg res:U{VARVAL}v
					vector<VARVAL> res;
					string msg;
					bool unknown;
					DOC_UI_SPECS_receive sp;
					sp.width = sp.height = 1000;
					sp.content_width = sp.content_height = 1000;
					sp.mobile = false;
					sp.fontsize = 14;
					bool success = documentd_playstep (glocal.games,gameid,steps,"sessadmin","admin",true,sp,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f save> // gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal GAME_P game = g->second;
						success = true;
						<call savefile>(documentd_path(gameid),false);
						<f dowrite>
							fprintf (fout,"boBO%s\n",glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
					}else{
						msg = "Unknown game id";
					}
					rep_save(success,msg);
				</f>
				<f load> // gameid = success:b msg 
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal.games.erase (g);
					}
					string tmp = documentd_path(gameid);
					FILE *fin = fopen (tmp.c_str(),"r");
					if (fin == NULL){
						msg = "Gameid file does not exist";
					}else{
						char buf[100];
						if (fgets(buf,sizeof(buf)-1,fin)!=NULL){
							GAME_P p = documentd_newgame(buf,gameid,msg);
							if (p != NULL){
								glocal.games[gameid] = p;
								DOC_READER doc(fin);
								p->load (doc,msg);
								success = msg.size() == 0 ? true : false;
							}
						}
						fclose (fin);
					}
					rep_save(success,msg);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_CLIENT){
				<call documentd_client>(this,c->req,line,info.linelen, endserver, endclient,no,c);
				<f test>
					rep_test(true);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f playstep>
					vector<VARVAL> res;
					string msg;
					translat_selectlang(lang);
					bool unknown;
					bool success = documentd_playstep (glocal.games,gameid,steps,session,username,maywrite,sp,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f rename>
					string msg;
					translat_selectlang(lang);
					auto oldg = glocal.games.find(old_gameid);
					if (oldg != glocal.games.end()){
						// This is ok if the old document is missing
						auto newg = glocal.games.find(new_gameid);
						if (newg != glocal.games.end()){
							msg = MSG_U(E_NEWEXIST,"Can't rename document, new name exist");
						}else{
							auto doc = oldg->second;
							glocal.games.erase(oldg);
							doc->setgameid(new_gameid);
							glocal.games[new_gameid] = doc;
						}
					}
					if (msg.size() > 0){
						rep_rename (false,msg);
					}else{
						rep_rename (true,"");
					}	
				</f>
				<f save>
					string msg;
					BOB_TYPE content;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						GAME_P game = g->second;
						DOC_WRITER doc;
						doc.write (string_f("boBO%s\n",game->getclass()));
						game->save(doc,false);
						content = doc.getcontent();
						game->resetmodified();
					}else{
						msg = "Unknown game id";
					}
					if (msg.size() > 0){
						content.clear();
						rep_save(false,msg,content,false);
					}else{
						rep_save (true,"",content,false);
					}
				</f>
				<f savemore>
					BOB_TYPE content;
					rep_savemore (false,"Not inplemented",content,false);
				</f>
				<f load>
					string msg;
					auto g = glocal.games.find(gameid);
					const char *type = (const char *)content.getbuffer();
					GAME_P game = nullptr;
					if (g != glocal.games.end()){
						game = g->second;
					}else{
						game = documentd_newgame(type,gameid,msg);
					}
					if (game != nullptr){
						glocal.games[gameid] = game;
						DOC_READER doc(type+9);
						game->load(doc,msg);
					}
					if (msg.size() > 0){
						rep_load (false,msg);
					}else{
						rep_load (true,"");
					}
				</f>
				<f loadmore>
				</f>
				<f is_modified> // gameid = success:b msg modified:b
					bool modified = false;
					const char *modified_by = "";
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						modified = g->second->is_modified();
						modified_by = g->second->get_modified_by();
					}else{
						msg = "Unknown document";
					}
					if (msg.size() > 0){
						rep_is_modified(false,msg,false,"",0);
					}else{
						rep_is_modified(true,"",modified,modified_by,g->second->get_revision());
					}
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			// Load saved games/documents
			if (file_type("/tmp/game.0")==0){
				<call walkfs>("/tmp");
				<f onefile>
					if (strncmp(basename,"game.",5)==0){
						FILE *fin = fopen (path,"r");
						if (fin == nullptr){
							tlmp_error ("Can't open saved game %s (%s)\n",path,strerror(errno));
						}else{
							char buf1[1000],buf2[1000];
							if (fgets(buf1,sizeof(buf1)-1,fin)!=nullptr
								&& fgets(buf2,sizeof(buf2)-1,fin)!=nullptr){
								strip_end (buf1);
								const char *pt;
								time_t mod = 0;
								if (is_start_any_of(buf2,pt,"modified=")){
									mod = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								string mod_by;
								if (is_start_any_of(buf2,pt,"modified_by=")){
									mod_by = pt;
									strip_end (mod_by);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								time_t act = 0;
								if (is_start_any_of(buf2,pt,"activity=")){
									act = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								strip_end (buf2);
								string msg;
								if (!documentd_startgame(glocal.games,buf2,buf1,msg)){
									tlmp_error ("Can't initialise game %s/%s (%s)\n",buf1,buf2,msg.c_str());
								}else{
									DOC_READER doc(fin);
									auto g = glocal.games[buf1];
									g->load(doc,msg);
									g->setmodified(mod,mod_by.c_str());
									g->setactivity(act);
								}
							}
							fclose (fin);
						}
						unlink (path);
					}
				</f>
				</call>
			}
			chmod (glocal.clientsock,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			open_instrument_file();
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

#include <ft2build.h>
#include FT_FREETYPE_H
#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000

// This one could use a better name, I just don't know a better one (yet?)
#define UTF8_OTHER_MASK 0b00111111

static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
/*
	Compute the width and height of the string using a font library.
*/
unsigned documentd_displaylen (const char *title, unsigned fontsize, float size)
{
	unsigned ret = 0;
	static bool some_errors = false;
	static bool is_init = false;
	static FT_Library  library;
	static FT_Face     face;      /* handle to face object */
	if (!is_init){
		is_init = true;
		some_errors = true;
		int error = FT_Init_FreeType( &library );
		if ( error ){
			tlmp_error ("  ... an error occurred during library initialization ...\n");
		}else{
			const char *fontfile = nullptr;
			for (auto s:{
				"/usr/share/fonts/liberation-sans/LiberationSans-Regular.ttf",
				"/usr/share/fonts/liberation/LiberationSans-Regular.ttf",
				"/usr/share/fonts/dejavu/DejaVuSans.ttf"
				}){
				if (file_type(s)!=-1){
					fontfile = s;
					break;
				}
			}
			if (fontfile == nullptr){
				some_errors = true;
				tlmp_error ("tlmpweb_displaylen: No font file found");
			}else{
				error = FT_New_Face(library,fontfile,0,&face);
				if ( error == FT_Err_Unknown_File_Format ){
					tlmp_error ("... the font file could be opened and read, but it appears\n"
						"... that its font format is unsupported\n");
				}else if ( error ){
					tlmp_error ("... another error code means that the font file could not\n"
						"... be opened or read, or that it is broken...\n");
				}else{
					some_errors = false;
				}
			}
		}

	}
	unsigned font_charsize = fontsize*64*size;
	font_charsize = 13.6*64*size;
	if (!some_errors){
		static unsigned last_charsize=0;
		//unsigned charsize = 13.6*64*size;
		if (font_charsize != last_charsize){
			last_charsize = font_charsize;
			int error = FT_Set_Char_Size(
				face,    /* handle to face object           */
				0,       /* char_width in 1/64th of points  */
				font_charsize,   /* char_height in 1/64th of points */
				0,     /* horizontal device resolution    */
				0 );   /* vertical device resolution      */
			if (error){
				tlmp_error ("Set_Char_Size %u error\n",font_charsize);
			}else{
				some_errors = false;
			}
		}
	}
	if (some_errors){
		ret = strlen(title)*9;
	}else{
		const char *pt = title;
		while (*pt != '\0'){
			unsigned t = *pt++;
			size_t charsize = utf8_codepoint_size(t);
			switch(charsize){
			case 1:
				break;
			case 2:
				if (*pt == '\0') break;
				t = (t<<8)+*pt++;
				break;
			case 3:
				break;
			case 4:
				break;
			}
			struct CACHECHAR{
				unsigned car;
				unsigned font_charsize;
				CACHECHAR(unsigned _car, unsigned _font_charsize){
					car = _car;
					font_charsize = _font_charsize;
				}
				bool operator < (const CACHECHAR &n) const {
					return tie(font_charsize,car) < tie(n.font_charsize,n.car);
				}
			};
			static map<CACHECHAR,unsigned short> cache;
			auto &cached_width = cache[CACHECHAR(t,font_charsize)];
			if (cached_width == 0){
				unsigned glyph_index = FT_Get_Char_Index( face, t );

				/* load glyph image into the slot (erase previous one) */
				int error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
				if ( error )   continue;  /* ignore errors */
				/* convert to an anti-aliased bitmap */
				error = FT_Render_Glyph( face->glyph, FT_RENDER_MODE_NORMAL );
				if ( error ) continue;

				//tlmp_error ("dislay_len: %c -> %u\n",t,(unsigned)(face->glyph->advance.x >> 6));
				cached_width = face->glyph->advance.x >> 6;
				//ret += 1;	// One pixel between characters. advance takes care of that
						// but for now, we are not using the same font as the browser
			}
			ret += cached_width;
		}
	}
	return ret;
}

