/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Documents and games manager.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <translat.h>
#include <deque>
#include <memory>
#include <string>
#include "filesystem.h"
#include "bolixo.h"
#include "bolixo.m"
#define INSTRUMENT_DONOTOPEN
#include "instrument.h"
#include "helper.h"
#include "documentd.h"


using namespace std;
static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

// Load and save may be spread over several calls
// We save the gameid to make sure
// This will be needed when loadmore is implemented
struct LOADSAVE{
	vector<string> lines;
};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	map<string,LOADSAVE> bufs;	// Used to handle save and load request from bod
					// The string is the gameid
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
DOC_WRITER::DOC_WRITER(FILE *_fout): fout(_fout)
{
}
int DOC_WRITER::write (const char *buf, unsigned len)
{
	int ret = -1;
	if (fout != nullptr){
		ret = fwrite (buf,1,len,fout);
	}else{
		FILE *f = fopen ("/tmp/save.log","a");
		fprintf (f,"%s",buf);
		fclose (f);
		lines.push_back(string(buf));
		ret = len;
	}
	return ret;
}
int DOC_WRITER::write (const string &l)
{
	return write (l.c_str(),l.size());
}
BOB_TYPE DOC_WRITER::getcontent () const
{
	size_t size = 0;
	for (auto &s:lines) size += s.size();
	BOB_TYPE ret (size);
	char *buf = (char*)ret.getbuffer();
	for (auto &s:lines){
		memcpy(buf,s.c_str(),s.size());
		buf += s.size();
	}
	return ret;
}

void fflush (DOC_WRITER *){}


char *fgets(char *s, int size, DOC_READER *r)
{
	char *ret = nullptr;
	if (r->fin != nullptr){
		ret = fgets(s,size,r->fin);
	}else if (r->bufptr != nullptr){
		const char *end = r->bufptr;
		if (*end != '\0'){
			while (*end != '\0' && *end != '\n') end++;
			int len = end - r->bufptr;
			if (len < size){
				ret = s;
				memcpy (s,r->bufptr,len);
				s[len] = '\0';
			}
			if (*end == '\n') end++;
			r->bufptr = end;
		}
	}
	return ret;
}
#include "proto/bod_client.protodef"
#include "proto/documentd_control.protoh"
#include "proto/documentd_client.protoh"

static string documentd_path (const char *name)
{
	return string_f("%s/bo-games/%s",getenv("HOME"),name);
}
void documentd_error (vector<VARVAL> &res, PARAM_STRING s)
{
	VARVAL v;
	v.var = VAR_ERROR;
	v.val = s.ptr;
	res.push_back(v);
}
void documentd_forcerefresh (vector<VARVAL> &res)
{
	VARVAL v;
	v.var = VAR_REFRESH;
	res.push_back(v);
}

void documentd_button (string &lines, unsigned command, const char *txt, bool highlit)
{
	lines += "&nbsp;";
	lines += string_f("<input id=button%u form=\"form\" type=button value='%s' onclick=gameaction('newgame:%u') style=background-color:%s;>\n"
		,command,txt,command,highlit ? "lightblue" : "lightgray");
}

using GAME_P = shared_ptr<GAME>;



static bool documentd_playstep (
	map<string,GAME_P> &games,
	const char *gameid,
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	unsigned width,
	unsigned height,
	vector<VARVAL> &res,
	string &msg,
	bool &unknown)
{
	bool success = false;
	unknown = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		success = true;
		for (auto &v:steps){
			g->second->exec(v.var,v.val,session,username,maywrite,width,height,res);
		}
		g->second->testwin(res);
	}else{
		msg = "Unknown game id";
		unknown = true;
	}
	return success;
}

static GAME_P documentd_newgame(const char *type, const char *gameid, string &msg)
{
	GAME_P p = nullptr;
	if (strncmp(type,"boBOTICT",8)==0){
		p = make_shared<TICTACTO>();
	}else if (strncmp(type,"boBOSUDO",8)==0){
		p = make_shared<SUDOKU>();
	}else if (strncmp(type,"boBOWORD",8)==0){
		p = make_shared<WORDPROC>();
	}else if (strncmp(type,"boBOCHEC",8)==0){
		p = make_shared<CHECKERS>();
	}else{
		msg = "Unknown game or document type";
	}
	if (p != nullptr) p->setgameid(gameid);
	return p;
}

static bool documentd_startgame(
	map<string,GAME_P> &games,
	const char *gamename,
	const char *gameid,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		msg = "Game already exist";
	}else{
		GAME_P p = documentd_newgame(gamename,gameid,msg);
		if (p != nullptr){
			games[gameid] = p;
			p->resetgame();
			ret = true;
		}
	}
	return ret;
}
static bool documentd_endgame (
	map<string,GAME_P> &games,
	const char *gameid,
	unsigned revision,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		if (g->second->get_revision() != revision){
			msg = "Revision mismatch";
		}else{
			ret = true;
			games.erase (g);
		}
	}else{
		msg = "Unknown game id";
	}
	return ret;
}

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/documentd.sock";
	glocal const char *clientsock = "/tmp/documentd_client.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *pidfile = "/var/run/documentd.pid";
	glocal const char *hostname = NULL;

	translat_setlang ("eng,fr");
	static const char *tbdic[]={"bolixo",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("documentd",VERSION,"Process document content");
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for documentd-control",glocal.control,false);
		setarg ('C',"clientsock","Unix socket for documentd-client",glocal.clientsock,false);
		setgrouparg ("Misc.");
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
		setarg (' ',"client-secrets","File holding client secrets for communication",glocal.client_secretfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		int ret = -1;
		glocal map<string,GAME_P> games;
		glocal unsigned messages_sent = 0;
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal string clientport = string_f("unix:%s",glocal.clientsock);
		glocal map<string,string> client_secrets;
		glocal pid_t pid = (pid_t)-1;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		signal (SIGCHLD,SIG_IGN);
		<obj TCPSERVER s>(glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(info.port,glocal.clientport)==0){
				n->req.secret = fdpass_findsecret (glocal.client_secrets,info.port);
				n->type = TYPE_CLIENT;
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call documentd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					instrument_status(tb);
					for (auto g:glocal.games){
						DATEASC act,mod;
						fdpass_asctime(g.second->get_last_activity(),act);
						if (g.second->is_modified()) fdpass_asctime(g.second->get_modified(),mod);
						tb.push_back(string_f("gameid: %s last_activity=%s modified=%s modified_by=%s revision=%u",g.first.c_str()
							,act.buf,mod.buf,g.second->get_modified_by(),g.second->get_revision()));
					}
					rep_status(tb);
				</f>
				<f listgames>
					vector<GAMESTAT> stats;
					for (auto g:glocal.games){
						GAMESTAT st;
						st.gameid = g.first;
						st.modified = g.second->is_modified() ? g.second->get_modified() : 0;
						st.modified_by = g.second->get_modified_by();
						st.last_activity = g.second->get_last_activity();
						st.revision = g.second->get_revision();
						stats.emplace_back(st);
					}
					rep_listgames(stats);
				</f>
				<f instrument>
					toggle_instrument_file(on);
				</f>
				<f quit>
					// Save all games/documents in a file
					unsigned num=0;
					for (auto &g:glocal.games){
						glocal GAME_P game = g.second;
						glocal const char *gameid = g.first.c_str();
						<call savefile>(string_f("/tmp/game.%u",num),false);
						<f dowrite>
							fprintf (fout,"%s\nmodified=%lu\nmodified_by=%s\nactivity=%lu\nboBO%s\n"
								,glocal.gameid,glocal.game->get_modified()
								,glocal.game->get_modified_by()
								,glocal.game->get_last_activity()
								,glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
						num++;
					}
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f endgames>
					glocal.games.clear();
				</f>
				<f resetgame>	// gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						success = true;
						g->second->resetgame();
					}else{
						msg = "Unknown game id";
					}
					rep_resetgame (success,msg);
				</f>
				<f playstep>	// gameid steps:U{VARVAL}v width:u height:u = success:b msg res:U{VARVAL}v
					vector<VARVAL> res;
					string msg;
					bool unknown;
					bool success = documentd_playstep (glocal.games,gameid,steps,"sessadmin","admin",true,1000,1000,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f save> // gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal GAME_P game = g->second;
						success = true;
						<call savefile>(documentd_path(gameid),false);
						<f dowrite>
							fprintf (fout,"boBO%s\n",glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
					}else{
						msg = "Unknown game id";
					}
					rep_save(success,msg);
				</f>
				<f load> // gameid = success:b msg 
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal.games.erase (g);
					}
					string tmp = documentd_path(gameid);
					FILE *fin = fopen (tmp.c_str(),"r");
					if (fin == NULL){
						msg = "Gameid file does not exist";
					}else{
						char buf[100];
						if (fgets(buf,sizeof(buf)-1,fin)!=NULL){
							GAME_P p = documentd_newgame(buf,gameid,msg);
							if (p != NULL){
								glocal.games[gameid] = p;
								DOC_READER doc(fin);
								p->load (doc,msg);
								success = msg.size() == 0 ? true : false;
							}
						}
						fclose (fin);
					}
					rep_save(success,msg);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_CLIENT){
				<call documentd_client>(this,c->req,line,info.linelen, endserver, endclient,no,c);
				<f test>
					rep_test(true);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f playstep>
					vector<VARVAL> res;
					string msg;
					translat_selectlang(lang);
					bool unknown;
					bool success = documentd_playstep (glocal.games,gameid,steps,session,username,maywrite,width,height,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f rename>
					string msg;
					translat_selectlang(lang);
					auto oldg = glocal.games.find(old_gameid);
					if (oldg != glocal.games.end()){
						// This is ok if the old document is missing
						auto newg = glocal.games.find(new_gameid);
						if (newg != glocal.games.end()){
							msg = MSG_U(E_NEWEXIST,"Can't rename document, new name exist");
						}else{
							auto doc = oldg->second;
							glocal.games.erase(oldg);
							doc->setgameid(new_gameid);
							glocal.games[new_gameid] = doc;
						}
					}
					if (msg.size() > 0){
						rep_rename (false,msg);
					}else{
						rep_rename (true,"");
					}	
				</f>
				<f save>
					string msg;
					BOB_TYPE content;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						GAME_P game = g->second;
						DOC_WRITER doc;
						doc.write (string_f("boBO%s\n",game->getclass()));
						game->save(doc,false);
						content = doc.getcontent();
						game->resetmodified();
					}else{
						msg = "Unknown game id";
					}
					if (msg.size() > 0){
						content.clear();
						rep_save(false,msg,content,false);
					}else{
						rep_save (true,"",content,false);
					}
				</f>
				<f savemore>
					BOB_TYPE content;
					rep_savemore (false,"Not inplemented",content,false);
				</f>
				<f load>
					string msg;
					auto g = glocal.games.find(gameid);
					const char *type = (const char *)content.getbuffer();
					GAME_P game = nullptr;
					if (g != glocal.games.end()){
						game = g->second;
					}else{
						game = documentd_newgame(type,gameid,msg);
					}
					if (game != nullptr){
						glocal.games[gameid] = game;
						DOC_READER doc(type+9);
						game->load(doc,msg);
					}
					if (msg.size() > 0){
						rep_load (false,msg);
					}else{
						rep_load (true,"");
					}
				</f>
				<f loadmore>
				</f>
				<f is_modified> // gameid = success:b msg modified:b
					bool modified = false;
					const char *modified_by = "";
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						modified = g->second->is_modified();
						modified_by = g->second->get_modified_by();
					}else{
						msg = "Unknown document";
					}
					if (msg.size() > 0){
						rep_is_modified(false,msg,false,"",0);
					}else{
						rep_is_modified(true,"",modified,modified_by,g->second->get_revision());
					}
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			// Load saved games/documents
			if (file_type("/tmp/game.0")==0){
				<call walkfs>("/tmp");
				<f onefile>
					if (strncmp(basename,"game.",5)==0){
						FILE *fin = fopen (path,"r");
						if (fin == nullptr){
							tlmp_error ("Can't open saved game %s (%s)\n",path,strerror(errno));
						}else{
							char buf1[1000],buf2[1000];
							if (fgets(buf1,sizeof(buf1)-1,fin)!=nullptr
								&& fgets(buf2,sizeof(buf2)-1,fin)!=nullptr){
								strip_end (buf1);
								const char *pt;
								time_t mod = 0;
								if (is_start_any_of(buf2,pt,"modified=")){
									mod = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								string mod_by;
								if (is_start_any_of(buf2,pt,"modified_by=")){
									mod_by = pt;
									strip_end (mod_by);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								time_t act = 0;
								if (is_start_any_of(buf2,pt,"activity=")){
									act = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								strip_end (buf2);
								string msg;
								if (!documentd_startgame(glocal.games,buf2,buf1,msg)){
									tlmp_error ("Can't initialise game %s/%s (%s)\n",buf1,buf2,msg.c_str());
								}else{
									DOC_READER doc(fin);
									auto g = glocal.games[buf1];
									g->load(doc,msg);
									g->setmodified(mod,mod_by.c_str());
									g->setactivity(act);
								}
							}
							fclose (fin);
						}
						unlink (path);
					}
				</f>
				</call>
			}
			chmod (glocal.clientsock,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			open_instrument_file();
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

