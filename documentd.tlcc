/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Documents and games manager.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include <fcntl.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <translat.h>
#include <deque>
#include <memory>
#include <string>
#include "filesystem.h"
#include "bolixo.h"
#include "bolixo.m"
#define INSTRUMENT_DONOTOPEN
#include "instrument.h"
#include "helper.h"
#include "documentd.h"


using namespace std;
static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_SUBPROGRAM};

// Load and save may be spread over several calls
// We save the gameid to make sure
// This will be needed when loadmore is implemented
struct LOADSAVE{
	vector<string> lines;
};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	map<string,LOADSAVE> bufs;	// Used to handle save and load request from bod
					// The string is the gameid
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
DOC_WRITER::DOC_WRITER(FILE *_fout): fout(_fout)
{
}
int DOC_WRITER::write (const char *buf, unsigned len)
{
	int ret = -1;
	if (fout != nullptr){
		ret = fwrite (buf,1,len,fout);
	}else{
		FILE *f = fopen ("/tmp/save.log","a");
		fprintf (f,"%s",buf);
		fclose (f);
		lines.push_back(string(buf,len));
		ret = len;
	}
	return ret;
}
int DOC_WRITER::write (const string &l)
{
	return write (l.c_str(),l.size());
}
BOB_TYPE DOC_WRITER::getcontent () const
{
	size_t size = 0;
	for (auto &s:lines) size += s.size();
	BOB_TYPE ret (size);
	char *buf = (char*)ret.getbuffer();
	for (auto &s:lines){
		memcpy(buf,s.c_str(),s.size());
		buf += s.size();
	}
	return ret;
}

void fflush (DOC_WRITER *){}


char *fgets(char *s, int size, DOC_READER *r)
{
	char *ret = nullptr;
	if (r->fin != nullptr){
		ret = fgets(s,size,r->fin);
	}else if (r->bufptr != nullptr){
		const char *end = r->bufptr;
		if (*end != '\0'){
			while (*end != '\0' && *end != '\n') end++;
			int len = end - r->bufptr;
			if (len < size){
				ret = s;
				memcpy (s,r->bufptr,len);
				s[len] = '\0';
			}
			if (*end == '\n') end++;
			r->bufptr = end;
		}
	}
	return ret;
}
#include "proto/bod_client.protodef"
#include "proto/documentd_control.protoh"
#define documentd_client_rep_waitevent_NEEDED
#include "proto/documentd_client.protoh"

static string documentd_path (const char *name)
{
	return string_f("%s/bo-games/%s",getenv("HOME"),name);
}
void documentd_error (vector<VARVAL> &res, PARAM_STRING s)
{
	VARVAL v;
	v.var = VAR_ERROR;
	v.val = s.ptr;
	res.push_back(v);
}
void documentd_forcerefresh (vector<VARVAL> &res)
{
	VARVAL v;
	v.var = VAR_REFRESH;
	res.push_back(v);
}
void documentd_setchanges (vector<VARVAL> &res)
{
	VARVAL v;
	v.var = VAR_CHANGES;
	res.push_back(v);
}

/*
	Escape ' in a stringh
*/
string documentd_escape(PARAM_STRING msg)
{
	string tmp;
	const char *pt = msg.ptr;
	while (*pt != '\0'){
		if (*pt == '\''){
			tmp += '\\';
		}
		tmp += *pt++;
	}
	return tmp;
}
void documentd_button_start(string &lines, const string &gameid)
{
	lines += string_f("<div id='buttons-%s' style='display:flex; flex-flow:row;'>\n",gameid.c_str());
}
void documentd_button_end(string &lines)
{
	lines += "</div>\n";
}
void documentd_button_label (string &lines, PARAM_STRING txt)
{
	lines += string_f("<div style='flex:0 1 auto;'>%s</div>\n",txt.ptr);
}
void documentd_button (string &lines, unsigned command, PARAM_STRING txt, bool highlit)
{
	lines += "&nbsp;";
	lines += "<div class='button-wrapper' style='float: left;' >\n";
	#if 1
	lines += string_f("<div class=button id=button%u onclick=gameaction(event,'newgame:%u')"
		" style='%sflex:0 1 auto; cursor:default;'"
		" >%s</div>\n"
		,command,command,highlit ? "background-color:lightblue;" : "",txt.ptr);
	#else
	lines += string_f("<div class=button id=button%u onclick=gameaction(event,'newgame:%u')"
		" style='%sflex:0 1 auto; border-radius:4px; text-align:center; border:1px solid black;cursor:default;"
		" padding-left:5; padding-right:5;  margin-left:5; margin-top:2; margin-bottom:2;'>%s</div>\n"
		,command,command,highlit ? "background-color:lightblue;" : "",txt.ptr);
	#endif
	lines += "</div>\n";
}
void documentd_button (string &lines, unsigned command, PARAM_STRING txt, const DOC_BUTTON_SPECS &specs, bool highlit)
{
	lines += "&nbsp;";
	lines += string_f("<div class=button id=button%u onclick=gameaction(event,'newgame:%u')"
		" style='background-color:%s;flex:0 1 auto; border-radius:%upx; width:%u; text-align:center;cursor:default;"
		" border:1pxsolid black; margin-left:%u; margin-top:%u; margin-bottom:%u;'>%s</div>\n"
		,command,command,highlit ? "lightblue" : "lightgray"
		,specs.radius,specs.width,specs.margin_left,specs.margin_top,specs.margin_bottom,txt.ptr);
}

/*
	Create a small one line chat
*/
void documentd_chat(string &lines, PARAM_STRING username, const vector<CHATLINE> &content, unsigned width, unsigned height)
{
	lines += string_f("<div id=chat style='width:%u; height:%u; cursor:default;padding-left:5px;border:1px black solid; overflow: auto;' >"
		,width,height);
	lines += "</div>\n";;
	lines += string_f("<input id=inputchat type=text style=width:%u; onkeypress=funcchat(event); placeholder='%s' />\n"
		,width,MSG_U(I_CHAT,"Chat"));
	lines +=
		"<script>\n"
		"function appendchat(unixdate,line){\n"
		"\tvar chat = document.getElementById('chat');\n"
		"\tif (chat != null){\n"
		"\t\tif (chat.innerHTML != ''){\n"
		"\t\t\tchat.innerHTML += '<br>\\n';\n"
		"\t\t}\n"
		"\t\tvar date = new Date(unixdate*1000);\n"
		"\t\tchat.innerHTML += date.toLocaleString() + ' ' + line;\n"
		"\t\tchat.scrollTop = chat.scrollHeight;\n"
		"\t}\n"
		"}\n"
		"function funcchat(event){\n"
		"\tif (event.key=='Enter'){\n"
		"\tvar txt = document.getElementById('inputchat');\n";
	lines += string_f("\t\tgameaction(event,'chat:<b>%s:</b> '+txt.value);\n",username.ptr);
	lines +=
		"\t\ttxt.value = '';\n"
		"\t}\n"
		"\tevent.stopPropagation();\n"
		"\treturn false;\n"
		"}\n";
	// We can't write the content directly to the following div. Instead we are sending the content using the appendchat
	// This allows the browser to convert the time_t in localised date.
	for (auto &c:content){
		lines += string_f("appendchat(%ld,\"%s\");\n",c.time,documentd_escape(c.line).c_str());
	}
	lines += "</script>\n";
}

// r.val is a list of fields. Each field has a name and a value on a single text line.
// name:value\nname:value\n
void documentd_parsefields (const char *val, vector<VARVAL> &fields)
{
	vector<string>tb;
	str_splitline (val,'\n',tb);
	for (auto &l:tb){
		const char *start = l.c_str();
		const char *pt = strchr(start,':');
		if (pt != nullptr){
			VARVAL var;
			var.var = string(start,pt-start);
			var.val = pt+1;
			fields.emplace_back(move(var));
		}
	}
}

using GAME_P = shared_ptr<GAME>;

GAME::~GAME()
{
	for (auto fd:notification_fds) close (fd);
}
void GAME::appendchat(PARAM_STRING line, string &notify)
{
	time_t now = time(nullptr);
	chat.emplace_back(now,line.ptr);
	while (chat.size() > 20) chat.erase(chat.begin());
	notify += string_f("appendchat(%ld,'%s');\n",now,documentd_escape(line.ptr).c_str());
}
void GAME::appendchat(PARAM_STRING line, string &notify, vector<VARVAL> &res)
{
	appendchat(line,notify);
	documentd_setchanges(res);
}
static size_t total_notify_size=0;
void GAME::add_notification (PARAM_STRING script)
{
	if (script.ptr[0] != '\0'){
		notifications.emplace_back(script,sequence);
		size_t len_script = strlen(script.ptr);
		for (auto fd:notification_fds){
			total_notify_size += len_script;
			documentd_client_rep_waitevent(fd,true,"",script,sequence);
		}
		notification_fds.clear();
		sequence++;
		// We keep around the last 10 notifications
		while (notifications.size() > 10) notifications.erase(notifications.begin());
	}
}
void GAME::add_notification_fd(int fd)
{
	notification_fds.insert(fd);
}
int GAME::del_notification_fd(int fd)
{
	return notification_fds.erase(fd) > 0 ? 0 : -1;
}

const char *GAME::locate_event (unsigned &sequence)
{
	const char *ret = nullptr;
	for (auto &n:notifications){
		if (n.sequence > sequence){
			sequence = n.sequence;
			ret = n.script.c_str();
			break;
		}
	}
	return ret;
}

void GAME::manyexec (
	const std::vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	for (auto &v:steps){
		exec(v.var,v.val,session,username,maywrite,sp,res);
	}
}

void GAME::engine_reply(const char *line, string &notify, bool &done)
{
	done = true;
}
static bool protocol_stats=false;	// produce a tlmp_warning showing how much is sent back
static size_t total_content_size = 0;
static unsigned total_requests=0;

static bool documentd_playstep (
	vector<SUBPROGRAM> &programs,
	map<string,GAME_P> &games,
	const char *gameid,
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res,
	string &msg,
	bool &unknown)
{
	bool success = false;
	unknown = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		success = true;
		GAME_P game = g->second;
		game->manyexec(steps,session,username,maywrite,sp,res);
		game->testwin(res);
		size_t content_size = 0;
		size_t notify_size = 0;
		for (auto r = res.begin(); r != res.end(); ){
			if (r->var == VAR_NOTIFY){
				// Notifications are sent using the waitevent system
				notify_size += r->val.size();
				if (r->val.size() > 0) game->add_notification(r->val);
				r = res.erase(r);
			}else if (r->var == VAR_CONTENT){
				content_size += r->val.size();
				r->val += "<script>\n";
				r->val += string_f("var gamesequence=%u;\n",game->get_sequence()-1);
				r->val += "</script>\n";
				r++;
			}else if (r->var == VAR_ENGINE){
				// We send commands to the engine, and removes it.
				bool found = false;
				for (auto &p:programs){
					if (p.is_class(game->getclass())){
						p.send(gameid,r->val);
						found = true;
						break;
					}
				}
				if (!found){
					tlmp_error ("No engine for game type %s, gameid=%s",game->getclass(),gameid);
				}
				r = res.erase(r);
			}else{
				r++;
			}
		}
		if (protocol_stats) tlmp_warning ("protocol content_size=%lu notify_size=%lu",content_size,notify_size);
		total_content_size += content_size;
		total_requests++;
	}else{
		msg = "Unknown game id";
		unknown = true;
	}
	return success;
}

static GAME_P documentd_newgame(const char *type, const char *gameid, string &msg)
{
	GAME_P p = nullptr;
	if (strncmp(type,"boBOTICT",8)==0){
		p = make_shared<TICTACTO>();
	}else if (strncmp(type,"boBOSUDO",8)==0){
		p = make_shared<SUDOKU>();
	}else if (strncmp(type,"boBOWORD",8)==0){
		p = make_shared<WORDPROC>();
	}else if (strncmp(type,"boBOCHEC",8)==0){
		p = make_shared<CHECKERS>();
	}else if (strncmp(type,"boBOCHES",8)==0){
		p = make_shared<CHESS>();
	}else{
		msg = "Unknown game or document type";
	}
	if (p != nullptr) p->setgameid(gameid);
	return p;
}

static bool documentd_startgame(
	map<string,GAME_P> &games,
	const char *gamename,
	const char *gameid,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		msg = "Game already exist";
	}else{
		GAME_P p = documentd_newgame(gamename,gameid,msg);
		if (p != nullptr){
			games[gameid] = p;
			p->resetgame();
			ret = true;
		}
	}
	return ret;
}
static bool documentd_endgame (
	map<string,GAME_P> &games,
	const char *gameid,
	unsigned revision,
	string &msg)
{
	bool ret = false;
	auto g = games.find(gameid);
	if (g != games.end()){
		if (g->second->get_revision() != revision){
			msg = "Revision mismatch";
		}else if (g->second->get_nbwait() > 0){
			msg = "User waitings";
		}else{
			ret = true;
			games.erase (g);
		}
	}else{
		msg = "Unknown game id";
	}
	return ret;
}

static void closetb(int tb[2])
{
	close (tb[0]);
	close (tb[1]);
}
static void forgettb(int tb[2])
{
	tb[0] = tb[1] = -1;
}

static void dup_close (int fd, int target_fd)
{
	dup2 (fd,target_fd);
	close (fd);
}
SUBPROGRAM::SUBPROGRAM(PARAM_STRING _gameclass, PARAM_STRING _command)
	:command(_command.ptr), gameclass(_gameclass.ptr)
{
	int tbin[2];
	if (pipe2(tbin,O_DIRECT)!=-1){
		int tbout[2];
		if (pipe(tbout)!=-1){
			int tberr[2];
			if (pipe(tberr)!=-1){
				pid = fork();
				if (pid == (pid_t)0){
					for (int i=0; i<1024; i++){
						if (!is_any_of(i,tbin[0],tbout[1],tberr[1])) close (i);
					}
					dup_close (tbin[0],0);
					dup_close (tbout[1],1);
					dup_close (tberr[1],2);
					vector<string> tb;
					str_splitline (_command.ptr,' ',tb);
					const char *tbp[tb.size()+1];
					for (unsigned i=0; i<tb.size(); i++) tbp[i] = tb[i].c_str();
					tbp[tb.size()] = nullptr;
					execv (tbp[0],(char**)tbp);
					_exit (0);
				}else if (pid != (pid_t)-1){
					fdin = tbin[1];
					fdout = tbout[0];
					fderr = tberr[0];
					close(tbin[0]);
					close(tbout[1]);
					close(tberr[1]);
					forgettb(tbin);
					forgettb(tbout);
					forgettb(tberr);
				}else{
					tlmp_error ("Can't fork: %s",strerror(errno));
				}
				closetb(tberr);
			}
			closetb(tbout);
		}
		closetb (tbin);
	}
}
void SUBPROGRAM::subswap(SUBPROGRAM &&n)
{
	swap(pid,n.pid);
	swap(fdin,n.fdin);
	swap(fdout,n.fdout);
	swap(fderr,n.fderr);
	//printf ("pid=%d %d %d %d\n",(int)pid,fdin,fdout,fderr);
	//printf ("npid=%d %d %d %d\n",(int)n.pid,n.fdin,n.fdout,n.fderr);
	swap(command,n.command);
	swap(gameid,n.gameid);
	swap(gameclass,n.gameclass);
	swap(tosend,n.tosend);
	swap(nbrec,n.nbrec);
	swap(nbsend,n.nbsend);
}
SUBPROGRAM::SUBPROGRAM(SUBPROGRAM &&n)
{
	subswap(forward<SUBPROGRAM>(n));
}
SUBPROGRAM &SUBPROGRAM::operator =(SUBPROGRAM &&n)
{
	if (this != &n){
		subswap(forward<SUBPROGRAM>(n));
	}
	return *this;
}
SUBPROGRAM::~SUBPROGRAM()
{
	//printf ("pid=%d fdin=%d fdout=%d fderr=%d command=%s\n",(int)pid,fdin,fdout,fderr,command.c_str());
	close (fdin);
	close (fdout);
	close (fderr);
	if (pid != (pid_t)-1){
		//printf ("kill %u\n",pid);
		kill (pid,SIGTERM);
	}
}
void SUBPROGRAM::send(PARAM_STRING gameid, PARAM_STRING line)
{
	tosend.emplace_back(gameid,line);
	sendmore();
}
/*
	Send more lines to the engine until we reach an empty line.
	This means we expect some answer from the engine before sending more.
*/
int SUBPROGRAM::sendmore()
{
	int ret = 0;
	if (tosend.size() > 0
		&& (gameid.empty() || tosend[0].gameid == gameid)){
		gameid = tosend[0].gameid;
		for (auto &l:tosend){
			if (l.gameid != gameid){
				break;
			}else{
				ret++;
				write (fdin,l.line.c_str(),l.line.size());
			}
		}
		tosend.erase(tosend.begin(),tosend.begin()+ret);
		nbsend += ret;
	}
	return ret;
}
void subprogram_exec (PARAM_STRING gameid, const char *cmd)
{
}

static void documentd_chess_move(vector<SUBPROGRAM> &programs, map<string,GAME_P> &games, const char *gameid, PARAM_STRING move)
{
	if (strlen(move.ptr)==4
		&& isalpha(move.ptr[0])
		&& isdigit(move.ptr[1])
		&& isalpha(move.ptr[2])
		&& isdigit(move.ptr[3])){
		DOC_UI_SPECS_receive sp;
		sp.width = sp.height = sp.content_width = sp.content_height = 1000;
		sp.mobile = false;
		sp.fontsize = 14;
		vector<VARVAL> res;
		unsigned col1 = move.ptr[0] - 'a';
		unsigned line1 = 8-(move.ptr[1] - '0');
		unsigned col2 = move.ptr[2] - 'a';
		unsigned line2 = 8-(move.ptr[3] - '0');
		
		string cmd1 = string_f("%u,%u,1",line1,col1);
		string cmd2 = string_f("%u,%u,1",line2,col2);
		vector<VARVAL_receive> steps;
		VARVAL_receive st;
		st.var = "place";
		st.val = cmd1.c_str();
		steps.emplace_back(st);
		st.val = cmd2.c_str();
		steps.emplace_back(st);
		string msg;
		bool unknown;
		documentd_playstep (programs,games,gameid,steps,"session","user",true,sp,res,msg,unknown);
	}
}
static void documentd_chess_print (const char *user, map<string,GAME_P> &games, const char *gameid)
{
	DOC_UI_SPECS_receive sp;
	sp.width = sp.height = sp.content_width = sp.content_height = 1000;
	sp.mobile = false;
	sp.fontsize = 14;
	vector<VARVAL> res;
	string msg;
	bool unknown;
	vector<VARVAL_receive> steps;
	VARVAL_receive st;
	st.var = "print";
	st.val = "console";
	steps.emplace_back(st);
	vector<SUBPROGRAM> programs;
	documentd_playstep (programs,games,gameid,steps,"session",user,true,sp,res,msg,unknown);
	for (auto &r:res){
		if (r.var == VAR_CONTENT){
			printf("\n%s\n",r.val.c_str());
			break;
		}
	}
}
/*
	Start all available game engines
*/
static void documentd_start_engines(vector<SUBPROGRAM> &programs)
{
	if (file_type("/usr/bin/stockfish")!=-1){
		programs.emplace_back(CLASS_CHESS,"/usr/bin/stockfish");
		auto &s = programs[programs.size()-1];
		for (auto line:{"uci\n","ucinewgame\n","setoption name Skill Level value 0\n","isready\n"}){
			s.send ("",line);
		}
	}else if (file_type("/usr/bin/gnuchess")!=-1){
		programs.emplace_back(CLASS_CHESS,"/usr/bin/gnuchess -u");
		auto &s = programs[programs.size()-1];
		for (auto line:{"uci\n","","ucinewgame\n","isready\n"}){
			s.send ("",line);
		}
	}
}
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/documentd.sock";
	glocal const char *clientsock = "/tmp/documentd_client.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *pidfile = "/var/run/documentd.pid";
	glocal const char *hostname = NULL;
	glocal vector<SUBPROGRAM> programs;

	translat_setlang ("eng,fr");
	static const char *tbdic[]={"bolixo",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("documentd",VERSION,"Process document content");
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for documentd-control",glocal.control,false);
		setarg ('C',"clientsock","Unix socket for documentd-client",glocal.clientsock,false);
		setgrouparg ("Misc.");
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
		setarg (' ',"client-secrets","File holding client secrets for communication",glocal.client_secretfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main>
		// This is used for testing/debug
		//long long start = fdpass_getnow();
		//long long end = fdpass_getnow();
		//long long diff = end - start;
		//tlmp_warning ("set_para_spec %Ld.%06Ld",diff/1000000,diff%1000000);
		void wordproc_testparagraph (const char *line, unsigned width, unsigned fontsize, unsigned para_cursor);
		if (strcmp(argv[0],"testparagraph")==0){
			if (argc > 1){
				for (int i=1; i<argc; i++){
					const char *arg = argv[i];
					printf ("----%s\n",arg);
					for (unsigned col=0; col<15; col++){
						wordproc_testparagraph(arg,1300,14,col);
					}
				}
			}else{
				for (auto s:{
					"hello how are you today ? How was it yesterday ? hello how are you today ? how was it yesterday ? And now How do you feel ?",
					//"1234\013b;BOLD\014abcd",
					//"1234\016abcd",
					//"this is a short line",
					//"this is a short paragraph using a much longer line that is talking about nothing useful and even more"
					}){
					printf ("----%s\n",s);
					for (unsigned col=0; col<15; col++){
						wordproc_testparagraph(s,1300,14,col);
					}
				}
			}
		}else if (strcmp(argv[0],"subprogram")==0){
			glocal const char *gameid = "id";
			string msg;
			glocal map<string,GAME_P> games;
			documentd_startgame(glocal.games,"boBOCHES",glocal.gameid,msg);
			// Trick to assign the users
			documentd_chess_print ("user1",glocal.games,glocal.gameid);
			documentd_chess_print ("robot",glocal.games,glocal.gameid);
			if (argc == 1){
				documentd_start_engines(glocal.programs);
			}else{
				string cmd = argv[1];
				for (int i=2; i<argc; i++) cmd += string_f(" %s",argv[i]);
				SUBPROGRAM p(CLASS_CHESS,cmd);
				for (auto line:{"uci\n","","ucinewgame\n","isready\n",""}){
					p.send ("",line);
				}
				glocal.programs.push_back(move(p));
			}
			<obj TCPSERVER o>();
			<f newclient>
			</f>
			<f endclient>
				printf ("endclient %d\n",no);
			</f>
			<f receive>
				auto &s = glocal.programs[0];
				if (no == 0){
					// stdin
					documentd_chess_move(glocal.programs,glocal.games,glocal.gameid,line);
					documentd_chess_print("user1",glocal.games,glocal.gameid);
				}else if (s.is_fdout(no)){
					const char *gameid = s.get_gameid();
					if (gameid[0] == '\0'){
						printf ("out: %s\n",line);
					}else{
						printf ("out %s: %s\n",gameid,line);
						for (auto &m:glocal.games){
							if (m.first == gameid){
								string notify;
								bool done = false;
								m.second->engine_reply(line,notify,done);
								if (notify.size() > 0) documentd_chess_print("user1",glocal.games,glocal.gameid);
								if (done) s.reset_gameid();
								s.sendmore();
								break;
							}
						}
					}
				}else if (s.is_fderr(no)){
					printf ("err: %s\n",line);
				}
			</f>
			</obj>
			for (auto &s:glocal.programs){
				o.inject (s.get_fdout(),nullptr);
				o.inject (s.get_fderr(),nullptr);
			}
			o.inject (0,nullptr);
			o.loop();
			
		}else{
			tlmp_error ("Invalid test command\n");
		}

		return 0;
	</f>
	<f main_noarg>
		int ret = -1;
		glocal map<string,GAME_P> games;
		glocal unsigned messages_sent = 0;
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal string clientport = string_f("unix:%s",glocal.clientsock);
		glocal map<string,string> client_secrets;
		glocal pid_t pid = (pid_t)-1;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		signal (SIGCHLD,SIG_IGN);
		documentd_start_engines(glocal.programs);
		<obj TCPSERVER s>(glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(info.port,glocal.clientport)==0){
				n->req.secret = fdpass_findsecret (glocal.client_secrets,info.port);
				n->type = TYPE_CLIENT;
			}
		</f>
		<f endclient>
			// Is this client waiting for a notification ?
			bool found = false;
			for (auto g:glocal.games){
				if (g.second->del_notification_fd(no)!=-1){
					found = true;
					break;
				}
			}
			if (!found){
				for (auto p=glocal.programs.begin(); p != glocal.programs.end(); p++){
					if (p->is_fdout(no) || p->is_fderr(no)){
						tlmp_error ("Engine %s ending",p->getclass());
						glocal.programs.erase(p);
						break;
					}
				}
			}
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call documentd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					instrument_status(tb);
					unsigned nbwait=0;
					for (auto g:glocal.games){
						DATEASC act,mod;
						fdpass_asctime(g.second->get_last_activity(),act);
						if (g.second->is_modified()) fdpass_asctime(g.second->get_modified(),mod);
						tb.push_back(string_f("gameid: %s last_activity=%s modified=%s modified_by=%s revision=%u nbwait=%u sequence=%u"
							,g.first.c_str()
							,act.buf,mod.buf,g.second->get_modified_by(),g.second->get_revision()
							,g.second->get_nbwait(),g.second->get_sequence()));
						nbwait += g.second->get_nbwait();
					}
					tb.push_back(string_f("protocolstats: %d",protocol_stats));
					tb.push_back(string_f("chessmaxskill: %u",chess_getmaxskill()));
					tb.push_back(string_f("bytes sent: requests=%u content=%lu notify=%lu",total_requests,total_content_size,total_notify_size));
					tb.push_back(string_f("nbwaiting: %u",nbwait));
					tb.push_back(string_f("subprograms: %lu",glocal.programs.size()));
					for (auto &p:glocal.programs){
						tb.push_back(string_f("subprogram %s: nbsend=%u nbrec=%u gameid=%s command=%s"
							,p.getclass(),p.getnbsend(),p.getnbrec(),p.getgameid(),p.getcommand()));
					}
					rep_status(tb);
				</f>
				<f listgames>
					vector<GAMESTAT> stats;
					for (auto g:glocal.games){
						GAMESTAT st;
						st.gameid = g.first;
						st.modified = g.second->is_modified() ? g.second->get_modified() : 0;
						st.modified_by = g.second->get_modified_by();
						st.last_activity = g.second->get_last_activity();
						st.revision = g.second->get_revision();
						stats.emplace_back(st);
					}
					rep_listgames(stats);
				</f>
				<f instrument>
					toggle_instrument_file(on);
				</f>
				<f protocolstats>
					protocol_stats = on;
				</f>
				<f chessmaxskill>
					 chess_setmaxskill(maxskill);
				</f>
				<f quit>
					// Save all games/documents in a file
					unsigned num=0;
					for (auto &g:glocal.games){
						glocal GAME_P game = g.second;
						glocal const char *gameid = g.first.c_str();
						<call savefile>(string_f("/tmp/game.%u",num),false);
						<f dowrite>
							fprintf (fout,"%s\nmodified=%lu\nmodified_by=%s\nactivity=%lu\nboBO%s\n"
								,glocal.gameid,glocal.game->get_modified()
								,glocal.game->get_modified_by()
								,glocal.game->get_last_activity()
								,glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
						num++;
					}
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f endgames>
					glocal.games.clear();
				</f>
				<f resetgame>	// gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						success = true;
						g->second->resetgame();
					}else{
						msg = "Unknown game id";
					}
					rep_resetgame (success,msg);
				</f>
				<f playstep>	// gameid steps:U{VARVAL}v width:u height:u = success:b msg res:U{VARVAL}v
					vector<VARVAL> res;
					string msg;
					bool unknown;
					DOC_UI_SPECS_receive sp;
					sp.width = sp.height = 1000;
					sp.content_width = sp.content_height = 1000;
					sp.mobile = false;
					sp.fontsize = 14;
					bool success = documentd_playstep (glocal.programs,glocal.games,gameid,steps,"sessadmin","admin",true,sp,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f save> // gameid = success:b msg
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal GAME_P game = g->second;
						success = true;
						<call savefile>(documentd_path(gameid),false);
						<f dowrite>
							fprintf (fout,"boBO%s\n",glocal.game->getclass());
							DOC_WRITER doc(fout);
							glocal.game->save(doc,true);
							return 0;
						</f>
						</call>
					}else{
						msg = "Unknown game id";
					}
					rep_save(success,msg);
				</f>
				<f load> // gameid = success:b msg 
					bool success = false;
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						glocal.games.erase (g);
					}
					string tmp = documentd_path(gameid);
					FILE *fin = fopen (tmp.c_str(),"r");
					if (fin == NULL){
						msg = "Gameid file does not exist";
					}else{
						char buf[100];
						if (fgets(buf,sizeof(buf)-1,fin)!=NULL){
							GAME_P p = documentd_newgame(buf,gameid,msg);
							if (p != NULL){
								glocal.games[gameid] = p;
								DOC_READER doc(fin);
								p->load (doc,msg);
								success = msg.size() == 0 ? true : false;
							}
						}
						fclose (fin);
					}
					rep_save(success,msg);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_CLIENT){
				<call documentd_client>(this,c->req,line,info.linelen, endserver, endclient,no,c);
				<f test>
					rep_test(true);
				</f>
				<f startgame>	// gamename gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_startgame(glocal.games,gamename,gameid,msg);
					rep_startgame(success,msg);
				</f>
				<f endgame>	// gameid = success:b msg
					string msg;
					translat_selectlang(lang);
					bool success = documentd_endgame(glocal.games,gameid,revision,msg);
					rep_endgame (success,msg);
				</f>
				<f playstep>
					vector<VARVAL> res;
					string msg;
					translat_selectlang(lang);
					bool unknown;
					bool success = documentd_playstep (glocal.programs,glocal.games,gameid,steps,session,username,maywrite,sp,res,msg,unknown);
					rep_playstep(success,unknown,msg,res);
				</f>
				<f rename>
					// Rename a document. It is possible that old_gameid is not a document, but a folder, so we must
					// rename all documents in this folder.
					string msg;
					translat_selectlang(lang);
					vector<pair<string,string>> to_renames;	// Will contain the entries to rename
										// We do a first pass to identify all entries to rename
										// The second pass will complete the work.
										// We do this because glocal.games must not be changes during
										// the first pass.
					for (auto &g:glocal.games){
						const char *pt;
						if (g.first == old_gameid){
							// We have found a document with this name
							to_renames.emplace_back(old_gameid,new_gameid);
							break;
						}else if (is_start_any_of(g.first,pt,old_gameid) && pt[0] == '/'){
							// old_gameid is in fact a directory.
							// We assume new_gameid is the new name of the directory.
							to_renames.emplace_back(g.first,string_f("%s%s",new_gameid,pt));
						}
					}
					for (auto &r:to_renames){
						// This is ok if the old document is missing
						auto oldg = glocal.games.find(r.first);
						auto newg = glocal.games.find(r.second);
						if (newg != glocal.games.end()){
							msg = MSG_U(E_NEWEXIST,"Can't rename document, new name exist");
							break;
						}else{
							auto doc = oldg->second;
							static const char *tb[][2]={
								{"CHEC","doc_checkers"},
								{"CHES","doc_chess"},
								{"SUDO","doc_sudoku"},
								{"WORD","doc_wordproc"},
								{"TICT","doc_tictacto"},
							};
							const char *type = doc->getclass();
							const char *docid=nullptr;
							for (auto &t:tb){
								if (strcmp(t[0],type)==0){
									docid=t[1];
									break;
								}
							}
							tlmp_warning ("class=%s docid=%s",type,docid);
							const char *relname = r.second.c_str();
							const char *pt;
							if (is_start_any_of(r.second,pt,"/projects/")) relname = pt;
							
							string script;
							script = 
								"let div = document.createElement(\"div\");\n"
								"console.log ('div='+div);\n"
								"div.setAttribute(\"class\", \"popup\");\n"
								"div.innerHTML=\""
								"<div class='popup-content' id='popup' style='padding:10px 10px 10px 10px;'>";
							script += string_f(MSG_U(I_RENAMED,"<center>Attention</center><p>"
								"The document has been renamed by %s<br>"
								"Its new name is<br>"
								"<center>%s</center><p>"
								"Close the document and reopen it using the new name<br>"
								"All your modifications are preserved"),username,relname);
							script +=
								"</div>"
								"\";\n"
								"document.body.appendChild(div);\n"
								"var pop=document.getElementById('popup');\n"
								"pop.classList.toggle('show');\n";
							script += string_f("var doc=document.getElementById('%s');\n",docid);
							script += "if (doc == null){\n";
							script += string_f("\tdoc=document.getElementById('full%s');\n",docid);
							script += "}\n";
							script += "var rectpop = pop.getBoundingClientRect();\n";
							script += "var rectdoc = doc.getBoundingClientRect();\n";
							script += "pop.style.left=rectdoc.left+(rectdoc.right-rectdoc.left)/2-(rectpop.right-rectpop.left)/2;\n"
								"pop.style.top=rectdoc.top+(rectdoc.bottom-rectdoc.top)/2;\n";
							doc->add_notification (script);
							doc->setgameid(r.second);
							glocal.games.erase(r.first);
							glocal.games[r.second] = doc;
						}
					}
					if (msg.size() > 0){
						rep_rename (false,msg);
					}else{
						rep_rename (true,"");
					}	
				</f>
				<f save>
					string msg;
					BOB_TYPE content;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						GAME_P game = g->second;
						DOC_WRITER doc;
						doc.write (string_f("boBO%s\n",game->getclass()));
						game->save(doc,false);
						content = doc.getcontent();
						game->resetmodified();
					}else{
						msg = "Unknown game id";
					}
					if (msg.size() > 0){
						content.clear();
						rep_save(false,msg,content,false);
					}else{
						rep_save (true,"",content,false);
					}
				</f>
				<f savemore>
					BOB_TYPE content;
					rep_savemore (false,"Not inplemented",content,false);
				</f>
				<f load>
					string msg;
					auto g = glocal.games.find(gameid);
					const char *type = (const char *)content.getbuffer();
					GAME_P game = nullptr;
					if (g != glocal.games.end()){
						game = g->second;
					}else{
						game = documentd_newgame(type,gameid,msg);
					}
					if (game != nullptr){
						glocal.games[gameid] = game;
						DOC_READER doc(type+9);
						game->load(doc,msg);
					}
					if (msg.size() > 0){
						rep_load (false,msg);
					}else{
						rep_load (true,"");
					}
				</f>
				<f loadmore>
				</f>
				<f is_modified> // gameid = success:b msg modified:b
					bool modified = false;
					const char *modified_by = "";
					string msg;
					auto g = glocal.games.find(gameid);
					if (g != glocal.games.end()){
						modified = g->second->is_modified();
						modified_by = g->second->get_modified_by();
					}else{
						msg = "Unknown document";
					}
					if (msg.size() > 0){
						rep_is_modified(false,msg,false,"",0);
					}else{
						rep_is_modified(true,"",modified,modified_by,g->second->get_revision());
					}
				</f>
				<f waitevent>	// gameid sequence:u = success:b msg script sequence:u
					auto g = glocal.games.find(gameid);
					if (g == glocal.games.end()){
						rep_waitevent (false,"Invalid gameid","",0);
					}else{
						GAME_P game = g->second;
						// We either reply immediatly, or when an event occur
						const char *script = game->locate_event(sequence);
						if (script != nullptr){
							total_notify_size += strlen(script);
							rep_waitevent (true,"",script,sequence);
						}else{
							game->add_notification_fd(no);
						}
					}
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_SUBPROGRAM){
				for (auto &s:glocal.programs){
					if (s.is_fdout(no)){
						//printf ("out %s: %s\n",s.get_gameid(),line);
						s.inc_nbrec();
						for (auto &m:glocal.games){
							if (m.first == s.get_gameid()){
								string notify;
								bool done = false;
								m.second->engine_reply(line,notify,done);
								if (done) s.reset_gameid();
								s.sendmore();
								m.second->add_notification(notify);
								break;
							}
						}
					}else if (s.is_fderr(no)){
						tlmp_error ("engine %s error: %s\n",s.get_gameid(),line);
					}
				}
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}
		// Register all subprograms
		for (auto &p:glocal.programs){
			HANDLE_INFO *n = new HANDLE_INFO;
			n->type = TYPE_SUBPROGRAM;
			s.inject (p.get_fdout(),n);
			n = new HANDLE_INFO;
			n->type = TYPE_SUBPROGRAM;
			s.inject (p.get_fderr(),n);
		}

		if (!some_errors && s.is_ok()){
			// Load saved games/documents
			if (file_type("/tmp/game.0")==0){
				<call walkfs>("/tmp");
				<f onefile>
					if (strncmp(basename,"game.",5)==0){
						FILE *fin = fopen (path,"r");
						if (fin == nullptr){
							tlmp_error ("Can't open saved game %s (%s)\n",path,strerror(errno));
						}else{
							char buf1[1000],buf2[1000];
							if (fgets(buf1,sizeof(buf1)-1,fin)!=nullptr
								&& fgets(buf2,sizeof(buf2)-1,fin)!=nullptr){
								strip_end (buf1);
								const char *pt;
								time_t mod = 0;
								if (is_start_any_of(buf2,pt,"modified=")){
									mod = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								string mod_by;
								if (is_start_any_of(buf2,pt,"modified_by=")){
									mod_by = pt;
									strip_end (mod_by);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								time_t act = 0;
								if (is_start_any_of(buf2,pt,"activity=")){
									act = atoi(pt);
									fgets(buf2,sizeof(buf2)-1,fin);
								}
								strip_end (buf2);
								string msg;
								if (!documentd_startgame(glocal.games,buf2,buf1,msg)){
									tlmp_error ("Can't initialise game %s/%s (%s)\n",buf1,buf2,msg.c_str());
								}else{
									DOC_READER doc(fin);
									auto g = glocal.games[buf1];
									g->load(doc,msg);
									g->setmodified(mod,mod_by.c_str());
									g->setactivity(act);
								}
							}
							fclose (fin);
						}
						unlink (path);
					}
				</f>
				</call>
			}
			chmod (glocal.clientsock,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			open_instrument_file();
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

#include <ft2build.h>
#include FT_FREETYPE_H
#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000

// This one could use a better name, I just don't know a better one (yet?)
#define UTF8_OTHER_MASK 0b00111111

static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
/*
	Compute the width and height of the string using a font library.
*/
unsigned documentd_displaylen (const char *title, unsigned fontsize, float size)
{
	unsigned ret = 0;
	static bool some_errors = false;
	static bool is_init = false;
	static FT_Library  library;
	static FT_Face     face;      /* handle to face object */
	if (!is_init){
		is_init = true;
		some_errors = true;
		int error = FT_Init_FreeType( &library );
		if ( error ){
			tlmp_error ("  ... an error occurred during library initialization ...\n");
		}else{
			const char *fontfile = nullptr;
			for (auto s:{
				"/usr/share/fonts/dejavu/DejaVuSerif.ttf",
				"/usr/share/fonts/liberation-sans/LiberationSans-Regular.ttf",
				"/usr/share/fonts/liberation/LiberationSans-Regular.ttf",
				"/usr/share/fonts/dejavu/DejaVuSans.ttf"
				}){
				if (file_type(s)!=-1){
					fontfile = s;
					break;
				}
			}
			if (fontfile == nullptr){
				some_errors = true;
				tlmp_error ("tlmpweb_displaylen: No font file found");
			}else{
				error = FT_New_Face(library,fontfile,0,&face);
				if ( error == FT_Err_Unknown_File_Format ){
					tlmp_error ("... the font file could be opened and read, but it appears\n"
						"... that its font format is unsupported\n");
				}else if ( error ){
					tlmp_error ("... another error code means that the font file could not\n"
						"... be opened or read, or that it is broken...\n");
				}else{
					some_errors = false;
				}
			}
		}

	}
	unsigned font_charsize = fontsize*64*size;
	font_charsize = 13.6*64*size;
	if (!some_errors){
		static unsigned last_charsize=0;
		//unsigned charsize = 13.6*64*size;
		if (font_charsize != last_charsize){
			last_charsize = font_charsize;
			int error = FT_Set_Char_Size(
				face,    /* handle to face object           */
				0,       /* char_width in 1/64th of points  */
				font_charsize,   /* char_height in 1/64th of points */
				0,     /* horizontal device resolution    */
				0 );   /* vertical device resolution      */
			if (error){
				tlmp_error ("Set_Char_Size %u error\n",font_charsize);
			}else{
				some_errors = false;
			}
		}
	}
	if (some_errors){
		ret = strlen(title)*9;
	}else{
		const char *pt = title;
		while (*pt != '\0'){
			unsigned t = *pt++;
			size_t charsize = utf8_codepoint_size(t);
			switch(charsize){
			case 1:
				break;
			case 2:
				if (*pt == '\0') break;
				t = (t<<8)+*pt++;
				break;
			case 3:
				break;
			case 4:
				break;
			}
			struct CACHECHAR{
				unsigned car;
				unsigned font_charsize;
				CACHECHAR(unsigned _car, unsigned _font_charsize){
					car = _car;
					font_charsize = _font_charsize;
				}
				bool operator < (const CACHECHAR &n) const {
					return tie(font_charsize,car) < tie(n.font_charsize,n.car);
				}
			};
			static map<CACHECHAR,unsigned short> cache;
			auto &cached_width = cache[CACHECHAR(t,font_charsize)];
			if (cached_width == 0){
				unsigned glyph_index = FT_Get_Char_Index( face, t );

				/* load glyph image into the slot (erase previous one) */
				int error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );
				if ( error )   continue;  /* ignore errors */
				/* convert to an anti-aliased bitmap */
				error = FT_Render_Glyph( face->glyph, FT_RENDER_MODE_NORMAL );
				if ( error ) continue;

				//tlmp_error ("dislay_len: %c -> %u\n",t,(unsigned)(face->glyph->advance.x >> 6));
				cached_width = face->glyph->advance.x >> 6;
				//ret += 1;	// One pixel between characters. advance takes care of that
						// but for now, we are not using the same font as the browser
			}
			ret += cached_width;
		}
	}
	return ret;
}

