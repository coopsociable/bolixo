/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	White board drawing program.
	The goal of this program is to create drawings very quickly. It may contain
		text
		graph

	Anything we usually draw to explain an idea.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;


#include "proto/documentd_whiteboard.protoch"
#include "proto/documentd_whiteboard.protoh"

enum WHITEBOARD_ELMTYPE {	// Type of element
	TYPE_ELLIPSE,
	TYPE_RECT,
	TYPE_LINE,	// One line or arrow
	TYPE_HANDLINE,	// line drawn by hand
};

enum WHITEBOARD_SELMODE{
	SEL_NONE,
	SEL_SELECTED,	// This element is selected so we can act on it
			// (move it, enlarge it).
	SEL_STAR,	// This element is selected so we can attach
			// more elements to it.
	SEL_IMBED,	// This element is selected so we can insert
			// more elements into it.
};
static const char *tbcolor[]={"black","red","yellow","green"};

enum ARROW_TYPE{
	ARROW_NONE,	// No line
	ARROW_END,	// A line with an arrow at tne end
	ARROW_START,	// A line with an arrow at the start
	ARROW_BOTH,	// A line with an arrow at the start and the end
	ARROW_RETURN,	// A line with an arrow at the end and another line, curved, with an arrow at the start
	ARROW_LINE,	// Just a line
	ARROW_LAST,	// Last item in the list + 1
};
struct SUBELM{
	unsigned id = 0;
	ARROW_TYPE arrow;
	SUBELM(unsigned _id, ARROW_TYPE _arrow)
		:id(_id), arrow(_arrow){
	}
};
/*
	Make sure size do not underflow
*/
inline void check_limit (unsigned short &size, int val)
{
	if (val > 0 || -val < size){
		size += val;
	}
}
struct WHITEBOARD_ELM{
	WHITEBOARD_SELMODE selmode = SEL_NONE;	// Make the element more visible
						// for other actions
	unsigned id = 0;
	unsigned short x;	// Coordinates
	unsigned short y;
	unsigned short x1=0;	// end coordinates
	unsigned short y1=0;
	unsigned short width=0;
	unsigned short height=0;
	std::string label;	// Useful to reference the element in scripts ?
	WHITEBOARD_ELMTYPE type;
	std::string txt;	// Caption
	vector<unsigned> insides;		// insides are drawn inside the element.
	vector<SUBELM> subelms;		// subelms are related elements.
	void resize(int val, bool horizontal_only, bool vertical_only){
		if (horizontal_only){
			check_limit(width,val);
		}else if (vertical_only){
			check_limit(height,val);
		}else if (width == height || width == 0 || height == 0){
			check_limit (width,val);
			check_limit (height,val);
		}else{
			// Here we should compute the aspect ratio of the object and preserve it.
			double ratio = (double)width/height;
			check_limit(width,ratio*val);
			check_limit(height,val/ratio);
		}
	}
	void move(map<unsigned,WHITEBOARD_ELM> &elements, int movex, int movey, set<unsigned> &ids){
		ids.insert (id);
		x += movex;
		y += movey;
		for (auto &e:insides){
			elements[e].move(elements,movex,movey,ids);
		}
	}
	void redraw(VARVAL &var){
		const char *stroke_color = tbcolor[selmode];
		unsigned w_2 = width/2;
		unsigned h_2 = height/2;
		if (type == TYPE_ELLIPSE){
			var.val += string_f("replace_ellipse('e%u',%u,%u,%u,%u,'%s');\n",id,x,y,w_2,h_2,stroke_color);
		}else if (type == TYPE_RECT){
			var.val += string_f("replace_rect('e%u',%d,%d,%u,%u,'%s');\n",id,(int)x-w_2,(int)y-h_2,width,height,stroke_color);
		}else{
		}
	}
};

struct WHITEBOARD_PREF{
	bool selecting = true;
	bool starmode = false;	// We are attaching more items to another.
	bool imbedmode = false;	// We are inserting items inside another.
	MOD_KBD mod;
};

class WHITEBOARD: public GAME{
	map<unsigned,WHITEBOARD_ELM> elms;
	vector<unsigned> baseelms;
	map<string,WHITEBOARD_PREF> prefs;	// Per session state
	unsigned alloc_id=0;
	void update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res);
	void resetsel(WHITEBOARD_SELMODE, set<unsigned> &ids);
	void redraw(const set<unsigned> &ids, VARVAL &var);
	void alloc_elm(WHITEBOARD_ELM &elm, WHITEBOARD_ELMTYPE type, unsigned x0, unsigned y0){
		elm.selmode = SEL_SELECTED;
		elm.id = alloc_id++;
		elm.type = type;
		elm.x = x0;
		elm.y = y0;
	}
	void add_element(const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, WHITEBOARD_ELM &newelm){
		if (star_elms.size() > 0){
			for (auto p:star_elms) p->subelms.emplace_back(newelm.id,ARROW_END);
		}else if (imbed_elms.size() > 0){
			for (auto p:imbed_elms) p->insides.push_back(newelm.id);
		}else{
			baseelms.push_back(newelm.id);
		}
		elms[newelm.id] = move(newelm);
	}
	unsigned add_ellipse (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned x_ray, unsigned y_ray){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_ELLIPSE,x,y);
		elm.width = x_ray*2;
		elm.height = y_ray*2;
		elm.selmode = SEL_SELECTED;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_rect (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned width, unsigned height){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_RECT,x,y);
		elm.width = width;
		elm.height = height;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_line (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_LINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[elm.id] = move(elm);
		return ret;
	}
	unsigned add_handline (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_HANDLINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[elm.id] = move(elm);
		return ret;
	}
	WHITEBOARD_ELM *locate (unsigned x, unsigned y);
	vector<WHITEBOARD_ELM *> findselected (WHITEBOARD_SELMODE sel);
	void execstep (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp,
		VARVAL &script_var, VARVAL &notify_var, set<unsigned> &notify_ids, std::vector<VARVAL> &res);
	void changeline (const vector<WHITEBOARD_ELM*> &parents, const vector<WHITEBOARD_ELM*> &elms, VARVAL &notify_var);
public:
	friend void walkboard(class _F_walkboard &c, WHITEBOARD *board);
	void save(DOC_WRITER &w, bool);
	void load(DOC_READER &r, std::string &msg);
	void resetgame();
	WHITEBOARD();
	const char *getclass() const;
	void testwin(std::vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res);
	void manyexec (const vector<VARVAL_receive> &steps, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, vector<VARVAL> &res);
};

GAME_P make_WHITEBOARD()
{
	return make_shared<WHITEBOARD>();
}

WHITEBOARD::WHITEBOARD()
{
}
void WHITEBOARD::update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	mvar.val += string_f("updmsg('%s','%s');\n",color,documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void WHITEBOARD::save(DOC_WRITER &w, bool)
{
	documentd_whiteboard_header(&w,revision,alloc_id);
	vector<WHITEBOARD_ELEMENT> elements;
	for (auto &m:elms){
		WHITEBOARD_ELEMENT elm;
		WHITEBOARD_ELM &e = m.second;
		elm.id = e.id;
		elm.x = e.x;
		elm.y = e.y;
		elm.x1 = e.x1;
		elm.y1 = e.y1;
		elm.width = e.width;
		elm.height = e.height;
		elm.type = e.type;
		elm.label = e.label;
		elm.txt = e.txt;
		elm.insides = e.insides;
		for (auto &s:e.subelms){
			WHITEBOARD_SUBELM selm;
			selm.id = s.id;
			selm.arrow = s.arrow;
			elm.subelms.emplace_back(move(selm));
		}
		elements.emplace_back(move(elm));
	}
	documentd_whiteboard_elements (&w,elements);
	documentd_whiteboard_baseelms (&w,baseelms);
}
<mod>
void WHITEBOARD::load(DOC_READER &r, std::string &msg)
{
	resetgame();
	glocal alloc_id;
	glocal revision;
	glocal elms;
	glocal baseelms;
	<call documentd_whiteboard>(&r);
	<f header>
		glocal.revision = revision;
		glocal.alloc_id = alloc_id;
	</f>
	<f elements>
		for (auto &e:elements){
			WHITEBOARD_ELM elm;
			elm.id = e.id;
			elm.x = e.x;
			elm.y = e.y;
			elm.x1 = e.x1;
			elm.y1 = e.y1;
			elm.width = e.width;
			elm.height = e.height;
			elm.type = (WHITEBOARD_ELMTYPE)e.type;
			elm.label = e.label;
			elm.txt = e.txt;
			elm.insides = e.insides;
			for (auto &s:e.subelms) elm.subelms.emplace_back(s.id,(ARROW_TYPE)s.arrow);
			glocal.elms[elm.id] = move(elm);
		}
	</f>
	<f baseelms>
		glocal.baseelms = baseelms;
	</f>
	<f invalid>
	</f>
	</call>
}
</mod>
#define _TLMP_walkboard
struct _F_walkboard{
	#define _F_walkboard_element(x) void x element(WHITEBOARD_ELM &elm, WHITEBOARD_ELM *parent, ARROW_TYPE arrow, bool firstseen, bool &end)
	virtual _F_walkboard_element( )=0;
};
void walkboard(_F_walkboard &c, WHITEBOARD *board)
{
	set<unsigned> seen;
	struct ELEMENTS{
		WHITEBOARD_ELM *parent;
		vector<SUBELM> *subelms;
		vector<unsigned> *insides;
		ELEMENTS(WHITEBOARD_ELM *_parent, vector<SUBELM> *_subelms, vector<unsigned> *_insides)
			: parent(_parent), subelms(_subelms), insides(_insides){
		}
		size_t size() const {
			if (subelms != nullptr) return subelms->size();
			return insides->size();
		}
		SUBELM operator [] (unsigned item) const{
			if (subelms != nullptr){
				return (*subelms)[item];
			}else{
				return SUBELM ((*insides)[item],ARROW_NONE);
			}
		}
	}; 
	deque<ELEMENTS> todo;
	todo.emplace_back(nullptr,nullptr,&board->baseelms);
	bool end = false;
	while (todo.size() > 0 && !end){
		auto elms = todo.front();
		todo.pop_front();
		for (unsigned i=0; i<elms.size(); i++){
			auto subelm = elms[i];
			auto &elm = board->elms[subelm.id];
			bool firstseen = seen.insert(subelm.id).second;
			c.element(elm,elms.parent,subelm.arrow,firstseen,end);
			if (end) break;
			if (elm.insides.size() > 0) todo.emplace_back(nullptr,nullptr,&elm.insides);
			if (elm.subelms.size() > 0){
				todo.emplace_back(&elm,&elm.subelms,nullptr);
			}
		}
	}
}

/*
	Unselect the selected elements.
	ids will contain the id of selected elements.
*/
<mod>
void WHITEBOARD::resetsel(WHITEBOARD_SELMODE selmode, set<unsigned> &ids)
{
	glocal ids;
	glocal selmode;
	<call walkboard>(this);
	<f element>
		if (elm.selmode == glocal.selmode){
			elm.selmode = SEL_NONE;
			glocal.ids.insert(elm.id);
		}
	</f>
	</call>
}
</mod>
struct LINE_SPEC{
	unsigned x;
	unsigned y;
	unsigned len;
	double angle;
	LINE_SPEC (WHITEBOARD_ELM &parent, WHITEBOARD_ELM &elm){
		x = parent.x;
		y = parent.y+parent.height/2;
		auto elm_y = elm.y - elm.height/2;
		int diff_y = elm_y - y;
		int diff_x = elm.x - x;
		angle = atan2(diff_y,diff_x)/M_PI*180;
		len = sqrt(diff_y*diff_y+diff_x*diff_x);
	}
};
/*
	Redraw all elments which have changed
*/
<mod>
void WHITEBOARD::redraw(const set<unsigned> &ids, VARVAL &var)
{
	glocal ids;
	glocal var;
	<call walkboard>(this);
	<f element>
		if (glocal.ids.count(elm.id) > 0){
			elm.redraw(glocal.var);
			if (parent != nullptr){
				LINE_SPEC spec(*parent,elm);
				glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
					,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
			}
		}else if (parent != nullptr && glocal.ids.count(parent->id)>0){
			// The parent was moved, so we must redraw the line to each child.
			LINE_SPEC spec(*parent,elm);
			glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
				,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
		}
	</f>
	</call>
}
</mod>
/*
	Find the first selected item
*/
<mod>
vector<WHITEBOARD_ELM *>WHITEBOARD::findselected(WHITEBOARD_SELMODE selmode)
{
	glocal vector<WHITEBOARD_ELM *> ret;
	glocal selmode;
	<call walkboard>(this);
	<f element>
		if (elm.selmode == glocal.selmode){
			glocal.ret.push_back(&elm);
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>
void WHITEBOARD::resetgame()
{
	elms.clear();
	baseelms.clear();
	alloc_id = 0;
}
const char *WHITEBOARD::getclass() const
{
	return "WHIT";
}
void WHITEBOARD::testwin(std::vector<VARVAL> &res)
{
}

/*
	Locate an element base on coordinates
*/
<mod>
WHITEBOARD_ELM *WHITEBOARD::locate (unsigned x, unsigned y)
{
	glocal WHITEBOARD_ELM *ret = nullptr;
	glocal x;
	glocal y;
	<call walkboard>(this);
	<f element>
		auto x = glocal.x;
		auto y = glocal.y;
		auto w_2 = elm.width/2;
		auto h_2 = elm.height/2;
		switch(elm.type){
		case TYPE_ELLIPSE:
		case TYPE_RECT:
			// tlmp_warning ("x=%u x0=%d x1=%d y=%u y0=%d y1=%u",x,elm.x-elm.len,elm.x+elm.len,y,elm.y-elm.len,elm.y+elm.len);
			if ((int)x > elm.x-w_2 && (int)x < elm.x+w_2 && (int)y > elm.y-h_2 && (int)y < elm.y+h_2){
				glocal.ret = &elm;
			}
			break;
		case TYPE_LINE:
			break;
		case TYPE_HANDLINE:
			break;
		}
		// The following line is removed. We want the function to go deep so it locate objects inside objects.
		//if (glocal.ret != nullptr) end = true;
	</f>
	</call>
	return glocal.ret;
}
static void addsvgelement(
	VARVAL &var,
	const string &gameid,
	const char *elmtype,
	const char *color,
	unsigned stroke_width,
	PARAM_STRING id)
{
	var.val += string_f("var svg = document.getElementById('board-%s');\n",gameid.c_str());
	var.val += string_f("var newElement = document.createElementNS('http://www.w3.org/2000/svg', '%s');\n",elmtype);
	var.val += string_f("newElement.style.stroke = '%s';\n",color);
	var.val += "newElement.style.fill = 'none';\n";
	var.val += string_f("newElement.style.strokeWidth = '%u';\n",stroke_width);
	var.val += string_f("newElement.id='%s';\n",id.ptr);
	var.val += "svg.appendChild(newElement);\n";
}
<mod>
void WHITEBOARD::changeline (const vector<WHITEBOARD_ELM*> &parents, const vector<WHITEBOARD_ELM*> &elms, VARVAL &notify_var)
{
	glocal parents;
	glocal elms;
	glocal notify_var;
	glocal baseelms;
	glocal gameid;
	glocal set<unsigned> has_parent;	// All elements who are in parent.subelms[]
	glocal vector<unsigned> lost_parent;	// This element was disconnected from a parent
						// so it it does not has a parent, it
						// most be added to baseelms;
	<call walkboard>(this);
	<f element>
		if (find(glocal.parents.begin(),glocal.parents.end(),&elm)!=glocal.parents.end()){
			for (auto child:glocal.elms){
				auto sub = find_if(elm.subelms.begin(),elm.subelms.end(),[child](auto &s){return s.id == child->id;});
				if (sub == elm.subelms.end()){
					// This child is not related to the parent, so we add it
					elm.subelms.emplace_back(child->id,ARROW_END);
					// Remove it from baseelms if there
					auto base = find(glocal.baseelms.begin(),glocal.baseelms.end(),child->id);
					if (base != glocal.baseelms.end()) glocal.baseelms.erase(base);
					glocal.has_parent.insert(child->id);
					addsvgelement(glocal.notify_var,glocal.gameid,"g","black",2,string_f("l%u,%u",elm.id,child->id));
				}else{
					sub->arrow = (ARROW_TYPE)((unsigned)sub->arrow+1);
					if (sub->arrow == ARROW_LAST){
						// We loop back to ARROW_NONE.
						// We just remove the entry
						elm.subelms.erase(sub);
						glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",elm.id,child->id);
						// Is it owned by another elements ? If not we have to add it to baseelms.
						glocal.lost_parent.push_back(child->id);
					}else{
						glocal.has_parent.insert(child->id);
					}
				}
			}
		}	
	</f>
	</call>
	for (auto id:glocal.lost_parent){
		if (glocal.has_parent.count(id)==0){
			// Add it to baseelms if not there
			auto base = find (baseelms.begin(),baseelms.end(),id);
			if (base == baseelms.end()) baseelms.push_back(id);
		}
	}
}
</mod>
</mod>
static void whiteboard_update_button (string &script, bool oldstate, bool newstate, unsigned button_id)
{
	if (newstate != oldstate){
		script += string_f("var button = document.getElementById('button%u');\n",button_id);
		script += "if (button != null){\n";
		script += string_f("\tbutton.style.background='%s';\n",newstate ? "lightblue" : "lightgray");
		script += "}\n";
	}
}
void WHITEBOARD::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	tlmp_error ("WHITEBOARD::exec called");
}
<mod>
void WHITEBOARD::execstep (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	VARVAL &notify_var,
	set<unsigned> &notify_ids,
	std::vector<VARVAL> &res)
{
	auto &pref = prefs[session];
	string error,status;
	setactivity();
	if (strcmp(var,"print")==0){
		if (is_any_of(val,"","full")){
			VARVAL v;
			v.var = VAR_CONTENT;
			v.val += "<style>\n";
			v.val += "</style>\n";
			v.val += "<script>\n";

			// Clicking on the board
			v.val += "var mbuttons=[0,0,0];\n";
			v.val += "var mod_ctrl=0;\n";
			v.val += "var mod_shift=0;\n";
			v.val += "var mod_alt=0;\n";
			v.val += "function gameselect(event){\n";
			v.val += "\tmbuttons[event.which-1] = 1;\n";
			v.val += string_f("\tvar elm = document.getElementById('board-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tgameaction(event,'select:'+(event.clientX-rect.left)+','+(event.clientY-rect.top)+ ','+event.which);\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "function gamemouseup(event){\n";
			v.val += "\tmbuttons[event.which-1] = 0;\n";
			v.val += "}\n";

			// Mouse wheel
			v.val += "function gamewheel(event){\n";
			v.val += "\tif (event.deltaY < 0){\n";
                        v.val += "\t\tgameaction(event,'wheel:1,'+mod_ctrl+','+mod_alt+','+mod_shift);\n";
                        v.val += "\t}else{\n";
                        v.val += "\t\tgameaction(event,'wheel:-1,'+mod_ctrl+','+mod_alt+','+mod_shift);\n";
                        v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "var lastx = null;\n";
			v.val += "var lasty = null;\n";

			// Moving an object
			v.val += "function gamemove(event){\n";
			//v.val += "\tconsole.log('mbuttons[]='+mbuttons+' which='+event.which+' button='+event.button+' buttons='+event.buttons+' '+lastx+' '+lasty);\n";
			v.val += "\tif (mbuttons[0]!=1){\n";
			v.val += "\t\tlastx = null;\n";
			v.val += "\t}else{\n";
			v.val += "\t\tif (lastx){\n";
                        v.val += "\t\t\tgameaction(event,'mousemove:'+(event.clientX-lastx)+','+(event.clientY-lasty));\n";
                        v.val += "\t\t}\n";
			v.val += "\t\tlastx=event.clientX;\n";
			v.val += "\t\tlasty=event.clientY;\n";
                        v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";

			// Updating an object 
			v.val += "function replace_ellipse(id, x, y, rx,ry,color){\n";
			js_find_loop_set_META(v.val,"board","ellipse");
			v.val += "\t\t\t\te.setAttribute('cx',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('cy',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('rx',rx);\n"; 
			v.val += "\t\t\t\te.setAttribute('ry',ry);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			js_find_loop_set_end_META(v.val);
			v.val += "function replace_rect(id, x, y, w,h, color){\n";
			js_find_loop_set_META(v.val,"board","rect");
			v.val += "\t\t\t\te.setAttribute('x',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('y',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('width',w);\n"; 
			v.val += "\t\t\t\te.setAttribute('height',h);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			js_find_loop_set_end_META(v.val);
			v.val += "function replace_line(id, x, y, angle, len, color,arrow){\n";
			js_find_loop_set_META(v.val,"board","g");
			v.val += "\t\t\t\twhile (e.firstChild) {\n";
			v.val += "\t\t\t\t\te.removeChild(e.lastChild);\n";
			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.style.stroke = color;\n";
			v.val += "\t\t\t\te.style.fill = color;\n";
			v.val += "\t\t\t\te.style.strokeWidth = '2';\n";
			v.val += "\t\t\t\tvar newElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\te.appendChild(newElement);\n";
			v.val += "\t\t\t\tlen-=10;\n";
			v.val += "\t\t\t\tif(arrow==1){\n";
			// ARROW_END
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==2){\n";
			// ARROW_START
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}else if(arrow==3){\n";
			// ARROW_BOTH
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==4){\n";
			// ARROW_RETURN
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t\tvar path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\te.appendChild(path2);\n";
			v.val += "\t\t\t\t\tpath2.style.fill = 'none';\n";
			v.val += "\t\t\t\t\tvar lenq=len-10;\n";
			v.val += "\t\t\t\t\tpath2.setAttribute('d','M'+lenq+',-7 q-'+(lenq/2)+',-20,-'+(lenq-10)+',0');\n"; 
			v.val += "\t\t\t\t\tvar subg = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n";
			v.val += "\t\t\t\t\te.appendChild(subg);\n";
			v.val += "\t\t\t\t\tsubg.setAttribute('transform','rotate(-15,0,0)');\n";
			v.val += "\t\t\t\t\tvar path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\tpath3.setAttribute('d','M10,-5 l2,-5 l-10,5 l10,5 l-2,-5');\n";
			v.val += "\t\t\t\t\tsubg.appendChild(path3);\n";
			v.val += "\t\t\t\t}else if(arrow==5){\n";
			// ARROW_LINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.setAttribute('transform','translate('+x+','+y+') rotate('+angle+',0,0) translate(5,0)');\n"; 
			js_find_loop_set_end_META(v.val);
			wordproc_set_gamepress(v.val);
			// Dummy needed by gamepress, shared with doc_wordproc
			v.val += "function getlastline(){\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Remove an element
			v.val += "function removeelm(id,tag){\n";
			js_find_loop_set_META(v.val,"board","tag");
			v.val += "\t\t\t\te.parentNode.removeChild(e);\n";
			js_find_loop_set_end_META(v.val);
			// Update the message field
			v.val += "function updmsg(color,msg){\n";
			v.val += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
			v.val += "\tif (elm != null){\n";
			v.val += "\t\telm.style.color=color;\n";
			v.val += "\t\telm.innerHTML=msg;\n";
			v.val += "\t}\n";
			v.val += "}\n";
			
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				documentd_button_start(v.val,gameid);
				documentd_button (v.val,0,"_",specs,false);
				documentd_button (v.val,1,"C",specs,false);
				documentd_button (v.val,2,"Q",specs,false);
				documentd_button (v.val,3,"L",specs,false);
				documentd_button (v.val,4,"H",specs,false);
				documentd_button (v.val,5,"S",specs,pref.selecting);
				documentd_button (v.val,6,"-*-",specs,pref.starmode);
				documentd_button (v.val,7,"[]",specs,pref.imbedmode);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Board
			v.val += string_f("<div class=webtable id=%sdoc_whiteboard >\n",val);
			v.val += string_f("<div id='text-%s'"
				" onkeydown='gamepress(event);return false;'"
				" onkeyup='gamepress(event);return false;'"
				" tabindex=0 >\n",gameid.c_str());
			v.val += string_f("<svg id='board-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'"
				" style=cursor:default;"
				" onmousedown='gameselect(event);'"
				" onmouseup='gamemouseup(event); return false;'"
				" onwheel='gamewheel(event); return false;'"
				" onmousemove='gamemove(event); return false;'"
				" >\n"
				,gameid.c_str(),sp.content_width,sp.content_height,sp.content_width,sp.content_height);
			
			glocal v;
			<call walkboard>(this);
			<f element>
				if (firstseen){
					const char *color = tbcolor[elm.selmode];
					switch(elm.type){
					case TYPE_ELLIPSE:
						glocal.v.val += string_f("<ellipse id='e%u' cx=%u cy=%u rx=%u ry=%u stroke='%s' stroke-width=2 fill='none'/>\n"
							,elm.id,elm.x,elm.y,elm.width/2,elm.height/2,color);
						break;
					case TYPE_RECT:
						glocal.v.val += string_f("<rect id='e%u' x=%d y=%d width=%u height=%u stroke='%s' stroke-width='2' fill='none'/>\n"
							,elm.id,(int)elm.x-elm.width/2,(int)elm.y-elm.height/2,elm.width,elm.height,color);
						break;
					case TYPE_LINE:
						glocal.v.val += string_f("<line id='e%u' x1=%u y1=%u x2=%u y2=%u stroke='%s' stroke-width='2' fill='none'/>\n"
							,elm.id,elm.x,elm.y,elm.x1,elm.y1,color);
						break;
					case TYPE_HANDLINE:
						glocal.v.val += string_f("<path id='e%u' stroke='%s' stroke-width='4' fill='none' d='M%u %u L %u %u'/>\n"
							,elm.id,color,elm.x,elm.y,elm.x1,elm.y1);
						break;
					}
				}
				if (parent != nullptr){
					LINE_SPEC spec(*parent,elm);
					glocal.v.val += string_f("<g id='l%u,%u'/>\n"
						"<script>replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);</script>\n"
						,parent->id,elm.id,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
				}
			</f>
			</call>
			v.val += "</svg>\n";
			v.val += "</div>\n";
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += string_f("<div id=msg-%s style=color:black>&nbsp;</div>\n",gameid.c_str());
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else if (maywrite){
		unsigned lastline = 1000;
		string tmpvar,tmpval;
		if (strcmp(var,"kbd")==0){
			wordproc_kbd(val,pref.mod,tmpvar,tmpval,lastline);
			var = tmpvar.c_str();
			val = tmpval.c_str();		
		}
		if (strcmp(var,"select")==0){
			vector<string> tb;
			int n = str_splitline(val,',',tb);
			if (n == 3){
				unsigned x = atoi(tb[0].c_str());
				unsigned y = atoi(tb[1].c_str());
				unsigned button = atoi(tb[2].c_str());
				if (button == 1 && !pref.mod.shift){
					auto selmode = SEL_SELECTED;
					if (pref.starmode){
						selmode = SEL_STAR;
					}else if(pref.imbedmode){
						selmode = SEL_IMBED;
					}
					resetsel(selmode,notify_ids);
				}
				auto e = locate (x,y);
				tlmp_warning ("select: val=%s x=%u y=%u e=%p",val,x,y,e);
				if (e != nullptr){
					if (pref.selecting){
						if (button == 2){
							auto parents = findselected(SEL_STAR);
							auto selects = findselected(SEL_SELECTED);
							if (parents.size() == 0){
								error = MSG_U(E_NOPARENT,"No parent node selected");
							}else if (selects.size() == 0){
								error = MSG_U(E_NONODE,"No node selected");
							}else{
								changeline (parents,selects,notify_var);
								for (auto s:selects) notify_ids.insert(s->id);
							}
						}else{
							e->selmode = SEL_SELECTED;
						}
					}else if (pref.starmode){
						e->selmode = e->selmode == SEL_STAR ? SEL_NONE : SEL_STAR;
					}else if (pref.imbedmode){
						e->selmode = e->selmode == SEL_IMBED ? SEL_NONE : SEL_IMBED;
					}
					notify_ids.insert(e->id);
				}			
			}
		}else if (strcmp(var,"mousemove")==0){
			auto selects = findselected(SEL_SELECTED);
			if (selects.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				tlmp_warning ("mousemove: n=%d %s",n,val);
				if (n == 2){
					int movex = atoi(tb[0].c_str());
					int movey = atoi(tb[1].c_str());
					for (auto elm:selects) elm->move(elms,movex,movey,notify_ids);
					setmodified(username);
				}
			}
		}else if (strcmp(var,"wheel")==0){
			auto elms = findselected(SEL_SELECTED);
			if (elms.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				if (n == 4){
					int grow = atoi(tb[0].c_str())*5;
					for (auto elm:elms){
						elm->resize(grow,pref.mod.ctrl,pref.mod.shift);
						notify_ids.insert(elm->id);
					}
					setmodified(username);
				}
			}
		}else if (strcmp(var,"newgame")==0){
			int uval = atoi(val);
			auto oldpref = pref;
			if (uval == 0){
				resetgame();
				setmodified(username);
			}else if (is_any_of(uval,1,2,3,4)){
				resetsel(SEL_SELECTED,notify_ids);
				auto star_elms = findselected(SEL_STAR);
				auto imbed_elms = findselected(SEL_IMBED);
				tlmp_warning ("star_elm=%lu imbed_elm=%lu",star_elms.size(),imbed_elms.size());
				
				unsigned id=0;
				const unsigned default_size=20;
				const unsigned x=50;
				const unsigned y=50;
				const char *elmtype = "";
				unsigned stroke_width = 2;
				string extra;
				bool addline = false;
				if (uval == 1){
					id = add_ellipse(star_elms,imbed_elms,x,y,default_size/2,default_size/2);
					elmtype = "ellipse";
					extra += string_f("newElement.setAttribute('cx',%u);\n",x);
					extra += string_f("newElement.setAttribute('cy',%u);\n",y);
					extra += string_f("newElement.setAttribute('rx',%u);\n",default_size/2);
					extra += string_f("newElement.setAttribute('ry',%u);\n",default_size/2);
					addline = star_elms.size() > 0;
				}else if (uval == 2){
					id = add_rect(star_elms,imbed_elms,x,y,default_size,default_size);
					elmtype = "rect";
					extra += string_f("newElement.setAttribute('x',%u);\n",x-default_size/2);
					extra += string_f("newElement.setAttribute('y',%u);\n",y-default_size/2);
					extra += string_f("newElement.setAttribute('width',%u);\n",default_size);
					extra += string_f("newElement.setAttribute('height',%u);\n",default_size);
					addline = star_elms.size() > 0;
				}else if (uval == 3){
					id = add_line(x,y,x+default_size,y+default_size);
					elmtype = "line";
					extra += string_f("newElement.setAttribute('x1',%u);\n",x);
					extra += string_f("newElement.setAttribute('y1',%u);\n",y);
					extra += string_f("newElement.setAttribute('x2',%u);\n",x+default_size);
					extra += string_f("newElement.setAttribute('y2',%u);\n",y+default_size);
				}else if (uval == 4){
					stroke_width = 4;
					id = add_handline(x,y,x+default_size,y+default_size);
					elmtype = "path";
				}
				addsvgelement(notify_var,gameid,elmtype,"red",stroke_width,string_f("e%u",id));
				notify_var.val += extra;
				if (addline){
					for (auto p:star_elms) addsvgelement(notify_var,gameid,"g","black",stroke_width,string_f("l%u,%u",p->id,id));
				}
				notify_ids.insert(id);
				setmodified(username);
				pref.selecting = true;
				pref.starmode = pref.imbedmode = false;
			}else if (is_any_of(uval,5,6,7)){
				if (uval == 5){
					pref.selecting = true;
					resetsel(SEL_SELECTED,notify_ids);
					pref.starmode = pref.imbedmode = false;
				}else if (uval == 6){
					resetsel(SEL_STAR,notify_ids);
					pref.starmode = true;
					pref.selecting = pref.imbedmode = false;
				}else if (uval == 7){
					resetsel(SEL_IMBED,notify_ids);
					pref.imbedmode = true;
					pref.selecting = pref.starmode = false;
				}
			}else{
				tlmp_error ("checkers newgame=%d",uval);
			}
			whiteboard_update_button (script_var.val, oldpref.selecting,pref.selecting, 5);
			whiteboard_update_button (script_var.val, oldpref.starmode,pref.starmode, 6);
			whiteboard_update_button (script_var.val, oldpref.imbedmode,pref.imbedmode, 7);
			script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
		}
	}else{
		error = MSG_R(E_READONLY);
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else{
		update_msg(false,"&nbsp;","white",res);
	}
}
</mod>
void WHITEBOARD::manyexec (
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	set<unsigned> notify_ids;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,session,username,maywrite,sp,script_var,notify_var,notify_ids,res);
	}
	redraw(notify_ids,notify_var);
	res.emplace_back(move(notify_var));
	res.emplace_back(move(script_var));
}
