/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	White board drawing program.
	The goal of this program is to create drawings very quickly. It may contain
		text
		graph

	Anything we usually draw to explain an idea.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;

enum WHITEBOARD_SELMODE{
	SEL_NONE,
	SEL_SELECTED,	// This element is selected so we can act on it
			// (move it, enlarge it).
	SEL_STAR,	// This element is selected so we can attach
			// more elements to it.
	SEL_IMBED,	// This element is selected so we can insert
			// more elements into it.
};
enum WHITEBOARD_TEXTPOS{
	TEXTPOS_INSIDE,
	TEXTPOS_TOP,
	TEXTPOS_BOTTOM,
	TEXTPOS_LEFT,
	TEXTPOS_RIGHT,
	TEXTPOS_LAST
};
enum ARROW_TYPE{
	ARROW_NONE,	// No line
	ARROW_END,	// A line with an arrow at tne end
	ARROW_START,	// A line with an arrow at the start
	ARROW_BOTH,	// A line with an arrow at the start and the end
	ARROW_RETURN,	// A line with an arrow at the end and another line, curved, with an arrow at the start
	ARROW_LINE,	// Just a line
	ARROW_DASH,	// Just a dash line
	ARROW_DOT,	// Just a dot line
	ARROW_LAST,	// Last item in the list + 1
};
enum BOX_TYPE{
	BOX_SOLID,	// Solid line
	BOX_DASH,	// Dash line
	BOX_DOT,	// Dot line
	BOX_LAST,	// Last item in the list + 1
};

#include "proto/documentd_whiteboard.protoch"
#include "proto/documentd_whiteboard.protoh"

enum WHITEBOARD_ELMTYPE {	// Type of element
	TYPE_ELLIPSE,
	TYPE_RECT,
	TYPE_LINE,	// One line or arrow
	TYPE_HANDLINE,	// line drawn by hand
};

static const char *tbcolor[]={"black","red","yellow","green"};


struct SUBELM{
	unsigned id = 0;
	ARROW_TYPE arrow;
	SUBELM(unsigned _id, ARROW_TYPE _arrow)
		:id(_id), arrow(_arrow){
	}
};
/*
	Make sure size do not underflow
*/
inline void check_limit (unsigned short &size, int val)
{
	if (val > 0 || -val < size){
		size += val;
	}
}
struct WHITEBOARD_ELM{
	WHITEBOARD_SELMODE selmode = SEL_NONE;	// Make the element more visible
						// for other actions
	BOX_TYPE box_type = BOX_SOLID;
	unsigned id = 0;
	unsigned short x;	// Coordinates
	unsigned short y;
	unsigned short x1=0;	// end coordinates
	unsigned short y1=0;
	unsigned short width=0;
	unsigned short height=0;
	std::string label;	// Useful to reference the element in scripts ?
	WHITEBOARD_ELMTYPE type;
	std::string txt;	// Caption
	WHITEBOARD_TEXTPOS textpos = TEXTPOS_INSIDE;
	vector<unsigned> insides;		// insides are drawn inside the element.
	vector<SUBELM> subelms;		// subelms are related elements.
	void resize(int val, bool horizontal_only, bool vertical_only){
		if (horizontal_only){
			check_limit(width,val);
		}else if (vertical_only){
			check_limit(height,val);
		}else if (width == height || width == 0 || height == 0){
			check_limit (width,val);
			check_limit (height,val);
		}else{
			// Here we should compute the aspect ratio of the object and preserve it.
			double ratio = (double)width/height;
			check_limit(width,ratio*val);
			check_limit(height,val/ratio);
		}
	}
	void move(map<unsigned,WHITEBOARD_ELM> &elements, int movex, int movey, set<unsigned> &ids){
		ids.insert (id);
		x += movex;
		y += movey;
		if (type == TYPE_LINE){
			x1 += movex;
			y1 += movey;
		}
		for (auto &e:insides){
			elements[e].move(elements,movex,movey,ids);
		}
	}
	void gettextpos(unsigned &textx, unsigned &texty){
		static unsigned fontsize=14;
		textx=0;
		texty=0;
		unsigned w_2 = width/2;
		unsigned h_2 = height/2;
		unsigned textlen = documentd_displaylen (txt.c_str(),fontsize,1);
		unsigned centerx=0;
		unsigned centery=y+fontsize/2-3;
		if (textlen >= width){
			// Text too large, put it at the start of the object
			centerx = x-w_2;
		}else{
			// Center the text
			centerx = x-w_2+(width-textlen)/2;
		}
		switch(textpos){
		case TEXTPOS_LAST:
		case TEXTPOS_INSIDE:
			textx = centerx;
			texty = centery;
			break;
		case TEXTPOS_TOP:
			textx = centerx;
			texty = y-h_2-3;
			break;
		case TEXTPOS_BOTTOM:
			textx = centerx;
			texty = y+h_2+fontsize;
			break;
		case TEXTPOS_LEFT:
			textx = x-w_2-3-textlen;
			texty = centery;
			break;
		case TEXTPOS_RIGHT:
			textx = x+w_2+3;
			texty = centery;
			break;
		}
	}
	void redraw(VARVAL &var){
		const char *stroke_color = tbcolor[selmode];
		unsigned w_2 = width/2;
		unsigned h_2 = height/2;
		if (type == TYPE_ELLIPSE){
			var.val += string_f("replace_ellipse('e%u',%u,%u,%u,%u,'%s',%u);\n",id,x,y,w_2,h_2,stroke_color,box_type);
		}else if (type == TYPE_RECT){
			var.val += string_f("replace_rect('e%u',%d,%d,%u,%u,'%s',%u);\n",id,(int)x-w_2,(int)y-h_2,width,height,stroke_color,box_type);
		}else if (type == TYPE_LINE){
			var.val += string_f("replace_typeline('e%u',%u,%u,%u,%u,'%s',%u);\n",id,x,y,x1,y1,stroke_color,box_type);
		}else{
		}
		unsigned textx,texty;
		gettextpos(textx,texty);
		var.val += string_f("replace_text('t%u',%u,%u,'%s','%s');\n",id,textx,texty,stroke_color,documentd_escape(txt).c_str());
	}
};

struct WHITEBOARD_PREF{
	bool selecting = true;
	bool starmode = false;	// We are attaching more items to another.
	bool imbedmode = false;	// We are inserting items inside another.
	MOD_KBD mod;
};

class WHITEBOARD: public GAME{
	map<unsigned,WHITEBOARD_ELM> elms;
	vector<unsigned> baseelms;
	map<string,WHITEBOARD_PREF> prefs;	// Per session state
	unsigned alloc_id=0;
	void update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res);
	void resetsel(WHITEBOARD_SELMODE, set<unsigned> &ids);
	void redraw(const set<unsigned> &ids, VARVAL &var);
	void alloc_elm(WHITEBOARD_ELM &elm, WHITEBOARD_ELMTYPE type, unsigned x0, unsigned y0){
		elm.selmode = SEL_SELECTED;
		elm.id = alloc_id++;
		elm.type = type;
		elm.x = x0;
		elm.y = y0;
	}
	void add_element(const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, WHITEBOARD_ELM &newelm){
		if (star_elms.size() > 0){
			for (auto p:star_elms) p->subelms.emplace_back(newelm.id,ARROW_END);
		}else if (imbed_elms.size() > 0){
			for (auto p:imbed_elms) p->insides.push_back(newelm.id);
		}else{
			baseelms.push_back(newelm.id);
		}
		elms[newelm.id] = move(newelm);
	}
	unsigned add_ellipse (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned x_ray, unsigned y_ray){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_ELLIPSE,x,y);
		elm.width = x_ray*2;
		elm.height = y_ray*2;
		elm.selmode = SEL_SELECTED;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_rect (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned width, unsigned height){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_RECT,x,y);
		elm.width = width;
		elm.height = height;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_line (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_LINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[ret] = move(elm);
		baseelms.push_back(ret);
		return ret;
	}
	unsigned add_handline (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_HANDLINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[ret] = move(elm);
		baseelms.push_back(ret);
		return ret;
	}
	WHITEBOARD_ELM *locate (unsigned x, unsigned y);
	vector<WHITEBOARD_ELM *> findselected (WHITEBOARD_SELMODE sel);
	void execstep (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp,
		VARVAL &script_var, VARVAL &notify_var, set<unsigned> &notify_ids, std::vector<VARVAL> &res);
	void changeline (const vector<WHITEBOARD_ELM*> &parents, const vector<WHITEBOARD_ELM*> &elms, int direction, ARROW_TYPE arrow, VARVAL &notify_var);
	void delete_elm(unsigned id, VARVAL &notify_var);
	unsigned place_newelm(WHITEBOARD_ELMTYPE type, unsigned x, unsigned y, unsigned width, unsigned height,
		vector<WHITEBOARD_ELM*> &star_elms, vector<WHITEBOARD_ELM*> &imbed_elms,
		VARVAL &notify_var, set<unsigned> &notify_ids);
public:
	friend void walkboard(class _F_walkboard &c, WHITEBOARD *board);
	void save(DOC_WRITER &w, bool);
	void load(DOC_READER &r, std::string &msg);
	void resetgame();
	WHITEBOARD();
	const char *getclass() const;
	void testwin(std::vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res);
	void manyexec (const vector<VARVAL_receive> &steps, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, vector<VARVAL> &res);
};

GAME_P make_WHITEBOARD()
{
	return make_shared<WHITEBOARD>();
}

WHITEBOARD::WHITEBOARD()
{
}
void WHITEBOARD::update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	mvar.val += string_f("updmsg('%s','%s');\n",color,documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void WHITEBOARD::save(DOC_WRITER &w, bool)
{
	documentd_whiteboard_header(&w,revision,alloc_id);
	vector<WHITEBOARD_ELEMENT> elements;
	for (auto &m:elms){
		WHITEBOARD_ELEMENT elm;
		WHITEBOARD_ELM &e = m.second;
		elm.id = e.id;
		elm.selmode = e.selmode;
		elm.box_type = e.box_type;
		elm.x = e.x;
		elm.y = e.y;
		elm.x1 = e.x1;
		elm.y1 = e.y1;
		elm.width = e.width;
		elm.height = e.height;
		elm.type = e.type;
		elm.label = e.label;
		elm.txt = e.txt;
		elm.textpos = e.textpos;
		elm.insides = e.insides;
		for (auto &s:e.subelms){
			WHITEBOARD_SUBELM selm;
			selm.id = s.id;
			selm.arrow = s.arrow;
			elm.subelms.emplace_back(move(selm));
		}
		elements.emplace_back(move(elm));
	}
	documentd_whiteboard_elements (&w,elements);
	documentd_whiteboard_baseelms (&w,baseelms);
}
<mod>
void WHITEBOARD::load(DOC_READER &r, std::string &msg)
{
	resetgame();
	glocal alloc_id;
	glocal revision;
	glocal elms;
	glocal baseelms;
	<call documentd_whiteboard>(&r);
	<f header>
		glocal.revision = revision;
		glocal.alloc_id = alloc_id;
	</f>
	<f elements>
		for (auto &e:elements){
			WHITEBOARD_ELM elm;
			elm.id = e.id;
			elm.selmode = e.selmode;
			elm.box_type = e.box_type;
			elm.x = e.x;
			elm.y = e.y;
			elm.x1 = e.x1;
			elm.y1 = e.y1;
			elm.width = e.width;
			elm.height = e.height;
			elm.type = (WHITEBOARD_ELMTYPE)e.type;
			elm.label = e.label;
			elm.txt = e.txt;
			elm.textpos = e.textpos;
			elm.insides = e.insides;
			for (auto &s:e.subelms) elm.subelms.emplace_back(s.id,s.arrow);
			glocal.elms[elm.id] = move(elm);
		}
	</f>
	<f baseelms>
		glocal.baseelms = baseelms;
	</f>
	<f invalid>
		tlmp_error ("Invalid record while reading whiteboard file: %s",msg);
	</f>
	</call>
}
</mod>
#define _TLMP_walkboard
struct _F_walkboard{
	#define _F_walkboard_element(x) void x element(WHITEBOARD_ELM &elm, WHITEBOARD_ELM *parent, ARROW_TYPE arrow, bool firstseen, bool &end)
	virtual _F_walkboard_element( )=0;
};
void walkboard(_F_walkboard &c, WHITEBOARD *board)
{
	set<unsigned> seen;
	struct ELEMENTS{
		WHITEBOARD_ELM *parent;
		vector<SUBELM> *subelms;
		vector<unsigned> *insides;
		ELEMENTS(WHITEBOARD_ELM *_parent, vector<SUBELM> *_subelms, vector<unsigned> *_insides)
			: parent(_parent), subelms(_subelms), insides(_insides){
		}
		size_t size() const {
			if (subelms != nullptr) return subelms->size();
			return insides->size();
		}
		SUBELM operator [] (unsigned item) const{
			if (subelms != nullptr){
				return (*subelms)[item];
			}else{
				return SUBELM ((*insides)[item],ARROW_NONE);
			}
		}
	}; 
	deque<ELEMENTS> todo;
	todo.emplace_back(nullptr,nullptr,&board->baseelms);
	bool end = false;
	while (todo.size() > 0 && !end){
		auto elms = todo.front();
		todo.pop_front();
		for (unsigned i=0; i<elms.size(); i++){
			auto subelm = elms[i];
			auto &elm = board->elms[subelm.id];
			bool firstseen = seen.insert(subelm.id).second;
			c.element(elm,elms.parent,subelm.arrow,firstseen,end);
			if (end) break;
			if (elm.insides.size() > 0) todo.emplace_back(nullptr,nullptr,&elm.insides);
			if (elm.subelms.size() > 0){
				todo.emplace_back(&elm,&elm.subelms,nullptr);
			}
		}
	}
}

/*
	Unselect the selected elements.
	ids will contain the id of selected elements.
*/
<mod>
void WHITEBOARD::resetsel(WHITEBOARD_SELMODE selmode, set<unsigned> &ids)
{
	glocal ids;
	glocal selmode;
	<call walkboard>(this);
	<f element>
		if (elm.selmode == glocal.selmode){
			elm.selmode = SEL_NONE;
			glocal.ids.insert(elm.id);
		}
	</f>
	</call>
}
</mod>
struct LINE_SPEC{
	unsigned x;
	unsigned y;
	unsigned len;
	double angle;
	LINE_SPEC (WHITEBOARD_ELM &parent, WHITEBOARD_ELM &elm){
		x = parent.x;
		y = parent.y+parent.height/2;
		auto elm_y = elm.y - elm.height/2;
		int diff_y = elm_y - y;
		int diff_x = elm.x - x;
		angle = atan2(diff_y,diff_x)/M_PI*180;
		len = sqrt(diff_y*diff_y+diff_x*diff_x);
	}
};
/*
	Redraw all elments which have changed
*/
<mod>
void WHITEBOARD::redraw(const set<unsigned> &ids, VARVAL &var)
{
	glocal ids;
	glocal var;
	<call walkboard>(this);
	<f element>
		if (glocal.ids.count(elm.id) > 0){
			elm.redraw(glocal.var);
			if (parent != nullptr){
				LINE_SPEC spec(*parent,elm);
				glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
					,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
			}
		}else if (parent != nullptr && glocal.ids.count(parent->id)>0){
			// The parent was moved, so we must redraw the line to each child.
			LINE_SPEC spec(*parent,elm);
			glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
				,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
		}
	</f>
	</call>
}
</mod>
/*
	Find all selected items (matching selmode)
*/
<mod>
vector<WHITEBOARD_ELM *>WHITEBOARD::findselected(WHITEBOARD_SELMODE selmode)
{
	vector<WHITEBOARD_ELM *> ret;
	for (auto &e:elms){
		if (e.second.selmode == selmode) ret.push_back(&e.second);
	}
	return ret;
}
</mod>
void WHITEBOARD::resetgame()
{
	elms.clear();
	baseelms.clear();
	alloc_id = 0;
}
const char *WHITEBOARD::getclass() const
{
	return "WHIT";
}
void WHITEBOARD::testwin(std::vector<VARVAL> &res)
{
}

/*
	Locate an element base on coordinates
*/
<mod>
WHITEBOARD_ELM *WHITEBOARD::locate (unsigned x, unsigned y)
{
	glocal WHITEBOARD_ELM *ret = nullptr;
	glocal x;
	glocal y;
	<call walkboard>(this);
	<f element>
		auto x = glocal.x;
		auto y = glocal.y;
		auto w_2 = elm.width/2;
		auto h_2 = elm.height/2;
		switch(elm.type){
		case TYPE_ELLIPSE:
		case TYPE_RECT:
			// tlmp_warning ("x=%u x0=%d x1=%d y=%u y0=%d y1=%u",x,elm.x-elm.len,elm.x+elm.len,y,elm.y-elm.len,elm.y+elm.len);
			if ((int)x > elm.x-w_2 && (int)x < elm.x+w_2 && (int)y > elm.y-h_2 && (int)y < elm.y+h_2){
				glocal.ret = &elm;
			}
			break;
		case TYPE_LINE:
			/*
				Selecting a line is harder of the user.
				Here is the logic
				1. We compute the angle of the line: angle
				2. We compute the len of the line: len
				3. We compute the angle of the line made from the start of the line to the pointer position x,y: angle2
				4. We compute the len of this new line: len2
				5. We compute the angle of a triangle rectangle made this way. We use len2 as the base and 5 as the side.
				   This angle represent the how far away the user can click off the line. This is max_angle_diff.
			*/	
			{
				int diffx = elm.x1 - elm.x;
				int diffy = elm.y1 - elm.y;
				double angle = atan2(diffy,diffx);
				tlmp_warning ("diffy=%d diffx=%d angle=%lf",diffy,diffx,angle);
				double len = sqrt(diffx*diffx+diffy*diffy);
				diffx = glocal.x - elm.x;
				diffy = glocal.y - elm.y;
				double angle2 = atan2(diffy,diffx);
				double len2 = sqrt(diffx*diffx+diffy*diffy);
				tlmp_warning ("diffy=%d diffx=%d angle2=%lf",diffy,diffx,angle2);
				tlmp_warning ("angle=%lf angle2=%lf fabs=%lf len=%lf len2=%lf",angle,angle2,fabs(angle2-angle),len,len2);
				double max_angle_diff = atan2 (5,len2);
				tlmp_warning ("max_angle_diff=%lf",max_angle_diff);
				if (len2 <= len && fabs(angle2-angle) < max_angle_diff){
tlmp_warning ("found line");
					glocal.ret = &elm;
				}
			}
			break;
		case TYPE_HANDLINE:
			break;
		}
		// The following line is removed. We want the function to go deep so it locate objects inside objects.
		//if (glocal.ret != nullptr) end = true;
	</f>
	</call>
	return glocal.ret;
}
static void addsvgelement(
	VARVAL &var,
	const string &gameid,
	const char *elmtype,
	const char *color,
	unsigned stroke_width,
	PARAM_STRING id)
{
	var.val += string_f("var svg = document.getElementById('board-%s');\n",gameid.c_str());
	var.val += string_f("var newElement = document.createElementNS('http://www.w3.org/2000/svg', '%s');\n",elmtype);
	var.val += string_f("newElement.style.stroke = '%s';\n",color);
	var.val += "newElement.style.fill = 'none';\n";
	var.val += string_f("newElement.style.strokeWidth = '%u';\n",stroke_width);
	var.val += string_f("newElement.id='%s';\n",id.ptr);
	var.val += "svg.appendChild(newElement);\n";
}
/*
	Change the arrow type between parents and child (elms).
	In interactive mode, we cycle through the arrow type. The parameter direction is either -1 or 1 to control the
	direction of the cycling.
	When direction == 0, the arrow parameter force a specific arrow type.


	Note that ARROW_NONE is never really applied. The relation between parents and elms are removed.
*/
<mod>
void WHITEBOARD::changeline (
	const vector<WHITEBOARD_ELM*> &parents,
	const vector<WHITEBOARD_ELM*> &elms,
	int direction,
	ARROW_TYPE arrow,
	VARVAL &notify_var)
{
	glocal parents;
	glocal elms;
	glocal direction;
	glocal arrow;
	glocal notify_var;
	glocal baseelms;
	glocal gameid;
	glocal set<unsigned> has_parent;	// All elements who are in parent.subelms[]
	glocal vector<unsigned> lost_parent;	// This element was disconnected from a parent
						// so it it does not has a parent, it
						// most be added to baseelms;
	<call walkboard>(this);
	<f element>
		if (find(glocal.parents.begin(),glocal.parents.end(),&elm)!=glocal.parents.end()){
			for (auto child:glocal.elms){
				auto sub = find_if(elm.subelms.begin(),elm.subelms.end(),[child](auto &s){return s.id == child->id;});
				if (sub == elm.subelms.end()){
					if (glocal.direction != 0 || glocal.arrow != ARROW_NONE){
						// This child is not related to the parent, so we add it
						ARROW_TYPE type = glocal.arrow;
						if (glocal.direction != 0) type = glocal.direction==1 ? ARROW_END : ARROW_LINE;
						elm.subelms.emplace_back(child->id,type);
						// Remove it from baseelms if there
						auto base = find(glocal.baseelms.begin(),glocal.baseelms.end(),child->id);
						if (base != glocal.baseelms.end()) glocal.baseelms.erase(base);
						glocal.has_parent.insert(child->id);
						addsvgelement(glocal.notify_var,glocal.gameid,"g","black",2,string_f("l%u,%u",elm.id,child->id));
					}
				}else{
					if (glocal.direction != 0){
						sub->arrow = (ARROW_TYPE)((unsigned)sub->arrow+glocal.direction);
					}else{
						sub->arrow = glocal.arrow;
					}
					if (is_any_of(sub->arrow,ARROW_NONE,ARROW_LAST)){
						// We loop back to ARROW_NONE.
						// We just remove the entry
						elm.subelms.erase(sub);
						glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",elm.id,child->id);
						// Is it owned by another elements ? If not we have to add it to baseelms.
						glocal.lost_parent.push_back(child->id);
					}else{
						glocal.has_parent.insert(child->id);
					}
				}
			}
		}	
	</f>
	</call>
	for (auto id:glocal.lost_parent){
		if (glocal.has_parent.count(id)==0){
			// Add it to baseelms if not there
			auto base = find (baseelms.begin(),baseelms.end(),id);
			if (base == baseelms.end()) baseelms.push_back(id);
		}
	}
}
</mod>
/*
	Delete one element.
	Remove all arrows related to this element (from and to).
	subelms becoming orphans (not connect to any parent) are add to baseelms.
*/
<mod>
void WHITEBOARD::delete_elm (unsigned id, VARVAL &notify_var)
{
	glocal id;
	glocal notify_var;
	glocal bool subelm_done = false;
	glocal set<unsigned> has_parent;
	<call walkboard>(this);
	<f element>
		if (elm.id == glocal.id){
			if (!glocal.subelm_done){
				glocal.subelm_done = true;
				for (auto &s:elm.subelms){
					glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",elm.id,s.id);
				}
				// The subelms become orphan or are owned by another
				elm.subelms.clear();
			}
			if (parent != nullptr){
				glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",parent->id,elm.id);
				auto pt = find_if (parent->subelms.begin(),parent->subelms.end(),[elm](auto &selm){return elm.id==selm.id;});
				parent->subelms.erase(pt);
			}
		}
		for (auto s:elm.subelms) glocal.has_parent.insert(s.id);
	</f>
	</call>
	auto pt = elms.find(id);
	if (pt != elms.end()){
		static const char *tbtag[]={"ellipse","rect","line","path"};
		notify_var.val += string_f("removeelm('e%u','%s');\n",id,tbtag[pt->second.type]);
		notify_var.val += string_f("removeelm('t%u','text');\n",id);
		elms.erase(pt);
		// Remove from baseelms if there
		auto pt = find(baseelms.begin(),baseelms.end(),id);
		if (pt != baseelms.end()) baseelms.erase(pt);
	}
	// We have to add the orphan sub-elements into baseelms
	for (auto &e:elms){
		if (glocal.has_parent.count(e.first)==0
			&& find(baseelms.begin(),baseelms.end(),e.first)==baseelms.end()){
			baseelms.push_back(e.first);
		}
	}
}
</mod>
static void whiteboard_update_button (string &script, bool oldstate, bool newstate, unsigned button_id)
{
	if (newstate != oldstate){
		script += string_f("var button = document.getElementById('button%u');\n",button_id);
		script += "if (button != null){\n";
		script += string_f("\tbutton.style.background='%s';\n",newstate ? "lightblue" : "lightgray");
		script += "}\n";
	}
}
void WHITEBOARD::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	tlmp_error ("WHITEBOARD::exec called");
}
unsigned WHITEBOARD::place_newelm(
	WHITEBOARD_ELMTYPE type,
	unsigned x,
	unsigned y,
	unsigned width,
	unsigned height,
	vector<WHITEBOARD_ELM*> &star_elms,
	vector<WHITEBOARD_ELM*> &imbed_elms,
	VARVAL &notify_var,
	set<unsigned> &notify_ids)
	
{
	const char *svgtype = "";
	unsigned id = 0;
	string extra;
	bool addline = false;
	unsigned width_2 = width/2;
	unsigned height_2 = height/2;
	unsigned stroke_width = 2;
	if (type == TYPE_ELLIPSE){
		id = add_ellipse(star_elms,imbed_elms,x,y,width_2,height_2);
		svgtype = "ellipse";
		extra += string_f("newElement.setAttribute('cx',%u);\n",x);
		extra += string_f("newElement.setAttribute('cy',%u);\n",y);
		extra += string_f("newElement.setAttribute('rx',%u);\n",width_2);
		extra += string_f("newElement.setAttribute('ry',%u);\n",height_2);
		addline = star_elms.size() > 0;
	}else if (type == TYPE_RECT){
		id = add_rect(star_elms,imbed_elms,x,y,width,height);
		svgtype = "rect";
		extra += string_f("newElement.setAttribute('x',%u);\n",x-width_2);
		extra += string_f("newElement.setAttribute('y',%u);\n",y-height_2);
		extra += string_f("newElement.setAttribute('width',%u);\n",width);
		extra += string_f("newElement.setAttribute('height',%u);\n",height);
		addline = star_elms.size() > 0;
	}else if (type == TYPE_LINE){
		id = add_line(x,y,x+width,y+height);
		svgtype = "line";
		extra += string_f("newElement.setAttribute('x1',%u);\n",x);
		extra += string_f("newElement.setAttribute('y1',%u);\n",y);
		extra += string_f("newElement.setAttribute('x2',%u);\n",x+width);
		extra += string_f("newElement.setAttribute('y2',%u);\n",y+height);
	}else if (type == TYPE_HANDLINE){
		stroke_width = 4;
		id = add_handline(x,y,x+width,y+height);
		svgtype = "path";
	}
	addsvgelement(notify_var,gameid,svgtype,"red",stroke_width,string_f("e%u",id));
	addsvgelement(notify_var,gameid,"text","red",1,string_f("t%u",id));
	notify_var.val += extra;
	if (addline){
		for (auto p:star_elms) addsvgelement(notify_var,gameid,"g","black",stroke_width,string_f("l%u,%u",p->id,id));
	}
	notify_ids.insert(id);
	return id;
}
<mod>
void WHITEBOARD::execstep (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	VARVAL &notify_var,
	set<unsigned> &notify_ids,
	std::vector<VARVAL> &res)
{
	auto &pref = prefs[session];
	string error,status;
	setactivity();
	if (strcmp(var,"print")==0){
		if (is_any_of(val,"","full")){
			VARVAL v;
			v.var = VAR_CONTENT;
			v.val += "<style>\n";
			v.val += "</style>\n";
			v.val += "<script>\n";

			// Clicking on the board
			v.val += "var mbuttons=[0,0,0];\n";
			v.val += "var mod_ctrl=0;\n";
			v.val += "var mod_shift=0;\n";
			v.val += "var mod_alt=0;\n";
			v.val += "function gameselect(event){\n";
			v.val += "\tmbuttons[event.which-1] = 1;\n";
			v.val += string_f("\tvar elm = document.getElementById('board-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tgameaction(event,'select:'+(event.clientX-rect.left)+','+(event.clientY-rect.top)+ ','+event.which+','+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "function gamemouseup(event){\n";
			v.val += "\tmbuttons[event.which-1] = 0;\n";
			v.val += "}\n";

			// Mouse wheel
			v.val += "function gamewheel(event){\n";
			v.val += "\tif (event.deltaY < 0){\n";
			v.val += "\t\tgameaction(event,'wheel:1,'+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\t}else{\n";
			v.val += "\t\tgameaction(event,'wheel:-1,'+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";
			v.val += "var lastx = null;\n";
			v.val += "var lasty = null;\n";

			// Moving an object
			v.val += "function gamemove(event){\n";
			//v.val += "\tconsole.log('mbuttons[]='+mbuttons+' which='+event.which+' button='+event.button+' buttons='+event.buttons+' '+lastx+' '+lasty);\n";
			v.val += "\tif (mbuttons[0]!=1){\n";
			v.val += "\t\tlastx = null;\n";
			v.val += "\t}else{\n";
			v.val += "\t\tif (lastx){\n";
                        v.val += "\t\t\tgameaction(event,'mousemove:'+(event.clientX-lastx)+','+(event.clientY-lasty)+','+event.shiftKey+','+event.ctrlKey);\n";
                        v.val += "\t\t}\n";
			v.val += "\t\tlastx=event.clientX;\n";
			v.val += "\t\tlasty=event.clientY;\n";
                        v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";

			// Updating an object 
			v.val += "function setboxtype(e,boxtype){\n";
			v.val += "\tif(boxtype==0){\n";
			v.val += "\t\te.removeAttribute('stroke-dasharray');\n";
			v.val += "\t}else if(boxtype==1){\n";
			v.val += "\t\te.setAttribute('stroke-dasharray','5,5');\n";
			v.val += "\t}else if(boxtype==2){\n";
			v.val += "\t\te.setAttribute('stroke-dasharray','2,5');\n";
			v.val += "\t}\n";
			v.val += "}\n";

			v.val += "function replace_ellipse(id, x, y, rx,ry,color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","ellipse");
			v.val += "\t\t\t\te.setAttribute('cx',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('cy',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('rx',rx);\n"; 
			v.val += "\t\t\t\te.setAttribute('ry',ry);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_rect(id, x, y, w,h, color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","rect");
			v.val += "\t\t\t\te.setAttribute('x',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('y',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('rx',5);\n"; 
			v.val += "\t\t\t\te.setAttribute('ry',5);\n"; 
			v.val += "\t\t\t\te.setAttribute('width',w);\n"; 
			v.val += "\t\t\t\te.setAttribute('height',h);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n";
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_typeline(id, x1, y1, x2, y2, color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","line");
			v.val += "\t\t\t\te.setAttribute('x1',x1);\n"; 
			v.val += "\t\t\t\te.setAttribute('y1',y1);\n"; 
			v.val += "\t\t\t\te.setAttribute('x2',x2);\n"; 
			v.val += "\t\t\t\te.setAttribute('y2',y2);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_text(id, x, y, color, txt){\n";
			js_find_loop_set_META(v.val,"board","text");
			v.val += "\t\t\t\te.setAttribute('x',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('y',y);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\te.style.fill=color;\n"; 
			v.val += "\t\t\t\te.innerHTML=txt;\n"; 
			js_find_loop_set_end_META(v.val);

			// line between a parent and sub-element
			v.val += "function replace_line(id, x, y, angle, len, color,arrow){\n";
			js_find_loop_set_META(v.val,"board","g");
			v.val += "\t\t\t\twhile (e.firstChild) {\n";
			v.val += "\t\t\t\t\te.removeChild(e.lastChild);\n";
			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.style.stroke = color;\n";
			v.val += "\t\t\t\te.style.fill = color;\n";
			v.val += "\t\t\t\te.style.strokeWidth = '1';\n";
			v.val += "\t\t\t\tvar newElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\te.appendChild(newElement);\n";
			v.val += "\t\t\t\tlen-=10;\n";
			v.val += "\t\t\t\tif(arrow==1){\n";
			// ARROW_END
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==2){\n";
			// ARROW_START
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}else if(arrow==3){\n";
			// ARROW_BOTH
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==4){\n";
			// ARROW_RETURN
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t\tvar path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\te.appendChild(path2);\n";
			v.val += "\t\t\t\t\tpath2.style.fill = 'none';\n";
			v.val += "\t\t\t\t\tvar lenq=len-10;\n";
			v.val += "\t\t\t\t\tpath2.setAttribute('d','M'+lenq+',-7 q-'+(lenq/2)+',-20,-'+(lenq-10)+',0');\n"; 
			v.val += "\t\t\t\t\tvar subg = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n";
			v.val += "\t\t\t\t\te.appendChild(subg);\n";
			v.val += "\t\t\t\t\tsubg.setAttribute('transform','rotate(-15,0,0)');\n";
			v.val += "\t\t\t\t\tvar path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\tpath3.setAttribute('d','M10,-5 l2,-5 l-10,5 l10,5 l-2,-5');\n";
			v.val += "\t\t\t\t\tsubg.appendChild(path3);\n";
			v.val += "\t\t\t\t}else if(arrow==5){\n";
			// ARROW_LINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}else if(arrow==6){\n";
			// ARROW_DASHLINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t\tnewElement.setAttribute('stroke-dasharray','5,5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==7){\n";
			// ARROW_DOTLINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t\tnewElement.setAttribute('stroke-dasharray','2,4');\n"; 

			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.setAttribute('transform','translate('+x+','+y+') rotate('+angle+',0,0) translate(5,0)');\n"; 
			js_find_loop_set_end_META(v.val);

			wordproc_set_gamepress(v.val);

			// Dummy needed by gamepress, shared with doc_wordproc
			v.val += "function getlastline(){\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Remove an element
			v.val += "function removeelm(id,tag){\n";
			js_find_loop_set_META(v.val,"board","tag");
			v.val += "\t\t\t\te.parentNode.removeChild(e);\n";
			js_find_loop_set_end_META(v.val);
			// Update the message field
			v.val += "function updmsg(color,msg){\n";
			v.val += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
			v.val += "\tif (elm != null){\n";
			v.val += "\t\telm.style.color=color;\n";
			v.val += "\t\telm.innerHTML=msg;\n";
			v.val += "\t}\n";
			v.val += "}\n";
			
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				#define BUTTON_NEWDOC	0
				#define BUTTON_ELLIPSE	1
				#define BUTTON_RECT	2 
				#define BUTTON_LINE	3
				#define BUTTON_HANDLINE	4
				#define BUTTON_SELECT	5
				#define BUTTON_STARMODE	6
				#define BUTTON_IMBEDMODE 7
				#define BUTTON_BOXTYPE	8
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				documentd_button_start(v.val,gameid);
				string svg_clear= string_f(
					"<svg width=%upx height=%upx>"
					"<rect stroke='black' fill=white stroke-width=1 rx=%u ry=%u x=%u y=%u width=%u height=%u />"
					"</svg>"
					,specs.width,specs.width
					,specs.radius-1,specs.radius-1,2,2,specs.width-4,specs.width-4);
				documentd_bar_button (v.val,BUTTON_NEWDOC,svg_clear,specs,false);
				documentd_button_space(v.val);
				string svg_ellipse= string_f(
					"<svg width=%upx height=%upx>"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=%u />"
					"</svg>"
					,specs.width,specs.width
					,specs.width/2,specs.width/2,specs.width/2-4);
				documentd_bar_button (v.val,BUTTON_ELLIPSE,svg_ellipse,specs,false);
				string svg_rect= string_f(
					"<svg width=%upx height=%upx>"
					"<rect stroke='black' fill=none stroke-width=1 rx=%u ry=%u x=%u y=%u width=%u height=%u />"
					"</svg>"
					,specs.width,specs.width
					,specs.radius-1,specs.radius-1,4,4,specs.width-8,specs.width-8);
				documentd_bar_button (v.val,BUTTON_RECT,svg_rect,specs,false);
				string svg_line= string_f(
					"<svg width=%upx height=%upx>"
					"<line stroke='black' fill=none stroke-width=1 x1=%u y1=%u x2=%u y2=%u />"
					"</svg>"
					,specs.width,specs.width
					,4,4,specs.width-4,specs.width-4);
				documentd_bar_button (v.val,BUTTON_LINE,svg_line,specs,false);
				string svg_handline= string_f(
					"<svg width=%upx height=%upx>"
					"<path stroke='black' fill=none stroke-width=3 d='M%u,%u l%u,%u l%u,%u l%u,%u l%u,%u' />"
					"</svg>"
					,specs.width,specs.width
					,4,4, 4,5, 5,4, 4,5, 5,4);
				documentd_bar_button (v.val,BUTTON_HANDLINE,svg_handline,specs,false);
				documentd_button_space(v.val);
				string svg_select = string_f(
					"<svg width=%upx height=%upx>"
					"<g transform=rotate(45,0,0) >"
					"<path stroke='black' fill=none stroke-width=2 d='M5,0 l%u,0 l-2,-2 l7,2 l-7,2 l2,-2' />"
					"</g>"
					"</svg>"
					,specs.width,specs.width
					,specs.width-4-5);
				documentd_bar_button (v.val,BUTTON_SELECT,svg_select,specs,pref.selecting);
				string svg_star= string_f(
					"<svg width=%upx height=%upx>"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"</svg>"
					,specs.width,specs.width
					,specs.width/4,2*specs.width/3
					,2*specs.width/4,specs.width/3
					,3*specs.width/4,2*specs.width/3);
				documentd_bar_button (v.val,BUTTON_STARMODE,svg_star,specs,pref.starmode);
				string svg_imbed= string_f(
					"<svg width=%upx height=%upx>"
					"<rect stroke='black' fill=none stroke-width=1 rx=%u ry=%u x=%u y=%u width=%u height=%u />"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"<circle stroke='black' fill=none stroke-width=1 cx=%u cy=%u r=3 />"
					"</svg>"
					,specs.width,specs.width
					,specs.radius-1,specs.radius-1,2,2,specs.width-4,specs.width-4
					,specs.width/4,specs.width/2
					,2*specs.width/4,specs.width/2
					,3*specs.width/4,specs.width/2);
				documentd_bar_button (v.val,BUTTON_IMBEDMODE,svg_imbed,specs,pref.imbedmode);
				string svg_dashrect= string_f(
					"<svg width=%upx height=%upx>"
					"<rect stroke='black' fill=none stroke-dasharray='5,5'stroke-width=1 rx=%u ry=%u x=%u y=%u width=%u height=%u />"
					"</svg>"
					,specs.width,specs.width
					,specs.radius-1,specs.radius-1,4,4,specs.width-8,specs.width-8);
				documentd_bar_button (v.val,BUTTON_BOXTYPE,svg_dashrect,specs,false);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Board
			v.val += string_f("<div class=webtable id=%sdoc_whiteboard >\n",val);
			v.val += string_f("<div id='text-%s'"
				" onkeydown='gamepress(event);return false;'"
				" tabindex=0 >\n",gameid.c_str());
			v.val += string_f("<svg id='board-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'"
				" style=cursor:default;"
				" onmousedown='gameselect(event);'"
				" onmouseup='gamemouseup(event); return false;'"
				" onwheel='gamewheel(event); return false;'"
				" onmousemove='gamemove(event); return false;'"
				" >\n"
				,gameid.c_str(),sp.content_width,sp.content_height,sp.content_width,sp.content_height);
			
			glocal v;
			<call walkboard>(this);
			<f element>
				if (firstseen){
					const char *color = tbcolor[elm.selmode];
					static const char *tbdash[]={
						""," stroke-dasharray='5,5'"," stroke-dasharray='2,5'"
					};
					const char *dasharray = tbdash[elm.box_type];
					switch(elm.type){
					case TYPE_ELLIPSE:
						glocal.v.val += string_f("<ellipse id='e%u' cx=%u cy=%u rx=%u ry=%u stroke='%s' stroke-width=2 fill='none'%s />\n"
							,elm.id,elm.x,elm.y,elm.width/2,elm.height/2,color,dasharray);
						break;
					case TYPE_RECT:
						glocal.v.val += string_f("<rect id='e%u' x=%d y=%d rx=5 ry=5 width=%u height=%u stroke='%s' stroke-width='2' fill='none'%s />\n"
							,elm.id,(int)elm.x-elm.width/2,(int)elm.y-elm.height/2,elm.width,elm.height,color,dasharray);
						break;
					case TYPE_LINE:
						glocal.v.val += string_f("<line id='e%u' x1=%u y1=%u x2=%u y2=%u stroke='%s' stroke-width='2' fill='none'%s />\n"
							,elm.id,elm.x,elm.y,elm.x1,elm.y1,color,dasharray);
						break;
					case TYPE_HANDLINE:
						glocal.v.val += string_f("<path id='e%u' stroke='%s' stroke-width='4' fill='none' d='M%u %u L %u %u'/>\n"
							,elm.id,color,elm.x,elm.y,elm.x1,elm.y1);
						break;
					}
					unsigned textx,texty;
					elm.gettextpos(textx,texty);
					glocal.v.val += string_f("<text id='t%u' X=%u Y=%u style='stroke:%s;fill:%s;'>%s</text>\n"
						,elm.id,textx,texty,color,color,documentd_escape(elm.txt).c_str());
				}
				if (parent != nullptr){
					LINE_SPEC spec(*parent,elm);
					glocal.v.val += string_f("<g id='l%u,%u'/>\n"
						"<script>replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);</script>\n"
						,parent->id,elm.id,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
				}
			</f>
			</call>
			v.val += "</svg>\n";
			v.val += "</div>\n";
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += string_f("<div id=msg-%s style=color:black>&nbsp;</div>\n",gameid.c_str());
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else if (strcmp(var,REQ_GETFIELDS)==0){
		VARVAL var;
		var.var = VAR_FIELDS;
		res.emplace_back(var);
	}else if (strcmp(var,"dump")==0){
		VARVAL var;
		var.var = "elements";
		for (auto &s:elms){
			var.val += string_f("element: id=%u label=%s txt=%s type=%u selmode=%u boxtype=%u x=%u y=%u x1=%u y1=%u width=%u height=%u\n"
				,s.first,s.second.label.c_str(),s.second.txt.c_str(),s.second.type,s.second.selmode,s.second.box_type
				,s.second.x,s.second.y,s.second.x1,s.second.y1,s.second.width,s.second.height);
			if (s.second.subelms.size() > 0){
				var.val += "subelms[]=";
				for (auto &sub:s.second.subelms) var.val += string_f(" id=%d,arrow=%u",sub.id,sub.arrow);
				var.val += "\n";
			}
			if (s.second.insides.size() > 0){
				var.val += "insides[]=";
				for (auto id:s.second.insides) var.val += string_f(" id=%d",id);
				var.val += "\n";
			}
		}
		var.val += "baseelms[]=";
		for (auto id:baseelms){
			var.val += string_f(" id=%u",id);
		}
		var.val += "\n";
		res.emplace_back(var);
	}else if (maywrite){
		unsigned lastline = 1000;
		string tmpvar,tmpval;
		if (strcmp(var,"kbd")==0){
			wordproc_kbd(val,pref.mod,tmpvar,tmpval,lastline);
			var = tmpvar.c_str();
			val = tmpval.c_str();		
		}
		if (strcmp(var,"deletechar")==0){
			if (pref.mod.shift){
				auto selects = findselected(SEL_SELECTED);
				for (auto s:selects){
					delete_elm (s->id,notify_var);
				}
			}
		}else if (is_any_of(var,"backspace","insertchar")){
			auto selects = findselected(SEL_SELECTED);
			for (auto s:selects){
				if (strcmp(var,"backspace")==0){
					size_t size = s->txt.size();
					if (size > 0) s->txt.resize(size-1);
				}else{
					s->txt += val;
				}
				notify_ids.insert(s->id);
			}
		}else if (strcmp(var,"select")==0){
			vector<string> tb;
			int n = str_splitline(val,',',tb);
			if (n == 5){
				unsigned x = atoi(tb[0].c_str());
				unsigned y = atoi(tb[1].c_str());
				unsigned button = atoi(tb[2].c_str());
				bool shiftkey = tb[3] == "true";
				bool ctrlkey = tb[4] == "true";
				/*
					The logic for pref.selecting, star_mode and imbed_mode is different
					In pref.selecting, select one item unselect all others unless the shift key is activivated.
					This is standard. Selecting again the same item keeps it selected. This is useful when
					moving the item.
					In imbed_mode, only one item may be selected at once. Re-selecting the item unselect it.
					In star_mode, you may select multiple items without using the shift key. Re-selecting the
					item unselect it.
				*/
				if (button == 1 && pref.selecting && !shiftkey && !ctrlkey){
					resetsel(SEL_SELECTED,notify_ids);
				}
				auto e = locate (x,y);
				//tlmp_warning ("select: val=%s x=%u y=%u e=%p",val,x,y,e);
				if (e != nullptr){
					if (pref.selecting){
						if (button == 2){
							if (ctrlkey){
								// We change the label position
								e->textpos = (WHITEBOARD_TEXTPOS)(e->textpos+1);
								if (e->textpos == TEXTPOS_LAST) e->textpos = TEXTPOS_INSIDE;
							}else{
								// We are cycling though the various line types connecting elms
								// shiftkey change the cycling direction
								auto parents = findselected(SEL_STAR);
								auto selects = findselected(SEL_SELECTED);
								if (parents.size() == 0){
									error = MSG_U(E_NOPARENT,"No parent node selected");
								}else if (selects.size() == 0){
									error = MSG_U(E_NONODE,"No node selected");
								}else{
									changeline (parents,selects,shiftkey ? -1 : 1,ARROW_NONE,notify_var);
									for (auto s:selects) notify_ids.insert(s->id);
								}
							}
						}else if (shiftkey && ctrlkey){
							if (e->selmode == SEL_NONE){
								resetsel(SEL_IMBED,notify_ids);	// Only one SEL_IMBED at once
								e->selmode = SEL_IMBED;
							}else{
								e->selmode = SEL_NONE;
							}
						}else if (ctrlkey){
							if (e->selmode == SEL_NONE){
								e->selmode = SEL_STAR;
							}else{
								e->selmode = SEL_NONE;
							}
						}else{
							e->selmode = SEL_SELECTED;
						}
					}else if (pref.starmode){
						e->selmode = e->selmode == SEL_STAR ? SEL_NONE : SEL_STAR;
					}else if (pref.imbedmode){
						if (e->selmode == SEL_NONE){
							resetsel(SEL_IMBED,notify_ids);	// Only one SEL_IMBED at once
							e->selmode = SEL_IMBED;
						}else{
							e->selmode = SEL_NONE;
						}
					}
					notify_ids.insert(e->id);
				}			
			}
		}else if (strcmp(var,"mousemove")==0){
			auto selects = findselected(SEL_SELECTED);
			if (selects.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				if (n == 4){
					int movex = atoi(tb[0].c_str());
					int movey = atoi(tb[1].c_str());
					bool shiftkey = tb[2] == "true";
					bool ctrlkey = tb[3] == "true";
					for (auto elm:selects){
						if (elm->type == TYPE_LINE){
							if(shiftkey){
								check_limit (elm->x,movex);
								check_limit (elm->y,movey);
							}else if (ctrlkey){
								check_limit (elm->x1,movex);
								check_limit (elm->y1,movey);
							}else{
								elm->move(elms,movex,movey,notify_ids);
							}
							notify_ids.insert(elm->id);
						}else{
							elm->move(elms,movex,movey,notify_ids);
						}
					}
					setmodified(username);
				}
			}
		}else if (strcmp(var,"wheel")==0){
			auto selects = findselected(SEL_SELECTED);
			if (selects.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				if (n == 3){
					bool shiftkey = tb[1] == "true";
					bool ctrlkey = tb[2] == "true";
					int grow = atoi(tb[0].c_str())*5;
					for (auto elm:selects){
						elm->resize(grow,ctrlkey,shiftkey);
						notify_ids.insert(elm->id);
					}
					setmodified(username);
				}
			}
		}else if (strcmp(var,"newgame")==0){
			int uval = atoi(val);
			auto oldpref = pref;
			if (uval == BUTTON_NEWDOC){
				VARVAL var;
				var.var = VAR_DIALOG;
				var.val = DIALOG_WHITEBOARD_NEW;
				res.emplace_back(var);
			}else if (is_any_of(uval,BUTTON_ELLIPSE,BUTTON_RECT,BUTTON_LINE,BUTTON_HANDLINE)){
				resetsel(SEL_SELECTED,notify_ids);
				auto star_elms = findselected(SEL_STAR);
				auto imbed_elms = findselected(SEL_IMBED);
				tlmp_warning ("star_elm=%lu imbed_elm=%lu",star_elms.size(),imbed_elms.size());
				static WHITEBOARD_ELMTYPE tbtype[]={TYPE_ELLIPSE,TYPE_RECT,TYPE_LINE,TYPE_HANDLINE};
				const unsigned default_size=20;
				const unsigned x=50;
				const unsigned y=50;
				unsigned id = place_newelm(tbtype[uval-BUTTON_ELLIPSE],x,y,default_size,default_size,star_elms,imbed_elms,notify_var,notify_ids);
				notify_ids.insert(id);
				setmodified(username);
				pref.selecting = true;
				pref.starmode = pref.imbedmode = false;
			}else if (is_any_of(uval,BUTTON_SELECT,BUTTON_STARMODE,BUTTON_IMBEDMODE)){
				if (uval == BUTTON_SELECT){
					pref.selecting = true;
					pref.starmode = pref.imbedmode = false;
				}else if (uval == BUTTON_STARMODE){
					pref.starmode = true;
					pref.selecting = pref.imbedmode = false;
				}else if (uval == BUTTON_IMBEDMODE){
					pref.imbedmode = true;
					pref.selecting = pref.starmode = false;
				}
			}else if (uval == BUTTON_BOXTYPE){
				auto selects = findselected (SEL_SELECTED);
				if (selects.size()==0){
					error = MSG_R(E_NONODE);
				}else{
					for (auto s:selects){
						s->box_type = (BOX_TYPE)((unsigned)s->box_type+1);
						if (s->box_type == BOX_LAST) s->box_type = BOX_SOLID;
						notify_ids.insert (s->id);
					}
				}
			}else{
				tlmp_error ("whiteboard newgame=%d",uval);
			}
			whiteboard_update_button (script_var.val, oldpref.selecting,pref.selecting, BUTTON_SELECT);
			whiteboard_update_button (script_var.val, oldpref.starmode,pref.starmode, BUTTON_STARMODE);
			whiteboard_update_button (script_var.val, oldpref.imbedmode,pref.imbedmode, BUTTON_IMBEDMODE);
			script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
		// The other actions are Used to script modification of the document
		}else if (strcmp(var,"addelm")==0){
			// val format: label "text" type x y width height
			vector<string>tb;
			int n = str_splitlineq(val,tb);
			if (n == 7){
				const char *label = tb[0].c_str();
				const char *text = tb[1].c_str();
				auto &type = tb[2];
				unsigned x = atoi(tb[3].c_str());
				unsigned y = atoi(tb[4].c_str());
				unsigned width = atoi(tb[5].c_str());
				unsigned height = atoi(tb[6].c_str());
				if (!is_any_of(type,"ellipse","rect","line","handline")){
				}else{
					WHITEBOARD_ELMTYPE elmtype = TYPE_ELLIPSE;
					if (type == "rect"){
						elmtype = TYPE_RECT;
					}else if (type == "line"){
						elmtype = TYPE_LINE;
					}else if (type == "handline"){
						elmtype = TYPE_HANDLINE;
					}
					auto star_elms = findselected(SEL_STAR);
					auto imbed_elms = findselected(SEL_IMBED);
					
					unsigned id = place_newelm(elmtype,x,y,width,height,star_elms,imbed_elms,notify_var,notify_ids);
					notify_ids.insert(id);
					setmodified(username);
					auto &elm = elms[id];
					elm.label = label;
					elm.txt = text;
				}
			}
			
		}else if (strcmp(var,"resetselect")==0){
			// val format: 0|1|2
			unsigned sel = atoi(val);
			static WHITEBOARD_SELMODE tbmode[]={SEL_SELECTED,SEL_STAR, SEL_IMBED};
			resetsel (tbmode[sel],notify_ids);
		}else if (strcmp(var,"labelselect")==0){
			// val format: label 0|1|2
			vector<string> tb;
			int n = str_splitline(val,' ',tb);
			if (n == 2){
				const char *label = tb[0].c_str();
				unsigned sel = atoi(tb[1].c_str());
				if (is_any_of((int)sel,0,1,2)){
					for (auto &e:elms){
						if (e.second.label==label){
							static WHITEBOARD_SELMODE tbmode[]={SEL_SELECTED,SEL_STAR, SEL_IMBED};
							e.second.selmode = tbmode[sel];
							notify_ids.insert(e.first);
							break;
						}
					}
				}	
			}
		}else if (strcmp(var,"selectline")==0){
			// val format: 0|1|... ARROW_TYPE 
			unsigned uval = atoi(val);
			if (uval < ARROW_LAST){
				ARROW_TYPE type = (ARROW_TYPE)uval;
				auto parents = findselected(SEL_STAR);
				auto selects = findselected(SEL_SELECTED);
				if (parents.size() == 0){
					error = MSG_R(E_NOPARENT);
				}else if (selects.size() == 0){
					error = MSG_R(E_NONODE);
				}else{
					changeline (parents,selects,0,type,notify_var);
					for (auto s:selects) notify_ids.insert(s->id);
				}
			}
		}else if (strcmp(var,"labeldelete")==0){
			// val format: label
			for (auto &e:elms){
				if (e.second.label==val){
					delete_elm (e.first,notify_var);
					break;
				}
			}
		}else if (strcmp(var,"resetgame")==0){
			resetgame();
			notify_var.val += string_f("var svg = document.getElementById('board-%s');\n",gameid.c_str());
			notify_var.val += "while (svg.firstChild) {\n";
			notify_var.val += "\tsvg.removeChild(svg.lastChild);\n";
			notify_var.val += "}\n";
			setmodified(username);
		}
	}else{
		error = MSG_R(E_READONLY);
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else{
		update_msg(false,"&nbsp;","white",res);
	}
}
</mod>
void WHITEBOARD::manyexec (
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	set<unsigned> notify_ids;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,session,username,maywrite,sp,script_var,notify_var,notify_ids,res);
	}
	redraw(notify_ids,notify_var);
	res.emplace_back(move(notify_var));
	res.emplace_back(move(script_var));
}
