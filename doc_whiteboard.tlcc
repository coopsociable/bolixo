/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	White board drawing program.
	The goal of this program is to create drawings very quickly. It may contain
		text
		graph

	Anything we usually draw to explain an idea.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "documentd_menu.h"
#include "bolixo.m"

using namespace std;

enum WHITEBOARD_SELMODE{
	SEL_NONE,
	SEL_SELECTED,	// This element is selected so we can act on it
			// (move it, enlarge it).
	SEL_STAR,	// This element is selected so we can attach
			// more elements to it.
	SEL_IMBED,	// This element is selected so we can insert
			// more elements into it.
};
enum WHITEBOARD_TEXTPOS{
	TEXTPOS_INSIDE,
	TEXTPOS_TOP,
	TEXTPOS_BOTTOM,
	TEXTPOS_LEFT,
	TEXTPOS_RIGHT,
	TEXTPOS_LAST
};
enum ARROW_TYPE{
	ARROW_NONE,	// No line
	ARROW_END,	// A line with an arrow at tne end
	ARROW_START,	// A line with an arrow at the start
	ARROW_BOTH,	// A line with an arrow at the start and the end
	ARROW_RETURN,	// A line with an arrow at the end and another line, curved, with an arrow at the start
	ARROW_LINE,	// Just a line
	ARROW_DASH,	// Just a dash line
	ARROW_DOT,	// Just a dot line
	ARROW_LAST,	// Last item in the list + 1
};
enum BOX_TYPE{
	BOX_SOLID,	// Solid line
	BOX_DASH,	// Dash line
	BOX_DOT,	// Dot line
	BOX_LAST,	// Last item in the list + 1
};

#include "proto/documentd_whiteboard.protoch"
#include "proto/documentd_whiteboard.protoh"

enum WHITEBOARD_ELMTYPE {	// Type of element
	TYPE_ELLIPSE,
	TYPE_RECT,
	TYPE_LINE,	// One line or arrow
	TYPE_HANDLINE,	// line drawn by hand
	TYPE_TEXT,	// Draw text with a bullet
};

static const char *tbcolor[]={"black","red","yellow","green"};


struct SUBELM{
	unsigned id = 0;
	ARROW_TYPE arrow;
	int angle=0;		// Angle between parent and child
				// The angle is in 1/10 degre, but start at -45 degre
				// See WHITEBOARD::sortsubelms()
	SUBELM(unsigned _id, ARROW_TYPE _arrow)
		:id(_id), arrow(_arrow){
	}
};
/*
	Erase the last character (UTF8) of a string
*/
static void eraselast (string &txt)
{
	size_t size = txt.size();
	if (size > 0){
		unsigned pos = 0;
		while (1){
			unsigned charsize = utf8_codepoint_size(txt[pos]);
			unsigned newpos = pos + charsize;
			if (newpos < size){
				pos = newpos;
			}else{
				break;
			}
		}
		txt.resize(pos);
	}
}
/*
	Make sure size do not underflow
*/
inline void check_limit (unsigned short &size, int val)
{
	if (val > 0 || -val < size){
		size += val;
	}
}
struct WHITEBOARD_ELM{
	WHITEBOARD_SELMODE selmode = SEL_NONE;	// Make the element more visible
						// for other actions
	BOX_TYPE box_type = BOX_SOLID;
	unsigned id = 0;
	unsigned short x;	// Coordinates
	unsigned short y;
	unsigned short x1=0;	// end coordinates
	unsigned short y1=0;
	unsigned short width=0;
	unsigned short height=0;
	std::string label;	// Useful to reference the element in scripts ?
	WHITEBOARD_ELMTYPE type;
	std::string txt;	// Caption
	WHITEBOARD_TEXTPOS textpos = TEXTPOS_INSIDE;
	vector<unsigned> insides;		// insides are drawn inside the element.
	vector<SUBELM> subelms;		// subelms are related elements.
	void resize(int val, bool horizontal_only, bool vertical_only){
		if (horizontal_only){
			check_limit(width,val);
		}else if (vertical_only){
			check_limit(height,val);
		}else if (width == height || width == 0 || height == 0){
			check_limit (width,val);
			check_limit (height,val);
		}else{
			// Here we should compute the aspect ratio of the object and preserve it.
			double ratio = (double)width/height;
			check_limit(width,ratio*val);
			check_limit(height,val/ratio);
		}
		if (width < 8) width = 8;
		if (height < 8) height = 8;
	}
	void move(map<unsigned,WHITEBOARD_ELM> &elements, int movex, int movey, set<unsigned> &ids){
		ids.insert (id);
		x += movex;
		y += movey;
		if (type == TYPE_LINE){
			x1 += movex;
			y1 += movey;
		}
		for (auto &e:insides){
			elements[e].move(elements,movex,movey,ids);
		}
	}
	void gettextpos(unsigned &textx, unsigned &texty, unsigned &textlen, unsigned fontsize){
		textx=0;
		texty=0;
		unsigned w_2 = width/2;
		unsigned h_2 = height/2;
		textlen = documentd_displaylen (txt.c_str(),fontsize,1);
		unsigned centerx=0;
		unsigned centery=y+fontsize/2-3;
		if (textlen >= width){
			// Text too large, put it at the start of the object
			centerx = x-w_2;
		}else{
			// Center the text
			centerx = x-w_2+(width-textlen)/2;
		}
		switch(textpos){
		case TEXTPOS_LAST:
		case TEXTPOS_INSIDE:
			textx = centerx;
			texty = centery;
			break;
		case TEXTPOS_TOP:
			textx = centerx;
			texty = y-h_2-3;
			break;
		case TEXTPOS_BOTTOM:
			textx = centerx;
			texty = y+h_2+fontsize;
			break;
		case TEXTPOS_LEFT:
			textx = x-w_2-3-textlen;
			texty = centery;
			break;
		case TEXTPOS_RIGHT:
			textx = x+w_2+3;
			texty = centery;
			break;
		}
	}
	void gettextpos(unsigned &textx, unsigned &texty, unsigned fontsize){
		unsigned textlen;
		gettextpos(textx,texty,textlen,fontsize);
	}
	void redraw(VARVAL &var, unsigned fontsize){
		const char *stroke_color = tbcolor[selmode];
		unsigned w_2 = width/2;
		unsigned h_2 = height/2;
		if (type == TYPE_ELLIPSE){
			var.val += string_f("replace_ellipse('e%u',%u,%u,%u,%u,'%s',%u);\n",id,x,y,w_2,h_2,stroke_color,box_type);
		}else if (type == TYPE_RECT){
			var.val += string_f("replace_rect('e%u',%d,%d,%u,%u,'%s',%u);\n",id,(int)x-w_2,(int)y-h_2,width,height,stroke_color,box_type);
		}else if (type == TYPE_LINE){
			var.val += string_f("replace_typeline('e%u',%u,%u,%u,%u,'%s',%u);\n",id,x,y,x1,y1,stroke_color,box_type);
		}else if (type == TYPE_TEXT){
			var.val += string_f("replace_typetext('e%u',%u,%u,'%s');\n",id,x,y,stroke_color);
		}else{
		}
		unsigned textx,texty;
		gettextpos(textx,texty,fontsize);
		var.val += string_f("replace_text('t%u',%u,%u,'%s','%s');\n",id,textx,texty,stroke_color,documentd_escape(txt).c_str());
	}
	void changetextpos(){
		textpos = (WHITEBOARD_TEXTPOS)(textpos+1);
		if (textpos == TEXTPOS_LAST){
			if (type == TYPE_TEXT){
				textpos = (WHITEBOARD_TEXTPOS)(TEXTPOS_INSIDE+1);
			}else{
				textpos = TEXTPOS_INSIDE;
			}
		}
	}
};

struct WHITEBOARD_PREF{
	bool selecting = true;
	bool starmode = false;	// We are attaching more items to another.
	bool imbedmode = false;	// We are inserting items inside another.
	MOD_KBD mod;
	unsigned lastx = 0;	// Last mouse position, converted in SVG viewbox coordinates
	unsigned lasty = 0;
};

class WHITEBOARD: public GAME{
	map<unsigned,WHITEBOARD_ELM> elms;
	vector<unsigned> baseelms;
	map<string,WHITEBOARD_PREF> prefs;	// Per session state
	unsigned alloc_id=0;
	void update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res);
	void resetsel(WHITEBOARD_SELMODE, set<unsigned> &ids);
	void redraw(const set<unsigned> &ids, VARVAL &var, unsigned fontsize);
	void alloc_elm(WHITEBOARD_ELM &elm, WHITEBOARD_ELMTYPE type, unsigned x0, unsigned y0){
		elm.selmode = SEL_SELECTED;
		elm.id = alloc_id++;
		elm.type = type;
		elm.x = x0;
		elm.y = y0;
	}
	void add_element(const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, WHITEBOARD_ELM &newelm){
		if (star_elms.size() > 0){
			for (auto p:star_elms) p->subelms.emplace_back(newelm.id,ARROW_END);
		}else if (imbed_elms.size() > 0){
			for (auto p:imbed_elms) p->insides.push_back(newelm.id);
		}else{
			baseelms.push_back(newelm.id);
		}
		elms[newelm.id] = move(newelm);
	}
	unsigned add_ellipse (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned x_ray, unsigned y_ray){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_ELLIPSE,x,y);
		elm.width = x_ray*2;
		elm.height = y_ray*2;
		elm.selmode = SEL_SELECTED;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_rect (const vector<WHITEBOARD_ELM *> &star_elms, const vector<WHITEBOARD_ELM *> &imbed_elms, unsigned x, unsigned y, unsigned width, unsigned height){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_RECT,x,y);
		elm.width = width;
		elm.height = height;
		unsigned ret = elm.id;
		add_element(star_elms,imbed_elms,elm);
		return ret;
	}
	unsigned add_line (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_LINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[ret] = move(elm);
		baseelms.push_back(ret);
		return ret;
	}
	unsigned add_handline (unsigned x0, unsigned y0, unsigned x1, unsigned y1){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_HANDLINE,x0,y0);
		elm.x1 = x1;
		elm.y1 = y1;
		unsigned ret = elm.id;
		elms[ret] = move(elm);
		baseelms.push_back(ret);
		return ret;
	}
	unsigned add_text (const vector<WHITEBOARD_ELM*> &imbed_elms, unsigned x0, unsigned y0){
		WHITEBOARD_ELM elm;
		alloc_elm(elm,TYPE_TEXT,x0,y0);
		elm.width = elm.height = 8;
		elm.textpos = TEXTPOS_RIGHT;
		unsigned ret = elm.id;
		vector<WHITEBOARD_ELM*> empty;
		add_element(empty,imbed_elms,elm);
		return ret;
	}
	WHITEBOARD_ELM *locate (unsigned x, unsigned y, unsigned fontsize);
	vector<WHITEBOARD_ELM *> findselected (WHITEBOARD_SELMODE sel);
	void execstep (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp,
		VARVAL &script_var, VARVAL &notify_var, set<unsigned> &notify_ids, std::vector<VARVAL> &res);
	void changeline (const vector<WHITEBOARD_ELM*> &parents, const vector<WHITEBOARD_ELM*> &elms, int direction, ARROW_TYPE arrow, VARVAL &notify_var);
	void changeline(int direction, string &error, VARVAL &notify_var, set<unsigned> &notify_ids);
	void delete_elm(unsigned id, VARVAL &notify_var);
	unsigned place_newelm(WHITEBOARD_ELMTYPE type, unsigned x, unsigned y, unsigned width, unsigned height,
		vector<WHITEBOARD_ELM*> &star_elms, vector<WHITEBOARD_ELM*> &imbed_elms,
		VARVAL &notify_var, set<unsigned> &notify_ids);
	void sortsubelms(set<unsigned> &notify_ids);
public:
	friend void walkboard(class _F_walkboard &c, WHITEBOARD *board);
	void save(DOC_WRITER &w, bool);
	void load(DOC_READER &r, std::string &msg);
	void resetgame();
	WHITEBOARD();
	const char *getclass() const;
	void testwin(std::vector<VARVAL> &res);
	void exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, std::vector<VARVAL> &res);
	void manyexec (const vector<VARVAL_receive> &steps, const char *session, const char *username, bool maywrite, const DOC_UI_SPECS_receive &sp, vector<VARVAL> &res);
};

GAME_P make_WHITEBOARD()
{
	return make_shared<WHITEBOARD>();
}

WHITEBOARD::WHITEBOARD()
{
}
void WHITEBOARD::update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	mvar.val += string_f("updmsg('%s','%s');\n",color,documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void WHITEBOARD::save(DOC_WRITER &w, bool)
{
	documentd_whiteboard_header(&w,revision,alloc_id);
	vector<WHITEBOARD_ELEMENT> elements;
	for (auto &m:elms){
		WHITEBOARD_ELEMENT elm;
		WHITEBOARD_ELM &e = m.second;
		elm.id = e.id;
		elm.selmode = e.selmode;
		elm.box_type = e.box_type;
		elm.x = e.x;
		elm.y = e.y;
		elm.x1 = e.x1;
		elm.y1 = e.y1;
		elm.width = e.width;
		elm.height = e.height;
		elm.type = e.type;
		elm.label = e.label;
		elm.txt = e.txt;
		elm.textpos = e.textpos;
		elm.insides = e.insides;
		for (auto &s:e.subelms){
			WHITEBOARD_SUBELM selm;
			selm.id = s.id;
			selm.arrow = s.arrow;
			elm.subelms.emplace_back(move(selm));
		}
		elements.emplace_back(move(elm));
	}
	documentd_whiteboard_elements (&w,elements);
	documentd_whiteboard_baseelms (&w,baseelms);
}
<mod>
void WHITEBOARD::load(DOC_READER &r, std::string &msg)
{
	resetgame();
	glocal alloc_id;
	glocal revision;
	glocal elms;
	glocal baseelms;
	<call documentd_whiteboard>(&r);
	<f header>
		glocal.revision = revision;
		glocal.alloc_id = alloc_id;
	</f>
	<f elements>
		for (auto &e:elements){
			WHITEBOARD_ELM elm;
			elm.id = e.id;
			elm.selmode = e.selmode;
			elm.box_type = e.box_type;
			elm.x = e.x;
			elm.y = e.y;
			elm.x1 = e.x1;
			elm.y1 = e.y1;
			elm.width = e.width;
			elm.height = e.height;
			elm.type = (WHITEBOARD_ELMTYPE)e.type;
			elm.label = e.label;
			elm.txt = e.txt;
			elm.textpos = e.textpos;
			elm.insides = e.insides;
			for (auto &s:e.subelms) elm.subelms.emplace_back(s.id,s.arrow);
			glocal.elms[elm.id] = move(elm);
		}
	</f>
	<f baseelms>
		glocal.baseelms = baseelms;
	</f>
	<f invalid>
		tlmp_error ("Invalid record while reading whiteboard file: %s",msg);
	</f>
	</call>
	set<unsigned> notify_ids;
	sortsubelms(notify_ids);
}
</mod>
enum WHITEBOARD_QUARTER{
	QUARTER_RIGHT,
	QUARTER_TOP,
	QUARTER_LEFT,
	QUARTER_BOTTOM
};
#define _TLMP_walkboard
struct _F_walkboard{
	#define _F_walkboard_element(x) void x element(WHITEBOARD_ELM &elm, WHITEBOARD_ELM *parent, ARROW_TYPE arrow, bool firstseen, \
		WHITEBOARD_QUARTER quarter, unsigned nosubelm, unsigned nbsubelm, bool &end)
	virtual _F_walkboard_element( )=0;
};
void walkboard(_F_walkboard &c, WHITEBOARD *board)
{
	set<unsigned> seen;
	struct ELEMENTS{
		WHITEBOARD_ELM *parent;
		vector<SUBELM> *subelms;
		vector<unsigned> *insides;
		ELEMENTS(WHITEBOARD_ELM *_parent, vector<SUBELM> *_subelms, vector<unsigned> *_insides)
			: parent(_parent), subelms(_subelms), insides(_insides){
		}
		size_t size() const {
			if (subelms != nullptr) return subelms->size();
			return insides->size();
		}
		SUBELM operator [] (unsigned item) const{
			if (subelms != nullptr){
				return (*subelms)[item];
			}else{
				return SUBELM ((*insides)[item],ARROW_NONE);
			}
		}
	}; 
	deque<ELEMENTS> todo;
	todo.emplace_back(nullptr,nullptr,&board->baseelms);
	bool end = false;
	while (todo.size() > 0 && !end){
		auto elms = todo.front();
		todo.pop_front();
		int limit_angle=0;
		unsigned quarter_pos = 0;
		unsigned quarter_num = 0;
		WHITEBOARD_QUARTER quarter=(WHITEBOARD_QUARTER)-1;
		for (unsigned i=0; i<elms.size(); i++){
			auto subelm = elms[i];
			while (subelm.angle >= limit_angle){
				quarter_pos=0;
				quarter_num=0;
				limit_angle += 900;
				for (unsigned j=i; j<elms.size(); j++){
					if (elms[j].angle >= limit_angle) break;
					quarter_num++;
				}
				quarter = (WHITEBOARD_QUARTER)((unsigned)quarter+1);
			}
			auto &elm = board->elms[subelm.id];
			bool firstseen = seen.insert(subelm.id).second;
			c.element(elm,elms.parent,subelm.arrow,firstseen,quarter,quarter_pos,quarter_num,end);
			quarter_pos++;
			if (end) break;
			if (elm.insides.size() > 0) todo.emplace_back(nullptr,nullptr,&elm.insides);
			if (elm.subelms.size() > 0){
				todo.emplace_back(&elm,&elm.subelms,nullptr);
			}
		}
	}
}

/*
	Unselect the selected elements.
	ids will contain the id of selected elements.
*/
<mod>
void WHITEBOARD::resetsel(WHITEBOARD_SELMODE selmode, set<unsigned> &ids)
{
	glocal ids;
	glocal selmode;
	<call walkboard>(this);
	<f element>
		if (elm.selmode == glocal.selmode){
			elm.selmode = SEL_NONE;
			glocal.ids.insert(elm.id);
		}
	</f>
	</call>
}
</mod>


struct LINE_SPEC{
	unsigned x;
	unsigned y;
	unsigned len;
	double angle;
	LINE_SPEC (WHITEBOARD_ELM &parent, WHITEBOARD_ELM &elm, WHITEBOARD_QUARTER quarter, unsigned nosubelm, unsigned nbsubelm){
		int elm_x=0;
		int elm_y=0;
		x = y = 0;
		// tlmp_warning ("quarter=%d nosubelm=%u nbsubelm=%u",quarter,nosubelm,nbsubelm);
		if (quarter == QUARTER_RIGHT){
			x = parent.x + parent.width/2;
			y = parent.y + parent.height/2 - parent.height/(nbsubelm+1)*(nosubelm+1);
			elm_x = elm.x - elm.width/2;
			elm_y = elm.y;
		}else if (quarter == QUARTER_TOP){
			x = parent.x + parent.width/2 - parent.width/(nbsubelm+1)*(nosubelm+1);
			y = parent.y - parent.height/2;
			elm_x = elm.x;
			elm_y = elm.y + elm.height/2;
		}else if (quarter == QUARTER_BOTTOM){
			x = parent.x - parent.width/2 + parent.width/(nbsubelm+1)*(nosubelm+1);
			y = parent.y + parent.height/2;
			elm_x = elm.x;
			elm_y = elm.y - elm.height/2;
		}else if (quarter == QUARTER_LEFT){
			x = parent.x - parent.width/2;
			y = parent.y - parent.height/2 + parent.height/(nbsubelm+1)*(nosubelm+1);
			elm_x = elm.x + elm.width/2;
			elm_y = elm.y;
		}
		int diff_y = elm_y - y;
		int diff_x = elm_x - x;
		angle = atan2(diff_y,diff_x)/M_PI*180;
		len = sqrt(diff_y*diff_y+diff_x*diff_x);
	}
};

/*
	Sort the sub-elements by angle.
	The goal is to organized in walkboard object into four quadrants (right,top,left,bottom).
	The angle computed here starts at -45 degre. So values from 0 to 90 actually represent sub-elements to the right.
*/
void WHITEBOARD::sortsubelms(set<unsigned> &notify_ids)
{
	for (auto &e:elms){
		auto &parent = e.second;
		auto &subelms = parent.subelms;
		vector<unsigned> before;
		for (auto &s:subelms){
			before.push_back(s.id);
			auto &child = elms[s.id];
			int diffy = child.y - parent.y;
			int diffx = child.x - parent.x;
			s.angle = atan2(-diffy,diffx)/M_PI*1800+3600+450;
			s.angle %= 3600;
		}
		sort (subelms.begin(),subelms.end(),[](auto &s1, auto &s2){ return s1.angle < s2.angle;});
		// before[] contain the original order. subelms is now sorted.
		// we compare both. If the order changed, we enter it in notify_ids.
		for (unsigned i=0; i<before.size(); i++){
			unsigned id = before[i];
			if (subelms[i].id != id) notify_ids.insert(id);
		}
	}
}
/*
	Redraw all elments which have changed
*/
<mod>
void WHITEBOARD::redraw(const set<unsigned> &ids, VARVAL &var, unsigned fontsize)
{
	glocal ids;
	glocal var;
	glocal fontsize;
	<call walkboard>(this);
	<f element>
		if (glocal.ids.count(elm.id) > 0){
			elm.redraw(glocal.var,glocal.fontsize);
			if (parent != nullptr){
				LINE_SPEC spec(*parent,elm,quarter,nosubelm,nbsubelm);
				glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
					,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
			}
		}else if (parent != nullptr && glocal.ids.count(parent->id)>0){
			// The parent was moved, so we must redraw the line to each child.
			LINE_SPEC spec(*parent,elm,quarter,nosubelm,nbsubelm);
			glocal.var.val += string_f("replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);\n"
				,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
		}
	</f>
	</call>
}
</mod>
/*
	Find all selected items (matching selmode)
*/
<mod>
vector<WHITEBOARD_ELM *>WHITEBOARD::findselected(WHITEBOARD_SELMODE selmode)
{
	vector<WHITEBOARD_ELM *> ret;
	for (auto &e:elms){
		if (e.second.selmode == selmode) ret.push_back(&e.second);
	}
	return ret;
}
</mod>
void WHITEBOARD::resetgame()
{
	elms.clear();
	baseelms.clear();
	alloc_id = 0;
}
const char *WHITEBOARD::getclass() const
{
	return "WHIT";
}
void WHITEBOARD::testwin(std::vector<VARVAL> &res)
{
}

/*
	Locate an element base on coordinates
*/
<mod>
WHITEBOARD_ELM *WHITEBOARD::locate (unsigned x, unsigned y, unsigned fontsize)
{
	glocal WHITEBOARD_ELM *ret = nullptr;
	glocal unsigned center_distance=(unsigned)-1;
	glocal x;
	glocal y;
	glocal fontsize;
	<call walkboard>(this);
	<f element>
		bool found = false;
		auto x = glocal.x;
		auto y = glocal.y;
		auto w_2 = elm.width/2;
		auto h_2 = elm.height/2;
		switch(elm.type){
		case TYPE_TEXT:
		case TYPE_ELLIPSE:
		case TYPE_RECT:
			// tlmp_warning ("x=%u x0=%d x1=%d y=%u y0=%d y1=%u",x,elm.x-elm.len,elm.x+elm.len,y,elm.y-elm.len,elm.y+elm.len);
			if ((int)x > elm.x-w_2 && (int)x < elm.x+w_2 && (int)y > elm.y-h_2 && (int)y < elm.y+h_2){
				found = true;
			}
			break;
		case TYPE_LINE:
			/*
				Selecting a line is harder of the user.
				Here is the logic
				1. We compute the angle of the line: angle
				2. We compute the len of the line: len
				3. We compute the angle of the line made from the start of the line to the pointer position x,y: angle2
				4. We compute the len of this new line: len2
				5. We compute the angle of a triangle rectangle made this way. We use len2 as the base and 5 as the side.
				   This angle represent the how far away the user can click off the line. This is max_angle_diff.
			*/	
			{
				int diffx = elm.x1 - elm.x;
				int diffy = elm.y1 - elm.y;
				double angle = atan2(diffy,diffx);
				//tlmp_warning ("diffy=%d diffx=%d angle=%lf",diffy,diffx,angle);
				double len = sqrt(diffx*diffx+diffy*diffy);
				diffx = glocal.x - elm.x;
				diffy = glocal.y - elm.y;
				double angle2 = atan2(diffy,diffx);
				double len2 = sqrt(diffx*diffx+diffy*diffy);
				//tlmp_warning ("diffy=%d diffx=%d angle2=%lf",diffy,diffx,angle2);
				//tlmp_warning ("angle=%lf angle2=%lf fabs=%lf len=%lf len2=%lf",angle,angle2,fabs(angle2-angle),len,len2);
				double max_angle_diff = atan2 (5,len2);
				//tlmp_warning ("max_angle_diff=%lf",max_angle_diff);
				if (len2 <= len && fabs(angle2-angle) < max_angle_diff){
					//tlmp_warning ("found line");
					found = true;
				}
			}
			break;
		case TYPE_HANDLINE:
			break;
		}
		// We can click on the text of an element
		if (!found && elm.txt.size() > 0){
			unsigned textx1,texty2,lentxt;
			elm.gettextpos(textx1,texty2,lentxt,glocal.fontsize);
			unsigned textx2 = textx1 + lentxt;
			unsigned texty1 = texty2 - glocal.fontsize;
			if (x >= textx1 && x <= textx2 && y >= texty1 && y <= texty2){
				found = true;
			}
		}
		if (found){
			// An element may be on top of another and larger, so we won't be able to select it.
			// We note the distance from the center of the object to the point selected by the user.
			// If the distance is smaller, we pick this object.
			// We do not execute the square root, since we do not care about the exact distance.
			unsigned diffx = glocal.x-elm.x;
			unsigned diffy = glocal.y-elm.y;
			unsigned distance = diffx*diffx+diffy*diffy;
			if (distance < glocal.center_distance){
				glocal.center_distance = distance;
				glocal.ret = &elm;
			}
		}
		// The following line is removed. We want the function to go deep so it locate objects inside objects.
		//if (glocal.ret != nullptr) end = true;
	</f>
	</call>
	return glocal.ret;
}
static void addsvgelement(
	VARVAL &var,
	const string &gameid,
	const char *elmtype,
	const char *color,
	unsigned stroke_width,
	PARAM_STRING id)
{
	var.val += string_f("var svg = document.getElementById('board-%s');\n",gameid.c_str());
	var.val += string_f("var newElement = document.createElementNS('http://www.w3.org/2000/svg', '%s');\n",elmtype);
	var.val += string_f("newElement.id='%s';\n",id.ptr);
	var.val += string_f("newElement.style.stroke = '%s';\n",color);
	if (strcmp(elmtype,"text")==0){
		var.val += "newElement.classList.add('whitext');\n";
	}else{
		var.val += "newElement.style.fill = 'none';\n";
		var.val += string_f("newElement.style.strokeWidth = '%u';\n",stroke_width);
	}
	var.val += "svg.appendChild(newElement);\n";
}
/*
	Change the arrow type between parents and child (elms).
	In interactive mode, we cycle through the arrow type. The parameter direction is either -1 or 1 to control the
	direction of the cycling.
	When direction == 0, the arrow parameter force a specific arrow type.


	Note that ARROW_NONE is never really applied. The relation between parents and elms are removed.
*/
<mod>
void WHITEBOARD::changeline (
	const vector<WHITEBOARD_ELM*> &parents,
	const vector<WHITEBOARD_ELM*> &selects,
	int direction,
	ARROW_TYPE arrow,
	VARVAL &notify_var)
{
	set<unsigned> has_parent;	// All elements who are in parent.subelms[]
	vector<unsigned> lost_parent;	// This element was disconnected from a parent
					// so it it does not has a parent, it
					// most be added to baseelms;
	for (auto &e:elms){
		auto &elm = e.second;
		if (find(parents.begin(),parents.end(),&elm)!=parents.end()){
			for (auto child:selects){
				auto sub = find_if(elm.subelms.begin(),elm.subelms.end(),[child](auto &s){return s.id == child->id;});
				if (sub == elm.subelms.end()){
					if (direction != 0 || arrow != ARROW_NONE){
						// This child is not related to the parent, so we add it
						ARROW_TYPE type = arrow;
						if (direction != 0) type = direction==1 ? ARROW_END : ARROW_LINE;
						elm.subelms.emplace_back(child->id,type);
						// Remove it from baseelms if there
						auto base = find(baseelms.begin(),baseelms.end(),child->id);
						if (base != baseelms.end()) baseelms.erase(base);
						has_parent.insert(child->id);
						addsvgelement(notify_var,gameid,"g","black",2,string_f("l%u,%u",elm.id,child->id));
					}
				}else{
					if (direction != 0){
						sub->arrow = (ARROW_TYPE)((unsigned)sub->arrow+direction);
					}else{
						sub->arrow = arrow;
					}
					if (is_any_of(sub->arrow,ARROW_NONE,ARROW_LAST)){
						// We loop back to ARROW_NONE.
						// We just remove the entry
						elm.subelms.erase(sub);
						notify_var.val += string_f("removeelm('l%u,%u','g');\n",elm.id,child->id);
						// Is it owned by another elements ? If not we have to add it to baseelms.
						lost_parent.push_back(child->id);
					}else{
						has_parent.insert(child->id);
					}
				}
			}
		}	
	}
	for (auto id:lost_parent){
		if (has_parent.count(id)==0){
			// Add it to baseelms if not there
			auto base = find (baseelms.begin(),baseelms.end(),id);
			if (base == baseelms.end()) baseelms.push_back(id);
		}
	}
}
</mod>
void WHITEBOARD::changeline(int direction, string &error, VARVAL &notify_var, set<unsigned> &notify_ids)
{
	auto parents = findselected(SEL_STAR);
	auto selects = findselected(SEL_SELECTED);
	if (parents.size() == 0){
		error = MSG_U(E_NOPARENT,"No parent node selected");
	}else if (selects.size() == 0){
		error = MSG_U(E_NONODE,"No node selected");
	}else{
		changeline (parents,selects,direction,ARROW_NONE,notify_var);
		for (auto s:selects) notify_ids.insert(s->id);
	}
}
/*
	Delete one element.
	Remove all arrows related to this element (from and to).
	subelms becoming orphans (not connect to any parent) are add to baseelms.
*/
<mod>
void WHITEBOARD::delete_elm (unsigned id, VARVAL &notify_var)
{
	glocal id;
	glocal notify_var;
	glocal bool subelm_done = false;
	glocal set<unsigned> has_parent;
	<call walkboard>(this);
	<f element>
		if (elm.id == glocal.id){
			if (!glocal.subelm_done){
				glocal.subelm_done = true;
				for (auto &s:elm.subelms){
					glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",elm.id,s.id);
				}
				// The subelms become orphan or are owned by another
				elm.subelms.clear();
			}
			if (parent != nullptr){
				glocal.notify_var.val += string_f("removeelm('l%u,%u','g');\n",parent->id,elm.id);
				auto pt = find_if (parent->subelms.begin(),parent->subelms.end(),[elm](auto &selm){return elm.id==selm.id;});
				parent->subelms.erase(pt);
			}
		}
		for (auto s:elm.subelms) glocal.has_parent.insert(s.id);
	</f>
	</call>
	auto pt = elms.find(id);
	if (pt != elms.end()){
		static const char *tbtag[]={"ellipse","rect","line","path","circle"};
		notify_var.val += string_f("removeelm('e%u','%s');\n",id,tbtag[pt->second.type]);
		notify_var.val += string_f("removeelm('t%u','text');\n",id);
		elms.erase(pt);
		// Remove from baseelms if there
		auto pt = find(baseelms.begin(),baseelms.end(),id);
		if (pt != baseelms.end()) baseelms.erase(pt);
	}
	// We have to add the orphan sub-elements into baseelms
	for (auto &e:elms){
		if (glocal.has_parent.count(e.first)==0
			&& find(baseelms.begin(),baseelms.end(),e.first)==baseelms.end()){
			baseelms.push_back(e.first);
		}
	}
}
</mod>
static void whiteboard_update_button (string &script, bool oldstate, bool newstate, unsigned button_id)
{
	if (newstate != oldstate){
		script += string_f("var button = document.getElementById('button%u');\n",button_id);
		script += "if (button != null){\n";
		script += string_f("\tbutton.style.background='%s';\n",newstate ? "lightblue" : "lightgray");
		script += "}\n";
	}
}
void WHITEBOARD::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	tlmp_error ("WHITEBOARD::exec called");
}
unsigned WHITEBOARD::place_newelm(
	WHITEBOARD_ELMTYPE type,
	unsigned x,
	unsigned y,
	unsigned width,
	unsigned height,
	vector<WHITEBOARD_ELM*> &star_elms,
	vector<WHITEBOARD_ELM*> &imbed_elms,
	VARVAL &notify_var,
	set<unsigned> &notify_ids)
	
{
	const char *svgtype = "";
	unsigned id = 0;
	bool addline = false;
	unsigned width_2 = width/2;
	unsigned height_2 = height/2;
	unsigned stroke_width = 2;
	if (type == TYPE_ELLIPSE){
		id = add_ellipse(star_elms,imbed_elms,x,y,width_2,height_2);
		svgtype = "ellipse";
		addline = star_elms.size() > 0;
	}else if (type == TYPE_RECT){
		id = add_rect(star_elms,imbed_elms,x,y,width,height);
		svgtype = "rect";
		addline = star_elms.size() > 0;
	}else if (type == TYPE_LINE){
		id = add_line(x,y,x+width,y+height);
		svgtype = "line";
	}else if (type == TYPE_HANDLINE){
		stroke_width = 4;
		id = add_handline(x,y,x+width,y+height);
		svgtype = "path";
	}else if (type == TYPE_TEXT){
		id = add_text(imbed_elms,x,y);
		svgtype = "circle";
	}
	addsvgelement(notify_var,gameid,svgtype,"red",stroke_width,string_f("e%u",id));
	addsvgelement(notify_var,gameid,"text","red",1,string_f("t%u",id));
	if (addline){
		for (auto p:star_elms) addsvgelement(notify_var,gameid,"g","black",stroke_width,string_f("l%u,%u",p->id,id));
	}
	notify_ids.insert(id);
	return id;
}
<mod>
void WHITEBOARD::execstep (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	VARVAL &notify_var,
	set<unsigned> &notify_ids,
	std::vector<VARVAL> &res)
{
	glocal unsigned fontsize = sp.fontsize;
	auto &pref = prefs[session];
	unsigned waiting_users_width = sp.mobile ? 62 : 42;
	unsigned board_width = sp.content_width - waiting_users_width;	// Space for user list
	if (sp.content_height < board_width) board_width = sp.content_height;
	unsigned board_height = board_width;
	const unsigned SVG_BOARD_WIDTH=1000;	// SVG viewbox specs
	const unsigned SVG_BOARD_HEIGHT=1000;
	string error,status;
	setactivity();
	if (strcmp(var,"print")==0){
		if (is_any_of(val,"","full")){
			VARVAL v;
			v.var = VAR_CONTENT;
			v.val += "<style>\n";
			v.val += ".whitext{\n";
			v.val += "\tfont-family: serif;\n";
			v.val += "\tstroke-width: 0.5;\n";
			v.val += string_f("\tfont-size:%u;\n",sp.mobile ? sp.fontsize - 15 : sp.fontsize + 3);
			v.val += "}\n";
			v.val += "</style>\n";
			v.val += "<script>\n";

			// Clicking on the board
			v.val += "var mbuttons=[0,0,0];\n";
			v.val += "function gameselect(event){\n";
			v.val += "\tmbuttons[event.which-1] = 1;\n";
			v.val += string_f("\tvar elm = document.getElementById('board-%s');\n",gameid.c_str());
			v.val += "\tvar rect = elm.getBoundingClientRect();\n";
			v.val += "\tgameaction(event,'select:'+(event.clientX-rect.left)+','+(event.clientY-rect.top)+ ','+event.which+','+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\tevent.preventDefault();\n";
			v.val += string_f("\tdocument.getElementById('text-%s').focus();\n",gameid.c_str());
			v.val += "}\n";
			v.val += "function gamemouseup(event){\n";
			v.val += "\tmbuttons[event.which-1] = 0;\n";
			v.val += "}\n";

			// Mouse wheel
			v.val += "function gamewheel(event){\n";
			v.val += "\tif (event.deltaY < 0){\n";
			v.val += "\t\tgameaction(event,'wheel:1,'+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\t}else{\n";
			v.val += "\t\tgameaction(event,'wheel:-1,'+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "}\n";

			// Moving an object
			v.val += "function gamemove(event){\n";
			v.val += "\tif(mbuttons[0] == 1){\n";
			v.val += string_f("\t\tvar elm = document.getElementById('board-%s');\n",gameid.c_str());
			v.val += "\t\tvar rect = elm.getBoundingClientRect();\n";
                        v.val += "\t\tgameaction(event,'mousemove:'+(event.clientX-rect.left)+','+(event.clientY-rect.top)+','+event.shiftKey+','+event.ctrlKey);\n";
			v.val += "\t}\n";
			v.val += "\tevent.stopPropagation();\n";
			v.val += "\tevent.preventDefault();\n";
			v.val += "}\n";

			// Updating an object 
			v.val += "function setboxtype(e,boxtype){\n";
			v.val += "\tif(boxtype==0){\n";
			v.val += "\t\te.removeAttribute('stroke-dasharray');\n";
			v.val += "\t}else if(boxtype==1){\n";
			v.val += "\t\te.setAttribute('stroke-dasharray','5,5');\n";
			v.val += "\t}else if(boxtype==2){\n";
			v.val += "\t\te.setAttribute('stroke-dasharray','2,5');\n";
			v.val += "\t}\n";
			v.val += "}\n";

			v.val += "function replace_ellipse(id, x, y, rx,ry,color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","ellipse");
			v.val += "\t\t\t\te.setAttribute('cx',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('cy',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('rx',rx);\n"; 
			v.val += "\t\t\t\te.setAttribute('ry',ry);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_rect(id, x, y, w,h, color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","rect");
			v.val += "\t\t\t\te.setAttribute('x',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('y',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('rx',5);\n"; 
			v.val += "\t\t\t\te.setAttribute('ry',5);\n"; 
			v.val += "\t\t\t\te.setAttribute('width',w);\n"; 
			v.val += "\t\t\t\te.setAttribute('height',h);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n";
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_typeline(id, x1, y1, x2, y2, color,boxtype){\n";
			js_find_loop_set_META(v.val,"board","line");
			v.val += "\t\t\t\te.setAttribute('x1',x1);\n"; 
			v.val += "\t\t\t\te.setAttribute('y1',y1);\n"; 
			v.val += "\t\t\t\te.setAttribute('x2',x2);\n"; 
			v.val += "\t\t\t\te.setAttribute('y2',y2);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\tsetboxtype(e,boxtype);\n";
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_typetext(id, x, y, color){\n";
			js_find_loop_set_META(v.val,"board","circle");
			v.val += "\t\t\t\te.setAttribute('cx',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('cy',y);\n"; 
			v.val += "\t\t\t\te.setAttribute('r',4);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\te.style.fill='black';\n"; 
			js_find_loop_set_end_META(v.val);

			v.val += "function replace_text(id, x, y, color, txt){\n";
			js_find_loop_set_META(v.val,"board","text");
			v.val += "\t\t\t\te.setAttribute('x',x);\n"; 
			v.val += "\t\t\t\te.setAttribute('y',y);\n"; 
			v.val += "\t\t\t\te.style.stroke=color;\n"; 
			v.val += "\t\t\t\te.style.fill=color;\n"; 
			v.val += "\t\t\t\te.innerHTML=txt;\n"; 
			js_find_loop_set_end_META(v.val);

			// line between a parent and sub-element
			v.val += "function replace_line(id, x, y, angle, len, color,arrow){\n";
			js_find_loop_set_META(v.val,"board","g");
			v.val += "\t\t\t\twhile (e.firstChild) {\n";
			v.val += "\t\t\t\t\te.removeChild(e.lastChild);\n";
			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.style.stroke = color;\n";
			v.val += "\t\t\t\te.style.fill = color;\n";
			v.val += "\t\t\t\te.style.strokeWidth = '1';\n";
			v.val += "\t\t\t\tvar newElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\te.appendChild(newElement);\n";
			v.val += "\t\t\t\tlen-=10;\n";
			v.val += "\t\t\t\tif(arrow==1){\n";
			// ARROW_END
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==2){\n";
			// ARROW_START
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}else if(arrow==3){\n";
			// ARROW_BOTH
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l10,-5 l-2,5 l2,5 l-10,-5 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==4){\n";
			// ARROW_RETURN
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+(len-10)+',0 l-2,-5 l10,5 l-10,5 l2,-5');\n"; 
			v.val += "\t\t\t\t\tvar path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\te.appendChild(path2);\n";
			v.val += "\t\t\t\t\tpath2.style.fill = 'none';\n";
			v.val += "\t\t\t\t\tvar lenq=len-10;\n";
			v.val += "\t\t\t\t\tpath2.setAttribute('d','M'+lenq+',-7 q-'+(lenq/2)+',-20,-'+(lenq-10)+',0');\n"; 
			v.val += "\t\t\t\t\tvar subg = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n";
			v.val += "\t\t\t\t\te.appendChild(subg);\n";
			v.val += "\t\t\t\t\tsubg.setAttribute('transform','rotate(-15,0,0)');\n";
			v.val += "\t\t\t\t\tvar path3 = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n";
			v.val += "\t\t\t\t\tpath3.setAttribute('d','M10,-5 l2,-5 l-10,5 l10,5 l-2,-5');\n";
			v.val += "\t\t\t\t\tsubg.appendChild(path3);\n";
			v.val += "\t\t\t\t}else if(arrow==5){\n";
			// ARROW_LINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t}else if(arrow==6){\n";
			// ARROW_DASHLINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t\tnewElement.setAttribute('stroke-dasharray','5,5');\n"; 
			v.val += "\t\t\t\t}else if(arrow==7){\n";
			// ARROW_DOTLINE
			v.val += "\t\t\t\t\tnewElement.setAttribute('d','M0,0 l'+len+',0');\n"; 
			v.val += "\t\t\t\t\tnewElement.setAttribute('stroke-dasharray','2,4');\n"; 

			v.val += "\t\t\t\t}\n";
			v.val += "\t\t\t\te.setAttribute('transform','translate('+x+','+y+') rotate('+angle+',0,0) translate(5,0)');\n"; 
			js_find_loop_set_end_META(v.val);

			wordproc_set_gamepress(v.val);

			// Dummy needed by gamepress, shared with doc_wordproc
			v.val += "function getlastline(){\n";
			v.val += "\treturn 0;\n";
			v.val += "}\n";
			// Remove an element
			v.val += "function removeelm(id,tag){\n";
			js_find_loop_set_META(v.val,"board","tag");
			v.val += "\t\t\t\te.parentNode.removeChild(e);\n";
			js_find_loop_set_end_META(v.val);
			// Update the message field
			v.val += "function updmsg(color,msg){\n";
			v.val += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
			v.val += "\tif (elm != null){\n";
			v.val += "\t\telm.style.color=color;\n";
			v.val += "\t\telm.innerHTML=msg;\n";
			v.val += "\t}\n";
			v.val += "}\n";
			
			v.val += "</script>\n";
			// Buttons line
			if (maywrite){
				#define BUTTON_NEWDOC	0
				#define BUTTON_TEXT	1
				#define BUTTON_ELLIPSE	2
				#define BUTTON_RECT	3 
				#define BUTTON_LINE	4
				#define BUTTON_HANDLINE	5
				#define BUTTON_SELECT	6
				#define BUTTON_STARMODE	7
				#define BUTTON_IMBEDMODE 8
				#define BUTTON_BOXTYPE	9
				#define BUTTON_LINETYPE	10
				#define BUTTON_TEXTPOS	11
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				WHITEBOARD_MENU menu(specs);
				documentd_button_start(v.val,gameid);
				documentd_bar_button (v.val,BUTTON_NEWDOC,menu.svg_clear,specs,false);
				documentd_button_space(v.val);
				documentd_bar_button (v.val,BUTTON_TEXT,menu.svg_text,specs,false);
				documentd_bar_button (v.val,BUTTON_ELLIPSE,menu.svg_ellipse,specs,false);
				documentd_bar_button (v.val,BUTTON_RECT,menu.svg_rect,specs,false);
				documentd_bar_button (v.val,BUTTON_LINE,menu.svg_line,specs,false);
				if (documentd_getflag("whiteboard_handline")!=nullptr){
					documentd_bar_button (v.val,BUTTON_HANDLINE,menu.svg_handline,specs,false);
				}
				documentd_button_space(v.val);
				documentd_bar_button (v.val,BUTTON_SELECT,menu.svg_select,specs,pref.selecting);
				documentd_bar_button (v.val,BUTTON_STARMODE,menu.svg_star,specs,pref.starmode);
				documentd_bar_button (v.val,BUTTON_IMBEDMODE,menu.svg_imbed,specs,pref.imbedmode);

				// Actions on selected elements
				documentd_button_space(v.val);
				documentd_bar_button (v.val,BUTTON_BOXTYPE,menu.svg_dashrect,specs,false);
				documentd_bar_button (v.val,BUTTON_LINETYPE,menu.svg_linetype,specs,false);
				documentd_bar_button (v.val,BUTTON_TEXTPOS,menu.svg_textpos,specs,false);
				documentd_button_end(v.val);
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += "Read only";
			}
			v.val += "</div>\n";
			// Board
			v.val += string_f("<div class=webtable id=%sdoc_whiteboard style='display:flex; flex-flow:row;' >\n",val);
			v.val += string_f("<div id='text-%s' style='flex:0 0 auto;width:%u;height:%u;border:1px solid black;margin-left: auto; margin-right: auto;'"
				" onkeydown='gamepress(event);return false;'"
				" tabindex=0 >\n",gameid.c_str(),board_width,board_height);
			v.val += string_f("<svg id='board-%s' viewbox='0 0 %u %u'"
				" style=cursor:default;"
				" onmousedown='gameselect(event);'"
				" onmouseup='gamemouseup(event); return false;'"
				" onwheel='gamewheel(event); return false;'"
				" onmousemove='gamemove(event); return false;'"
				" >\n"
				,gameid.c_str(),SVG_BOARD_WIDTH,SVG_BOARD_HEIGHT);
			
			glocal v;
			<call walkboard>(this);
			<f element>
				if (firstseen){
					const char *color = tbcolor[elm.selmode];
					static const char *tbdash[]={
						""," stroke-dasharray='5,5'"," stroke-dasharray='2,5'"
					};
					const char *dasharray = tbdash[elm.box_type];
					switch(elm.type){
					case TYPE_ELLIPSE:
						glocal.v.val += string_f("<ellipse id='e%u' cx=%u cy=%u rx=%u ry=%u stroke='%s' stroke-width=2 fill='none'%s />\n"
							,elm.id,elm.x,elm.y,elm.width/2,elm.height/2,color,dasharray);
						break;
					case TYPE_RECT:
						glocal.v.val += string_f("<rect id='e%u' x=%d y=%d rx=5 ry=5 width=%u height=%u stroke='%s' stroke-width='2' fill='none'%s />\n"
							,elm.id,(int)elm.x-elm.width/2,(int)elm.y-elm.height/2,elm.width,elm.height,color,dasharray);
						break;
					case TYPE_LINE:
						glocal.v.val += string_f("<line id='e%u' x1=%u y1=%u x2=%u y2=%u stroke='%s' stroke-width='2' fill='none'%s />\n"
							,elm.id,elm.x,elm.y,elm.x1,elm.y1,color,dasharray);
						break;
					case TYPE_HANDLINE:
						glocal.v.val += string_f("<path id='e%u' stroke='%s' stroke-width='4' fill='none' d='M%u %u L %u %u'/>\n"
							,elm.id,color,elm.x,elm.y,elm.x1,elm.y1);
						break;
					case TYPE_TEXT:
						glocal.v.val += string_f("<circle id='e%u' stroke='%s' fill='black' cx=%u cy=%u r=%u />\n"
							,elm.id,color,elm.x,elm.y,elm.width/2);
					}
					unsigned textx,texty;
					elm.gettextpos(textx,texty,glocal.fontsize);
					glocal.v.val += string_f("<text class=whitext id='t%u' X=%u Y=%u style='stroke:%s;fill:%s;'>%s</text>\n"
						,elm.id,textx,texty,color,color,documentd_escape(elm.txt).c_str());
				}
				if (parent != nullptr){
					LINE_SPEC spec(*parent,elm,quarter,nosubelm,nbsubelm);
					glocal.v.val += string_f("<g id='l%u,%u'/>\n"
						"<script>replace_line('l%u,%u',%u,%u,%lf,%u,'black',%u);</script>\n"
						,parent->id,elm.id,parent->id,elm.id,spec.x,spec.y,spec.angle,spec.len,arrow);
				}
			</f>
			</call>
			v.val += "</svg>\n";
			v.val += "</div>\n";
			draw_waiting_users(v.val,waiting_users_width,board_height,"flex:0 0 auto;");
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += string_f("<div id=msg-%s style=color:black>&nbsp;</div>\n",gameid.c_str());
			v.val += "</div>\n";
			res.emplace_back(v);
		}
	}else if (strcmp(var,REQ_GETFIELDS)==0){
		VARVAL var;
		var.var = VAR_FIELDS;
		res.emplace_back(var);
	}else if (strcmp(var,"dump")==0){
		VARVAL var;
		var.var = "elements";
		for (auto &s:elms){
			var.val += string_f("\nelement: id=%u label=%s txt=%s type=%u selmode=%u boxtype=%u x=%u y=%u x1=%u y1=%u width=%u height=%u"
				,s.first,s.second.label.c_str(),s.second.txt.c_str(),s.second.type,s.second.selmode,s.second.box_type
				,s.second.x,s.second.y,s.second.x1,s.second.y1,s.second.width,s.second.height);
			if (s.second.subelms.size() > 0){
				var.val += "\n\tsubelms[]=";
				for (auto &sub:s.second.subelms) var.val += string_f(" id=%d,arrow=%u,angle=%d",sub.id,sub.arrow,sub.angle);
			}
			if (s.second.insides.size() > 0){
				var.val += "\n\tinsides[]=";
				for (auto id:s.second.insides) var.val += string_f(" id=%d",id);
			}
		}
		var.val += "\nbaseelms[]=";
		for (auto id:baseelms){
			var.val += string_f(" id=%u",id);
		}
		var.val += "\n";
		res.emplace_back(var);
	}else if (maywrite){
		unsigned lastline = 1000;
		string tmpvar,tmpval;
		if (strcmp(var,"kbd")==0){
			wordproc_kbd(val,pref.mod,tmpvar,tmpval,lastline);
			var = tmpvar.c_str();
			val = tmpval.c_str();		
		}
		if (strcmp(var,"deletechar")==0){
			if (pref.mod.shift){
				auto selects = findselected(SEL_SELECTED);
				for (auto s:selects){
					delete_elm (s->id,notify_var);
				}
			}
		}else if (is_any_of(var,"backspace","insertchar","break")){
			auto selects = findselected(SEL_SELECTED);
			for (auto s:selects){
				if (strcmp(var,"backspace")==0){
					eraselast(s->txt);
				}else if (strcmp(var,"break")==0){
					auto star_elms = findselected(SEL_STAR);
					auto imbed_elms = findselected(SEL_IMBED);
					if (selects.size() > 1){
						error = MSG_U(E_DUPLICATEONE,"Duplication only applies to one element at once");
					}else{
						s->selmode = SEL_NONE;
						place_newelm(s->type,s->x,s->y+s->height+sp.fontsize,s->width,s->height,star_elms,imbed_elms,notify_var,notify_ids);
					}
				}else{
					s->txt += val;
				}
				notify_ids.insert(s->id);
			}
		}else if (strcmp(var,"select")==0){
			vector<string> tb;
			int n = str_splitline(val,',',tb);
			if (n == 5){
				unsigned x = atoi(tb[0].c_str())*SVG_BOARD_WIDTH/board_width;
				unsigned y = atoi(tb[1].c_str())*SVG_BOARD_HEIGHT/board_height;
				pref.lastx = x;
				pref.lasty = y;
				unsigned button = atoi(tb[2].c_str());
				bool shiftkey = tb[3] == "true";
				bool ctrlkey = tb[4] == "true";
				/*
					The logic for pref.selecting, star_mode and imbed_mode is different
					In pref.selecting, select one item unselect all others unless the shift key is activivated.
					This is standard. Selecting again the same item keeps it selected. This is useful when
					moving the item.
					In imbed_mode, only one item may be selected at once. Re-selecting the item unselect it.
					In star_mode, you may select multiple items without using the shift key. Re-selecting the
					item unselect it.
				*/
				if (button == 1 && pref.selecting && !shiftkey && !ctrlkey){
					resetsel(SEL_SELECTED,notify_ids);
				}
				auto e = locate (x,y,sp.fontsize);
				//tlmp_warning ("select: val=%s x=%u y=%u e=%p",val,x,y,e);
				if (e != nullptr){
					if (pref.selecting){
						if (button == 2){
							if (ctrlkey){
								// We change the label position
								auto selects = findselected(SEL_SELECTED);
								for (auto s:selects){
									s->changetextpos();
									notify_ids.insert(s->id);
								}
							}else{
								// We are cycling though the various line types connecting elms
								// shiftkey change the cycling direction
								changeline (shiftkey ? -1 : 1,error,notify_var,notify_ids);
							}
						}else if (shiftkey && ctrlkey){
							if (e->selmode != SEL_IMBED){
								resetsel(SEL_IMBED,notify_ids);	// Only one SEL_IMBED at once
								e->selmode = SEL_IMBED;
							}else{
								e->selmode = SEL_NONE;
							}
						}else if (ctrlkey && !is_any_of(e->type,TYPE_LINE,TYPE_HANDLINE)){
							if (e->selmode != SEL_STAR){
								e->selmode = SEL_STAR;
							}else{
								e->selmode = SEL_NONE;
							}
						}else{
							e->selmode = SEL_SELECTED;
						}
					}else if (pref.starmode){
						e->selmode = e->selmode == SEL_STAR ? SEL_NONE : SEL_STAR;
					}else if (pref.imbedmode){
						if (e->selmode != SEL_IMBED){
							resetsel(SEL_IMBED,notify_ids);	// Only one SEL_IMBED at once
							e->selmode = SEL_IMBED;
						}else{
							e->selmode = SEL_NONE;
						}
					}
					notify_ids.insert(e->id);
				}			
			}
		}else if (strcmp(var,"mousemove")==0){
			auto selects = findselected(SEL_SELECTED);
			if (selects.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				if (n == 4){
					int x = atoi(tb[0].c_str())*SVG_BOARD_WIDTH/board_width;
					int y = atoi(tb[1].c_str())*SVG_BOARD_HEIGHT/board_height;
					int movex = x-pref.lastx;
					int movey = y-pref.lasty;
					pref.lastx = x;
					pref.lasty = y;
					bool shiftkey = tb[2] == "true";
					bool ctrlkey = tb[3] == "true";
					for (auto elm:selects){
						if (elm->type == TYPE_LINE){
							if(shiftkey){
								check_limit (elm->x,movex);
								check_limit (elm->y,movey);
							}else if (ctrlkey){
								check_limit (elm->x1,movex);
								check_limit (elm->y1,movey);
							}else{
								elm->move(elms,movex,movey,notify_ids);
							}
							notify_ids.insert(elm->id);
						}else{
							elm->move(elms,movex,movey,notify_ids);
						}
					}
					setmodified(username);
				}
			}
		}else if (strcmp(var,"wheel")==0){
			auto selects = findselected(SEL_SELECTED);
			if (selects.size() > 0){
				vector<string> tb;
				int n = str_splitline(val,',',tb);
				if (n == 3){
					bool shiftkey = tb[1] == "true";
					bool ctrlkey = tb[2] == "true";
					int grow = atoi(tb[0].c_str())*5;
					for (auto elm:selects){
						elm->resize(grow,ctrlkey,shiftkey);
						notify_ids.insert(elm->id);
					}
					setmodified(username);
				}
			}
		}else if (strcmp(var,"newgame")==0){
			int uval = atoi(val);
			auto oldpref = pref;
			if (uval == BUTTON_NEWDOC){
				VARVAL var;
				var.var = VAR_DIALOG;
				var.val = DIALOG_WHITEBOARD_NEW;
				res.emplace_back(var);
			}else if (is_any_of(uval,BUTTON_TEXT,BUTTON_ELLIPSE,BUTTON_RECT,BUTTON_LINE,BUTTON_HANDLINE)){
				resetsel(SEL_SELECTED,notify_ids);
				auto star_elms = findselected(SEL_STAR);
				auto imbed_elms = findselected(SEL_IMBED);
				tlmp_warning ("star_elm=%lu imbed_elm=%lu",star_elms.size(),imbed_elms.size());
				static WHITEBOARD_ELMTYPE tbtype[]={TYPE_TEXT,TYPE_ELLIPSE,TYPE_RECT,TYPE_LINE,TYPE_HANDLINE};
				const unsigned default_size=20;
				const unsigned x=50;
				const unsigned y=50;
				place_newelm(tbtype[uval-BUTTON_TEXT],x,y,default_size,default_size,star_elms,imbed_elms,notify_var,notify_ids);
				setmodified(username);
				pref.selecting = true;
				pref.starmode = pref.imbedmode = false;
			}else if (is_any_of(uval,BUTTON_SELECT,BUTTON_STARMODE,BUTTON_IMBEDMODE)){
				if (uval == BUTTON_SELECT){
					pref.selecting = true;
					pref.starmode = pref.imbedmode = false;
				}else if (uval == BUTTON_STARMODE){
					pref.starmode = true;
					pref.selecting = pref.imbedmode = false;
				}else if (uval == BUTTON_IMBEDMODE){
					pref.imbedmode = true;
					pref.selecting = pref.starmode = false;
				}
			}else if (uval == BUTTON_BOXTYPE){
				auto selects = findselected (SEL_SELECTED);
				if (selects.size()==0){
					error = MSG_R(E_NONODE);
				}else{
					for (auto s:selects){
						s->box_type = (BOX_TYPE)((unsigned)s->box_type+1);
						if (s->box_type == BOX_LAST) s->box_type = BOX_SOLID;
						notify_ids.insert (s->id);
					}
				}
			}else if (uval == BUTTON_LINETYPE){
				changeline (1,error,notify_var,notify_ids);
			}else if (uval == BUTTON_TEXTPOS){
				auto selects = findselected (SEL_SELECTED);
				if (selects.size()==0){
					error = MSG_R(E_NONODE);
				}else{
					for (auto s:selects){
						s->changetextpos();
						notify_ids.insert(s->id);
					}
				}
			}else{
				tlmp_error ("whiteboard newgame=%d",uval);
			}
			whiteboard_update_button (script_var.val, oldpref.selecting,pref.selecting, BUTTON_SELECT);
			whiteboard_update_button (script_var.val, oldpref.starmode,pref.starmode, BUTTON_STARMODE);
			whiteboard_update_button (script_var.val, oldpref.imbedmode,pref.imbedmode, BUTTON_IMBEDMODE);
			script_var.val += string_f("document.getElementById('text-%s').focus();\n",gameid.c_str());
		// The other actions are Used to script modification of the document
		}else if (strcmp(var,"addelm")==0){
			// val format: label "text" type x y width height
			vector<string>tb;
			int n = str_splitlineq(val,tb);
			if (n == 7){
				const char *label = tb[0].c_str();
				const char *text = tb[1].c_str();
				auto &type = tb[2];
				unsigned x = atoi(tb[3].c_str());
				unsigned y = atoi(tb[4].c_str());
				unsigned width = atoi(tb[5].c_str());
				unsigned height = atoi(tb[6].c_str());
				if (!is_any_of(type,"ellipse","rect","line","handline")){
				}else{
					WHITEBOARD_ELMTYPE elmtype = TYPE_ELLIPSE;
					if (type == "rect"){
						elmtype = TYPE_RECT;
					}else if (type == "line"){
						elmtype = TYPE_LINE;
					}else if (type == "handline"){
						elmtype = TYPE_HANDLINE;
					}else if (type == "text"){
						elmtype = TYPE_TEXT;
					}
					auto star_elms = findselected(SEL_STAR);
					auto imbed_elms = findselected(SEL_IMBED);
					
					unsigned id = place_newelm(elmtype,x,y,width,height,star_elms,imbed_elms,notify_var,notify_ids);
					setmodified(username);
					auto &elm = elms[id];
					elm.label = label;
					elm.txt = text;
				}
			}
			
		}else if (strcmp(var,"resetselect")==0){
			// val format: 0|1|2
			unsigned sel = atoi(val);
			static WHITEBOARD_SELMODE tbmode[]={SEL_SELECTED,SEL_STAR, SEL_IMBED};
			resetsel (tbmode[sel],notify_ids);
		}else if (strcmp(var,"labelselect")==0){
			// val format: label 0|1|2
			vector<string> tb;
			int n = str_splitline(val,' ',tb);
			if (n == 2){
				const char *label = tb[0].c_str();
				unsigned sel = atoi(tb[1].c_str());
				if (is_any_of((int)sel,0,1,2)){
					for (auto &e:elms){
						if (e.second.label==label){
							static WHITEBOARD_SELMODE tbmode[]={SEL_SELECTED,SEL_STAR, SEL_IMBED};
							e.second.selmode = tbmode[sel];
							notify_ids.insert(e.first);
							break;
						}
					}
				}	
			}
		}else if (strcmp(var,"selectline")==0){
			// val format: 0|1|... ARROW_TYPE 
			unsigned uval = atoi(val);
			if (uval < ARROW_LAST){
				ARROW_TYPE type = (ARROW_TYPE)uval;
				auto parents = findselected(SEL_STAR);
				auto selects = findselected(SEL_SELECTED);
				if (parents.size() == 0){
					error = MSG_R(E_NOPARENT);
				}else if (selects.size() == 0){
					error = MSG_R(E_NONODE);
				}else{
					changeline (parents,selects,0,type,notify_var);
					for (auto s:selects) notify_ids.insert(s->id);
				}
			}
		}else if (strcmp(var,"labeldelete")==0){
			// val format: label
			for (auto &e:elms){
				if (e.second.label==val){
					delete_elm (e.first,notify_var);
					break;
				}
			}
		}else if (strcmp(var,"resetgame")==0){
			resetgame();
			notify_var.val += string_f("var svg = document.getElementById('board-%s');\n",gameid.c_str());
			notify_var.val += "while (svg.firstChild) {\n";
			notify_var.val += "\tsvg.removeChild(svg.lastChild);\n";
			notify_var.val += "}\n";
			setmodified(username);
		}
	}else{
		error = MSG_R(E_READONLY);
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else{
		update_msg(false,"&nbsp;","white",res);
	}
}
</mod>
void WHITEBOARD::manyexec (
	const vector<VARVAL_receive> &steps,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	set<unsigned> notify_ids;	// Lines to update using SCRIPT
	for (auto &v:steps){
		execstep (v.var,v.val,session,username,maywrite,sp,script_var,notify_var,notify_ids,res);
	}
	sortsubelms(notify_ids);
	redraw(notify_ids,notify_var,sp.fontsize);
	res.emplace_back(move(notify_var));
	res.emplace_back(move(script_var));
}
