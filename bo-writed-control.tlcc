/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Command line tool to control bo-writed
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <trlitool.h>

using namespace std;

#include "proto/bo-writed_control.protoch"

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/bo-writed.sock";
	// Options for deleteoldmsgs
	glocal bool doit = false;
	glocal unsigned keeppublic=30;
	glocal unsigned keepother=7;
	glocal unsigned keeprss=7;
	glocal unsigned min_msgs = 20;
	glocal unsigned min_pub_msgs = 20;
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("bo-writed-control",VERSION
			,"Command line tool to control bo-writed\n"
			 "\n"
			 "\tadd_default_interest interest\n"
			 "\tadd_interest user interest\n"
			 "\tadduser nickname email password lang\n"
			 "\tconfirmuser nickname\n"
			 "\tdebug 0/1\n"
			 "\tdebugfile filename\n"
			 "\tdel_incomplete seconds\n"
			 "\tdeleteoldmsgs user ...\n"
			 "\tdisable user\n"
			 "\tenable user\n"
			 "\tinstrument 0|1\n"
			 "\tlogin user\n"
			 "\tlogout sessionid\n"
			 "\tmailctrl 0|1 force_address|keep\n"
			 "\tmakeadmin email 1|0\n"
			 "\tquit\n"
			 "\treload file\n"
			 "\trotatelog\n"
			 "\tsetpassword user password\n"
			 "\tstatus\n"
			 "\tsyncdb\n"
			 "\n"
			 "\tnewacctresend email [ to_stdout ]\n"
			 "\tsendmail dest subject body\n"
			);
		setarg ('p',"control","Unix socket to reach trlid",glocal.control,false);
		setgrouparg ("deleteoldmsgs options");
		setarg (' ',"doit","Really delete entries, not just collect statistics",glocal.doit,false);
		setarg (' ',"keeppublic","Keep public messages for N days",glocal.keeppublic,false);
		setarg (' ',"keepother","Keep other messages for N days",glocal.keepother,false);
		setarg (' ',"keeprss","Keep public messages for RSS accounts for N days",glocal.keeprss,false);
		setarg (' ',"min_msgs","Maintain at least that many messages",glocal.min_msgs,false); 
		setarg (' ',"min_pub_msgs","Maintain at least that many messages in public folder",glocal.min_pub_msgs,false); 
	</f>
	<f main>
		glocal int ret = -1;
		CONNECT_INFO con;
		con.port = glocal.control;
		if (strcmp(argv[0],"status")==0 && argc==1){
			<call bo_writed_control_status>(con);
			<f ok>
				for (auto x:lines) printf ("%s\n",x);
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"quit")==0 && argc==1){
			<call bo_writed_control_quit>(con);
			<f ok>
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"reload")==0 && argc==1){
			<call bo_writed_control_reload>(con);
			<f ok>
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"syncbd")==0 && argc==1){
			<call bo_writed_control_syncbd>(con);
			<f ok>
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"debug")==0 && argc==2){
			<call bo_writed_control_debug>(con,atoi(argv[1]));
			<f ok>
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"debugfile")==0 && argc==2){
			<call bo_writed_control_debugfile>(con,argv[1]);
			<f ok>
				if (!internal_error) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"makeadmin")==0 && argc==3){
			<call bo_writed_control_makeadmin>(con,argv[1],atoi(argv[2]));
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					fprintf (stderr,"\tsuccess=%d msg=%s\n",success,msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"rotatelog")==0 && argc==1){
			<call bo_writed_control_rotatelog>(con);
			<f ok>
				printf ("\tsuccess=%d\n",success);
				if (success) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"truncatelog")==0 && argc==1){
			<call bo_writed_control_truncatelog>(con);
			<f ok>
				printf ("\tsuccess=%d\n",success);
				if (success) glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"del_incomplete")==0 && argc==2){
			<call bo_writed_control_del_incomplete>(con,atoi(argv[1]));
			<f ok>
				for (auto x:emails) printf ("\tdel_incomplete %s\n",x);
			</f>
			</call>
		}else if (strcmp(argv[0],"sendmail")==0 && argc==4){
			<call bo_writed_control_sendmail>(con,argv[1],argv[2],argv[3]);
			<f ok>
				printf ("success=%d\n",success);
			</f>
			</call>
		}else if (strcmp(argv[0],"newacctresend")==0 && (argc==2 || argc==3)){
			bool to_stdout = false;
			if (argc == 3){
				if (strcmp(argv[2],"to_stdout")==0){
					to_stdout = true;
				}else{
					tlmp_error ("newacctresend: Only option allowed is \"to_stdout\"\n");
					exit (-1);
				}
			}
			<call bo_writed_control_newacctresend>(con,argv[1],to_stdout);
			<f ok>
				printf ("success=%d\n",success);
				printf ("%s",msg);
			</f>
			</call>
		}else if (strcmp(argv[0],"mailctrl")==0 && argc==3){
			<call bo_writed_control_mailctrl>(con,atoi(argv[1]),argv[2]);
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"adduser")==0 && argc==5){
			const char *name = argv[1];
			const char *email = argv[2];
			const char *password = argv[3];
			const char *lang = argv[4];
			<call bo_writed_control_adduser>(con,name,email,password,lang);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("adduser: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"confirmuser")==0 && argc==2){
			const char *name = argv[1];
			<call bo_writed_control_confirmuser>(con,name);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("confirmuser: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"setpassword")==0 && argc==3){
			const char *name = argv[1];
			const char *password = argv[2];
			<call bo_writed_control_setpassword>(con,name,password);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("setpassword: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"disable")==0 && argc==2){
			const char *name = argv[1];
			<call bo_writed_control_disableuser>(con,name);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("disable: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"enable")==0 && argc==2){
			const char *name = argv[1];
			<call bo_writed_control_enableuser>(con,name);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("enable: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"login")==0 && argc==2){
			const char *name = argv[1];
			<call bo_writed_control_login>(con,name);
			<f ok>
				if (success){
					printf ("%s\n",session);
					glocal.ret = 0;
				}else{
					tlmp_error ("login: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"logout")==0 && argc==2){
			const char *sessionid = argv[1];
			<call bo_writed_control_logout>(con,sessionid);
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"instrument")==0 && argc==2){
			<call bo_writed_control_instrument>(con,atoi(argv[1]));
			<f ok>
				glocal.ret = 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"deleteoldmsgs")==0){
			glocal unsigned deleted = 0;
			glocal.ret = 0;
			for (int i=1; i<argc; i++){
				glocal const char *user = argv[i];
				glocal bool fail = false;
				<call bo_writed_control_deleteoldmsgs>(con,glocal.user,glocal.doit
					,glocal.keeppublic,glocal.keepother,glocal.keeprss
					,glocal.min_msgs,glocal.min_pub_msgs);
				<f ok>
					if (!success){
						glocal.fail = true;
						tlmp_error ("deleteoldmsgs failed for user %s: %s\n",glocal.user,msg);
						glocal.ret = -1;
					}else{
						for (auto const &s:stats){
							printf ("%-40s %-15s %5u\n",glocal.user,s.group,s.deleted);
							glocal.deleted += s.deleted;
						}
					}
				</f>
				</call>
				if (glocal.fail) break;
			}
			printf ("%u deleted messages\n",glocal.deleted);
		}else if (strcmp(argv[0],"add_interest")==0 && argc==3){
			const char *user = argv[1];
			const char *interest = argv[2];
			<call bo_writed_control_add_interest>(con,user,interest);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("add_interest: %s\n",msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"add_default_interest")==0 && argc==2){
			const char *interest = argv[1];
			<call bo_writed_control_add_default_interest>(con,interest);
			<f ok>
				if (success){
					glocal.ret = 0;
				}else{
					tlmp_error ("add_default_interest: %s\n",msg);
				}
			</f>
			</call>
		}else{
			tlmp_error ("Invalid command: %s\n",argv[0]);
			usage();
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

