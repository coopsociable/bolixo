#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpsql.h>
#include <string>
#include <vector>
#include <map>
#include <fdpass.h>
#include "filesystem.h"

using namespace std;

#if 0
#define bo_sessiond_admin_getsessioninfo_NOTNEED
#define bo_sessiond_admin_setsession_NOTNEED
#define bo_sessiond_admin_deletesession_NOTNEED
#define bo_sessiond_admin_deletesessions_NOTNEED
#define bo_sessiond_admin_createsession_NOTNEED
#define bo_sessiond_admin_test_NOTNEED
#include "proto/bo-sessiond_admin.protoch"
#endif

/*
	Create a uniq ID combining the process number of this instance, a random value and the time in micro-seconds
*/
string fs_makeid (int noproc)
{
	string ret;
	char tmp[100];
	struct timeval t;
	if (gettimeofday(&t,NULL)!=-1){
		static int fd = -1;
		static bool error_shown = false;
		if (fd == -1){
			fd = open ("/dev/urandom",O_RDONLY,0);
		}
		if (fd == -1){
			if (!error_shown){
				tlmp_error ("Can't open /dev/urandom (%s)\n",strerror(errno));
				error_shown = true;
			}
		}else{
			char buf[8];
			if (read(fd,buf,8)!=8){
				close (fd);
				fd = -1;
				if (!error_shown){
					tlmp_error ("Can't read 8 bytes from /dev/urandom (%s)\n",strerror(errno));
					error_shown = true;
				}
			}else{
				for (int i=0; i<8; i++) snprintf (tmp+i*2,3,"%02x",buf[i]);
				int n = snprintf (tmp+16,sizeof(tmp)-16-1,"%08lx%08lx",t.tv_sec,t.tv_usec);
				snprintf (tmp+16+n,sizeof(tmp)-16-n-1,"-%d",noproc);
				ret = tmp;
			}
		}
	}
	return ret;
}	
<mod>
static int fs_locate_entry (int dirid, PARAM_STRING fname, char &type, string &modified, unsigned &ownerid, const char *threshold)
{
	glocal int ret = -1;
	glocal char type='_';
	glocal unsigned ownerid=(unsigned)-1;
	glocal string *modified = &modified;
	<call sql_query>("select itemid,type,modified,ownerid from dirs_content"
		" join ids on dirs_content.itemid=ids.id"
		" where dirid=%d and name='%s' and modified <= '%s' order by modified desc limit 1"
		,dirid,fname.ptr,threshold);
	<f onerow>
		char type = row[1][0];
		if (type != '_'){
			glocal.ret = atoi(row[0]);
			glocal.type = type;
			(*glocal.modified)=row[2];
			glocal.ownerid = atoi(row[3]);
		}
	</f>
	</call>
	type = glocal.type;
	ownerid = glocal.ownerid;
	return glocal.ret;
}
</mod>
/*
	Locate a directory and retuns its id
*/
static int fs_locate_dir (vector<string> &tb, unsigned userid, string &msg, const char *threshold)
{
	int ret = -1;
	if (tb.size()==0){
		// root dir
		ret = 0;
	}else{
		int parentid = 0;
		string tmp;
		for (auto &d:tb){
			tmp += string("/") + d;
			char type;
			string modified;
			unsigned ownerid;
			int dirid = fs_locate_entry (parentid,d,type,modified,ownerid,threshold);
			if (dirid == -1){
				msg = string_f ("%s does not exist",tmp.c_str());
				ret = -1;
				break;
			}else if (type != 'D'){
				msg = string_f ("%s is not a directory",tmp.c_str());
				ret = -1;
				break;
			}else if (ownerid != userid){
				msg = string_f ("Access denied to directory %s",tmp.c_str());
				ret = -1;
				break;
			}else{
				ret = dirid;
				parentid = dirid;
			}
		}
	}
	return ret;
}

static int fs_parse_fname (const char *name, vector<string> &parentdirs, string &basename)
{
	int ret = -1;
	parentdirs.clear();
	basename.clear();
	if (name[0] == '/'){
		const char *start = name +1;
		while (1){
			const char *pt = start;
			while (*pt != '\0' && *pt != '/') pt++;
			if (pt == start) break;
			if (*pt == '/'){
				parentdirs.push_back(string(start,pt-start));
				start = pt+1;
			}else{
				basename = start;
				ret = 0;
				break;
			}
		}	 
	}
	return ret;
}

int fs_findentry (const char *name, ENTRY &entry, bool expect_exist, const char *threshold)
{
	int ret = -1;
	if (threshold[0] == '\0') threshold = "3000/01/01";
	vector<string> parents;
	if (name[0] == '/' && name[1] == '\0'){
		entry.dirid = 0;
		entry.entryid = 0;
		entry.type = 'D';
		if (!expect_exist){
			entry.msg = "Entry with that name exist";
		}else{
			ret = 0;
		}
	}else if (fs_parse_fname (name,parents,entry.basename) == -1){
		entry.msg = "Invalid name";
	}else{
		entry.dirid = fs_locate_dir (parents,entry.userid,entry.msg,threshold);
		if (entry.dirid != -1){
			const char *fname = entry.basename.c_str();
			entry.entryid = fs_locate_entry (entry.dirid,fname,entry.type,entry.modified,entry.ownerid,threshold);
			if (entry.entryid == -1){
				if (expect_exist){
					entry.msg = "Entry with that name does exist";
				}else{
					ret = 0;
				}
			}else if (!expect_exist){
				entry.msg = "Entry with that name exist";
			}else if (entry.userid != entry.ownerid){
				entry.msg = "Not allowed";
			}else{
				ret = 0;
			}
		}
	}
	return ret;
}

struct HANDLE{
	int fileid;
	string modified;
	FILE *f;
	string sessionid;	// A handle may only be used by the same sessionid
	HANDLE (int _fileid, PARAM_STRING _modified, FILE *_f, PARAM_STRING _sessionid){
		fileid = _fileid;
		modified = _modified.ptr;
		f = _f;
		sessionid = _sessionid.ptr;
	}
	HANDLE(){
		fileid = -1;
		f = NULL;
	}
	void close(){
		if (f != NULL) fclose (f);
	}
};
static map<string,HANDLE> handles;
unsigned fs_getnbhandle()
{
	return handles.size();
}

static string fs_createpath (int fileid, PARAM_STRING modified)
{
	const char *src = modified.ptr;
	char tmp[strlen(src)+1];
	char *dst = tmp;
	while (*src != '\0'){
		char car = *src++;
		if (car == '/' || car == '-'){
			*dst = '-';
		}else if (car == ' ' || car == '_'){
			*dst = '-';
		}else{
			*dst = car;
		}
		dst++;
	}
	*dst = '\0';
	return string_f ("/var/lib/bolixo/%d-%s",fileid,tmp);
}
/*
	Assign a file handle for one instance of a file
*/
FILE *fs_alloc_file_handle (int fileid, PARAM_STRING modified, const char *mode, string &handle, const char *sessionid)
{
	handle = fs_makeid (0);
	string path = fs_createpath (fileid,modified);
	FILE *ret = fopen (path.c_str(),mode);
	tlmp_error ("alloc_file_handle ret=%p path=%s (%s)\n",ret,path.c_str(),strerror(errno));
	if (ret != NULL){
		handles[handle] = HANDLE(fileid,modified,ret,sessionid);
	}else{
		handle.clear();
	}
	return ret;
}
long fs_get_filesize (int fileid, PARAM_STRING modified)
{
	long ret = -1;
	string path = fs_createpath (fileid,modified);
	struct stat64 st;
	if (stat64(path.c_str(),&st)!=-1) ret = st.st_size;
	return ret;
}

FILE *fs_get_file (const std::string &handle, const char *sessionid)
{
	FILE *ret = NULL;
	auto x = handles.find(handle);
	if (x != handles.end() && strcmp(x->second.sessionid.c_str(),sessionid)==0){
		ret = x->second.f;
	}
	return ret;
}
void fs_delete_handle (PARAM_STRING handle)
{
	auto x = handles.find(handle.ptr);
	if (x != handles.end()){
		x->second.close();
		handles.erase (x);
	}
}
