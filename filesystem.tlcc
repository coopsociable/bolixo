#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpsql.h>
#include <string>
#include <vector>
#include <map>
#include <fdpass.h>
#include "filesystem.h"

using namespace std;

#if 0
#define bo_sessiond_admin_getsessioninfo_NOTNEED
#define bo_sessiond_admin_setsession_NOTNEED
#define bo_sessiond_admin_deletesession_NOTNEED
#define bo_sessiond_admin_deletesessions_NOTNEED
#define bo_sessiond_admin_createsession_NOTNEED
#define bo_sessiond_admin_test_NOTNEED
#include "proto/bo-sessiond_admin.protoch"
#endif

/*
	Create a uniq ID combining the process number of this instance, a random value and the time in micro-seconds
*/
string fs_makeid (int noproc)
{
	string ret;
	char tmp[100];
	struct timeval t;
	if (gettimeofday(&t,NULL)!=-1){
		static int fd = -1;
		static bool error_shown = false;
		if (fd == -1){
			fd = open ("/dev/urandom",O_RDONLY,0);
		}
		if (fd == -1){
			if (!error_shown){
				tlmp_error ("Can't open /dev/urandom (%s)\n",strerror(errno));
				error_shown = true;
			}
		}else{
			char buf[8];
			if (read(fd,buf,8)!=8){
				close (fd);
				fd = -1;
				if (!error_shown){
					tlmp_error ("Can't read 8 bytes from /dev/urandom (%s)\n",strerror(errno));
					error_shown = true;
				}
			}else{
				for (int i=0; i<8; i++) snprintf (tmp+i*2,3,"%02x",buf[i]);
				int n = snprintf (tmp+16,sizeof(tmp)-16-1,"%08lx%08lx",t.tv_sec,t.tv_usec);
				snprintf (tmp+16+n,sizeof(tmp)-16-n-1,"-%d",noproc);
				ret = tmp;
			}
		}
	}
	return ret;
}	
<mod>
static int fs_locate_entry (int dirid, PARAM_STRING fname, char &type, string &modified, unsigned &ownerid, unsigned &group_list_id, const char *threshold)
{
	glocal int ret = -1;
	glocal char type='_';
	glocal unsigned ownerid=(unsigned)-1;
	glocal unsigned group_list_id=(unsigned)-1;
	glocal string *modified = &modified;
	<call sql_query>("select itemid,type,modified,ownerid,group_list_id from dirs_content"
		" join ids on dirs_content.itemid=ids.id"
		" where dirid=%d and name='%s' and modified <= '%s' order by modified desc limit 1"
		,dirid,fname.ptr,threshold);
	<f onerow>
		char type = row[1][0];
		if (type != '_'){
			glocal.ret = atoi(row[0]);
			glocal.type = type;
			(*glocal.modified)=row[2];
			glocal.ownerid = atoi(row[3]);
			glocal.group_list_id = row[4] != NULL ? atoi(row[4]) : (unsigned)-1;
		}
	</f>
	</call>
	type = glocal.type;
	ownerid = glocal.ownerid;
	group_list_id = glocal.group_list_id;
	return glocal.ret;
}
</mod>

<mod>
static bool fs_check_access(unsigned userid, unsigned ownerid, unsigned group_list_id, bool is_admin)
{
	glocal bool ret = false;
	if (is_admin){
		glocal.ret = true;
	}else if (userid == ownerid){
		glocal.ret = true;
	}else if (group_list_id == 0){
		glocal.ret = true;
	}else if (group_list_id != (unsigned)-1){
		<call sql_query>("select 1 from group_list_members"
			" join group_members on group_list_members.groupid = group_members.groupid"
			" where group_list_members.group_list_id=%u and userid=%u limit 1"
			,group_list_id,userid);
		<f onerow>
			glocal.ret = true;
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>
/*
	Locate a directory and retuns its id
*/
static int fs_locate_dir (
	vector<string> &tb,
	unsigned userid,	// Check access for this userid
	bool is_admin,
	string &msg,
	const char *threshold,
	bool create_missing,
	int noproc,
	vector<unsigned> *listids)
{
	int ret = -1;
	if (tb.size()==0){
		// root dir
		ret = 0;
	}else{
		int parentid = 0;
		string tmp;
		for (unsigned i=0; i<tb.size(); i++){
			auto &d = tb[i];
			tmp += string("/") + d;
			char type;
			string modified;
			unsigned ownerid,group_list_id;
			int dirid = fs_locate_entry (parentid,d,type,modified,ownerid,group_list_id,threshold);
			if (dirid == -1){
				if (!create_missing){
					msg = string_f ("%s does not exist",tmp.c_str());
					ret = -1;
					break;
				}else{
					// We have to create a directory owned by userid
					string uuid;
					dirid = fs_newid (userid,(*listids)[i],noproc,msg,uuid);
					if (dirid != -1){
						char now[20];
						fs_set_now(now);
						if (sql_action("insert into dirs_content (dirid,itemid,modified,type,name) values (%d,%d,'%s','D','%s')"
							,parentid,dirid,now,d.c_str())==-1){
							msg = "Internal error (dirs_content table)";
							break;
						}else{
							ret = dirid;
							parentid = dirid;
						}
					}else{
						msg = "Internal error (fs_newid)";
						break;
					}
				}
			}else if (type != 'D'){
				msg = string_f ("%s is not a directory",tmp.c_str());
				ret = -1;
				break;
			}else if (!fs_check_access(userid,ownerid,group_list_id,is_admin)){
				msg = string_f ("Access denied to directory %s",tmp.c_str());
				ret = -1;
				break;
			}else{
				ret = dirid;
				parentid = dirid;
			}
		}
	}
	return ret;
}
static int fs_locate_dir (
	vector<string> &tb,
	unsigned userid,	// Check access for this userid
	bool is_admin,
	string &msg,
	const char *threshold)
{
	return fs_locate_dir (tb,userid,is_admin,msg,threshold,false,0,NULL);
}

static int fs_parse_fname (const char *name, vector<string> &parentdirs, string &basename)
{
	int ret = -1;
	parentdirs.clear();
	basename.clear();
	if (name[0] == '/'){
		const char *start = name +1;
		while (1){
			const char *pt = start;
			while (*pt != '\0' && *pt != '/') pt++;
			if (pt == start) break;
			if (*pt == '/'){
				parentdirs.push_back(string(start,pt-start));
				start = pt+1;
			}else{
				basename = start;
				ret = 0;
				break;
			}
		}	 
	}
	return ret;
}

int fs_findentry (const char *name, ENTRY &entry, bool expect_exist, const char *threshold)
{
	int ret = -1;
	if (threshold[0] == '\0') threshold = END_OF_TIME;
	vector<string> parents;
	if (name[0] == '/' && name[1] == '\0'){
		entry.dirid = 0;
		entry.entryid = 0;
		entry.type = 'D';
		if (!expect_exist){
			entry.msg = "Entry with that name exist";
		}else{
			ret = 0;
		}
	}else if (fs_parse_fname (name,parents,entry.basename) == -1){
		entry.msg = "Invalid name";
	}else{
		entry.dirid = fs_locate_dir (parents,entry.userid,entry.is_admin,entry.msg,threshold);
		if (entry.dirid != -1){
			const char *fname = entry.basename.c_str();
			entry.entryid = fs_locate_entry (entry.dirid,fname,entry.type,entry.modified,entry.ownerid,entry.group_list_id,threshold);
			if (entry.entryid == -1){
				if (expect_exist){
					entry.msg = "Entry with that name does exist";
				}else{
					ret = 0;
				}
			}else if (!expect_exist){
				entry.msg = "Entry with that name exist";
			}else if (!fs_check_access(entry.userid,entry.ownerid,entry.group_list_id,entry.is_admin)){
				entry.msg = "Not allowed";
			}else{
				ret = 0;
			}
		}
	}
	return ret;
}

struct HANDLE{
	int fileid;
	string modified;
	FILE *f;
	string sessionid;	// A handle may only be used by the same sessionid
	HANDLE (int _fileid, PARAM_STRING _modified, FILE *_f, PARAM_STRING _sessionid){
		fileid = _fileid;
		modified = _modified.ptr;
		f = _f;
		sessionid = _sessionid.ptr;
	}
	HANDLE(){
		fileid = -1;
		f = NULL;
	}
	void close(){
		if (f != NULL) fclose (f);
	}
};
static map<string,HANDLE> handles;
unsigned fs_getnbhandle()
{
	return handles.size();
}

static string fs_createpath (int fileid, PARAM_STRING modified)
{
	const char *src = modified.ptr;
	char tmp[strlen(src)+1];
	char *dst = tmp;
	while (*src != '\0'){
		char car = *src++;
		if (car == '/' || car == '-'){
			*dst = '-';
		}else if (car == ' ' || car == '_'){
			*dst = '-';
		}else{
			*dst = car;
		}
		dst++;
	}
	*dst = '\0';
	return string_f ("/var/lib/bolixo/%d-%s",fileid,tmp);
}
/*
	Assign a file handle for one instance of a file
*/
FILE *fs_alloc_file_handle (int fileid, PARAM_STRING modified, const char *mode, string &handle, const char *sessionid)
{
	handle = fs_makeid (0);
	string path = fs_createpath (fileid,modified);
	FILE *ret = fopen (path.c_str(),mode);
	tlmp_error ("alloc_file_handle ret=%p path=%s (%s)\n",ret,path.c_str(),strerror(errno));
	if (ret != NULL){
		handles[handle] = HANDLE(fileid,modified,ret,sessionid);
	}else{
		handle.clear();
	}
	return ret;
}
long fs_get_filesize (int fileid, PARAM_STRING modified)
{
	long ret = -1;
	string path = fs_createpath (fileid,modified);
	struct stat64 st;
	if (stat64(path.c_str(),&st)!=-1) ret = st.st_size;
	return ret;
}

FILE *fs_get_file (const std::string &handle, const char *sessionid)
{
	FILE *ret = NULL;
	auto x = handles.find(handle);
	if (x != handles.end() && strcmp(x->second.sessionid.c_str(),sessionid)==0){
		ret = x->second.f;
	}
	return ret;
}
void fs_delete_handle (PARAM_STRING handle)
{
	auto x = handles.find(handle.ptr);
	if (x != handles.end()){
		x->second.close();
		handles.erase (x);
	}
}

<mod>
void fs_list_inboxes (unsigned userid, vector<string> &managers, vector<string> &projects, vector<string> &roles, vector<unsigned> &listids)
{
	glocal vector<string> *managers = &managers;
	glocal vector<string> *projects = &projects;
	glocal vector<string> *roles = &roles;
	glocal vector<unsigned> *listids = &listids;
	managers.push_back("");
	projects.push_back("inbox");
	roles.push_back("");
	listids.push_back((unsigned)-1);
	<call sql_query>("select id2name.name,group_lists.name,group_members.role,group_lists.id"
		" from group_members"
		" join group_list_members on group_list_members.groupid = group_members.groupid"
		" join group_lists on group_list_members.group_list_id=group_lists.id"
		" join id2name on group_lists.ownerid=id2name.userid"
		" where group_members.userid = %u",userid);
	<f onerow>
		glocal.managers->push_back(row[0]);
		glocal.projects->push_back(row[1]);
		glocal.roles->push_back(row[2]);
		glocal.listids->push_back(atoi(row[3]));
	</f>
	</call>
}
</mod>

/*
	Initialise now with the current date and time
*/
void fs_set_now (char now[20])
{
	fdpass_asctime(time(NULL),now);
}

/*
	Allocate a new entry in table ids.
*/
int fs_newid (unsigned userid, unsigned listid, int noproc, string &msg, string &uuid)
{
	int ret = -1;
	uuid = fs_makeid(noproc);
	char listid_str[30];
	if (listid == (unsigned)-1){
		strcpy (listid_str,"NULL");
	}else{
		snprintf (listid_str,sizeof(listid_str)-1,"%u",listid);
	}
	if (sql_action("insert into ids (ownerid,group_list_id,uuid) values (%u,%s,'%s')",userid,listid_str,uuid.c_str())==-1){
		msg = "Internal error (ids table)";
	}else{
		ret = sql_getlastid();
	}
	return ret;
}
int fs_newid (unsigned userid, int noproc, string &msg, string &uuid)
{
	return fs_newid (userid,(unsigned)-1,noproc,msg,uuid);
}
int fs_newid (unsigned userid, int noproc, string &msg)
{
	string uuid;
	return fs_newid (userid,(unsigned)-1,noproc,msg,uuid);
}
/*
	Find the directory ID of the inbox for this user.
	The directory is created as needed.
*/
unsigned fs_find_inbox (unsigned ownerid, const char *name, int noproc, string &msg)
{
	vector<string> dirs = {"msgs",name};
	vector<unsigned> listids = {0,(unsigned)-1};
	return fs_locate_dir (dirs,ownerid,true,msg,END_OF_TIME,true,noproc,&listids);
}
unsigned fs_find_project_inbox (unsigned ownerid, unsigned listid, const char *name, const char *project, const char *role, int noproc, string &msg)
{
	vector<string> dirs = {"msg-projects",name,project};
	if (role[0] != '\0') dirs.push_back(role);
	vector<unsigned> listids = {0,0,listid,listid};
	return fs_locate_dir (dirs,ownerid,true,msg,END_OF_TIME,true,noproc,&listids);
}
