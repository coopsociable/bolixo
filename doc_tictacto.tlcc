/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;

#include "proto/documentd_tictacto.protoh"
#include "proto/documentd_tictacto.protoch"

void TICTACTO::save(DOC_WRITER &w, bool)
{
	documentd_tictacto_header(&w,revision);
	documentd_tictacto_player(&w,x_is_player);
	unsigned row=0;
	for (auto &g:grid){
		documentd_tictacto_row(&w,row,g[0],g[1],g[2]);
		row++;
	}
}
<mod>
void TICTACTO::load(DOC_READER &r, string &msg)
{
	glocal x_is_player;
	glocal grid;
	glocal revision;
	glocal msg;
	<call documentd_tictacto>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f player>
		glocal.x_is_player = x_is_player;
	</f>
	<f row>
		if (rownum > 3){
			glocal.msg = string_f("Invalid row number for tictacto file: %u",rownum);
		}else{
			glocal.grid[rownum][0] = c1;
			glocal.grid[rownum][1] = c2;
			glocal.grid[rownum][2] = c3;
		}
	</f>
	<f invalid>
		glocal.msg = "Invalid format for tictacto file";
	</f>
	</call>
}
</mod>
void TICTACTO::resetgame()
{
	x_is_player = true;
	memset (grid,0,sizeof(grid));
}
TICTACTO::TICTACTO()
{
	resetgame();
}
const char *TICTACTO::getclass() const
{
	return "TICT";
}
void TICTACTO::testwin(vector<VARVAL> &res)
{
	bool won = false;
	for (auto g:grid){
		unsigned char v = g[0];
		if (v != 0){
			bool found = true;
			for (unsigned j=1; j<3; j++){
				if (v != g[j]){
					found = false;
					break;
				}
			}
			if (found){
				won = true;
				break;
			}
		}
	}
	if (!won){
		for (unsigned i=0; i<3; i++){
			unsigned char v = grid[0][i];
			if (v != 0){
				bool found = true;
				for (unsigned j=1; j<3; j++){
					if (v != grid[j][i]){
						found = false;
						break;
					}
				}
				if (found){
					won = true;
					break;
				}
			}
		}
		if (!won){
			if (grid[0][0] != 0
				&& grid[0][0] == grid[1][1]
				&& grid[0][0] == grid[2][2]){
				won = true;
			}else if (grid[0][2] != 0
				&& grid[0][2] == grid[1][1]
				&& grid[0][2] == grid[2][0]){
				won = true;
			}
		}
	}
	if (won){
		update_msg (true,MSG_U(I_WON,"Congratulation! You just won"),"blue",res);
	}
}
void TICTACTO::draw_x(unsigned cellx, unsigned celly, string &lines, unsigned x, unsigned y, unsigned len, bool visible)
{
	const char *color = visible ? "black" : "none";
	const unsigned off = len/4;
	x += off;
	y += off;
	len -= off*2;
	lines += string_f("<path class=x_o id=xl%u,%u stroke='%s' stroke-width='2' fill='%s' d='M%u,%u L%u %u'/>\n"
		,cellx,celly,visible ? "black" : "none",color,x,y,x+len,y+len);
	lines += string_f("<path class=x_o id=xr%u,%u stroke='%s' stroke-width='2' fill='%s' d='M%u,%u L%u %u'/>\n"
		,cellx,celly,color,color,x,y+len,x+len,y);
}
void TICTACTO::draw_o(unsigned cellx, unsigned celly, string &lines, unsigned x, unsigned y, unsigned len, bool visible)
{
	const char *color = visible ? "black" : "none";
	const unsigned off = len/4;
	x += off;
	y += off;
	len -= off*2;
	lines += string_f("<circle class=x_o id=c%u,%u stroke='%s' stroke-width='2' fill='none' cx='%u' cy='%u' r='%u'/>\n"
		,cellx,celly,color,x+len/2,y+len/2,len/2);
}
void TICTACTO::update_msg(
	bool to_all,	// The message will be shown to all player or not
	PARAM_STRING msg,
	const char *color,
	vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	js_find_set (mvar.val,"msg","style.color",color,"innerHTML",documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void TICTACTO::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	string error;
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	setactivity();
	if (strcmp(var,"print")==0){
		string lines;
		unsigned dim = sp.width < sp.height ? sp.width : sp.height;
		unsigned width = dim - dim % 4;
		//unsigned height = win_height - win_height % 3;
		unsigned w3 = width/4;
		unsigned h3 = w3;
		unsigned grid_width = w3*3;
		unsigned grid_height = grid_width;
		
		lines += "<script>\n";
		lines += "function gameplace(event){\n";
		lines += string_f("\tvar elm = document.getElementById('gamegrid-%s');\n",gameid.c_str());
		lines += "\tvar rect = elm.getBoundingClientRect();\n";
		lines += string_f("\tgameaction(event,'place:'+Math.floor((event.clientY-rect.top)/%u)+','+Math.floor((event.clientX-rect.left)/%u));\n",h3,w3);
		lines += "}\n";
		lines += "</script>\n";
		
		lines += string_f("<div id=tab_form style='margin-top:10px; margin-bottom:10px;'>\n");
		documentd_button_start(lines,gameid);
		documentd_button_label(lines,MSG_R(I_NEWGAME));
		documentd_button (lines,0,MSG_U(I_RESTART,"Restart"),false);
		documentd_button_end(lines);
		lines += "</div>\n";
		lines += "<div class=webtable id=doc_tictacto>\n";
		lines += string_f("<svg id=player-%s width='50px' height='200px' viewbox='0 0 50 200'>\n",gameid.c_str());
		draw_x (0,0,lines,0,0,50,true);
		draw_o (0,0,lines,0,100,50,true);
		lines += string_f("<path id=s0 stroke='%s' stroke-width='2' fill='none' d='M0,%u h50 v50 h-50 z'/>\n"
			,x_is_player ? "black" : "none",0);
		lines += string_f("<path id=s1 stroke='%s' stroke-width='2' fill='none' d='M0,%u h50 v50 h-50 z'/>\n"
			,!x_is_player ? "black" : "none",100);
		lines += "</svg>\n";
		lines += "&nbsp;&nbsp;&nbsp;";
		lines += string_f("<svg id='gamegrid-%s' onclick=gameplace(event) width='%upx' height='%upx' viewbox='0 0 %u %u'>\n"
			,gameid.c_str(),grid_width,grid_height,grid_width,grid_height);
		// Draw the board
		for (unsigned i=1; i<3; i++){
			lines += string_f("<path stroke='black' stroke-width='2' fill='black' d='M%u,1 L%u %u'/>\n"
				,i*w3,i*w3,grid_height);
			lines += string_f("<path stroke='black' stroke-width='2' fill='black' d='M1,%u L%u %u'/>\n"
				,i*h3,grid_width,i*h3);

		}
		// Draw the content
		for (unsigned x=0; x<3; x++){
			for (unsigned y=0; y<3; y++){
				unsigned val = grid[x][y];
				draw_x (x,y,lines,x*h3,y*h3,h3,val==1);
				draw_o (x,y,lines,x*h3,y*h3,h3,val==2);
			}
		}
		lines += "</svg>\n";
		lines += "</div>\n";
		lines += "<div id=tab_form>\n";
		lines += string_f("<div id=msg-%s style=color:white>XXXXXXXX</div>\n",gameid.c_str());
		lines += "</div>\n";
		VARVAL v;
		v.var = VAR_CONTENT;
		v.val = lines;
		res.push_back(v);
				
	}else if (maywrite){
		if (strcmp(var,"place")==0){
			bool ok = false;
			unsigned x=atoi(val);
			const char *pt = str_skipdig(val);
			const char *msg = "Invalid syntax";
			if (*pt == ','){
				pt++;
				unsigned y=atoi(pt);
				pt = str_skipdig(pt);
				if (*pt == '\0'){
					msg = "Invalid values";
					if (x < 3 && y < 3){
						unsigned char &g = grid[y][x];
						if (g == 0){
							g = x_is_player ? 1 : 2;
							js_find_loop_start_class(notify_var.val,"gamegrid","x_o");
							notify_var.val += "\t\tfor (var i=0; i<elms.length; i++){\n";
							notify_var.val += "\t\t\tvar e=elms[i];\n";
							if (x_is_player){
								string id1 = string_f("xl%u,%u",y,x);
								string id2= string_f("xr%u,%u",y,x);
								notify_var.val += string_f("\t\t\tif (e.id == '%s' || e.id == '%s'){\n",id1.c_str(),id2.c_str());
								notify_var.val += "\t\t\t\te.style.stroke='black';\n";
							}else{
								string id1 = string_f("c%u,%u",y,x);
								notify_var.val += string_f("\t\t\tif (e.id == '%s'){\n",id1.c_str());
								notify_var.val += "\t\t\t\te.style.stroke='black';\n";
							}
							notify_var.val += "\t\t\t}\n";
							notify_var.val += "\t\t}\n";
							js_find_loop_end(notify_var.val);
							x_is_player = !x_is_player;
							js_find_loop_set(notify_var.val,"player","path","s0","style.stroke",x_is_player ? "black" : "none");
							js_find_loop_set(notify_var.val,"player","path","s1","style.stroke",x_is_player ? "none" : "black");
							ok = true;
							setmodified(username);
							documentd_setchanges(res);
						}else{
							msg = "Location already played";
						}
					}
				}
			}
			if (!ok){
				documentd_error (res,string_f("Invalid command %s=%s: %s",var,val,msg));
			}
		}else if (strcmp(var,"newgame")==0 && maywrite){
			resetgame();
			setmodified(username);
			js_find_loop_start_class(notify_var.val,"gamegrid","x_o");
			notify_var.val += "\t\tfor (var i=0; i<elms.length; i++){\n";
			notify_var.val += "\t\t\tvar e=elms[i];\n";
			notify_var.val += "\t\t\te.style.stroke='none';\n";
			notify_var.val += "\t\t\te.style.fill='none';\n";
			notify_var.val += "\t\t}\n";
			js_find_loop_end(notify_var.val);
			js_find_loop_set(notify_var.val,"player","path","s0","style.stroke","black");
			js_find_loop_set(notify_var.val,"player","path","s1","style.stroke","none");
			documentd_setchanges(res);
		}
		//documentd_forcerefresh(res);
	}else{
		error = MSG_R(E_READONLY);
	}
	if (notify_var.val.size() > 0) res.emplace_back(notify_var);
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else{
		update_msg(false,"","white",res);
	}
}

