Megage sur serveur
	Network-Manager disable tunnel lxc
	Enleve sssd

Un utilisateur a une page d'accueil et un fil de nouvelles et de photos.

A faire
=======

On peut créer des utilisateurs externes dans la base de données. Ces utilisateurs
n'ont pas de mot de passe (NULL). Mais ils ont un userid standard. Donc ils peuvent
faire partie de groupe comme n'importe quel autre. Voici des exemples
	bo:usager@node2.bolixo.org
	mail:quelquun@gmail.com
Donc on peut avoir des relations (amis) qui ne sont pas dans bolixo.

Courriel:
	On peut accepter des courriels si l'utilisateur est dans une de
	nos liste. Ou non.


	On voit les boites de courriels associées à nos projets
	et amis. Mais nous avons aussi un vue globale où
	tous les messages sont visibles. Ça évite de visiter
	tous nos projets un après l'autre.

Agenda:
	On peut inviter une liste, un groupe, un role ou une personne
	a un évènement. Ce n'est pas explosé. Si on ajoute quelqu'un à un
	groupe, il recevra l'invitation.

tâche:
	Est-ce qu'on peut gérer cela comme les alarmes qu'on assigne
	à un document ?

Lorsqu'un paragraphe d'un message termine avec un point d'interrogation, alors
la réponse à ce message est automatiquement formattée pour qu'une réponse soit fournie.

Il y a des groupes définis par l'administrateur. Il peut en définir plusieurs qui
correspondent alors aux différents départements de l'organisation. Ces groupes ont
des noms qui ne peuvent pas entrer en conflit avec les groupes définis par l'utilisateur.
Genre, ils commencent pas un #. Et le # serait interdit dans les groupes d'utilisateurs.

FAIT: Un message est un fichier dont le nom est son uuid. Il y aura une fonction sendmsg qui
      retournera entre le uuid. Les réponses et attachements iront dans uuid.dir.

FAIT: Comment savoir les messages qui doivent être affichés dans la boite de réception d'un
      utilisateur. Il faut résoudre ce qui doit être fait lorsqu'un message est
      envoyé à
	-Un utilisateur
	-Un rôle
	-Un projet
	-Un fichier Voir Alarmes

Alarmes: Message associé à une action sur un fichier ou répertoire.

FAIT: Non ce n'est pas ce qu'on a fait. Le message n'est pas dupliqué.
	La boite de reception est un répertoire normal. Lorsqu'on envoie un message à un projet, il
	est copié (le lien dans dirs_content) à tous les membres du projet. Ils peuvent alors effacer le
	message de leur boite de réception, le marqué comme lue, etc... Donc il y a un processus
	de copiage. Mais on peut toujours consulter la boite de message d'un projet.
	>>>NON. La seule boite de réception qui contient des messages et le inbox personnel de l'utilisateur.
	Les autres pointent à des espaces partagés. À l'aide d'une table marks, l'utilisateur peut
	indiquer si il a lu un message ou pas.

FAIT: Ajouter un identifiant unique à la table dirs_content. Cela permettra de trier de façon
      précise en utilisant l'identifiant au lieu de la date de modification d'un document.
      Ajout de eventtime plutôt qu'un identifiant unique. C'est cela qui est utilisé comme
      threshold.

markview: Permet d'annoter si un document a été vue par un utilisateur. Ça pourrait ajouter
	une ligne dans dirs_content avec type='V'.

Une sequence de discussion possède une conclusion que le gestionnaire de projet met à jour.

Un site central permet d'avoir un annuaire de tous les sites. Ainsi on peut trouver quelqu'un sur
une node. Chaque node est libre de publier dans l'annuaire ou non. Ça donne un lieu central
pour trouver quelqu'un.

FAIT: Un groupe peut contenir des utilisateurs, mais aussi des rôles.
FAIT: Sécurité de readmore et appendfile. On doit valider le sessionid. On pourrait tout simplement
	encodé le sessionid dans la table de handle. On verifie que le sessionid est valide
	et ensuite on s'assure que ce handle lui est associé.

FAIT: bofs. Un utilitaire pour faire des cat,cp,rm,mkdir,rmdir,mv
FAIT: copydir. Chaque répertoire et sous répertoire devra être répliqué.
FAIT: rename
FAIT: copy (uniquement pour les fichiers)

A faire sécurité
================

Valider la robustesse du protocole de sérialisation.
	Terminer les séquences incomplètes après 5 secondes.
	Faire un programme de test qui envoie n'importe quoi.

bolixo:
======

Le principe de bolixo, c'est qu'un message/document peut apparaitre à plusieurs place
dans une hiérarchie de document, comme les liens symboliques. Mais en plus, on peut trouver
d'ou un document provient. On a la relation inverse.

Pour l'instant, il est très facile de trouver quels répertoires référencent un fichier parce
qu'ils ont tous fileid. On peut ensuite retrouver le parent de chaque répertoire jusqu'à la racine.
Ce n'est pas très rapide, mais ce n'est pas quelque chose qui arrivera souvent.

projets:
=======

Il a des projets. Les gens peuvent s'abonner au projets.
	Ou aussi directement a la personne.

Un projet est transférable.

On peut envoyer un message a un projet. L'historique est conservé dans le projet. Les membres
du projet recoivent une copie. Dans le monde bolixo, ils reçoivent un lien.

Un projet a des règles de sécurité. Tout message envoyé au projet reste dans le privé ou on peut
faire un 'spin' sur le message et le propager plus loin.

Est-ce qu'il y a des sous-projets. Les gens utilisent les réseaux sociaux pour s'organiser. Ils pourraient
créer l'organigramme du projet avec les sous-groupes.

spin:
=====

Un spin re-publie le message ou le document. Les gens abonnés à la personne recevront le spin.

Ou encore, si le message provient d'un sous-projet, il est transmis plus haut, dont à tous les membres du
projet.

un-spin. Un utilisateur peut faire un un-spin. C'est un moyen poli de dire que ce message n'est pas apprécié.
Il est alors possible d'attacher un message à cet action (une explication) ou encore un message déjà fait. Le unspin
revient à celui qui a fait la spin. C'est privé. Donc le unspin n'est pas un broadcast négatif.

Évènement:
=========

On peut envoyer un message à un évènement.
	Quand quelqu'un consulte un document, le modifie ou le distribue.

	Quand on clique sur un fichier, on peut envoyer un message
		-déclenché par un certain évènement du fichier (accédé, lue, effacé)
		-au propriétaire du fichier
		-à la personne présentement propriétaire.

Pair a pair:
============

Chaque document possède une signature permettant de savoir d'où il vient.

Lorsqu'un document est transmis (spin), on envoie une copie aux pairs avec une date
d'expiration. Le pairs pourra utiliser la copie au début et pourra ensuite la purger et
conserver uniquement l'hyperlien. Donc si un document devient viral, la charge
sera distribuée. Après quelques jours, le serveur qui l'a produit sera capable de prendre la charge.

Comment savoir à qui envoyer le document. On le sait par les relations amis. Ce n'est pas un
broadcast.

Code utilisateur
================

Le code est un identifiant choisi par l'utilisateur. C'est comme un courriel. usager@serveurX.

L'utilisateur et l'administrateur pourront choisir si ils acceptent des messages de l'extérieur ou pas
(courriels).

Messages
========


Tout message possède 2 signatures. Une identifiant le serveur d'origine et l'autre l'utilisateur. L'utilisateur
pourra gèrer lui même sa clé d'identification. À l'aide d'un client, il pourra composer les messages et seul
lui pourra signer ce message. Cela évite les faux messages (vol d'identité).

Il faut que la signature deviennent simple à utiliser et valider, contrairement à aujourd'hui avec les courriels
(personne n'utilise PGP ou très peu).

TLMP
====
