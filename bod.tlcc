/*
	Main server for the project. Hides database logic and controls security/access
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syslog.h>
#include <signal.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <memory>
#include <trlitool.h>
#include <tlmpsql.h>
#include "filesystem.h"
#include <openssl/bn.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/bio.h>
#include <openssl/x509.h>
#include "bolixo.h"


static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_ADMIN };

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	int no;
	std::string host;
	REQUEST_INFO req;
	std::string userid;
	HANDLE_INFO(){
		no = -1;
		type = TYPE_NONE;
	}
};
struct DIRENTRY{
	std::string eventdate;
	std::string modified;
	std::string viewed;
	ENTRY_TYPE type;
	FILE_TYPE file_type;
	std::string owner;
	std::string members;
	std::string listmode;
	std::string title;
	unsigned size;
	bool islarge;
	DIRENTRY (const char *_eventdate, const char *_modified, ENTRY_TYPE _type, FILE_TYPE _file_type, bool _islarge, const char *_owner,
		const char *_members, const char *_listmode, unsigned _size, const char *_title, const char *_viewed){
		eventdate = _eventdate;
		modified = _modified;
		type = _type;
		islarge = _islarge;
		file_type = _file_type;
		owner = _owner;
		members = _members;
		listmode = _listmode;
		size = _size;
		title = _title;
		viewed = _viewed;
	}
	DIRENTRY(){
		type = ENTRY_DELETED;
		size = 0;
	}
};

#include "proto/bod_control.protoh"
#include "proto/bod_client.protoh"
#include "proto/bod_admin.protoh"

using namespace std;


#include "proto/bo-writed_client.protoch"
#define bo_sessiond_client_getsessioninfovars_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#include "proto/bo-sessiond_client.protoch"

/*
	Get the userid associated with the sessionid
*/
<mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin, string &name)
{
	glocal unsigned userid = 0;
	glocal bool is_admin = false;
	glocal string *name = &name;
	//long long start = fdpass_getnow();
	//for (int i=0; i<10000; i++){
	<call bo_sessiond_client_getsessioninfo>(con,sessionid);
	<f ok>
		glocal.userid = userid;
		glocal.is_admin = admin;
		(*glocal.name) = name;
	</f>
	</call>
	//}
	//long long end = fdpass_getnow();
	//printf ("exec time = %lf\n",(end-start)/1000000.0);
	is_admin = glocal.is_admin;
	return glocal.userid;
}
</mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin)
{
	string username;
	return trli_getsessionuser (con,sessionid,is_admin,username);
}
static int bod_findentry (CONNECT_INFO &con, const char *sessionid, PARAM_STRING name, ENTRY &entry, const char *threshold)
{
	int ret = -1;
	entry.userid = trli_getsessionuser(con,sessionid,entry.is_admin);
	if (entry.userid == 0){
		entry.msg = "Invalid session";
	}else{
		ret = fs_findentry(name,entry,true,threshold);
	}
	return ret;
}
/*
	Identify the userid who will perform some group administration.
	Normally, user are only allowed to work on list they own.
	But administrator can work on behalf of another user. The parameter "owner" is the other user.
	For normal user, this parameter is ignored.

	Return 0 if not a valid userid (sessionid is invalid)
*/
<mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &username, string &msg)
{
	bool is_admin;
	glocal unsigned userid = trli_getsessionuser (con,sessionid,is_admin,username);
	if (is_admin && owner[0] != '\0'){
		<call sql_query>("select userid from id2name where name='%s'",owner);
		<f onerow>
			glocal.userid = atoi(row[0]);
		</f>
		<f empty>
			glocal.userid = 0;
		</f>
		</call>
		username = owner;
		if (glocal.userid == 0) msg = "Unknown owner";
	}
	return glocal.userid;
}
</mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &msg)
{
	string username;
	return bo_writed_get_group_owner (con,sessionid,owner,username,msg);
}
/*
	Keeps only a slice of the vector
*/
template<class T> static void bod_trim (vector<T> &tb, unsigned offset, unsigned nb)
{
	if (offset >= tb.size()){
		tb.clear();
	}else if (offset + nb >= tb.size()){
		tb.erase (tb.begin(),tb.begin()+offset);
	}else{
		if (offset > 0){
			tb.erase (tb.begin(),tb.begin()+offset);
		}
		if (nb < tb.size()){
			tb.erase (tb.begin()+nb,tb.end());
		}
	}
}
namespace {
	struct BIOFreeAll { void operator()(BIO* p) { BIO_free_all(p); } };
}
// Assumes no newlines or extra characters in encoded string
std::vector<unsigned char> Base64Decode(const char* encoded)
{
	std::unique_ptr<BIO,BIOFreeAll> b64(BIO_new(BIO_f_base64()));
	BIO_set_flags(b64.get(), BIO_FLAGS_BASE64_NO_NL);
	BIO* source = BIO_new_mem_buf(encoded, -1); // read-only source
	BIO_push(b64.get(), source);
	const int maxlen = strlen(encoded) / 4 * 3 + 1;
	std::vector<unsigned char> decoded(maxlen);
	const int len = BIO_read(b64.get(), decoded.data(), maxlen);
	decoded.resize(len);
	return decoded;
}
static int bod_verify( 
	PARAM_STRING msg,
	EVP_PKEY *key,
	PARAM_STRING sig64)
{
	int ret = -1;
	int len=strlen(sig64.ptr);
	if (len < 2000){
		/* Initialize `key` with a public key */
		char sig64_clean[len+1];
		char *dst = sig64_clean;
		const char *pt = sig64.ptr;
		while (*pt != '\0'){
			char car = *pt++;
			if (car > ' ') *dst++ = car;
		}
		*dst = '\0';
		vector<unsigned char> sig = Base64Decode(sig64_clean);
		EVP_MD_CTX *mdctx = EVP_MD_CTX_create();
		if (mdctx != NULL){
			if(EVP_DigestVerifyInit(mdctx, NULL, EVP_sha256(), NULL, key) == 1){
				// Initialize `key` with a public key
				if(EVP_DigestVerifyUpdate(mdctx, msg.ptr, strlen(msg.ptr)) == 1){
					if(EVP_DigestVerifyFinal(mdctx, sig.data(), sig.size()) == 1){
						// Success
						ret = 0;
					}else{
						// Failure
					}
				}
			}
			EVP_MD_CTX_destroy(mdctx);
		}
	}
	return ret;
}
static EVP_PKEY *bod_load_public (PARAM_STRING p)
{
	BIO *bio = BIO_new_mem_buf((void*)p.ptr, strlen(p.ptr));
	EVP_PKEY *pkey = PEM_read_bio_PUBKEY(bio, NULL,NULL,NULL);
	BIO_free_all (bio);
	return pkey;
}
/*
	Check that public access is enable for one account.
	Translate the relative_path into absolute path by using the username and the public_dir
	Return the user id.
	Return -1 if any problem.
*/
<mod>
static int bod_checkpublic(const char *username, const char *relative_path, string &msg, string &abspath)
{
	glocal string *msg = &msg;
	glocal string public_dir;
	glocal int ret = -1;
	<call sql_query>("select public_view,public_dir,id2name.userid from id2name"
		" join config on config.userid=id2name.userid"
		" where id2name.name='%s'",username);
	<f empty>
		(*glocal.msg) = "no user";
	</f>
	<f onerow>
		bool public_view = atoi(row[0]);
		if (!public_view){
			(*glocal.msg) = "no public data available";
		}else{
			glocal.public_dir = row[1];
			glocal.ret = atoi(row[2]);
		}
	</f>
	</call>
	if (glocal.ret != -1){
		abspath = string_f("/projects/%s/public/%s",username,glocal.public_dir.c_str());
		if (strcmp(relative_path,"/") !=0){
			if (relative_path[0] == '/'){
				abspath += relative_path;
			}else{
				abspath += string_f ("/%s",relative_path);
			}
		}
	}
	return glocal.ret;
}
</mod>
<mod>
static int trlid_main (
	const char *bind,
	const char *portstr,
	const char *control,	// Unix socket
	const CONNECT_INFO &con,
	const CONNECT_INFO &con_sess,
	const char *user,
	const char *pidfile,
	bool daemon,
	const map<string,string> &admin_secrets,
	const map<string,string> &client_secrets)
{
	int ret = -1;
	glocal CONNECT_INFO con = con;
	glocal CONNECT_INFO con_sess = con_sess;
	glocal const map<string,string> *admin_secrets = &admin_secrets;
	glocal const map<string,string> *client_secrets = &client_secrets;
	glocal unsigned long nbrequest_client = 0;
	glocal unsigned long nbrequest_admin = 0;
	glocal string unixportclient = string_f("unix:/tmp/bod-client-%s.sock",portstr);
	glocal string unixportadmin = string_f("unix:/tmp/bod-admin-%s.sock",portstr);
	<obj TCPSERVER s>(bind,glocal.unixportclient,5);
	<f newclient>
		HANDLE_INFO *n = new HANDLE_INFO;
		info.data = n;
		if (strcmp(info.port,glocal.unixportclient.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				tlmp_error ("Rejected client connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strcmp(info.port,glocal.unixportadmin.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.admin_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_ADMIN;
			}else{
				tlmp_error ("Rejected admin connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strncmp(info.port,"unix:",5)==0){
			n->type = TYPE_CONTROL;
		}else{
			settcpnodelay(true);
			char addr[20];
			ipnum_ip2a (from,addr);
			n->host = addr;
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,addr);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				n->req.secret = fdpass_findsecret (*glocal.admin_secrets,addr);
				if (n->req.secret.size() > 0){
					n->type = TYPE_ADMIN;
				}else{
					tlmp_error ("Rejected connexion from IP %s\n",addr);
					endclient = true;
				}
			}
		}
	</f>
	<f endclient>
	</f>
	<f receive>
		HANDLE_INFO *c = (HANDLE_INFO*)info.data;
		glocal HANDLE_INFO *c = c;
		glocal string userid = c->userid;
		debug_printf (D_PROTO,"receive line[%d]: %s\n",info.linelen,line);
		if (c->type == TYPE_CONTROL){
			<call bod_control>(this,c->req,line,info.linelen, endserver, endclient, no,c,c->host.c_str());
			<f status>
				vector<string> tb;
				tb.push_back(string_f("Version %s",VERSION));
				tb.push_back(string_f ("nbrequest_admin=%lu",glocal.nbrequest_admin));
				tb.push_back(string_f ("nbrequest_client=%lu",glocal.nbrequest_client));
				rep_status(tb);
			</f>
			<f quit>
				endserver = true;
			</f>
			<f debug>
				if (on){
					debug_seton();
				}else{
					debug_setoff();
				}
			</f>
			<f debugfile>
				debug_setfdebug (filename);
			</f>
			<f invalid>
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_CLIENT){
			glocal.nbrequest_client++;
			<call bod_client>(this,c->req,line,info.linelen, endserver, endclient,no,c,c->host.c_str());
			<f createsession>
				<call bo_writed_client_createsession>(glocal.con);
				<f ok>
					glocal.bod_client.rep_createsession(sessionid);
				</f>
				</call>
			</f>
			<f login>
				<call bo_writed_client_login>(glocal.con,sessionid,email,password);
				<f ok>
					glocal.bod_client.rep_login(success);
				</f>
				</call>
			</f>
			<f logout>
				<call bo_writed_client_logout>(glocal.con,sessionid);
				<f ok>
				</f>
				</call>
			</f>
			<f adduser>
				<call bo_writed_client_adduser>(glocal.con,name,email,password);
				<f ok>
					glocal.bod_client.rep_adduser (confirmid,msg);
				</f>
				</call>
			</f>
			<f confirmuser>
				<call bo_writed_client_confirmuser>(glocal.con,id);
				<f ok>
					glocal.bod_client.rep_confirmuser(success,msg);
				</f>
				</call>
			</f>
			<f deleteuser>
				<call bo_writed_client_deleteuser>(glocal.con,sessionid);
				<f ok>
					glocal.bod_client.rep_deleteuser (email,confirmid);
				</f>
				</call>
			</f>
			<f confirmdelete>
				<call bo_writed_client_confirmdelete>(glocal.con,confirmid);
				<f ok>
					glocal.bod_client.rep_confirmdelete(success,msg);
				</f>
				</call>
			</f>
			<f mkdir> // sessionid name = success:b dirid msg
				<call bo_writed_client_mkdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_mkdir(success,msg);
				</f>
				</call>
			</f>
			<f rmdir> // sessionid name = success:b msg
				<call bo_writed_client_rmdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_rmdir(success,msg);
				</f>
				</call>
			</f>
			<f addfile> // sessionid name content = success:b fileid msg
				<call bo_writed_client_addfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_addfile(success,msg);
				</f>
				</call>
			</f>
			<f addfile_bob> // sessionid name content:o more:b = success:b fileid msg
				debug_printf ("bob size=%lu\n",content.getsize());
				<call bo_writed_client_addfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_addfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f appendfile> // sessionid fileid content:o more:b = success:b msg
				<call bo_writed_client_appendfile>(glocal.con,sessionid,handle,content,more);
				<f ok>
					glocal.bod_client.rep_appendfile(success,msg);
				</f>
				</call>
			</f>
			<f delfile> // sessionid name = success:b msg
				<call bo_writed_client_delfile>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_delfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile> // sessionid name content = success:b msg
				<call bo_writed_client_modifyfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_modifyfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile_bob> // sessionid name content:o more:b = success:b handle msg
				<call bo_writed_client_modifyfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_modifyfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f rename> // sessionid oldname newname = success:b msg
				// Rename file, directory or symlink
				<call bo_writed_client_rename>(glocal.con,sessionid,oldname,newname);
				<f ok>
					glocal.bod_client.rep_rename(success,msg);
				</f>
				</call>
			</f>
			<f copy> // sessionid srcname srcname = success:b msg
				// Copy file, directory or symlink
				<call bo_writed_client_copy>(glocal.con,sessionid,srcname,dstname);
				<f ok>
					glocal.bod_client.rep_copy(success,msg);
				</f>
				</call>
			</f>
			<f readfile> // sessionid name = success:b msg content
				ENTRY entry;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)==-1){
					rep_readfile (false,entry.msg,"");
				}else{
					if (!bolixo_isfile(entry.type)){
						rep_readfile (false,"Entry is not a file","");
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,entry.entryid,entry.modified.c_str());
						<f onerow>
							if (row[0] != NULL){
								glocal.bod_client.rep_readfile (true,"",row[0]);
							}else{
								glocal.bod_client.rep_readfile (false,"Internal error, must use readfile_bob for large content","");
							}
						</f>
						<f empty>
							glocal.bod_client.rep_readfile (false,"Internal error, reading table files","");
						</f>
						</call>
					}
				}
			</f>
			<f readfile_bob> // sessionid name = success:b msg content:o handle more:b
				glocal ENTRY entry;
				glocal const char *sessionid = sessionid;
				BOB_TYPE empty;
				if (bod_findentry (glocal.con_sess,sessionid,name,glocal.entry,threshold)==-1){
					rep_readfile_bob (false,glocal.entry.msg,empty,"",false,0);
				}else{
					if (!bolixo_isfile(glocal.entry.type)){
						rep_readfile_bob (false,"Entry is not a file",empty,"",false,0);
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,glocal.entry.entryid,glocal.entry.modified.c_str());
						<f onerow>
							if (row[0] != NULL){
								unsigned len = strlen(row[0]);
								BOB_TYPE bob (row[0],len,false);
								glocal.bod_client.rep_readfile_bob (true,"",bob,"",false,len);
							}else{
								string handle;
								FILE *fin = fs_alloc_file_handle (glocal.entry.entryid,glocal.entry.modified,"r",handle,glocal.sessionid);
								if (fin == NULL){
									glocal.bod_client.rep_readfile_bob (false,"Internal error, reading content file"
										,BOB_TYPE(),"",false,0);
									fs_delete_handle (handle);
								}else{
									struct stat64 st;
									if (fstat64(fileno(fin),&st)==-1){
										glocal.bod_client.rep_readfile_bob (false,"Internal error, getting file size"
											,BOB_TYPE(),"",false,0);
										fs_delete_handle (handle);
									}else{
										char buf[50000];
										int len = fread (buf,1,50000,fin);
										BOB_TYPE bob (buf,len,false);
										bool more = len==50000;
										if (!more){
											fs_delete_handle(handle);
											handle.clear();
										}
										glocal.bod_client.rep_readfile_bob (true,"Ok"
											,bob,handle,more,st.st_size);
									}
								}
							}
						</f>
						<f empty>
							glocal.bod_client.rep_readfile_bob (false,"Internal error, reading table files"
								,BOB_TYPE(),"",false,0);
						</f>
						</call>
					}
				}
			</f>
			<f readmore>	// sessionid handle = success:b msg content:o more:b
				bool is_admin;
				if (trli_getsessionuser(glocal.con_sess,sessionid,is_admin)==0){
					rep_readmore (false,"Invalid session",BOB_TYPE(),false);
				}else{
					FILE *fin = fs_get_file (handle,sessionid);
					if (fin == NULL){
						rep_readmore (false,"Internal error, reading content file",BOB_TYPE(),false);
						fs_delete_handle (handle);
					}else{
						char buf[50000];
						int len = fread (buf,1,50000,fin);
						BOB_TYPE bob (buf,len,false);
						bool more = len == 50000;
						rep_readmore (true,"Ok",bob,more);
						if (!more){
							fs_delete_handle(handle);
						}
					}
				}
			</f>
			<f set_access>	//  sessionid name username listname = success:b msg
				<call bo_writed_client_set_access>(glocal.con,sessionid,name,username,listname,listmode);
				<f ok>
					glocal.bod_client.rep_set_access (success,msg);
				</f>
				</call>
			</f>
			<f markview> // sessionid name = success:b msg
				<call bo_writed_client_markview>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_set_access(success,msg);
				</f>
				</call>
			</f>
			<f stat> // sessionid name threshold = success:b msg file:U{FILEINFO}
				glocal FILEINFO file;
				glocal ENTRY entry;
				if (bod_findentry (glocal.con_sess,sessionid,name,glocal.entry,threshold)!=-1){
					if (threshold[0] == '\0') threshold = END_OF_TIME;
					<call sql_query>("select dirs_content.name,dirs_content.modified,type,id2name.name"
						",group_list_id,group_lists.name,ids.listmode"
						",length(files.content),dirs_content.itemid,files.title,dirs_content.eventtime"
						",files.filetype"
						" from dirs_content"
						" join ids on dirs_content.itemid=ids.id"
						" join id2name on ids.ownerid=id2name.userid"
						" left join group_lists on ids.group_list_id=group_lists.id"
						" left join files on dirs_content.itemid=files.id and dirs_content.modified=files.modified"
						" where dirid=%d and dirs_content.name='%s' and dirs_content.eventtime <= '%s' order by eventtime desc limit 1"
						,glocal.entry.dirid,glocal.entry.basename.c_str(),threshold);
					<f onerow>
						const char *name = row[0];
						const char *modified = row[1];
						ENTRY_TYPE type = (ENTRY_TYPE) atoi(row[2]);
						const char *owner = row[3];
						const char *listid = row[4];
						const char *listname = row[5];
						const char *listmode = row[6] != NULL ? row[6] : "";
						if (listname == NULL){
							listname = "";
							if (listid != NULL){
								if (strcmp(listid,"0")==0){
									listname = ALL_MAY_READ;
								}
							}
						}
						unsigned size=0;
						if (row[7] != NULL){
							size = atoi(row[7]);
						}else if (bolixo_isfile(type)){
							// Content stored as a file
							size = fs_get_filesize(atoi(row[8]),modified);
						}
						const char *title = row[9] == NULL ? "" : row[9];
						const char *eventdate = row[10];
						FILE_TYPE file_type = row[11] == NULL ? FILE_UNKNOWN : (FILE_TYPE)atoi(row[11]);
						if (!bolixo_isdeleted(type)){
							glocal.file.name = name;
							glocal.file.modified = modified;
							glocal.file.type = type;
							glocal.file.owner = owner;
							glocal.file.listname = listname;
							glocal.file.listmode = listmode;
							glocal.file.size = size;
							glocal.file.title = title;
							glocal.file.eventdate = eventdate;
							glocal.file.file_type = file_type;
							glocal.file.viewed = "not done";
							glocal.entry.msg = "";
						}
					</f>
					</call>
				}
				if (glocal.entry.msg.size() > 0){
					glocal.file.clear();
					rep_stat (false,glocal.entry.msg,glocal.file);
				}else{
					rep_stat (true,"",glocal.file);
				}
			</f>
			<f listdir>
				ENTRY entry;
				glocal vector<FILEINFO> files;
				glocal map<string,DIRENTRY> mp;
				glocal bool history = history;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)!=-1){
					if (!bolixo_isdir(entry.type)){
						entry.msg = "Is not a directory";
					}else if (entry.ownerid != entry.userid && entry.listmode == 'p' && !entry.is_admin){
						entry.msg = "Not allowed to list";
					}else{
						if (threshold[0] == '\0') threshold = END_OF_TIME;
						<call sql_query>("select dirs_content.name,dirs_content.modified,type,id2name.name"
							",group_list_id,group_lists.name,ids.listmode"
							",length(files.content),dirs_content.itemid,files.title,dirs_content.eventtime"
							",files.filetype,files.content is null"
							" from dirs_content"
							" join ids on dirs_content.itemid=ids.id"
							" join id2name on ids.ownerid=id2name.userid"
							" left join group_lists on ids.group_list_id=group_lists.id"
							" left join files on dirs_content.itemid=files.id and dirs_content.modified=files.modified"
							" where dirid=%d and dirs_content.eventtime <= '%s' order by eventtime"
							,entry.entryid,threshold);
						<f onerow>
							const char *name = row[0];
							const char *modified = row[1];
							ENTRY_TYPE type = (ENTRY_TYPE) atoi(row[2]);
							const char *owner = row[3];
							const char *listid = row[4];
							const char *listname = row[5];
							const char *listmode = row[6] != NULL ? row[6] : "";
							if (listname == NULL){
								listname = "";
								if (listid != NULL){
									if (strcmp(listid,"0")==0){
										listname = ALL_MAY_READ;
									}
								}
							}
							unsigned size=0;
							if (row[7] != NULL){
								size = atoi(row[7]);
							}else if (bolixo_isfile(type)){
								// Content stored as a file
								size = fs_get_filesize(atoi(row[8]),modified);
							}
							const char *title = row[9] == NULL ? "" : row[9];
							const char *eventdate = row[10];
							FILE_TYPE file_type = row[11] == NULL ? FILE_UNKNOWN : (FILE_TYPE)atoi(row[11]);
							bool islarge = atoi(row[12])!=0;
							if (glocal.history){
								FILEINFO info;
								info.name = name;
								info.eventdate = eventdate;
								info.modified = modified;
								info.type = type;
								info.file_type = file_type;
								info.owner = owner;
								info.listname = listname;
								info.listmode = listmode;
								info.size = size;
								info.title = title;
								info.viewed = "not done";
								info.islarge = islarge;
								glocal.files.push_back(info);
							}else{
								glocal.mp[name] = DIRENTRY(eventdate,modified,type,file_type,islarge,owner,listname,listmode,size,title,"not done");
							}
						</f>
						</call>
						if (!glocal.history){
							for (auto &x:glocal.mp){
								if (!bolixo_isdeleted(x.second.type)){
									FILEINFO info;
									info.name = x.first;
									info.type = x.second.type;
									info.file_type = x.second.file_type;
									info.eventdate = x.second.eventdate;
									info.modified = x.second.modified;
									info.owner = x.second.owner;
									info.listname = x.second.members;
									info.listmode = x.second.listmode;
									info.size = x.second.size;
									info.title = x.second.title;
									info.viewed = x.second.viewed;
									info.islarge = x.second.islarge;
									glocal.files.push_back(info);
								}
							}
						}
					}
				}
				if (entry.msg.size() > 0){
					glocal.files.clear();
					rep_listdir (false,entry.msg,glocal.files);
				}else{
					bod_trim (glocal.files,offset,nb);
					rep_listdir (true,"",glocal.files);
				}
			</f>
			<f create_project_dir> // sessionid listname owner = success:b msg
				<call bo_writed_client_create_project_dir>(glocal.con,sessionid,listname,owner);
				<f ok>
					glocal.bod_client.rep_create_project_dir(success,msg);
				</f>
				</call>
			</f>
			<f create_group_list> // sessionid listname owner = success:b msg
				<call bo_writed_client_create_group_list>(glocal.con,sessionid,listname,owner);
				<f ok>
					glocal.bod_client.rep_create_group_list(success,msg);
				</f>
				</call>
			</f>
			<f create_group> // sessionid groupname owner = success:b msg
				<call bo_writed_client_create_group>(glocal.con,sessionid,groupname,owner);
				<f ok>
					glocal.bod_client.rep_create_group(success,msg);
				</f>
				</call>
			</f>
			<f set_group>	// sessionid listname groupname defaultaccess owner = success:b msg
				<call bo_writed_client_set_group>(glocal.con,sessionid,listname,groupname,defaultaccess,owner);
				<f ok>
					glocal.bod_client.rep_set_group(success,msg);
				</f>
				</call>
			</f>
			<f set_member>	// sessionid groupname user defaultaccess owner = success:b msg
				<call bo_writed_client_set_member>(glocal.con,sessionid,groupname,user,access,role,owner);
				<f ok>
					glocal.bod_client.rep_set_member(success,msg);
				</f>
				</call>
			</f>
			<f set_list_desc>	// sessionid listname description owner = success:b msg
				<call bo_writed_client_set_list_desc>(glocal.con,sessionid,listname,description,owner);
				<f ok>
					glocal.bod_client.rep_set_list_desc (success,msg);
				</f>
				</call>
			</f>
			<f set_group_desc>	// sessionid groupname description owner = success:b msg
				<call bo_writed_client_set_group_desc>(glocal.con,sessionid,groupname,description,owner);
				<f ok>
					glocal.bod_client.rep_set_group_desc (success,msg);
				</f>
				</call>
			</f>
			<f delete_list>	// sessionid listname owner = success:b msg
				<call bo_writed_client_delete_list>(glocal.con,sessionid,listname,owner);
				<f ok>
					glocal.bod_client.rep_delete_list(success,msg);
				</f>
				</call>
			</f>
			<f delete_group> // sessionid groupname owner = success:b msg
				<call bo_writed_client_delete_group>(glocal.con,sessionid,groupname,owner);
				<f ok>
					glocal.bod_client.rep_delete_group(success,msg);
				</f>
				</call>
			</f>
			<f list_lists>	//  sessionid owner = success:b msg lists:v groups:vv access:v
				glocal string msg = "Invalid session";
				glocal vector<LIST> lists;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal string last_list;
					<call sql_query>("select group_lists.name,group_lists.description,groups.name,group_list_members.defaultaccess"
						" from group_lists"
						" left join group_list_members on group_lists.id=group_list_members.group_list_id"
						" left join groups on group_list_members.groupid=groups.id"
						" where group_lists.ownerid=%u order by group_lists.name,groups.name",userid);
					<f onerow>
						if (strcmp(glocal.last_list.c_str(),row[0])!=0){
							glocal.last_list = row[0];
							LIST l;
							l.name = row[0];
							l.description = row[1];
							glocal.lists.push_back(l);
						}
						if (row[1] != NULL && row[2] != NULL){
							LIST &l = glocal.lists[glocal.lists.size()-1];
							l.groups.push_back(row[2]);
							l.access.push_back(row[3]);
						}
						glocal.msg = "";
					</f>
					<f empty>
						glocal.msg = "No list";
					</f>
					</call>
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.lists.clear();
				}
				rep_list_lists (ret,glocal.msg,glocal.lists);
			</f>
			<f list_groups>	// sessionid owner only_onwer:b = success:b msg groups:v users:vv access:vv
				// List either all groups own by the logged user
				// or all groups it belongs to
				glocal string msg = "Invalid session";
				glocal vector<GROUP> groups;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal unsigned last_group_id = (unsigned)-1;
					string sql = "select groups.id,groups.name,id2.name,id2name.name,group_members.access,group_members.role,groups.description"
						" from groups"
						" left join group_members on groups.id=group_members.groupid"
						" left join id2name on group_members.userid=id2name.userid"
						" left join id2name id2 on groups.ownerid=id2.userid"
						" where ";
					if (only_owner){
						sql += "groups.ownerid=%u";
					}else{
						sql += "groups.id in (select groupid from group_members where userid=%u)";
					}
					sql += " order by id2.name,groups.name,id2name.name";
					<call sql_query>(sql.c_str(),userid);
					<f onerow>
						unsigned group_id = atoi(row[0]);
						if (glocal.last_group_id != group_id){
							glocal.last_group_id = group_id;
							GROUP group;
							group.name = row[1];
							group.owner = row[2];
							group.description = row[6];
							glocal.groups.push_back(group);
						}
						if (row[3] != NULL && row[4] != NULL){
							GROUP &g = glocal.groups[glocal.groups.size()-1];
							g.users.push_back(row[3]);
							g.access.push_back(row[4]);
							const char *role = row[5];
							if (role == NULL) role = "";
							g.roles.push_back(role);
						}
						glocal.msg = "";
					</f>
					<f empty>
						glocal.msg = "No list";
					</f>
					</call>
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.groups.clear();
				}
				rep_list_groups (ret,glocal.msg,glocal.groups);
			</f>
			<f list_inboxes> // sessionid owner = success:b msg inboxes:U{INBOX}v
					 // &INBOX manager project role
				glocal string msg = "Invalid session";
				glocal vector<INBOX> inboxes;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal.msg = "";
					vector<unsigned> listids;
					fs_list_inboxes (userid,glocal.inboxes,listids);
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.inboxes.clear();
				}
				rep_list_inboxes (ret,glocal.msg,glocal.inboxes);
			</f>
			<f list_msgs> // sessionid owner project deleted:b offset:u nb:u = success:b msg messages:U{MESSAGE}v
					// &MESSAGE manager project role uuid title submit viewed
				// We can extract the messasges for either all inboxes or a single project
				// if project is empty
				glocal string msg = "Invalid session";
				glocal vector<MESSAGE> msgs;
				string username;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, username, glocal.msg);
				if (userid != 0){
					glocal map<int,INBOX> id2prj;
					glocal.msg = "";
					string dirids;
					const char *sep = "";
					if (project[0] == '\0'){
						int dirid = fs_find_inbox(userid,username.c_str(),false,glocal.msg);
						if (dirid != -1){
							dirids = string_f("%d",dirid);
							sep = ",";
						}
					}
					vector<unsigned> listids;
					vector<INBOX> inboxes;
					fs_list_inboxes (userid,inboxes,listids);
					for (unsigned i=0; i<inboxes.size(); i++){
						auto &inb = inboxes[i];
						unsigned listid = listids[i];
						const char *manager = inb.manager.c_str();
						if (project[0] != '\0' && strcmp(project,inb.project.c_str())!=0) continue;
						vector<const char *> roles;
						roles.push_back("");
						if (inb.role.size() > 0) roles.push_back(inb.role.c_str());
						int ownerid = fs_rec_getid ("select userid from id2name where name='%s'",manager);
						if (ownerid == -1){
							glocal.msg = string_f("manager %s unknown",manager);
							break;
						}else{
							INBOX tmp = inb;
							for (auto role:roles){
								int dirid = fs_find_project_inbox(ownerid, listid, manager,inb.project.c_str(),role,false,glocal.msg);
								if (dirid != -1){
									tmp.role = role;
									glocal.id2prj[dirid] = tmp;	//inb;
									dirids += string_f ("%s%d",sep,dirid);
									sep = ",";
								}
							}
						}
					}
					if (dirids.size() > 0){
						glocal.msg = "";
						<call sql_query>("select dirs_content.name,files.title,dirs_content.modified,id2name.name,marks.modified,dirs_content.dirid"
							" from dirs_content"
							" join files on files.id = dirs_content.itemid and files.modified = dirs_content.modified"
							" join ids on dirs_content.itemid = ids.id"
							" join id2name on ids.ownerid = id2name.userid"
							" left join marks on marks.itemid=dirs_content.itemid and marks.userid=%u"
							" where dirid in (%s) and type=%u order by eventtime desc limit %u,%u"
							,userid,dirids.c_str(),ENTRY_MSG,offset,nb);
						<f onerow>
							MESSAGE msg;
							msg.uuid = row[0];
							msg.title = row[1];
							msg.submit = row[2];
							msg.from = row[3];
							msg.viewed = row[4] == NULL ? "" : row[4];
							int dirid = atoi(row[5]);
							auto pt = glocal.id2prj.find(dirid);
							if (pt != glocal.id2prj.end()){
								msg.manager = pt->second.manager;
								msg.project = pt->second.project;
								msg.role = pt->second.role;
							}
							glocal.msgs.push_back(msg);
						</f>
						</call>
					}
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.msgs.clear();
				}
				rep_list_msgs (ret,glocal.msg,glocal.msgs);
			</f>
			<f sendmsg> // sessionid owner recipients:v title content = success:b msg msgid
				<call bo_writed_client_sendmsg>(glocal.con,sessionid,owner,recipients,title,content);
				<f ok>
					glocal.bod_client.rep_sendmsg(success,msg,msgid);
				</f>
				</call>
			</f>
			<f sendmsg_project> // sessionid owner manager project role title content = success:b msg msgid
				<call bo_writed_client_sendmsg_project>(glocal.con,sessionid,owner,manager,project,role,title,content);
				<f ok>
					glocal.bod_client.rep_sendmsg_project(success,msg,msgid);
				</f>
				</call>
			</f>
			<f replymsg> // sessionid owner msgid recipients:v title content = success:b msg replyid
				<call bo_writed_client_replymsg>(glocal.con,sessionid,owner,msgid,recipients,title,content);
				<f ok>
					glocal.bod_client.rep_replymsg(success,msg,replyid);
				</f>
				</call>
			</f>
			<f replymsg_project> // sessionid owner manager project role msgid title content = success:b msg replyid
				<call bo_writed_client_replymsg_project>(glocal.con,sessionid,owner,manager,project,role,msgid,title,content);
				<f ok>
					glocal.bod_client.rep_replymsg_project(success,msg,replyid);
				</f>
				</call>
			</f>
			<f sendattach> // sessionid owner msgid content:o more:b = success:b msg handle
				<call bo_writed_client_sendattach>(glocal.con,sessionid,owner,msgid,content,more);
				<f ok>
					glocal.bod_client.rep_sendattach(success,msg,handle);
				</f>
				</call>
			</f>
			<f verifysign>	// nickname msg = status:e{ERR_CODE} msg
				glocal const char *content = msg;
				glocal ERR_CODE status = ERR_CODE_IVLDACCOUNT;
				glocal string msg;
				<call sql_query>("select pub_key from id2name where name='%s'",nickname);
				<f onerow>
					if (row[0] == NULL){
						glocal.status = ERR_CODE_CANTVERIFY;
						glocal.msg = "No public key for this account";
					}else{
						EVP_PKEY *p = bod_load_public (row[0]);
						if (p != NULL){
							// Find the signature in the content
							const char *pt = strstr(glocal.content,"------\n");
							if (pt == NULL){
								glocal.status = ERR_CODE_NOSIGFOUND;
								glocal.msg = "Signature not found";
							}else{
								string tmp = string(glocal.content,pt-glocal.content);
								string sig = pt+7;
								strip_end (sig);
								if (bod_verify(tmp,p,sig)==-1){
									glocal.status = ERR_CODE_VERIFYFAILED;
									glocal.msg = "Signature does not match";
								}else{
									glocal.status = ERR_CODE_NONE;
									glocal.msg = "Signature ok";
								}
							}
							EVP_PKEY_free (p);
						}
					}
				</f>
				</call> 
				rep_verifysign (glocal.status,glocal.msg);
			</f>
			<f sendtalk>	// sessionid owner groupname groupowner content:o = success:b msg handle
				<call bo_writed_client_sendtalk>(glocal.con,sessionid,owner,groupname,groupowner,content,more);
				<f ok>
					glocal.bod_client.rep_sendtalk(success,msg,handle);
				</f>
				</call>
			</f>
			<f sendtalk_file>	// sessionid owner groupname groupowner filename = success:b msg handle
				<call bo_writed_client_sendtalk_file>(glocal.con,sessionid,owner,groupname,groupowner,filename);
				<f ok>
					glocal.bod_client.rep_sendtalk_file(success,msg);
				</f>
				</call>
			</f>
			<f list_talk>	// sessionid owner groupname groupowner offset:u nb:u = success:b msg messages:U{MESSAGE}v
				glocal const char *groupname = groupname;
				glocal const char *groupowner = groupowner;
				glocal unsigned offset = offset;
				glocal unsigned nb = nb;
				glocal string msg = "Invalid session";
				glocal vector<SHORTMSG> msgs;
				string username;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, username, glocal.msg);
				if (userid != 0){
					// Is the current user a member of the group
					<call sql_query>("select groups.ownerid from groups"
						" join id2name on id2name.userid=groups.ownerid"
						" join group_members on group_members.groupid = groups.id"
						" where id2name.name='%s' and groups.name='%s' and group_members.userid=%u"
						,groupowner,groupname,userid);
					<f empty>
						glocal.msg = "Unknown group name, empty group, or user not a member";
					</f>
					<f onerow>
						int dirid = fs_find_short_inbox (atoi(row[0]),glocal.groupowner,glocal.groupname,false,glocal.msg);
						glocal.msg.clear();
						if (dirid != -1){
							<call sql_query>("select dirs_content.name,dirs_content.modified,id2name.name,files.filetype,dirs_content.itemid,files.content"
								" from dirs_content"
								" join files on files.id = dirs_content.itemid and files.modified = dirs_content.modified"
								" join ids on dirs_content.itemid = ids.id"
								" join id2name on ids.ownerid = id2name.userid"
								" where dirid = %d and type=%u order by eventtime desc limit %u,%u"
								,dirid,ENTRY_MSG,glocal.offset,glocal.nb);
							<f onerow>
								SHORTMSG msg;
								msg.uuid = row[0];
								const char *modified = row[1];
								msg.submit = modified;
								msg.from = row[2];
								msg.file_type = row[3] == NULL ? FILE_UNKNOWN : (FILE_TYPE)atoi(row[3]);
								if (row[5] != NULL){
									msg.content = row[5];
									msg.size = msg.content.size();
								}else{
									msg.size = fs_get_filesize(atoi(row[4]),modified);
								}
								glocal.msgs.push_back(msg);
							</f>
							</call>
						}
					</f>
					</call>
				}
				if (glocal.msg.size()>0){
					glocal.msgs.clear();
					rep_list_talk(false,glocal.msg,glocal.msgs);
				}else{
					rep_list_talk(true,glocal.msg,glocal.msgs);
				}
			</f>
			<f contact_request>	// sessionid owner user intro = success:b msg
				<call bo_writed_client_contact_request>(glocal.con,sessionid,owner,user,intro);
				<f ok>
					glocal.bod_client.rep_contact_request (success,msg);
				</f>
				</call>
			</f>
			<f contact_manage>	// sessionid owner user status = success:b msg
				<call bo_writed_client_contact_manage>(glocal.con,sessionid,owner,user,status);
				<f ok>
					glocal.bod_client.rep_contact_manage (success,msg);
				</f>
				</call>
			</f>
			<f contact_list>	// sessionid owner offset:u nb:u = success:b msg contacts:U{CONTACT}v
				// CONTACT user reqdate message status
				glocal vector<CONTACT> contacts;
				glocal string msg;
				string username;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, username, glocal.msg);
				if (userid != 0){
					<call sql_query>("select id2name.name,message,status,reqdate from contact_requests"
						" join id2name on id2name.userid=contact_requests.reqid"
						" where contact_requests.userid=%u order by id2name.name limit %u,%u"
						,userid,offset,nb);
					<f onerow>
						CONTACT c;
						c.user = row[0];
						c.message = row[1];
						c.status = (CONTACT_STATUS)atoi(row[2]);
						c.reqdate = row[3];
						glocal.contacts.push_back(c);
					</f>
					</call>
				}
				if (glocal.msg.size() != 0){
					glocal.contacts.clear();
					rep_contact_list (false,glocal.msg,glocal.contacts);
				}else{
					rep_contact_list (true,"",glocal.contacts);
				}
			</f>
			<f config_read>	// sessionid owner = success:b msg config:U{CONFIG}
				// &CONFIG lang public_view:b public_dir
				glocal string msg;
				glocal CONFIG config;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					<call sql_query>("select lang,public_view,public_dir from config where userid=%u",userid);
					<f empty>
						glocal.msg = "Internal error, no configuration for user";
					</f>
					<f onerow>
						glocal.config.lang = row[0];
						glocal.config.public_view = atoi(row[1]);
						glocal.config.public_dir = row[2];
					</f>
					</call>
				}	
				if (glocal.msg.size() > 0){
					rep_config_read (false,glocal.msg,glocal.config);
				}else{
					rep_config_read (true,glocal.msg,glocal.config);
				}
			</f>
			<f config_write>// sessionid owner config:U{CONFIG} = success:b msg
				<call bo_writed_client_config_write>(glocal.con,sessionid,owner,config);
				<f ok>
					glocal.bod_client.rep_config_write (success,msg);
				</f>
				</call>
			</f>
			<f public_listdir>	// username dirpath offset:u nb:u = success:b msg files:U{FILEINFO}v
				//glocal const char *username = username;
				//glocal const char *dirpath = dirpath;
				glocal unsigned offset = offset;
				glocal unsigned nb = nb;
				glocal string msg;
				glocal vector<FILEINFO> files;
				glocal map<string,DIRENTRY> mp;
				ENTRY entry;
				string abspath;
				entry.userid = bod_checkpublic(username,dirpath,glocal.msg,abspath);
				if (entry.userid != (unsigned)-1){
					if (fs_findentry(abspath,entry,true,"")==-1){
						glocal.msg = entry.msg;
					}else if (!bolixo_isdir(entry.type)){
						glocal.msg = "Is not a directory";
					}else{
						<call sql_query>("select dirs_content.name,dirs_content.modified,type,id2name.name"
							",group_list_id,group_lists.name,ids.listmode"
							",length(files.content),dirs_content.itemid,files.title,dirs_content.eventtime"
							",files.filetype,files.content is null"
							" from dirs_content"
							" join ids on dirs_content.itemid=ids.id"
							" join id2name on ids.ownerid=id2name.userid"
							" left join group_lists on ids.group_list_id=group_lists.id"
							" left join files on dirs_content.itemid=files.id and dirs_content.modified=files.modified"
							" where dirid=%d and dirs_content.eventtime <= '%s' order by eventtime"
							,entry.entryid,END_OF_TIME);
						<f onerow>
							const char *name = row[0];
							const char *modified = row[1];
							ENTRY_TYPE type = (ENTRY_TYPE) atoi(row[2]);
							const char *owner = row[3];
							const char *listid = row[4];
							const char *listname = row[5];
							const char *listmode = row[6] != NULL ? row[6] : "";
							if (listname == NULL){
								listname = "";
								if (listid != NULL){
									if (strcmp(listid,"0")==0){
										listname = ALL_MAY_READ;
									}
								}
							}
							unsigned size=0;
							if (row[7] != NULL){
								size = atoi(row[7]);
							}else if (bolixo_isfile(type)){
								// Content stored as a file
								size = fs_get_filesize(atoi(row[8]),modified);
							}
							const char *title = row[9] == NULL ? "" : row[9];
							const char *eventdate = row[10];
							FILE_TYPE file_type = row[11] == NULL ? FILE_UNKNOWN : (FILE_TYPE)atoi(row[11]);
							bool islarge = atoi(row[12])!=0;
							glocal.mp[name] = DIRENTRY(eventdate,modified,type,file_type,islarge,owner,listname,listmode,size,title,"not done");
						</f>
						</call>
						for (auto &x:glocal.mp){
							if (!bolixo_isdeleted(x.second.type)){
								FILEINFO info;
								info.name = x.first;
								info.type = x.second.type;
								info.file_type = x.second.file_type;
								info.eventdate = x.second.eventdate;
								info.modified = x.second.modified;
								info.owner = x.second.owner;
								info.listname = x.second.members;
								info.listmode = x.second.listmode;
								info.size = x.second.size;
								info.title = x.second.title;
								info.viewed = x.second.viewed;
								info.islarge = x.second.islarge;
								glocal.files.push_back(info);
							}
						}
					}
				}
				if (glocal.msg.size() > 0){
					glocal.files.clear();
					rep_public_listdir (false,glocal.msg,glocal.files);
				}else{
					rep_public_listdir (true,"",glocal.files);
				}
			</f>
			<f public_readfile>	// username filepath offset:u = success:b msg content:o more:b size:u
				glocal unsigned offset = offset;
				glocal string msg;
				glocal ENTRY entry;
				string abspath;
				glocal.entry.userid = bod_checkpublic(username,filepath,glocal.msg,abspath);
				if (glocal.entry.userid != (unsigned)-1){
					if (fs_findentry(abspath,glocal.entry,true,"")==-1){
						glocal.msg = glocal.entry.msg;
					}else if (!bolixo_isfile(glocal.entry.type)){
						glocal.msg = "Is not a file";
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,glocal.entry.entryid,glocal.entry.modified.c_str());
						<f onerow>
							if (row[0] != NULL){
								unsigned len = strlen(row[0]);
								BOB_TYPE bob (row[0],len,false);
								glocal.bod_client.rep_public_readfile(true,"",bob,false,len);
							}else{
								string path = fs_createpath (glocal.entry.entryid,glocal.entry.modified);
								FILE *fin = fopen (path.c_str(),"r");
								if (fin == NULL){
									glocal.msg = "Internal error, reading content file";
								}else{
									struct stat64 st;
									if (fstat64(fileno(fin),&st)==-1){
										glocal.msg = "Internal error, getting file size";
									}else if (glocal.offset >= st.st_size){
										glocal.msg = "offset too large, no seek";
									}else if (fseek(fin,glocal.offset,SEEK_SET)==-1){
										glocal.msg = "Seek failed";
									}else{
										char buf[50000];
										int len = fread (buf,1,50000,fin);
										BOB_TYPE bob (buf,len,false);
										bool more = len==50000;
										glocal.bod_client.rep_public_readfile (true,""
											,bob,more,st.st_size);
									}
									fclose (fin);
								}
							}
						</f>
						<f empty>
							glocal.msg = "Internal error, reading table files";
						</f>
						</call>
					}
				}
				if (glocal.msg.size() > 0){
					BOB_TYPE empty;
					rep_public_readfile(false,glocal.msg,empty,false,0);
				}
			</f>
			<f invalid>
				tlmp_error ("CLIENT: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_ADMIN){
			glocal.nbrequest_admin++;
			<call bod_admin>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
			<f test>
				glocal bool sessiond1=false;
				glocal bool sessiond2=false;
				glocal bool writed = false;
				glocal bool bdfiles1 = false;
				glocal bool bdfiles2 = false;
				glocal bool bdusers = false;
				glocal bool keysd = false;
				glocal bool internal_error1 = false;
				<call bo_sessiond_client_test>(glocal.con_sess);
				<f ok>
					glocal.internal_error1 = internal_error;
					glocal.sessiond1 = success;
				</f>
				</call>
				<call bo_writed_client_test>(glocal.con);
				<f ok>
					glocal.writed = !internal_error;
					glocal.sessiond2 = sessiond;
					glocal.bdusers = bdusers;
					glocal.bdfiles2 = bdfiles;
					glocal.keysd = keysd;
				</f>
				</call>
				<call sql_query>("select count(*) from id2name");
				<f onerow>
					glocal.bdfiles1=true;
				</f>
				</call>
				glocal.bod_admin.rep_test(glocal.internal_error1
					,glocal.writed,glocal.bdfiles1,glocal.bdfiles2,glocal.bdusers
					,glocal.sessiond1,glocal.sessiond2,glocal.keysd);
			</f>
			<f invalid>
				tlmp_error ("ADMIN: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}
	</f>
	</obj>
	bool some_errors = false;
	if (control != NULL && fdpass_setcontrol(s,control,user)==-1){
		some_errors = true;
	}
	if (s.listen(NULL,glocal.unixportadmin)==-1){
		tlmp_error ("Can't setup socket on %s (%s)\n",glocal.unixportadmin,strerror(errno));
		some_errors = true;
	}


	if (!some_errors && s.is_ok()){
		chmod (glocal.unixportclient.c_str()+5,0666);
		chmod (glocal.unixportadmin.c_str()+5,0666);
		s.setrawmode (true);
		if (daemon){
			daemon_init(pidfile,user);
		}
		s.loop();
		ret = 0;
	}
	return ret;
}
</mod>
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *admin_secretfile = "/etc/bolixo/secrets.admin";
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *bind = "0.0.0.0";
	glocal const char *port = "9000";
	glocal const char *control = "/var/run/bod.sock";
	glocal const char *adminhost = "127.0.0.3";
	glocal const char *adminport = "9100";
	glocal const char *sesshost = "127.0.0.4";
	glocal const char *sessport = "9200";
	glocal const char *user = "bolixo";
	glocal const char *mysecret = NULL;
	glocal const char *dbserv = "localhost";
	glocal const char *dbname = "trli";
	glocal const char *dbuser = NULL;
	glocal const char *sql_tcpport = NULL;
	glocal bool daemon = false;
	glocal int workers = 1;
	glocal const char *pidfile = "/var/run/bod.pid";

	signal (SIGPIPE,SIG_IGN);
	glocal.ret = <call tlmpprogram>(argc,argv,"tlmpsql");
	<f init>
		setproginfo ("bod",VERSION,"Implement all business logic");
		setgrouparg ("Networking");
		setarg ('b',"bindaddr","Bind to this address (TCP)",glocal.bind,false);
		setarg ('p',"tcpport","Listen for command on this TCP port",glocal.port,false);
		setarg ('c',"control","Unix socket for trlid-control",glocal.control,false);
		setgrouparg ("Admin server");
		setarg (' ',"adminhost","Host running the bo-writed server",glocal.adminhost,false);
		setarg (' ',"adminport","Port to reach the bo-writed server",glocal.adminport,false);
		setarg (' ',"sesshost","Host running the bo-sessiond server",glocal.sesshost,false);
		setarg (' ',"sessport","Port to reach the bo-sessiond server",glocal.sessport,false);
		setarg (' ',"mysecret","Secret used to communicate with bo-writed",glocal.mysecret,true);
		setgrouparg ("Misc.");
		setarg (' ',"admin_secrets","File holding admin secrets for communication",glocal.admin_secretfile,false);
		setarg (' ',"client_secrets","File holding client secrets for communication",glocal.client_secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"workers","Number of sub-process to lauch",glocal.workers,false);
		setarg (' ',"pidfile","FIle holding the PID of the process",glocal.pidfile,false);
		setgrouparg ("Database");
		setarg (' ',"dbserv","Database server",glocal.dbserv,false);
		setarg (' ',"dbname","Database name",glocal.dbname,false);
		setarg (' ',"dbuser","Database user",glocal.dbuser,true);
		setarg (' ',"sqltcpport","Database TCP port",glocal.sql_tcpport,false);
	</f>
	<f showerror>
		glocal const char *msg = msg;
		<call savefile>("/tmp/err.log",true);
		<f dowrite>
			fprintf (fout,"%s\n",glocal.msg);
			return 0;
		</f>
		</call>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		glocal CONNECT_INFO con;
		glocal CONNECT_INFO con_sess;
		glocal map<string,string> admin_secrets;
		glocal map<string,string> client_secrets;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		fdpass_readsecrets (glocal.admin_secretfile,glocal.admin_secrets);
		//glocal.con.host = glocal.adminhost;
		glocal.con.port = glocal.adminport;
		glocal.con.secret = glocal.mysecret;
		glocal.con.bind = glocal.bind;
		//glocal.con_sess.host = glocal.sesshost;
		glocal.con_sess.port = glocal.sessport;
		glocal.con_sess.secret = glocal.mysecret;
		glocal.con_sess.bind = glocal.bind;
		if (glocal.sql_tcpport != NULL) nsql_settcpport (atoi(glocal.sql_tcpport));
		{
			const char *dbpass = getenv("BOD_PWD");
			if (dbpass == NULL){
				tlmp_error ("Can't get database password from environment,aborting\n");
				exit (-1);
			}
			query_setdefaultdb (glocal.dbserv,glocal.dbname,glocal.dbuser,dbpass);
		}

		int ret = -1;
		if (glocal.workers==1){
			ret = trlid_main (glocal.bind,glocal.port,glocal.control
				,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,glocal.daemon
				,glocal.admin_secrets,glocal.client_secrets);
		}else{
			int port = atoi(glocal.port);
			for (int w=0; w<glocal.workers; w++){
				char portstr[10];
				snprintf (portstr,sizeof(portstr)-1,"%d",port+w);
				string control = string(glocal.control) + string_f("+%d",w);
				pid_t pid = fork();
				if (pid == (pid_t)0){
					ret = trlid_main (glocal.bind,portstr,control.c_str()
						,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,false
						,glocal.admin_secrets,glocal.client_secrets);
				}else if (pid == (pid_t)-1){
					tlmp_error("Can't fork (%s), aborting\n",strerror(errno));
					exit (-1);
				}else{
				}
			}
		}

		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

