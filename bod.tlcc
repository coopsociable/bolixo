/*
	Main server for the project. Hides database logic and controls security/access
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syslog.h>
#include <signal.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <fdpass.h>
#include <tlmpsql.h>
#include "filesystem.h"


static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_ADMIN };

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	int no;
	std::string host;
	REQUEST_INFO req;
	std::string userid;
	HANDLE_INFO(){
		no = -1;
		type = TYPE_NONE;
	}
};
struct DIRENTRY{
	std::string modified;
	char type;
	std::string owner;
	unsigned size;
	DIRENTRY (const char *_modified, char _type, const char *_owner, unsigned _size){
		modified = _modified;
		type = _type;
		owner = _owner;
		size = _size;
	}
	DIRENTRY(){
		type = '_';
		size = 0;
	}
};

#include "proto/bod_control.protoh"
#include "proto/bod_client.protoh"
#include "proto/bod_admin.protoh"

using namespace std;


#include "proto/bo-writed_client.protoch"
#define bo_sessiond_client_getsessioninfovars_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#include "proto/bo-sessiond_client.protoch"

/*
	Get the userid associated with the sessionid
*/
<mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin)
{
	glocal unsigned userid = 0;
	glocal bool is_admin = false;
	//long long start = fdpass_getnow();
	//for (int i=0; i<10000; i++){
	<call bo_sessiond_client_getsessioninfo>(con,sessionid);
	<f ok>
		glocal.userid = userid;
		glocal.is_admin = admin;
	</f>
	</call>
	//}
	//long long end = fdpass_getnow();
	//printf ("exec time = %lf\n",(end-start)/1000000.0);
	is_admin = glocal.is_admin;
	return glocal.userid;
}
</mod>
static int bod_findentry (CONNECT_INFO &con, const char *sessionid, const char *name, ENTRY &entry, const char *threshold)
{
	int ret = -1;
	entry.userid = trli_getsessionuser(con,sessionid,entry.is_admin);
	if (entry.userid == 0){
		entry.msg = "Invalid session";
	}else{
		ret = fs_findentry(name,entry,true,threshold);
	}
	return ret;
}
<mod>
static int trlid_main (
	const char *bind,
	const char *portstr,
	const char *control,	// Unix socket
	const CONNECT_INFO &con,
	const CONNECT_INFO &con_sess,
	const char *user,
	const char *pidfile,
	bool daemon,
	const map<string,string> &admin_secrets,
	const map<string,string> &client_secrets)
{
	int ret = -1;
	glocal CONNECT_INFO con = con;
	glocal CONNECT_INFO con_sess = con_sess;
	glocal const map<string,string> *admin_secrets = &admin_secrets;
	glocal const map<string,string> *client_secrets = &client_secrets;
	glocal unsigned long nbrequest_client = 0;
	glocal unsigned long nbrequest_admin = 0;
	glocal string unixportclient = string_f("unix:/tmp/bod-client-%s.sock",portstr);
	glocal string unixportadmin = string_f("unix:/tmp/bod-admin-%s.sock",portstr);
	<obj TCPSERVER s>(bind,glocal.unixportclient,5);
	<f newclient>
		HANDLE_INFO *n = new HANDLE_INFO;
		info.data = n;
		if (strcmp(info.port,glocal.unixportclient.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				tlmp_error ("Rejected client connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strcmp(info.port,glocal.unixportadmin.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.admin_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_ADMIN;
			}else{
				tlmp_error ("Rejected admin connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strncmp(info.port,"unix:",5)==0){
			n->type = TYPE_CONTROL;
		}else{
			settcpnodelay(true);
			char addr[20];
			ipnum_ip2a (from,addr);
			n->host = addr;
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,addr);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				n->req.secret = fdpass_findsecret (*glocal.admin_secrets,addr);
				if (n->req.secret.size() > 0){
					n->type = TYPE_ADMIN;
				}else{
					tlmp_error ("Rejected connexion from IP %s\n",addr);
					endclient = true;
				}
			}
		}
	</f>
	<f endclient>
	</f>
	<f receive>
		HANDLE_INFO *c = (HANDLE_INFO*)info.data;
		glocal HANDLE_INFO *c = c;
		glocal string userid = c->userid;
		debug_printf (D_PROTO,"receive line[%d]: %s\n",info.linelen,line);
		if (c->type == TYPE_CONTROL){
			<call bod_control>(this,c->req,line,info.linelen, endserver, endclient, no,c,c->host.c_str());
			<f status>
				vector<string> tb;
				tb.push_back(string_f("Version %s",VERSION));
				tb.push_back(string_f ("nbrequest_admin=%lu",glocal.nbrequest_admin));
				tb.push_back(string_f ("nbrequest_client=%lu",glocal.nbrequest_client));
				rep_status(tb);
			</f>
			<f quit>
				endserver = true;
			</f>
			<f debug>
				if (on){
					debug_seton();
				}else{
					debug_setoff();
				}
			</f>
			<f debugfile>
				debug_setfdebug (filename);
			</f>
			<f invalid>
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_CLIENT){
			glocal.nbrequest_client++;
			<call bod_client>(this,c->req,line,info.linelen, endserver, endclient,no,c,c->host.c_str());
			<f createsession>
				<call bo_writed_client_createsession>(glocal.con);
				<f ok>
					glocal.bod_client.rep_createsession(sessionid);
				</f>
				</call>
			</f>
			<f login>
				<call bo_writed_client_login>(glocal.con,sessionid,email,password);
				<f ok>
					glocal.bod_client.rep_login(success);
				</f>
				</call>
			</f>
			<f logout>
				<call bo_writed_client_logout>(glocal.con,sessionid);
				<f ok>
				</f>
				</call>
			</f>
			<f adduser>
				<call bo_writed_client_adduser>(glocal.con,name,email,password);
				<f ok>
					glocal.bod_client.rep_adduser (confirmid,msg);
				</f>
				</call>
			</f>
			<f confirmuser>
				<call bo_writed_client_confirmuser>(glocal.con,id);
				<f ok>
					glocal.bod_client.rep_confirmuser(success,msg);
				</f>
				</call>
			</f>
			<f deleteuser>
				<call bo_writed_client_deleteuser>(glocal.con,sessionid);
				<f ok>
					glocal.bod_client.rep_deleteuser (email,confirmid);
				</f>
				</call>
			</f>
			<f confirmdelete>
				<call bo_writed_client_confirmdelete>(glocal.con,confirmid);
				<f ok>
					glocal.bod_client.rep_confirmdelete(success,msg);
				</f>
				</call>
			</f>
			<f mkdir> // sessionid name = success:b dirid msg
				<call bo_writed_client_mkdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_mkdir(success,dirid,msg);
				</f>
				</call>
			</f>
			<f rmdir> // sessionid name = success:b msg
				<call bo_writed_client_rmdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_rmdir(success,msg);
				</f>
				</call>
			</f>
			<f addfile> // sessionid name content = success:b fileid msg
				<call bo_writed_client_addfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_addfile(success,msg);
				</f>
				</call>
			</f>
			<f addfile_bob> // sessionid name content:o more:b = success:b fileid msg
				debug_printf ("bob size=%lu\n",content.getsize());
				<call bo_writed_client_addfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_addfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f appendfile> // sessionid fileid content:o more:b = success:b msg
				<call bo_writed_client_appendfile>(glocal.con,sessionid,handle,content,more);
				<f ok>
					glocal.bod_client.rep_appendfile(success,msg);
				</f>
				</call>
			</f>
			<f delfile> // sessionid name = success:b msg
				<call bo_writed_client_delfile>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_delfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile> // sessionid name content = success:b msg
				<call bo_writed_client_modifyfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_modifyfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile_bob> // sessionid name content:o more:b = success:b handle msg
				<call bo_writed_client_modifyfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_modifyfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f rename> // sessionid oldname newname = success:b msg
				// Rename file, directory or symlink
				<call bo_writed_client_rename>(glocal.con,sessionid,oldname,newname);
				<f ok>
					glocal.bod_client.rep_rename(success,msg);
				</f>
				</call>
			</f>
			<f copy> // sessionid srcname srcname = success:b msg
				// Copy file, directory or symlink
				<call bo_writed_client_copy>(glocal.con,sessionid,srcname,dstname);
				<f ok>
					glocal.bod_client.rep_copy(success,msg);
				</f>
				</call>
			</f>
			<f readfile> // sessionid name = success:b msg content
				ENTRY entry;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)==-1){
					rep_readfile (false,entry.msg,"");
				}else{
					if (entry.type != 'F'){
						rep_readfile (false,"Entry is not a file","");
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,entry.entryid,entry.modified.c_str());
						<f onerow>
							glocal.bod_client.rep_readfile (true,"",row[0]);
						</f>
						<f empty>
							glocal.bod_client.rep_readfile (false,"Internal error, reading table files","");
						</f>
						</call>
					}
				}
			</f>
			<f readfile_bob> // sessionid name = success:b msg content:o handle more:b
				glocal ENTRY entry;
				glocal const char *sessionid = sessionid;
				BOB_TYPE empty;
				if (bod_findentry (glocal.con_sess,sessionid,name,glocal.entry,threshold)==-1){
					rep_readfile_bob (false,glocal.entry.msg,empty,"",false);
				}else{
					if (glocal.entry.type != 'F'){
						rep_readfile_bob (false,"Entry is not a file",empty,"",false);
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,glocal.entry.entryid,glocal.entry.modified.c_str());
						<f onerow>
							if (row[0] != NULL){
								BOB_TYPE bob (row[0],strlen(row[0]),false);
								glocal.bod_client.rep_readfile_bob (true,"",bob,"",false);
							}else{
								string handle;
								FILE *fin = fs_alloc_file_handle (glocal.entry.entryid,glocal.entry.modified,"r",handle,glocal.sessionid);
								if (fin == NULL){
									glocal.bod_client.rep_readfile_bob (false,"Internal error, reading content file"
										,BOB_TYPE(),"",false);
									fs_delete_handle (handle);
								}else{
									char buf[50000];
									int len = fread (buf,1,50000,fin);
									BOB_TYPE bob (buf,len,false);
									bool more = len==50000;
									if (!more){
										fs_delete_handle(handle);
										handle.clear();
									}
									glocal.bod_client.rep_readfile_bob (true,"Ok"
										,bob,handle,more);
								}
							}
						</f>
						<f empty>
							glocal.bod_client.rep_readfile_bob (false,"Internal error, reading table files"
								,BOB_TYPE(),"",false);
						</f>
						</call>
					}
				}
			</f>
			<f readmore>	// sessionid handle = success:b msg content:o more:b
				bool is_admin;
				if (trli_getsessionuser(glocal.con_sess,sessionid,is_admin)==0){
					rep_readmore (false,"Invalid session",BOB_TYPE(),false);
				}else{
					FILE *fin = fs_get_file (handle,sessionid);
					if (fin == NULL){
						rep_readmore (false,"Internal error, reading content file",BOB_TYPE(),false);
						fs_delete_handle (handle);
					}else{
						char buf[50000];
						int len = fread (buf,1,50000,fin);
						BOB_TYPE bob (buf,len,false);
						bool more = len == 50000;
						rep_readmore (true,"Ok",bob,more);
						if (!more){
							fs_delete_handle(handle);
						}
					}
				}
			</f>
			<f listdir>
				ENTRY entry;
				glocal vector<string> entries;
				glocal vector<unsigned> types;
				glocal vector<string> modified;
				glocal vector<string> owners;
				glocal vector<unsigned> sizes;
				glocal map<string,DIRENTRY> mp;
				glocal bool history = history;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)==-1){
					rep_listdir (false,entry.msg,glocal.entries,glocal.types,glocal.modified,glocal.owners,glocal.sizes);
				}else if (entry.type != 'D'){
					rep_listdir (false,"Is not a directory",glocal.entries,glocal.types,glocal.modified,glocal.owners,glocal.sizes);
				}else{
					if (threshold[0] == '\0') threshold = "3000/01/01 00:00:00";
					<call sql_query>("select dirs_content.name,dirs_content.modified,type,id2name.name,length(files.content),dirs_content.itemid"
						" from dirs_content"
						" join ids on dirs_content.itemid=ids.id"
						" join id2name on ids.ownerid=id2name.userid"
						" left join files on dirs_content.itemid=files.id and dirs_content.modified=files.modified"
						" where dirid=%d and dirs_content.modified <= '%s' order by modified"
						,entry.entryid,threshold);
					<f onerow>
						const char *name = row[0];
						const char *modified = row[1];
						char type = row[2][0];
						const char *owner = row[3];
						unsigned size=0;
						if (row[4] != NULL){
							size = atoi(row[4]);
						}else if (type == 'F'){
							// Content stored as a file
							size = fs_get_filesize(atoi(row[5]),modified);
						}
						if (glocal.history){
							glocal.entries.push_back (name);
							glocal.modified.push_back (modified);
							glocal.types.push_back(type);
							glocal.owners.push_back(owner);
							glocal.sizes.push_back(size);
						}else{
							glocal.mp[name] = DIRENTRY(modified,type,owner,size);
						}
					</f>
					</call>
					if (!glocal.history){
						for (auto &x:glocal.mp){
							if (x.second.type != '_'){
								glocal.entries.push_back(x.first);
								glocal.types.push_back(x.second.type);
								glocal.modified.push_back(x.second.modified);
								glocal.owners.push_back(x.second.owner);
								glocal.sizes.push_back(x.second.size);
							}
						}
					}
					rep_listdir (true,"",glocal.entries,glocal.types,glocal.modified,glocal.owners,glocal.sizes);
				}
			</f>
			<f invalid>
				tlmp_error ("CLIENT: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_ADMIN){
			glocal.nbrequest_admin++;
			<call bod_admin>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
			<f test>
				glocal bool sessiond1=false;
				glocal bool sessiond2=false;
				glocal bool writed = false;
				glocal bool bdfiles1 = false;
				glocal bool bdfiles2 = false;
				glocal bool bdusers = false;
				glocal bool internal_error1 = false;
				<call bo_sessiond_client_test>(glocal.con_sess);
				<f ok>
					glocal.internal_error1 = internal_error;
					glocal.sessiond1 = success;
				</f>
				</call>
				<call bo_writed_client_test>(glocal.con);
				<f ok>
					glocal.writed = !internal_error;
					glocal.sessiond2 = sessiond;
					glocal.bdusers = bdusers;
					glocal.bdfiles2 = bdfiles;
				</f>
				</call>
				<call sql_query>("select count(*) from id2name");
				<f onerow>
					glocal.bdfiles1=true;
				</f>
				</call>
				glocal.bod_admin.rep_test(glocal.internal_error1
					,glocal.writed,glocal.bdfiles1,glocal.bdfiles2,glocal.bdusers
					,glocal.sessiond1,glocal.sessiond2);
			</f>
			<f invalid>
				tlmp_error ("ADMIN: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}
	</f>
	</obj>
	bool some_errors = false;
	if (control != NULL && fdpass_setcontrol(s,control,user)==-1){
		some_errors = true;
	}
	if (s.listen(NULL,glocal.unixportadmin)==-1){
		tlmp_error ("Can't setup socket on %s (%s)\n",glocal.unixportadmin,strerror(errno));
		some_errors = true;
	}


	if (!some_errors && s.is_ok()){
		chmod (glocal.unixportclient.c_str()+5,0666);
		chmod (glocal.unixportadmin.c_str()+5,0666);
		s.setrawmode (true);
		if (daemon){
			daemon_init(pidfile,user);
		}
		s.loop();
		ret = 0;
	}
	return ret;
}
</mod>
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *admin_secretfile = "/etc/bolixo/secrets.admin";
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *bind = "0.0.0.0";
	glocal const char *port = "9000";
	glocal const char *control = "/var/run/bod.sock";
	glocal const char *adminhost = "127.0.0.3";
	glocal const char *adminport = "9100";
	glocal const char *sesshost = "127.0.0.4";
	glocal const char *sessport = "9200";
	glocal const char *user = "bolixo";
	glocal const char *mysecret = NULL;
	glocal const char *dbserv = "localhost";
	glocal const char *dbname = "trli";
	glocal const char *dbuser = NULL;
	glocal const char *sql_tcpport = NULL;
	glocal bool daemon = false;
	glocal int workers = 1;
	glocal const char *pidfile = "/var/run/bod.pid";

	signal (SIGPIPE,SIG_IGN);
	glocal.ret = <call tlmpprogram>(argc,argv,"tlmpsql");
	<f init>
		setproginfo ("bod",VERSION,"Implement all business logic");
		setgrouparg ("Networking");
		setarg ('b',"bindaddr","Bind to this address (TCP)",glocal.bind,false);
		setarg ('p',"tcpport","Listen for command on this TCP port",glocal.port,false);
		setarg ('c',"control","Unix socket for trlid-control",glocal.control,false);
		setgrouparg ("Admin server");
		setarg (' ',"adminhost","Host running the bo-writed server",glocal.adminhost,false);
		setarg (' ',"adminport","Port to reach the bo-writed server",glocal.adminport,false);
		setarg (' ',"sesshost","Host running the bo-sessiond server",glocal.sesshost,false);
		setarg (' ',"sessport","Port to reach the bo-sessiond server",glocal.sessport,false);
		setarg (' ',"mysecret","Secret used to communicate with bo-writed",glocal.mysecret,true);
		setgrouparg ("Misc.");
		setarg (' ',"admin_secrets","File holding admin secrets for communication",glocal.admin_secretfile,false);
		setarg (' ',"client_secrets","File holding client secrets for communication",glocal.client_secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"workers","Number of sub-process to lauch",glocal.workers,false);
		setarg (' ',"pidfile","FIle holding the PID of the process",glocal.pidfile,false);
		setgrouparg ("Database");
		setarg (' ',"dbserv","Database server",glocal.dbserv,false);
		setarg (' ',"dbname","Database name",glocal.dbname,false);
		setarg (' ',"dbuser","Database user",glocal.dbuser,true);
		setarg (' ',"sqltcpport","Database TCP port",glocal.sql_tcpport,false);
	</f>
	<f showerror>
		glocal const char *msg = msg;
		<call savefile>("/tmp/err.log",true);
		<f dowrite>
			fprintf (fout,"%s\n",glocal.msg);
			return 0;
		</f>
		</call>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		glocal CONNECT_INFO con;
		glocal CONNECT_INFO con_sess;
		glocal map<string,string> admin_secrets;
		glocal map<string,string> client_secrets;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		fdpass_readsecrets (glocal.admin_secretfile,glocal.admin_secrets);
		//glocal.con.host = glocal.adminhost;
		glocal.con.port = glocal.adminport;
		glocal.con.secret = glocal.mysecret;
		glocal.con.bind = glocal.bind;
		//glocal.con_sess.host = glocal.sesshost;
		glocal.con_sess.port = glocal.sessport;
		glocal.con_sess.secret = glocal.mysecret;
		glocal.con_sess.bind = glocal.bind;
		if (glocal.sql_tcpport != NULL) nsql_settcpport (atoi(glocal.sql_tcpport));
		{
			const char *dbpass = getenv("BOD_PWD");
			if (dbpass == NULL){
				tlmp_error ("Can't get database password from environment,aborting\n");
				exit (-1);
			}
			query_setdefaultdb (glocal.dbserv,glocal.dbname,glocal.dbuser,dbpass);
		}

		int ret = -1;
		if (glocal.workers==1){
			ret = trlid_main (glocal.bind,glocal.port,glocal.control
				,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,glocal.daemon
				,glocal.admin_secrets,glocal.client_secrets);
		}else{
			int port = atoi(glocal.port);
			for (int w=0; w<glocal.workers; w++){
				char portstr[10];
				snprintf (portstr,sizeof(portstr)-1,"%d",port+w);
				string control = string(glocal.control) + string_f("+%d",w);
				pid_t pid = fork();
				if (pid == (pid_t)0){
					ret = trlid_main (glocal.bind,portstr,control.c_str()
						,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,false
						,glocal.admin_secrets,glocal.client_secrets);
				}else if (pid == (pid_t)-1){
					tlmp_error("Can't fork (%s), aborting\n",strerror(errno));
					exit (-1);
				}else{
				}
			}
		}

		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

