/*
	Main server for the project. Hides database logic and controls security/access
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syslog.h>
#include <signal.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <fdpass.h>
#include <tlmpsql.h>
#include "filesystem.h"


static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_ADMIN };

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	int no;
	std::string host;
	REQUEST_INFO req;
	std::string userid;
	HANDLE_INFO(){
		no = -1;
		type = TYPE_NONE;
	}
};
struct DIRENTRY{
	std::string eventdate;
	std::string modified;
	ENTRY_TYPE type;
	std::string owner;
	std::string members;
	std::string listmode;
	std::string title;
	unsigned size;
	DIRENTRY (const char *_eventdate, const char *_modified, ENTRY_TYPE _type, const char *_owner, const char *_members, const char *_listmode, unsigned _size, const char *_title){
		eventdate = _eventdate;
		modified = _modified;
		type = _type;
		owner = _owner;
		members = _members;
		listmode = _listmode;
		size = _size;
		title = _title;
	}
	DIRENTRY(){
		type = ENTRY_DELETED;
		size = 0;
	}
};

#include "proto/bod_control.protoh"
#include "proto/bod_client.protoh"
#include "proto/bod_admin.protoh"

using namespace std;


#include "proto/bo-writed_client.protoch"
#define bo_sessiond_client_getsessioninfovars_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#include "proto/bo-sessiond_client.protoch"

/*
	Get the userid associated with the sessionid
*/
<mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin, string &name)
{
	glocal unsigned userid = 0;
	glocal bool is_admin = false;
	glocal string *name = &name;
	//long long start = fdpass_getnow();
	//for (int i=0; i<10000; i++){
	<call bo_sessiond_client_getsessioninfo>(con,sessionid);
	<f ok>
		glocal.userid = userid;
		glocal.is_admin = admin;
		(*glocal.name) = name;
	</f>
	</call>
	//}
	//long long end = fdpass_getnow();
	//printf ("exec time = %lf\n",(end-start)/1000000.0);
	is_admin = glocal.is_admin;
	return glocal.userid;
}
</mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin)
{
	string username;
	return trli_getsessionuser (con,sessionid,is_admin,username);
}
static int bod_findentry (CONNECT_INFO &con, const char *sessionid, const char *name, ENTRY &entry, const char *threshold)
{
	int ret = -1;
	entry.userid = trli_getsessionuser(con,sessionid,entry.is_admin);
	if (entry.userid == 0){
		entry.msg = "Invalid session";
	}else{
		ret = fs_findentry(name,entry,true,threshold);
	}
	return ret;
}
/*
	Identify the userid who will perform some group administration.
	Normally, user are only allowed to work on list they own.
	But administrator can work on behalf of another user. The parameter "owner" is the other user.
	For normal user, this parameter is ignored.

	Return 0 if not a valid userid (sessionid is invalid)
*/
<mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &username, string &msg)
{
	bool is_admin;
	glocal unsigned userid = trli_getsessionuser (con,sessionid,is_admin,username);
	if (is_admin && owner[0] != '\0'){
		<call sql_query>("select userid from id2name where name='%s'",owner);
		<f onerow>
			glocal.userid = atoi(row[0]);
		</f>
		<f empty>
			glocal.userid = 0;
		</f>
		</call>
		username = owner;
		if (glocal.userid == 0) msg = "Unknown owner";
	}
	return glocal.userid;
}
</mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &msg)
{
	string username;
	return bo_writed_get_group_owner (con,sessionid,owner,username,msg);
}
/*
	Keeps only a slice of the vector
*/
template<class T> static void bod_trim (vector<T> &tb, unsigned offset, unsigned nb)
{
	if (offset >= tb.size()){
		tb.clear();
	}else if (offset + nb >= tb.size()){
		tb.erase (tb.begin(),tb.begin()+offset);
	}else{
		if (offset > 0){
			tb.erase (tb.begin(),tb.begin()+offset);
		}
		if (nb < tb.size()){
			tb.erase (tb.begin()+nb,tb.end());
		}
	}
}
<mod>
static int trlid_main (
	const char *bind,
	const char *portstr,
	const char *control,	// Unix socket
	const CONNECT_INFO &con,
	const CONNECT_INFO &con_sess,
	const char *user,
	const char *pidfile,
	bool daemon,
	const map<string,string> &admin_secrets,
	const map<string,string> &client_secrets)
{
	int ret = -1;
	glocal CONNECT_INFO con = con;
	glocal CONNECT_INFO con_sess = con_sess;
	glocal const map<string,string> *admin_secrets = &admin_secrets;
	glocal const map<string,string> *client_secrets = &client_secrets;
	glocal unsigned long nbrequest_client = 0;
	glocal unsigned long nbrequest_admin = 0;
	glocal string unixportclient = string_f("unix:/tmp/bod-client-%s.sock",portstr);
	glocal string unixportadmin = string_f("unix:/tmp/bod-admin-%s.sock",portstr);
	<obj TCPSERVER s>(bind,glocal.unixportclient,5);
	<f newclient>
		HANDLE_INFO *n = new HANDLE_INFO;
		info.data = n;
		if (strcmp(info.port,glocal.unixportclient.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				tlmp_error ("Rejected client connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strcmp(info.port,glocal.unixportadmin.c_str())==0){
			n->req.secret = fdpass_findsecret (*glocal.admin_secrets,info.port);
			if (n->req.secret.size() > 0){
				n->type = TYPE_ADMIN;
			}else{
				tlmp_error ("Rejected admin connexion from port %s\n",info.port);
				endclient = true;
			}
		}else if (strncmp(info.port,"unix:",5)==0){
			n->type = TYPE_CONTROL;
		}else{
			settcpnodelay(true);
			char addr[20];
			ipnum_ip2a (from,addr);
			n->host = addr;
			n->req.secret = fdpass_findsecret (*glocal.client_secrets,addr);
			if (n->req.secret.size() > 0){
				n->type = TYPE_CLIENT;
			}else{
				n->req.secret = fdpass_findsecret (*glocal.admin_secrets,addr);
				if (n->req.secret.size() > 0){
					n->type = TYPE_ADMIN;
				}else{
					tlmp_error ("Rejected connexion from IP %s\n",addr);
					endclient = true;
				}
			}
		}
	</f>
	<f endclient>
	</f>
	<f receive>
		HANDLE_INFO *c = (HANDLE_INFO*)info.data;
		glocal HANDLE_INFO *c = c;
		glocal string userid = c->userid;
		debug_printf (D_PROTO,"receive line[%d]: %s\n",info.linelen,line);
		if (c->type == TYPE_CONTROL){
			<call bod_control>(this,c->req,line,info.linelen, endserver, endclient, no,c,c->host.c_str());
			<f status>
				vector<string> tb;
				tb.push_back(string_f("Version %s",VERSION));
				tb.push_back(string_f ("nbrequest_admin=%lu",glocal.nbrequest_admin));
				tb.push_back(string_f ("nbrequest_client=%lu",glocal.nbrequest_client));
				rep_status(tb);
			</f>
			<f quit>
				endserver = true;
			</f>
			<f debug>
				if (on){
					debug_seton();
				}else{
					debug_setoff();
				}
			</f>
			<f debugfile>
				debug_setfdebug (filename);
			</f>
			<f invalid>
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_CLIENT){
			glocal.nbrequest_client++;
			<call bod_client>(this,c->req,line,info.linelen, endserver, endclient,no,c,c->host.c_str());
			<f createsession>
				<call bo_writed_client_createsession>(glocal.con);
				<f ok>
					glocal.bod_client.rep_createsession(sessionid);
				</f>
				</call>
			</f>
			<f login>
				<call bo_writed_client_login>(glocal.con,sessionid,email,password);
				<f ok>
					glocal.bod_client.rep_login(success);
				</f>
				</call>
			</f>
			<f logout>
				<call bo_writed_client_logout>(glocal.con,sessionid);
				<f ok>
				</f>
				</call>
			</f>
			<f adduser>
				<call bo_writed_client_adduser>(glocal.con,name,email,password);
				<f ok>
					glocal.bod_client.rep_adduser (confirmid,msg);
				</f>
				</call>
			</f>
			<f confirmuser>
				<call bo_writed_client_confirmuser>(glocal.con,id);
				<f ok>
					glocal.bod_client.rep_confirmuser(success,msg);
				</f>
				</call>
			</f>
			<f deleteuser>
				<call bo_writed_client_deleteuser>(glocal.con,sessionid);
				<f ok>
					glocal.bod_client.rep_deleteuser (email,confirmid);
				</f>
				</call>
			</f>
			<f confirmdelete>
				<call bo_writed_client_confirmdelete>(glocal.con,confirmid);
				<f ok>
					glocal.bod_client.rep_confirmdelete(success,msg);
				</f>
				</call>
			</f>
			<f mkdir> // sessionid name = success:b dirid msg
				<call bo_writed_client_mkdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_mkdir(success,msg);
				</f>
				</call>
			</f>
			<f rmdir> // sessionid name = success:b msg
				<call bo_writed_client_rmdir>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_rmdir(success,msg);
				</f>
				</call>
			</f>
			<f addfile> // sessionid name content = success:b fileid msg
				<call bo_writed_client_addfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_addfile(success,msg);
				</f>
				</call>
			</f>
			<f addfile_bob> // sessionid name content:o more:b = success:b fileid msg
				debug_printf ("bob size=%lu\n",content.getsize());
				<call bo_writed_client_addfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_addfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f appendfile> // sessionid fileid content:o more:b = success:b msg
				<call bo_writed_client_appendfile>(glocal.con,sessionid,handle,content,more);
				<f ok>
					glocal.bod_client.rep_appendfile(success,msg);
				</f>
				</call>
			</f>
			<f delfile> // sessionid name = success:b msg
				<call bo_writed_client_delfile>(glocal.con,sessionid,name);
				<f ok>
					glocal.bod_client.rep_delfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile> // sessionid name content = success:b msg
				<call bo_writed_client_modifyfile>(glocal.con,sessionid,name,content);
				<f ok>
					glocal.bod_client.rep_modifyfile(success,msg);
				</f>
				</call>
			</f>
			<f modifyfile_bob> // sessionid name content:o more:b = success:b handle msg
				<call bo_writed_client_modifyfile_bob>(glocal.con,sessionid,name,content,more);
				<f ok>
					glocal.bod_client.rep_modifyfile_bob(success,handle,msg);
				</f>
				</call>
			</f>
			<f rename> // sessionid oldname newname = success:b msg
				// Rename file, directory or symlink
				<call bo_writed_client_rename>(glocal.con,sessionid,oldname,newname);
				<f ok>
					glocal.bod_client.rep_rename(success,msg);
				</f>
				</call>
			</f>
			<f copy> // sessionid srcname srcname = success:b msg
				// Copy file, directory or symlink
				<call bo_writed_client_copy>(glocal.con,sessionid,srcname,dstname);
				<f ok>
					glocal.bod_client.rep_copy(success,msg);
				</f>
				</call>
			</f>
			<f readfile> // sessionid name = success:b msg content
				ENTRY entry;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)==-1){
					rep_readfile (false,entry.msg,"");
				}else{
					if (!bolixo_isfile(entry.type)){
						rep_readfile (false,"Entry is not a file","");
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,entry.entryid,entry.modified.c_str());
						<f onerow>
							glocal.bod_client.rep_readfile (true,"",row[0]);
						</f>
						<f empty>
							glocal.bod_client.rep_readfile (false,"Internal error, reading table files","");
						</f>
						</call>
					}
				}
			</f>
			<f readfile_bob> // sessionid name = success:b msg content:o handle more:b
				glocal ENTRY entry;
				glocal const char *sessionid = sessionid;
				BOB_TYPE empty;
				if (bod_findentry (glocal.con_sess,sessionid,name,glocal.entry,threshold)==-1){
					rep_readfile_bob (false,glocal.entry.msg,empty,"",false);
				}else{
					if (!bolixo_isfile(glocal.entry.type)){
						rep_readfile_bob (false,"Entry is not a file",empty,"",false);
					}else{
						<call sql_query>("select content from files where id=%d and modified='%s'"
							,glocal.entry.entryid,glocal.entry.modified.c_str());
						<f onerow>
							if (row[0] != NULL){
								BOB_TYPE bob (row[0],strlen(row[0]),false);
								glocal.bod_client.rep_readfile_bob (true,"",bob,"",false);
							}else{
								string handle;
								FILE *fin = fs_alloc_file_handle (glocal.entry.entryid,glocal.entry.modified,"r",handle,glocal.sessionid);
								if (fin == NULL){
									glocal.bod_client.rep_readfile_bob (false,"Internal error, reading content file"
										,BOB_TYPE(),"",false);
									fs_delete_handle (handle);
								}else{
									char buf[50000];
									int len = fread (buf,1,50000,fin);
									BOB_TYPE bob (buf,len,false);
									bool more = len==50000;
									if (!more){
										fs_delete_handle(handle);
										handle.clear();
									}
									glocal.bod_client.rep_readfile_bob (true,"Ok"
										,bob,handle,more);
								}
							}
						</f>
						<f empty>
							glocal.bod_client.rep_readfile_bob (false,"Internal error, reading table files"
								,BOB_TYPE(),"",false);
						</f>
						</call>
					}
				}
			</f>
			<f readmore>	// sessionid handle = success:b msg content:o more:b
				bool is_admin;
				if (trli_getsessionuser(glocal.con_sess,sessionid,is_admin)==0){
					rep_readmore (false,"Invalid session",BOB_TYPE(),false);
				}else{
					FILE *fin = fs_get_file (handle,sessionid);
					if (fin == NULL){
						rep_readmore (false,"Internal error, reading content file",BOB_TYPE(),false);
						fs_delete_handle (handle);
					}else{
						char buf[50000];
						int len = fread (buf,1,50000,fin);
						BOB_TYPE bob (buf,len,false);
						bool more = len == 50000;
						rep_readmore (true,"Ok",bob,more);
						if (!more){
							fs_delete_handle(handle);
						}
					}
				}
			</f>
			<f set_access>	//  sessionid name listname = success:b msg
				<call bo_writed_client_set_access>(glocal.con,sessionid,name,listname,listmode);
				<f ok>
					glocal.bod_client.rep_set_access (success,msg);
				</f>
				</call>
			</f>
			<f listdir>
				ENTRY entry;
				glocal vector<string> entries;
				glocal vector<ENTRY_TYPE> types;
				glocal vector<string> modified;
				glocal vector<string> eventdates;
				glocal vector<string> owners;
				glocal vector<string> members;
				glocal vector<string> listmodes;
				glocal vector<string> titles;
				glocal vector<unsigned> sizes;
				glocal map<string,DIRENTRY> mp;
				glocal bool history = history;
				if (bod_findentry (glocal.con_sess,sessionid,name,entry,threshold)!=-1){
					if (!bolixo_isdir(entry.type)){
						entry.msg = "Is not a directory";
					}else if (entry.ownerid != entry.userid && entry.listmode == 'p' && !entry.is_admin){
						entry.msg = "Not allowed to list";
					}else{
						if (threshold[0] == '\0') threshold = END_OF_TIME;
						<call sql_query>("select dirs_content.name,dirs_content.modified,type,id2name.name"
							",group_list_id,group_lists.name,ids.listmode"
							",length(files.content),dirs_content.itemid,files.title,dirs_content.eventtime"
							" from dirs_content"
							" join ids on dirs_content.itemid=ids.id"
							" join id2name on ids.ownerid=id2name.userid"
							" left join group_lists on ids.group_list_id=group_lists.id"
							" left join files on dirs_content.itemid=files.id and dirs_content.modified=files.modified"
							" where dirid=%d and dirs_content.eventtime <= '%s' order by eventtime"
							,entry.entryid,threshold,offset,nb);
						<f onerow>
							const char *name = row[0];
							const char *modified = row[1];
							ENTRY_TYPE type = (ENTRY_TYPE) atoi(row[2]);
							const char *owner = row[3];
							const char *listid = row[4];
							const char *members = row[5];
							const char *listmode = row[6] != NULL ? row[6] : "";
							if (members == NULL){
								members = "";
								if (listid != NULL){
									if (strcmp(listid,"0")==0){
										members = ALL_MAY_READ;
									}
								}
							}
							unsigned size=0;
							if (row[7] != NULL){
								size = atoi(row[7]);
							}else if (bolixo_isfile(type)){
								// Content stored as a file
								size = fs_get_filesize(atoi(row[8]),modified);
							}
							const char *title = row[9] == NULL ? "" : row[9];
							const char *eventdate = row[10];
							if (glocal.history){
								glocal.entries.push_back (name);
								glocal.eventdates.push_back (eventdate);
								glocal.modified.push_back (modified);
								glocal.types.push_back(type);
								glocal.owners.push_back(owner);
								glocal.members.push_back(members);
								glocal.listmodes.push_back(listmode);
								glocal.sizes.push_back(size);
								glocal.titles.push_back(title);
							}else{
								glocal.mp[name] = DIRENTRY(eventdate,modified,type,owner,members,listmode,size,title);
							}
						</f>
						</call>
						if (!glocal.history){
							for (auto &x:glocal.mp){
								if (!bolixo_isdeleted(x.second.type)){
									glocal.entries.push_back(x.first);
									glocal.types.push_back(x.second.type);
									glocal.eventdates.push_back(x.second.eventdate);
									glocal.modified.push_back(x.second.modified);
									glocal.owners.push_back(x.second.owner);
									glocal.members.push_back(x.second.members);
									glocal.listmodes.push_back(x.second.listmode);
									glocal.sizes.push_back(x.second.size);
									glocal.titles.push_back(x.second.title);
								}
							}
						}
					}
				}
				if (entry.msg.size() > 0){
					glocal.entries.clear();
					glocal.types.clear();
					glocal.modified.clear();
					glocal.eventdates.clear();
					glocal.owners.clear();
					glocal.members.clear();
					glocal.listmodes.clear();
					glocal.sizes.clear();
					glocal.titles.clear();
					rep_listdir (false,entry.msg,glocal.entries,glocal.types,glocal.eventdates,glocal.modified,glocal.owners,glocal.members,glocal.listmodes,glocal.sizes,glocal.titles);
				}else{
					bod_trim (glocal.entries,offset,nb);
					bod_trim (glocal.types,offset,nb);
					bod_trim (glocal.modified,offset,nb);
					bod_trim (glocal.eventdates,offset,nb);
					bod_trim (glocal.owners,offset,nb);
					bod_trim (glocal.members,offset,nb);
					bod_trim (glocal.listmodes,offset,nb);
					bod_trim (glocal.sizes,offset,nb);
					bod_trim (glocal.titles,offset,nb);
					rep_listdir (true,"",glocal.entries,glocal.types,glocal.eventdates,glocal.modified,glocal.owners,glocal.members,glocal.listmodes,glocal.sizes,glocal.titles);
				}
			</f>
			<f create_group_list> // sessionid listname owner = success:b msg
				<call bo_writed_client_create_group_list>(glocal.con,sessionid,listname,owner);
				<f ok>
					glocal.bod_client.rep_create_group_list(success,msg);
				</f>
				</call>
			</f>
			<f create_group> // sessionid groupname owner = success:b msg
				<call bo_writed_client_create_group>(glocal.con,sessionid,groupname,owner);
				<f ok>
					glocal.bod_client.rep_create_group(success,msg);
				</f>
				</call>
			</f>
			<f set_group>	// sessionid listname groupname defaultaccess owner = success:b msg
				<call bo_writed_client_set_group>(glocal.con,sessionid,listname,groupname,defaultaccess,owner);
				<f ok>
					glocal.bod_client.rep_set_group(success,msg);
				</f>
				</call>
			</f>
			<f set_member>	// sessionid groupname user defaultaccess owner = success:b msg
				<call bo_writed_client_set_member>(glocal.con,sessionid,groupname,user,access,role,owner);
				<f ok>
					glocal.bod_client.rep_set_member(success,msg);
				</f>
				</call>
			</f>
			<f delete_list>	// sessionid listname owner = success:b msg
				<call bo_writed_client_delete_list>(glocal.con,sessionid,listname,owner);
				<f ok>
					glocal.bod_client.rep_delete_list(success,msg);
				</f>
				</call>
			</f>
			<f delete_group> // sessionid groupname owner = success:b msg
				<call bo_writed_client_delete_group>(glocal.con,sessionid,groupname,owner);
				<f ok>
					glocal.bod_client.rep_delete_group(success,msg);
				</f>
				</call>
			</f>
			<f list_lists>	//  sessionid owner = success:b msg lists:v groups:vv access:v
				glocal string msg = "Invalid session";
				glocal vector<string> lists;
				glocal vector<vector<string>> groups;
				glocal vector<vector<string>> access;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal string last_list;
					<call sql_query>("select group_lists.name,groups.name,group_list_members.defaultaccess"
						" from group_lists"
						" left join group_list_members on group_lists.id=group_list_members.group_list_id"
						" left join groups on group_list_members.groupid=groups.id"
						" where group_lists.ownerid=%u",userid);
					<f onerow>
						if (strcmp(glocal.last_list.c_str(),row[0])!=0){
							glocal.last_list = row[0];
							glocal.lists.push_back(glocal.last_list);
							glocal.groups.push_back(vector<string>());
							glocal.access.push_back(vector<string>());
						}
						if (row[1] != NULL && row[2] != NULL){
							unsigned last = glocal.groups.size()-1;
							glocal.groups[last].push_back(row[1]);
							glocal.access[last].push_back(row[2]);
						}
						glocal.msg = "";
					</f>
					<f empty>
						glocal.msg = "No list";
					</f>
					</call>
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.lists.clear();
					glocal.groups.clear();
					glocal.access.clear();
				}
				rep_list_lists (ret,glocal.msg,glocal.lists,glocal.groups,glocal.access);
			</f>
			<f list_groups>	// sessionid owner = success:b msg groups:v users:vv access:vv
				glocal string msg = "Invalid session";
				glocal vector<string> groups;
				glocal vector<vector<string>> users;
				glocal vector<vector<string>> access;
				glocal vector<vector<string>> roles;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal string last_group;
					<call sql_query>("select groups.name,id2name.name,group_members.access,group_members.role"
						" from groups"
						" left join group_members on groups.id=group_members.groupid"
						" left join id2name on group_members.userid=id2name.userid"
						" where groups.ownerid=%u",userid);
					<f onerow>
						if (strcmp(glocal.last_group.c_str(),row[0])!=0){
							glocal.last_group = row[0];
							glocal.groups.push_back(glocal.last_group);
							glocal.users.push_back(vector<string>());
							glocal.access.push_back(vector<string>());
							glocal.roles.push_back(vector<string>());
						}
						if (row[1] != NULL && row[2] != NULL){
							unsigned last = glocal.groups.size()-1;
							glocal.users[last].push_back(row[1]);
							glocal.access[last].push_back(row[2]);
							const char *role = row[3];
							if (role == NULL) role = "";
							glocal.roles[last].push_back(role);
						}
						glocal.msg = "";
					</f>
					<f empty>
						glocal.msg = "No list";
					</f>
					</call>
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.groups.clear();
					glocal.users.clear();
					glocal.access.clear();
					glocal.roles.clear();
				}
				rep_list_groups (ret,glocal.msg,glocal.groups,glocal.users,glocal.access,glocal.roles);
			</f>
			<f list_inboxes> // sessionid owner = success:b msg inboxes:v
				glocal string msg = "Invalid session";
				glocal vector<string> managers;
				glocal vector<string> projects;
				glocal vector<string> roles;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, glocal.msg);
				if (userid != 0){
					glocal.msg = "";
					vector<unsigned> listids;
					fs_list_inboxes (userid,glocal.managers,glocal.projects,glocal.roles,listids);
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.managers.clear();
					glocal.projects.clear();
					glocal.roles.clear();
				}
				rep_list_inboxes (ret,glocal.msg,glocal.managers,glocal.projects,glocal.roles);
			</f>
			<f list_msgs> // sessionid owner deleted:b offset:u nb:u = success:b msg managers:v projects:v roles:v uuids:v titles:v submits:v 
				glocal string msg = "Invalid session";
				glocal vector<string> managers;
				glocal vector<string> projects;
				glocal vector<string> roles;
				glocal vector<string> uuids;
				glocal vector<string> titles;
				glocal vector<string> submits;
				string username;
				unsigned userid = bo_writed_get_group_owner (glocal.con_sess, sessionid, owner, username, glocal.msg);
				if (userid != 0){
					glocal.msg = "";
					ENTRY entry;	
					entry.userid = userid;
					string inbox = string_f("/msgs/%s/inbox",username.c_str());
					if (fs_findentry(inbox,entry,true,END_OF_TIME)==-1){
						glocal.msg = entry.msg;
					}else{
						<call sql_query>("select name,files.title,dirs_content.modified"
							" from dirs_content"
							" join files on files.id = dirs_content.itemid and files.modified = dirs_content.modified"
							" where dirid=%u and type=%u order by eventtime desc limit %u,%u",entry.entryid,ENTRY_FILE,offset,nb);
						<f onerow>
							glocal.managers.push_back("");
							glocal.projects.push_back("");
							glocal.roles.push_back("");
							glocal.uuids.push_back(row[0]);
							glocal.titles.push_back(row[1]);
							glocal.submits.push_back(row[2]);
						</f>
						</call>
					}
					vector<unsigned> listids;
					vector<string> managers,projects,roles;
					fs_list_inboxes (userid,managers,projects,roles,listids);
				}
				bool ret = true;
				if (glocal.msg.size() > 0){
					ret = false;
					glocal.managers.clear();
					glocal.projects.clear();
					glocal.roles.clear();
					glocal.uuids.clear();
					glocal.titles.clear();
					glocal.submits.clear();
				}
				rep_list_msgs (ret,glocal.msg,glocal.managers,glocal.projects,glocal.roles,glocal.uuids,glocal.titles,glocal.submits);
			</f>
			<f sendmsg> // sessionid owner recipients:v title content = success:b msg msgid
				<call bo_writed_client_sendmsg>(glocal.con,sessionid,owner,recipients,title,content);
				<f ok>
					glocal.bod_client.rep_sendmsg(success,msg,msgid);
				</f>
				</call>
			</f>
			<f sendmsg_project> // sessionid owner manager project role title content = success:b msg msgid
				<call bo_writed_client_sendmsg_project>(glocal.con,sessionid,owner,manager,project,role,title,content);
				<f ok>
					glocal.bod_client.rep_sendmsg_project(success,msg,msgid);
				</f>
				</call>
			</f>
			<f replymsg> // sessionid owner msgid recipients:v title content = success:b msg replyid
				<call bo_writed_client_replymsg>(glocal.con,sessionid,owner,msgid,recipients,title,content);
				<f ok>
					glocal.bod_client.rep_replymsg(success,msg,replyid);
				</f>
				</call>
			</f>
			<f replymsg_project> // sessionid owner manager project role msgid title content = success:b msg replyid
				<call bo_writed_client_replymsg_project>(glocal.con,sessionid,owner,manager,project,role,msgid,title,content);
				<f ok>
					glocal.bod_client.rep_replymsg_project(success,msg,replyid);
				</f>
				</call>
			</f>
			<f sendattach> // sessionid owner msgid content:o more:b = success:b msg handle
				<call bo_writed_client_sendattach>(glocal.con,sessionid,owner,msgid,content,more);
				<f ok>
					glocal.bod_client.rep_sendattach(success,msg,handle);
				</f>
				</call>
			</f>
			<f invalid>
				tlmp_error ("CLIENT: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}else if (c->type == TYPE_ADMIN){
			glocal.nbrequest_admin++;
			<call bod_admin>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
			<f test>
				glocal bool sessiond1=false;
				glocal bool sessiond2=false;
				glocal bool writed = false;
				glocal bool bdfiles1 = false;
				glocal bool bdfiles2 = false;
				glocal bool bdusers = false;
				glocal bool internal_error1 = false;
				<call bo_sessiond_client_test>(glocal.con_sess);
				<f ok>
					glocal.internal_error1 = internal_error;
					glocal.sessiond1 = success;
				</f>
				</call>
				<call bo_writed_client_test>(glocal.con);
				<f ok>
					glocal.writed = !internal_error;
					glocal.sessiond2 = sessiond;
					glocal.bdusers = bdusers;
					glocal.bdfiles2 = bdfiles;
				</f>
				</call>
				<call sql_query>("select count(*) from id2name");
				<f onerow>
					glocal.bdfiles1=true;
				</f>
				</call>
				glocal.bod_admin.rep_test(glocal.internal_error1
					,glocal.writed,glocal.bdfiles1,glocal.bdfiles2,glocal.bdusers
					,glocal.sessiond1,glocal.sessiond2);
			</f>
			<f invalid>
				tlmp_error ("ADMIN: Invalid command: %s\n",line);
				endclient = true;
			</f>
			</call>
		}
	</f>
	</obj>
	bool some_errors = false;
	if (control != NULL && fdpass_setcontrol(s,control,user)==-1){
		some_errors = true;
	}
	if (s.listen(NULL,glocal.unixportadmin)==-1){
		tlmp_error ("Can't setup socket on %s (%s)\n",glocal.unixportadmin,strerror(errno));
		some_errors = true;
	}


	if (!some_errors && s.is_ok()){
		chmod (glocal.unixportclient.c_str()+5,0666);
		chmod (glocal.unixportadmin.c_str()+5,0666);
		s.setrawmode (true);
		if (daemon){
			daemon_init(pidfile,user);
		}
		s.loop();
		ret = 0;
	}
	return ret;
}
</mod>
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *admin_secretfile = "/etc/bolixo/secrets.admin";
	glocal const char *client_secretfile = "/etc/bolixo/secrets.client";
	glocal const char *bind = "0.0.0.0";
	glocal const char *port = "9000";
	glocal const char *control = "/var/run/bod.sock";
	glocal const char *adminhost = "127.0.0.3";
	glocal const char *adminport = "9100";
	glocal const char *sesshost = "127.0.0.4";
	glocal const char *sessport = "9200";
	glocal const char *user = "bolixo";
	glocal const char *mysecret = NULL;
	glocal const char *dbserv = "localhost";
	glocal const char *dbname = "trli";
	glocal const char *dbuser = NULL;
	glocal const char *sql_tcpport = NULL;
	glocal bool daemon = false;
	glocal int workers = 1;
	glocal const char *pidfile = "/var/run/bod.pid";

	signal (SIGPIPE,SIG_IGN);
	glocal.ret = <call tlmpprogram>(argc,argv,"tlmpsql");
	<f init>
		setproginfo ("bod",VERSION,"Implement all business logic");
		setgrouparg ("Networking");
		setarg ('b',"bindaddr","Bind to this address (TCP)",glocal.bind,false);
		setarg ('p',"tcpport","Listen for command on this TCP port",glocal.port,false);
		setarg ('c',"control","Unix socket for trlid-control",glocal.control,false);
		setgrouparg ("Admin server");
		setarg (' ',"adminhost","Host running the bo-writed server",glocal.adminhost,false);
		setarg (' ',"adminport","Port to reach the bo-writed server",glocal.adminport,false);
		setarg (' ',"sesshost","Host running the bo-sessiond server",glocal.sesshost,false);
		setarg (' ',"sessport","Port to reach the bo-sessiond server",glocal.sessport,false);
		setarg (' ',"mysecret","Secret used to communicate with bo-writed",glocal.mysecret,true);
		setgrouparg ("Misc.");
		setarg (' ',"admin_secrets","File holding admin secrets for communication",glocal.admin_secretfile,false);
		setarg (' ',"client_secrets","File holding client secrets for communication",glocal.client_secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"workers","Number of sub-process to lauch",glocal.workers,false);
		setarg (' ',"pidfile","FIle holding the PID of the process",glocal.pidfile,false);
		setgrouparg ("Database");
		setarg (' ',"dbserv","Database server",glocal.dbserv,false);
		setarg (' ',"dbname","Database name",glocal.dbname,false);
		setarg (' ',"dbuser","Database user",glocal.dbuser,true);
		setarg (' ',"sqltcpport","Database TCP port",glocal.sql_tcpport,false);
	</f>
	<f showerror>
		glocal const char *msg = msg;
		<call savefile>("/tmp/err.log",true);
		<f dowrite>
			fprintf (fout,"%s\n",glocal.msg);
			return 0;
		</f>
		</call>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		glocal CONNECT_INFO con;
		glocal CONNECT_INFO con_sess;
		glocal map<string,string> admin_secrets;
		glocal map<string,string> client_secrets;
		fdpass_readsecrets (glocal.client_secretfile,glocal.client_secrets);
		fdpass_readsecrets (glocal.admin_secretfile,glocal.admin_secrets);
		//glocal.con.host = glocal.adminhost;
		glocal.con.port = glocal.adminport;
		glocal.con.secret = glocal.mysecret;
		glocal.con.bind = glocal.bind;
		//glocal.con_sess.host = glocal.sesshost;
		glocal.con_sess.port = glocal.sessport;
		glocal.con_sess.secret = glocal.mysecret;
		glocal.con_sess.bind = glocal.bind;
		if (glocal.sql_tcpport != NULL) nsql_settcpport (atoi(glocal.sql_tcpport));
		{
			const char *dbpass = getenv("BOD_PWD");
			if (dbpass == NULL){
				tlmp_error ("Can't get database password from environment,aborting\n");
				exit (-1);
			}
			query_setdefaultdb (glocal.dbserv,glocal.dbname,glocal.dbuser,dbpass);
		}

		int ret = -1;
		if (glocal.workers==1){
			ret = trlid_main (glocal.bind,glocal.port,glocal.control
				,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,glocal.daemon
				,glocal.admin_secrets,glocal.client_secrets);
		}else{
			int port = atoi(glocal.port);
			for (int w=0; w<glocal.workers; w++){
				char portstr[10];
				snprintf (portstr,sizeof(portstr)-1,"%d",port+w);
				string control = string(glocal.control) + string_f("+%d",w);
				pid_t pid = fork();
				if (pid == (pid_t)0){
					ret = trlid_main (glocal.bind,portstr,control.c_str()
						,glocal.con,glocal.con_sess,glocal.user,glocal.pidfile,false
						,glocal.admin_secrets,glocal.client_secrets);
				}else if (pid == (pid_t)-1){
					tlmp_error("Can't fork (%s), aborting\n",strerror(errno));
					exit (-1);
				}else{
				}
			}
		}

		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

