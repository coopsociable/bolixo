/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Command line utility to manage bolixo servers
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlmplib.h>
#include <string>
#include <map>
#include "../bolixo.m"
#include <helper.h>

using namespace std;

#define _TLMP_procserver
struct _F_procserver{
	string home;
	string server;
	int ret = 0;
	void saveversion(PARAM_STRING version);
	string getversion() const;
	void fail();
	#define _F_procserver_doone(x) void x doone(const char *server, const char *path_pass, bool &end)
	virtual _F_procserver_doone( )=0;
};


void _F_procserver::fail()
{
	ret = -1;
}

<mod>
void _F_procserver::saveversion (PARAM_STRING version)
{
	glocal version;
	<call savefile>(string_f("%s/bolixo/%s.version",home.c_str(),server.c_str()),false);
	<f dowrite>
		fprintf (fout,"%s\n",glocal.version.ptr);
		return 0;
	</f>
	</call>
}
</mod>
<mod>
string _F_procserver::getversion () const
{
	glocal string version;
	<call loadfile>(string_f("%s/bolixo/%s.version",home.c_str(),server.c_str()),true);
	<f oneline>
		glocal.version = line;
		return 0;
	</f>
	</call>
	return glocal.version;
}
</mod>
static const char *gethome()
{
	const char *home = getenv("HOME");
	if (home == nullptr){
		tlmp_error (MSG_U(E_NOHOME,"No HOME variable, can't continue\n"));
		exit (-1);
	}
	return home;
}
<mod>
static int procserver(_F_procserver &c, int argc, char **argv)
{
	glocal bool end = false;
	glocal c;
	glocal const char *home = gethome();
	c.home = glocal.home;
	for (int i=0; i<argc && !glocal.end; i++){
		const char *arg = argv[i];
		string path_lst = string_f("%s/bolixo/%s.lst",glocal.home,arg);
		if (file_type(path_lst.c_str())==0){
			<call loadfile>(path_lst,true);
			<f oneline>
				if (line[0] != '\0'){
					string path_pass = string_f("%s/bolixo/%s.pass",glocal.home,line);
					if (file_type(path_pass.c_str())==0){
						glocal.c.server = line;
						glocal.c.doone (line,path_pass.c_str(),glocal.end);
					}else{
						tlmp_error (MSG_U(E_NOFILE,"File %s does not exist, can't continue\n"),path_pass.c_str());
						glocal.end = true;
					}
				}
				return glocal.end ? -1 : 0;
			</f>
			</call>
		}else{
			string path_pass = string_f("%s/bolixo/%s.pass",glocal.home,arg);
			if (file_type(path_pass.c_str())==0){
				glocal.c.server = arg;
				c.doone (arg,path_pass.c_str(),glocal.end);
			}else{
				tlmp_error (MSG_R(E_NOFILE),path_pass.c_str());
				glocal.end = true;
			}
		}
	}
	return c.ret;
}
</mod>

static void banner (const char *server)
{
	printf ("-------------------- %s\n",server);
}

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal bool getexpdate = false;
	glocal bool renew = false;
	glocal bool printexpdate = false;
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("bo-remote-manage",VERSION
			,"certificate options server ...\n"
			 "prepare-restart server ...\n"
			 "restart server ...\n"
			 "start server ...\n"
			 "stop server ...\n"
			 "update  server ...\n"
			 "update-restart  server ...\n"
			 "version server ...\n"
			 "listversion server ...\n"
			);
		setgrouparg(MSG_U(I_CERTOPTS,"Certificate command options"));
		setarg (' ',"renew",MSG_U(O_RENEW,"Renew certificate"),glocal.renew,false);
		setarg (' ',"getexpdate",MSG_U(I_GETEXPDATE,"Retrieve certificate expiration date from server"),glocal.getexpdate,false);
		setarg (' ',"printexpdate",MSG_U(I_PRINTEXPDATE,"Print expiration dates for servers"),glocal.printexpdate,false);
	</f>
	<f main>
		int ret = -1;
		glocal const char *cmd = argv[0];
		if (is_any_of(glocal.cmd,"stop","start","restart","prepare-restart")){
			ret = <call procserver>(argc-1,argv+1);
			<f doone>
				banner (server);
				int ret = 0;
				if (!is_eq(glocal.cmd,"stop")){
					string cmd = string_f("scp %s root@%s:/root/keysd.pass",path_pass,server);
					printf ("cmd=%s\n",cmd.c_str());
					ret = system(cmd.c_str());
				}
				if (ret == 0){
					if (!is_eq(glocal.cmd,"prepare-restart")){
						string cmd;
						if (is_eq(glocal.cmd,"restart")){	
							cmd = string_f("ssh root@%s bo restart most",server);
						}else if (is_eq(glocal.cmd,"start")){
							cmd = string_f("ssh root@%s /root/bolixostart.sh",server);
						}else if (is_eq(glocal.cmd,"stop")){
							cmd = string_f("ssh root@%s /root/bolixostop.sh",server);
						}
						printf ("cmd=%s\n",cmd.c_str());
						if (system(cmd.c_str())!=0){
							fail();
							end = true;
						}
					}
				}else{
					fail();
					end = true;
				}
			</f>
			</call>
		}else if (is_any_of(glocal.cmd,"update","update-restart")){
			ret = <call procserver>(argc-1,argv+1);
			<f doone>
				banner(server);
				vector<string> cmds;
				cmds.push_back(string_f("ssh root@%s \"rpm -Uvh /pkgs/* && rm -f /pkgs/* && bo update-script --doit && echo update done\"",server));
				//cmds.push_back(string_f("ssh root@%s rm -f /pkgs/*",server));
				//cmds.push_back(string_f("ssh root@%s bo update-script --doit",server));
				for (auto &cmd:cmds){
					printf ("cmd=%s\n",cmd.c_str());
					if (system(cmd.c_str())!=0){
						fail();
						end = true;
						break;
					}
				}
				if (!end){
					<call walkpopen>(string_f("ssh root@%s rpm -q bolixo",server),10);
					<f oneline>
						printf ("version=%s\n",line);
						glocal.procserver.saveversion (line);
						return 0;
					</f>
					</call>
					if (strcmp(glocal.cmd,"update-restart")==0){
						string cmd = string_f("scp %s root@%s:/root/keysd.pass",path_pass,server);
						printf ("cmd=%s\n",cmd.c_str());
						if (system(cmd.c_str())==0){
							cmd = string_f("ssh root@%s bo restart most",server);
							printf ("cmd=%s\n",cmd.c_str());
							if (system(cmd.c_str())!=0){
								fail();
								end = true;
							}
						}else{
							fail();
						}
					}
				}
			</f>
			</call>
		}else if (strcmp(glocal.cmd,"version")==0){
			ret = <call procserver>(argc-1,argv+1);
			<f doone>
				banner(server);
				<call walkpopen>(string_f("ssh root@%s rpm -q bolixo",server),10);
				<f oneline>
					printf ("version=%s\n",line);
					glocal.procserver.saveversion (line);
					return 0;
				</f>
				<f oneerr>
					tlmp_error ("%s: %s\n",command,line);
					glocal.procserver.fail();
					return 0;
				</f>
				</call>
			</f>
			</call>
		}else if (strcmp(glocal.cmd,"listversion")==0){
			ret = <call procserver>(argc-1,argv+1);
			<f doone>
				printf ("%s: %s\n",server,getversion().c_str());
			</f>
			</call>
		}else if (strcmp(glocal.cmd,"certificate")==0){
			if (!glocal.getexpdate && !glocal.renew && !glocal.printexpdate){
				tlmp_error (MSG_U(E_CERTOPT,"Option --getexpdate or --renew or --printexpdate must be selected\n"));
			}else{
				glocal bool changed = false;
				glocal map<string,string> expdates;
				string certlist = string_f("%s/bolixo/certificates.lst",gethome());
				<call loadfile>(certlist,true);
				<f oneline>
					vector<string> tb;
					str_splitline(line,' ',tb);
					if (tb.size()==2){
						glocal.expdates[tb[0]] = tb[1];
					}
					return 0;
				</f>
				<f missing>
				</f>
				</call>
				ret = <call procserver>(argc-1,argv+1);
				<f doone>
					glocal server;
					if (glocal.printexpdate){
						const char *expdate = MSG_U(I_UNKNOWN,"unknown");
						auto e = glocal.expdates.find(server);
						if (e != glocal.expdates.end()){
							expdate = e->second.c_str();
						}
						printf ("%s: %s\n",server,expdate);
					}else if (glocal.getexpdate){
						glocal bool this_server = false;	// The server may hold several certificates
											// alpha.bolixo.org also manages bolixo.org
						int ret = <call walkpopen>(string_f("ssh root@%s bo certificates",server),10);
						<f oneline>
							const char *pt;
							line = str_skip(line);
							if (is_start_any_of(line,pt,"Certificate Name:")){
								pt = str_skip(pt);
								glocal.this_server = is_eq(glocal.server,pt);
							}else if (glocal.this_server && is_start_any_of(line,pt,"Expiry Date:")){
								string date;
								str_copyword (date,pt);
								glocal.expdates[glocal.server] = date;
								glocal.changed = true;
							}
							return 0;
						</f>
						<f oneerr>
							tlmp_error ("%s: %s\n",command,line);
							//glocal.procserver.fail();
							return 0;
						</f>
						</call>
						if (ret < 0) fail();
					}else if (glocal.renew){
						vector<string> tb;
						tb.push_back(server);
						// Temp. bolixo.org is hosted on the same server as alpha.bolixo.org
						if (is_eq(server,"alpha.bolixo.org")) tb.push_back("bolixo.org");
						for (auto &s:tb){
							printf ("----------------- %s\n",s.c_str());
							int ret = <call walkpopen>(string_f("ssh root@%s bo certificate-renew doit %s",server,s.c_str()),10);
							<f oneline>
								printf ("%s\n",line);
								return 0;
							</f>
							<f oneerr>
								tlmp_error ("%s; %s\n",command,line);
								//glocal.procserver.fail();
								return 0;
							</f>
							</call>
							if (ret < 0) fail();
						}
					}
				</f>
				</call>
				if (glocal.changed){
					<call savefile>(certlist,false);
					<f dowrite>
						for (auto &m:glocal.expdates) fprintf (fout,"%s %s\n",m.first.c_str(),m.second.c_str());
						return 0;
					</f>
					</call>
				}
			}
		}else{
			usage();
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

