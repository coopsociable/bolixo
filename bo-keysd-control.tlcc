/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Command line tool to control bo-keysd
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <termios.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <trlitool.h>
#include "bolixo.h"

using namespace std;

#include "proto/bo-keysd_control.protoch"

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal unsigned nbrep=1;
	glocal const char *control = "/var/run/bo-keysd.sock";
	glocal.ret = <call tlmpprogram>(argc,argv);
	<f init>
		setproginfo ("bo-keysd-control",VERSION
			,"Command line tool to control bo-keysd\n"
			 "\n"
			 "\tcheckpassphrase pass-phrase\n"
			 "\tdebug 0/1\n"
			 "\tdebugfile filename\n"
			 "\tgenkey account\n"
			 "\tquit\n"
			 "\tsetpassphrase pass-phrase\n"
			 "\tsign usernum message\n"
			 "\tstatus\n"
			 "\twaitidle\n"
			);
		setarg ('p',"control","Unix socket to reach keysd",glocal.control,false);
		setgrouparg("tests");
		setarg ('r',"nbrep","Number of repetition (performance test)",glocal.nbrep,false);
	</f>
	<f main>
		glocal int ret = -1;
		CONNECT_INFO con;
		con.port = glocal.control;
		if (strcmp(argv[0],"status")==0 && argc==1){
			<call bo_keysd_control_status>(con);
			<f ok>
				glocal.ret = internal_error ? -1 : 0;
				for (auto x:lines) printf ("%s\n",x);
			</f>
			</call>
		}else if (strcmp(argv[0],"waitidle")==0 && argc==1){
			glocal bool done = false;
			while (!glocal.done){
				<call bo_keysd_control_runstatus>(con);
				<f ok>
					if (queuesize==0 && !running){
						glocal.done = true;
					}else{
						printf ("\tqueue size: %u\n",queuesize);
						sleep (1);
					}
				</f>
				</call>
			}
		}else if (strcmp(argv[0],"quit")==0 && argc==1){
			<call bo_keysd_control_quit>(con);
			<f ok>
				glocal.ret = internal_error ? -1 : 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"genkey")==0 && argc == 2){
			glocal CONNECT_INFO *con = &con;
			<call bo_keysd_control_genkey>(con,argv[1]);
			<f ok>
				if (status == ERR_CODE_NONE){
					// This is asynchronous. keysd is still working on it.
					// So we wait until all accounts size goes to 0.
					glocal bool done = false;
					while (!glocal.done){
						usleep(10000);
						<call bo_keysd_control_status>(*glocal.con);
						<f ok>
							for (auto x:lines){
								if (strcmp(x,"sub-process: not running")==0){
									glocal.done = true;
									break;
								}
							}
						</f>
						</call>
					}
					glocal.ret = 0;
				}else{
					tlmp_error ("status %d: %s\n",status,msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"sign")==0 && argc == 3){
			glocal string content = argv[2];
			if (glocal.content.size() > 0){
				size_t last = glocal.content.size()-1;
				if (glocal.content[last] != '\n') glocal.content += '\n';
			}
			for (unsigned i=0; i<glocal.nbrep; i++){
				<call bo_keysd_control_sign>(con,atoi(argv[1])
					,BOB_TYPE(glocal.content.c_str(),glocal.content.size(),false));
				<f ok>
					if (status == ERR_CODE_NONE){
						glocal.ret = 0;
						printf ("%s------\n%s\n",glocal.content.c_str(),sign);
					}else{
						tlmp_error ("status %d: %s\n",status,msg);
					}
				</f>
				</call>
			}
		}else if (strcmp(argv[0],"setpassphrase")==0 && (argc == 1 || argc == 2)){
			string pass;
			const char *env = getenv("KEYSDPASS");
			if (argc == 2){
				pass = argv[1];
			}else if (env != NULL){
				pass = env;
			}else{
				int fd = open ("/dev/tty",O_RDWR);
				if (fd == -1){
					tlmp_error ("Can't open /dev/tty (%s)\n",strerror(errno));
				}else{
					struct termios tio;
					if (tcgetattr(fd,&tio)!=-1){
						tio.c_lflag &= (~ECHO);
						tcsetattr(fd,TCSANOW,&tio);
					}
					static const char *prompt = "(keysd) Enter pass phrase : ";
					static const int len_prompt = strlen(prompt);
					write (fd,prompt,len_prompt);
					char line[1000];
					int len = read (fd,line,sizeof(line));
					if (len <= 0){
						tlmp_error ("No passphrase supplied, aborting\n");
						exit (-1);
					}else{
						int last = len - 1;
						if (line[last] == '\n') line[last] = '\0';
						pass = line;
					}
					tio.c_lflag |= ECHO;
					tcsetattr(fd,TCSANOW,&tio);
					write (fd,"\r\n",2);
					close (fd);
				}
			}
			<call bo_keysd_control_setpassphrase>(con,pass);
			<f ok>
				if (status == ERR_CODE_NONE){
					glocal.ret = 0;
				}else{
					tlmp_error ("status %d: %s\n",status,msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"checkpassphrase")==0 && (argc == 1 || argc == 2)){
			string pass;
			const char *env = getenv("KEYSDPASS");
			if (argc == 2){
				pass = argv[1];
			}else if (env != NULL){
				pass = env;
			}else{
				tlmp_error ("No pass phrase supplied, can't check\n");
				exit (-1);
			}
			<call bo_keysd_control_checkpassphrase>(con,pass);
			<f ok>
				if (status == ERR_CODE_NONE){
					glocal.ret = 0;
				}else{
					tlmp_error ("status %d: %s\n",status,msg);
				}
			</f>
			</call>
		}else if (strcmp(argv[0],"debug")==0 && argc==2){
			<call bo_keysd_control_debug>(con,atoi(argv[1]));
			<f ok>
				glocal.ret = internal_error ? -1 : 0;
			</f>
			</call>
		}else if (strcmp(argv[0],"debugfile")==0 && argc==2){
			<call bo_keysd_control_debugfile>(con,argv[1]);
			<f ok>
				glocal.ret = internal_error ? -1 : 0;
			</f>
			</call>
		}else{
			tlmp_error ("Invalid command: %s\n",argv[0]);
			usage();
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

