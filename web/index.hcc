#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <string.h>
#include <tlmpweb.h>
#include <tlmpnet.h>
#include <tlmplib.h>
#include <tlmpdoc.h>
#include <trlitool.h>
#include <string>
#include <algorithm>
#include "util.h"
#define DEFINE_TBFTYPE
#include "../bolixo.h"
#include "../bolixo.m"
#include <linuxconf/translat.h>

#define SECTION_NONE 0
extern DOC_ID section_none;
#define SECTION_TALK 1
extern DOC_ID section_talk;
#define SECTION_PROJECT 2
extern DOC_ID section_project;
#define SECTION_ACCOUNT 3
extern DOC_ID section_account;
#define SECTION_GROUPS 4
extern DOC_ID section_groups;
#define SECTION_PROJECTS 5
extern DOC_ID section_projects;
#define SECTION_CONTACTS 6
extern DOC_ID section_contacts;
#define SECTION_MAILS 7
extern DOC_ID section_mails;
#define SECTION_NBSECTIONS 8
extern void bolixo_doc (DOCUMENT_POINTER &, DOC_ID &jump);
extern void bolixo_doc_fr (DOCUMENT_POINTER &, DOC_ID &jump);

static WEBID ID_TALK("talk");
static WEBID ID_MAIL("mail");
static WEBID ID_PROJECT("project");
static WEBID ID_CONTACT("contact");
static WEBID ID_PRJTEXT("prjtext");
#define TAB_FORM "tab_form"

using namespace std;

#include "../proto/bod_client.protoch"
#include "../proto/bo-sessiond_client.protoch"

static const char *newscolor = "#DCDCDC";

static string w_session;
static W_SSTRING w_lang("lang");
static W_SSTRING w_public_dir("public_dir");
static W_UNSIGNED w_public_view("public_view");

static W_SSTRING w_folder("folder");
static W_SSTRING w_upload("upload");
static W_SSTRING w_accept("accept");
static W_SSTRING w_user("user");
static W_SSTRING w_list("list");
static W_SSTRING w_group("group");
static W_UNSIGNED w_add("add");
static W_SSTRING w_desc("desc");
static W_SSTRING w_group1("group1");
static W_SSTRING w_group2("group2");
static W_SSTRING w_group3("group3");
static W_SSTRING w_group4("group4");
static W_SSTRING w_access1("access1");
static W_SSTRING w_access2("access2");
static W_SSTRING w_access3("access3");
static W_SSTRING w_access4("access4");

static W_SSTRING w_image("image");
extern W_SSTRING w_webtable;
static map<string,unsigned> offsets;
static map<string,unsigned> currents;
enum WEBTAB_TYPE{
	WEBTAB_TYPE1, WEBTAB_TYPE2, WEBTAB_TYPE3, WEBTAB_TYPE4
};
struct WEBTAB{
	WEBTAB_TYPE type;
	string tab;	// Name of this tab in the webtab
	string title;
	int selorder;
	bool locked;	// Can't be deleted
	string state;	// It is a string set by the application and preserved
			// in the session manager. The state is passed back to the application
	void setargs(PARAM_STRING args){
		vector<string> tb;
		str_splitline(args.ptr,',',tb);
		for (auto &v:tb){
			const char *vs = v.c_str();
			const char *vs2 = vs+2;
			if (strncmp(vs,"f=",2)==0){
				selorder = atoi(vs2);
			}else if (strncmp(vs,"s=",2)==0){
				state = vs2;
			}else if (strncmp(vs,"t=",2)==0){
				title = vs2;
			}else if (strncmp(vs,"l=",2)==0){
				locked = atoi(vs2);
			}
		}
	}
	WEBTAB(){
		type = WEBTAB_TYPE1;
		selorder = 0;
		locked = false;
	}
	WEBTAB(WEBTAB_TYPE _type, PARAM_STRING _tab, PARAM_STRING _title, PARAM_STRING args){
		selorder = 0;
		type = _type;
		tab = _tab.ptr;
		title = _title.ptr;
		locked = false;
		setargs(args);
	}
	WEBTAB(PARAM_STRING _tab, PARAM_STRING args){
		selorder = 0;
		if (isdigit(_tab.ptr[0]) && _tab.ptr[1] == ':'){
			type = (WEBTAB_TYPE)(_tab.ptr[0] - '1');
			tab = _tab.ptr+2;
		}else{
			type = WEBTAB_TYPE1;
			tab  = _tab.ptr;
		}
		title.clear();
		locked = false;
		setargs(args);
	}
	bool operator < (const WEBTAB &n) const {
		bool ret = false;
		if (type < n.type){
			ret = true;
		}else if (type == n.type){
			ret = tab < n.tab;
		}
		return ret;
	}
};
static map<string,vector<WEBTAB>> tabs;
void webtab_init (const vector<SNAMEVAL_receive> &vals)
{
	for (auto &s:vals){
		// Split the name
		const char *pt = strchr(s.sname,':');
		if (pt != NULL){
			tabs[string(s.sname,pt)].push_back(WEBTAB(pt+1,s.sval));
		}
	}
}

static W_UNSIGNED w_order ("order");
static unsigned order = 0;
static W_UNSIGNED w_test("test");
static W_UNSIGNED w_robot("robot");
static W_SSTRING w_email("email");
static W_SSTRING w_password("password");

static W_SSTRING new_nickname("nickname");
static W_SSTRING new_email ("new_email");
static W_SSTRING new_password1 ("new_password1");
static W_SSTRING new_password2 ("new_password2");

static W_SSTRING w_content("content");
static W_SSTRING w_filename("filename");
static W_SSTRING w_confirm("confirm");

static const int step_main=1;
static const int step_login=2;
static const int step_adduser=3;
static const int step_logout=4;
static const int step_image=5;
// 6 unused
static const int step_projects=7;
static const int step_mails=8;
static const int step_talks=9;
static const int step_confirm=10;
static const int step_profile=11;
static const int step_doc=12;

static W_UNSIGNED w_webtab("webtab");
static W_SSTRING  w_webtab_add("webtab_add");

#define _TLMP_webtabs
struct _F_webtabs {
	bool redo;
	WEBTAB *curtab;
	const char *selected_id;
	string help_id;
	string help_title;
	_F_webtabs(){
		redo = false;
		curtab = NULL;
		selected_id = NULL;
	}
	void setid (PARAM_STRING id);	// Change the ID of the active TAB
	void sethelp();			// Set the context help button
	void sethelp(PARAM_STRING id, PARAM_STRING title);
	void settitle (PARAM_STRING title);	// Change the title of the active TAB
	void setstate (PARAM_STRING val);// Record some value for the active TAB
	void redotab ();		// Ask webtabs to redraw the current TAB
	bool selected(PARAM_STRING id);
	#define _F_webtabs_documents(x) void x documents()
	virtual _F_webtabs_documents( );
	#define _F_webtabs_docmain(x) void x docmain(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_docmain( )=0;
	#define _F_webtabs_doctype2(x) void x doctype2(const char *id, const char *formid, const char *state, const char *title)
	virtual _F_webtabs_doctype2( );
	#define _F_webtabs_doctype3(x) void x doctype3(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_doctype3( );
	#define _F_webtabs_doctype4(x) void x doctype4(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_doctype4( );
	#define _F_webtabs_init(x) void x init()
	virtual _F_webtabs_init( );
};
bool _F_webtabs::selected(PARAM_STRING id)
{
	return strcmp(selected_id,id.ptr)==0;
}
void _F_webtabs::setid (PARAM_STRING id)
{
	curtab->tab = id.ptr;
}
void _F_webtabs::sethelp ()
{
	help_id = "help";
	help_title = MSG_U(I_HELP,"Help");
}
void _F_webtabs::sethelp (PARAM_STRING id, PARAM_STRING title)
{
	help_id = id.ptr;
	help_title = title.ptr;
}
void _F_webtabs::settitle (PARAM_STRING title)
{
	curtab->title = title.ptr;
}
void _F_webtabs::setstate (PARAM_STRING state)
{
	curtab->state = state.ptr;
}
void _F_webtabs::redotab ()
{
	redo = true;
}
static string toupper (const char *s)
{
	string ret;
	while (*s != '\0'){
		ret += toupper(*s);
		s++;
	}
	return ret;
}
static void webtab_href_c (const char *title, const char *href, const char *color)
{
	htmlprintf ("<a href=\"#\" style=\"text-decoration:none\" onclick=formsubmit(\"%s\")><table bgcolor=\"%s\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>\n"
		,href,color,title);
}
static void webtab_aref_selected (const char *title, int tab)
{
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	webtab_href_c (title,href.c_str(),"#220022");
}
static void webtab_href (const char *title, PARAM_STRING href)
{
	webtab_href_c(title, href.ptr,"grey");	//"#33cc33");
}
static void webtab_aref (const char *title, int tab)
{
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	webtab_href (title,href);
}
static void webtab_aref (const char *title, int tab, const char *color)
{
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	webtab_href_c (title,href.c_str(),color);
}
void _F_webtabs::documents()
{
}
void _F_webtabs::doctype2(const char *id, const char *formid, const char *state, const char *title)
{
}
void _F_webtabs::doctype3(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::doctype4(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::init()
{
}
struct TABSEL {
	string id;
	unsigned no;	// Position in tabs
	TABSEL(){
		no = 0;
	}
};
#define WEBTAB_MARK '*'
<mod>
static void webtabs(_F_webtabs &c,
	const char *name,
	map<string,vector<WEBTAB>> &alltabs,
	bool may_delete,
	unsigned size[5])
{
	vector<WEBTAB> &tabs = alltabs[name];
	glocal bool may_delete = may_delete;
	int maxsel = -1;
	for (auto &t:tabs){
		if (t.selorder > maxsel) maxsel = t.selorder;
	}
	c.selected_id = "";
	c.init();
	if (w_webtab_add.isset()){
		// We are either adding a new tab or selecting an existing one.
		// While we look if the tab already exist, we de-select the others
		const char *ptid = w_webtab_add.c_str();
		const char *pt = ptid;
		WEBTAB_TYPE type = WEBTAB_TYPE1;
		if (isdigit(pt[0]) && pt[1] == ':'){
			type = (WEBTAB_TYPE)(pt[0]-'1');
			pt+=2;
			ptid = pt;
		}
		pt = strchr(pt,'~');
		string id,title;
		if (pt != NULL){
			id = string(ptid,pt-ptid);
			title = pt+1;
		}else{
			id = ptid;
			title = id;
		}
		bool found = false;
		for (auto &t:tabs){
			if (t.type == type){
				if (t.tab == id){
					found = true;
					t.selorder = ++maxsel;
					c.selected_id = t.tab.c_str();
				}
			}
		}
		if (!found){
			WEBTAB w(type,id,title,"");
			w.selorder = ++maxsel;
			tabs.push_back(w);
			// hack, do not sort the first locked tabs.
			for (auto t=tabs.begin(); t!= tabs.end(); t++){
				if (!t->locked){
					sort (t,tabs.end());
					break;
				}
			}
		}
		w_webtab = 0;
	}
	if (may_delete && w_webtab > 0 && (w_webtab & 1)==0){
		// A click on the X to delete one tab
		unsigned delete_tab = (w_webtab-1) / 2;
		unsigned nbtab = tabs.size();
		if (delete_tab < nbtab){
			const char *id = tabs[delete_tab].tab.c_str();
			tlmpweb_deleteform(id);
			tabs.erase (tabs.begin()+delete_tab);
			w_webtab = 0;
		}
	}
	glocal vector<WEBTAB> *tabs = &tabs;
	glocal const char *name = name;
	glocal WEBTAB *ptsel[4];
	for (unsigned i=0; i<4; i++) glocal.ptsel[i] = NULL;
	for (unsigned type=0; type < 4; type++){
		unsigned no = 1;
		for (auto &t:tabs){
			if (w_webtab == no){
				t.selorder = maxsel;
				c.selected_id = t.tab.c_str();
				maxsel++;
			}
			no+=2;
		}
	}
	// Assign the selected tab if none is selected
	for (unsigned type=0; type < 4; type++){
		WEBTAB *cur = NULL;
		int maxorder = -1;
		unsigned no = 1;
		for (auto &t:tabs){
			if (t.type == type){
				if (t.selorder > maxorder){
					cur = &t;
					maxorder = t.selorder;
				}
			}
			no+=2;
		}
		glocal.ptsel[type] = cur;
	}
	bool draw_ok = true;
	if (!tlmpweb_get_output_state()){
		// PATCH
		// This is a trick to allow the webtable::click system to work
		// inside a vframe2h. We assume this is only used on the right side for now.
		draw_ok = false;
	}

	// We draw the tab content before drawing the tabs because the tabs may change
	vector<string> lines[4];
	for (int type=3; type>=0; type--){
		if (glocal.ptsel[type] != NULL){
			if (draw_ok) tlmpweb_pushgrab(lines[type]);
			WEBTAB *ptt = glocal.ptsel[type];
			while (1){
				unsigned no=1;
				for (auto &t:*glocal.tabs){
					if (&t == ptt) w_webtab = no;
					no += 2;
				}
				FORM_HIDDEN t(w_webtab);
				const char *id = ptt->tab.c_str();
				const char *formid = id;
				const char *end = strchr(id,WEBTAB_MARK);
				string tmp;
				if (end != NULL){
					tmp = string(id,end-id);
					id = tmp.c_str();
				}
				c.curtab = ptt;
				const char *state = ptt->state.c_str();
				if (type == WEBTAB_TYPE1){
					c.docmain(id,formid,state);
				}else if (type == WEBTAB_TYPE2){
					c.doctype2(id,formid,state,ptt->title.c_str());
				}else if (type == WEBTAB_TYPE3){
					c.doctype3(id,formid,state);
				}else if (type == WEBTAB_TYPE4){
					c.doctype4(id,formid,state);
				}else{
					c.docmain(id,id,state);
				}
				if (!draw_ok) break;
				if (!c.redo) break;
				c.redo = false;
				lines[type].clear();
			}
			if (draw_ok) tlmpweb_popgrab();
		}
	}
	if (draw_ok){
		DIV sc; sc.w(100).dispflex().flowrow().align("stetch").bg("Dodge-Blue").print();
		vector<string> docs;
		tlmpweb_pushgrab(docs);
		c.documents();
		tlmpweb_popgrab();
		if (docs.size() > 0){
			DIV d; d.id("tab").flexfixe().bg("pink").w(size[0]).h(60).print();
			htmlout(docs);
		}
		glocal const char *help_id = c.help_id.c_str();
		glocal const char *help_title = c.help_title.c_str();
		for (unsigned type=0; type <4; type++){
			unsigned sz = size[type+1];
			if (sz != 0){
				DIV c; c.flexfixe().w(sz).bg("lightblue").print();
				DIV cc("tabs","tab"); cc.dispflex().flowcol().bg("gray").print();
				DIV top("","tabs"); top.align("flex-start").flexfixe().print();
				glocal unsigned type = type;
				<call button_row>(0,"white");
				<f draw>
					unsigned no = 1;
					for (auto &t:*glocal.tabs){
						if (t.type == glocal.type){
							split();
							const char *name = t.title.c_str();
							if (name[0] == '\0') name = t.tab.c_str();
							if (&t == glocal.ptsel[glocal.type]){
								webtab_aref_selected (name,no);
							}else{
								webtab_aref (name,no);
							}
							if (!t.locked && glocal.may_delete){
								split();
								webtab_aref("x",no+1,"lightgrey");
							}
						}
						no += 2;
					}
				</f>
				<f draw_right>
					if (glocal.help_id[0] != '\0'){
						split();
						url_self (string_f("webtab_add=2:%s~%s",glocal.help_id,glocal.help_title),"?");
						/- &nbsp;
					}
				</f>
				</call>
				top.end();
				DIV mi; mi.bg("pink").align("flex-start").flexgrow().print();
				htmlout (lines[type]);
				glocal.help_id = "";
			}
		}
		// /- </table>
		// /- </div>
	}
}
</mod>
void webtabs(_F_webtabs &c,
	const char *name,
	map<string,vector<WEBTAB>> &tabs,
	unsigned size[5])
{
	webtabs (c,name,tabs,true,size);
}
void webtabs(_F_webtabs &c,
	const char *name,
	const vector<string> &starttabs,
	map<string,vector<WEBTAB>> &alltabs,
	unsigned size[5])
{
	vector<WEBTAB> &tabs = alltabs[name];
	for (auto &s:starttabs){
		bool found = false;
		string tmp;
		const char *tab = s.c_str();
		const char *title = "";
		const char *pt = strchr(tab,'~');
		if (pt != NULL){
			title = pt + 1;
			tmp = string(tab,pt-tab);
			tab = tmp.c_str();
		}
		for (auto &w:tabs){
			if (strcmp(tab,w.tab.c_str())==0){
				w.title = title;
				w.locked = true;
				found = true;
				break;
			}
		}
		if (!found){
			WEBTAB w(WEBTAB_TYPE1,tab,title,"");
			w.locked = true;
			tabs.push_back(w);
		}
	}
	webtabs (c,name,alltabs,true,size);
}
struct _F_sendfile_common {
	string handle;
	bool success;
	void sethandle (PARAM_STRING handle);
	void setresult (bool success, PARAM_STRING msg);
};
void _F_sendfile_common::sethandle (PARAM_STRING _handle)
{
	handle = _handle.ptr;
}
void _F_sendfile_common::setresult (bool _success, PARAM_STRING msg)
{
	success = _success;
	if (!success) htmlprintf ("sendfile failed: %s<br>\n",msg.ptr);
}

#define _TLMP_sendfile
struct _F_sendfile: public _F_sendfile_common {
	#define _F_sendfile_start(x) void x start(const char *filepath, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_start( )=0;
	#define _F_sendfile_rest(x) void x rest(const string &handle, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_rest( )=0;
};

static void sendfile(_F_sendfile &c, PARAM_STRING filepath, PARAM_STRING localfile, bool &fail)
{
	c.success = true;
	FILE *fin = fopen (localfile.ptr,"r");
	if (fin == NULL){
		htmlprintf ("Internal error reading temp file: :%s:<br>\n",localfile.ptr);
		fail = true;
	}else{
		char buf[40000];
		size_t nb = fread (buf,1,sizeof(buf),fin);
		bool more = (nb == sizeof(buf));
		c.start (filepath.ptr,BOB_TYPE(buf,nb,false),more);
		if (more && c.success){
			if (c.handle.empty()){
				tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
				htmlprintf ("Internal error, sendfile has not handle<br>\n");
			}else{
				while (more && c.success){
					nb = fread (buf,1,sizeof(buf),fin);
					more = (nb == sizeof(buf));
					c.rest (c.handle,BOB_TYPE(buf,nb,false),more);
				}
			}
		}
		fclose (fin);
	}
	if (!c.success) fail = true;
}
#define _TLMP_sendfile_var
struct _F_sendfile_var: public _F_sendfile_common {
	#define _F_sendfile_var_start(x) void x start(const char *filepath, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_var_start( )=0;
	#define _F_sendfile_var_rest(x) void x rest(const string &handle, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_var_rest( )=0;
};
static void sendfile_var(_F_sendfile_var &c, PARAM_STRING filepath, const W_SSTRING &var_content, bool &fail)
{
	const char *content = var_content.c_str();
	c.success = true;
	unsigned len = strlen(content);
	unsigned nb = len;
	bool more = false;
	if (nb > 40000){
		nb = 40000;
		more = true;
	}
	c.start (filepath.ptr,BOB_TYPE(content,nb,false),more);
	if (more && c.success){
		if (c.handle.empty()){
			tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
			htmlprintf ("Internal error, sendfile has not handle<br>\n");
		}else{
			unsigned offset = nb;
			while (offset < len && c.success){
				nb = len - offset;
				more = false;
				if (nb > 40000){
					nb = 40000;
					more = true;
				}
				c.rest (c.handle,BOB_TYPE(content+offset,nb,false),more);
				offset += nb;
			}
		}
	}
	if (!c.success) fail = true;
}
	

static void show_buttons_right(_F_websteps *c)
{
	int step = c->getcurstep();
	/- <table border=0 cellspacing=0>
	/- <tr>
		
	bool is_user = userinfo.name.size() > 0;
	if (!is_user){
		if (step != step_login && step != step_adduser){
			/- <td>
			/- <font size=4 color=lightgray>
			htmlprintf (MSG_U(I_ANONYMOUS,"Anonymous, for your eyes only"));
			/- </font>
			/- <td>&nbsp;
			/- <td>
			print_aref (MSG_U(I_LOGIN,"Login"),step_login);
			/- <td>&nbsp;
			/- <td align=center>
			/- <font size=4 color=black>or</font>
			/- <td>&nbsp;
			/- <td>
			print_aref (MSG_U(I_CREATEACCT,"Create account"),step_adduser);
		}
	}
	if (userinfo.is_admin){
		/- <td>
		string tmp = string_f ("href=%s/admin.hc style=\"text-decoration:none\"",tlmpweb_curdir());
		print_href("Admin menu",tmp);
	}
	if (is_user){
		/- <td>
		/- <font size=4 color=gray>
		htmlprintf (MSG_U(I_WELCOME,"Welcome %s"),userinfo.name.c_str());
		int nb = 40 - userinfo.name.size() - 8; 
		for (int i=0; i<nb; i++){
			htmlprintf ("&nbsp;");
		}
		/- </font>
		/- <td>&nbsp;
		/- <td>
		print_aref (MSG_U(I_LOGOUT,"Logout"),step_logout);
	}
	/- </table>
}


static unsigned subject = 0;
const unsigned max_subject=7;

static void print_button (const char *title, int step, int curstep)
{
	if (step == curstep){
		print_aref_selected (title,step);
	}else{
		print_aref (title,step);
	}
}
struct CURRENTFORM{
	string id;
	vector<string> vars;
};
static vector<CURRENTFORM> currentforms;
<mod>
static void bolixo_title (const char *title, _F_websteps *c)
{
	glocal int step = c->getcurstep();

	string tmp = string_f ("Bolixo: %s",title);
	tlmpweb_title (tmp.c_str());
	util_google_code();
	util_defstyles();
	tlmpweb_body("white",NULL);
	
	DIV main; main.id("main").h(100).w(100).dispflex().flowcol().print();
	DIV head; head.id("head").flexfixe().print();
	/- <table border=0 width=100%><tr><td>
	htmlprintf ("<table border=0 width=100%% bgcolor=%s cellspacing=0><tr><td rowspan=2 align=left>\n",newscolor);
		/- <table border=0><tr><td><a href=/7s.html style=\"text-decoration:none\"><img src=/favicon.ico></a></td><td align=left>
		htmlout ("<a href=/index.hc style=\"text-decoration:none\"><font size=8 color=\"white\">Bolixo.org</font></a>&nbsp;&nbsp;&nbsp;");
		htmlprintf ("screen %u %u f=%u\n",tlmpweb_screenwidth(),tlmpweb_screenheight(),tlmpweb_fontsize());
		/- <td>
		if (userinfo.name.empty()) printhref ("/about.html",MSG_U(I_ABOUT,"<font color=white>A peer to peer open social media</font>"),true);
		/- </td></tr></table>
	/- </td><td align=right valign=top>
	show_buttons_right (c);
	/- </td></tr>
	/- <tr><td align=right>
	if (w_robot == 0 && userinfo.name.size() > 0){
		<call button_row>(0,newscolor,false);
		<f draw>
			split();
			print_button (MSG_U(M_MAIN,"Main"),1,glocal.step);
			split();
			print_button (MSG_U(M_TALK,"Talk"),step_talks,glocal.step);
			split();
			print_button (MSG_U(M_MAIL,"Mail"),step_mails,glocal.step);
			split();
			print_button (MSG_U(M_PROJECTS,"Projects"),step_projects,glocal.step);
			split();
			print_button (MSG_U(M_PROFILE,"Profile"),step_profile,glocal.step);
			split();
			print_button (MSG_U(M_DOCUM,"Documentation"),step_doc,glocal.step);
		</f>
		</call>
	}
	/- </tr></table>
	/- </table>
	head.end();
	DIV body; body.id("body").flexgrow().print();
	body.donotend();
	main.donotend();
}
</mod>
<mod>
static bool valid_context (CONNECT_INFO &con, _F_websteps *c, const char *subject, bool check_news, bool check_proof)
{
	glocal bool ret = true;
	if (userinfo.name.empty()){
		bolixo_title ("",c);
		/- <p>You must be logged to
		printf ("%s<p>\n",subject);
		/- You do not have an account, just create one (top right button).
		/- <br>
		/- It takes one minute.
		/- <p>
		/- See the 
		printhref_raw ("/terms-of-use.html","terms of use",false);
		/- &nbsp;for more details.
		glocal.ret = false;
	}
	return glocal.ret;
}
</mod>

static void trli_initvar (VAR &var, PARAM_STRING name, PARAM_STRING val)
{
	var.name = name.ptr;
	SNAMEVAL sval;
	sval.sval = val.ptr;
	var.vals.push_back(sval);
}

<mod>
static void trli_getsessioninfo(CONNECT_INFO &con, CONNECT_INFO &con_sess, vector<DOCUMENT_POINTER> &docpointers)
{
	glocal CONNECT_INFO *con = &con;
	glocal vector<DOCUMENT_POINTER> *docpointers = &docpointers;
	<call bo_sessiond_client_getsessioninfovars>(con_sess,w_session.c_str());
	<f ok>
		if (success){
			userinfo.lang = lang;
			if (lang[0] != '\0') translat_selectlang (lang);
			userinfo.name = name;
			userinfo.is_admin = admin;
			for (auto &var:vars){
				if (strcmp(var.name,"subject")==0 && var.vals.size()==1) subject=atoi(var.vals[0].sval);
				if (strcmp(var.name,"order")==0 && var.vals.size()==1) order=atoi(var.vals[0].sval);
				if (strcmp(var.name,"offsets")==0){
					for (auto &s:var.vals) offsets[s.sname] = atoi(s.sval);
				}else if (strcmp(var.name,"currents")==0){
					for (auto &s:var.vals) currents[s.sname] = atoi(s.sval);
				}else if (strcmp(var.name,"webtabs")==0){
					webtab_init (var.vals);
				}else if (strcmp(var.name,"document")==0){
					// Several document pointers are stored in sequence, repeating the same variable names
					unsigned nodoc = 0;
					unsigned s1=0,s2=0,s3=0,s4=0;
					for (auto &v:var.vals){
						if (strcmp(v.sname,"s1")==0){
							s1 = atoi(v.sval);
						}else if (strcmp(v.sname,"s2")==0){
							s2 = atoi(v.sval);
						}else if (strcmp(v.sname,"s3")==0){
							s3 = atoi(v.sval);
						}else if (strcmp(v.sname,"s4")==0){
							s4 = atoi(v.sval);
							while (nodoc >= glocal.docpointers->size()) glocal.docpointers->push_back(DOCUMENT_POINTER());
							(*glocal.docpointers)[nodoc].set(s1,s2,s3,s4);
							(*glocal.docpointers)[nodoc].resetchanged();
							nodoc++;
						}
					}
						
				}else if (strcmp(var.name,"currentform")==0){
					CURRENTFORM form;
					for (auto &v:var.vals){
						if (strcmp(v.sname,"id")==0){
							if (form.id.size()>0){
								currentforms.push_back(form);
							}
							form.id = v.sval;
							form.vars.clear();
						}else if (strcmp(v.sname,"var")==0){
							form.vars.push_back(v.sval);
						}
					}
					if (form.id.size()>0){
						currentforms.push_back(form);
					}
				}else if (strcmp(var.name,"geometry")==0){
					// We receive triplets: id,height,width
					WEBID id;
					unsigned height;
					for (auto &v:var.vals){
						if (strcmp(v.sname,"id")==0){
							id.set(v.sval);
						}else if (strcmp(v.sname,"height")==0){
							height = atoi(v.sval);
						}else if (strcmp(v.sname,"width")==0){
							tlmpweb_settablegeometry(id,height,atoi(v.sval));
						}
					}
				}
			}
			// Refresh the cookie so it is valid for 2 more days
			websession_setcookie("session",w_session.c_str(),time(NULL)+48*60*60);
		}else{
			userinfo.reset();
			<call bod_client_createsession>(*glocal.con);
			<f ok>
				w_session = sessionid;
				websession_setcookie("session",sessionid,time(NULL)+48*60*60);
			</f>
			</call>
		}
	</f>
	</call>
}
</mod>
static void index_doc (DOCUMENT_POINTER &pt, DOC_ID &jump)
{
	if (userinfo.lang == "eng"){
		bolixo_doc (pt,jump);
	}else{
		bolixo_doc_fr(pt,jump);
	}
}

static void button_validate(int step)
{
	htmlprintf ("<input type=\"submit\" value=\"Validate\" formaction=\"%s?webstep=%d&validate=1\">\n"
		,tlmpweb_curpage(),step);
}

<mod>
static void web_updateoffsets(CONNECT_INFO &con_sess)
{
	//if (w_webtable.isset() && w_offset.isset()){
	//	if (offsets[w_webtable.c_str()] != w_offset){
	//		offsets[w_webtable.c_str()] = w_offset;
			VAR var;
			var.name = "offsets";
			for (auto &v:offsets){
				SNAMEVAL val;
				val.sname = v.first;
				val.sval = string_f ("%u",v.second);
				var.vals.push_back(val);
			}
			<call bo_sessiond_client_setvar>(con_sess,w_session.c_str(),var);
			<f ok>
				if (!success) printf ("Can't set variable offset: %s\n",msg);
			</f>
			</call>
	//	}
	//}
}
</mod>
<mod>
static void web_updatecurrents(CONNECT_INFO &con_sess)
{
	VAR var;
	var.name = "currents";
	for (auto &v:currents){
		SNAMEVAL val;
		val.sname = v.first;
		val.sval = string_f ("%u",v.second);
		var.vals.push_back(val);
	}
	<call bo_sessiond_client_setvar>(con_sess,w_session.c_str(),var);
	<f ok>
		if (!success) printf ("Can't set variable current: %s\n",msg);
	</f>
	</call>
}
</mod>

/*
	Format a short message, remove the signature
*/
static string index_format_shortmsg (const char *txt, unsigned nblines)
{
	string ret;
	unsigned pos=0;
	unsigned noline=0;
	if (nblines == 0) nblines=(unsigned)-1;
	while (*txt != '\0' && noline < nblines){
		if (strncmp(txt,"------\n",7)==0){
			break;
		}else if (*txt == '<'){
			ret += "&lt;";
		}else if (*txt == '>'){
			ret += "&gt;";
		}else if (*txt == '\n'){
			ret += "<br>\n";
			pos=0;
			noline++;
		}else if (*txt == '\t'){
			unsigned nb = 4 - (pos%4);
			for (unsigned i=0; i<nb; i++) ret += "&nbsp;";
		}else{
			ret += *txt;
			pos++;
		}
		txt++;
	}
	return ret;
}
static string index_format_shortmsg (const char *txt)
{
	return index_format_shortmsg (txt,0);
}
<mod>
static void index_sendfile (CONNECT_INFO &con, PARAM_STRING filename, const char *filetype)
{
	glocal CONNECT_INFO *con = &con;
	glocal const char *filetype = filetype;
	<call bod_client_readfile_bob>(con,w_session.c_str(),filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
		}else{
			tlmpweb_doctype (glocal.filetype,size);
			htmlwrite (content.getbuffer(),content.getsize());
			glocal bool more = more;
			while (glocal.more){
				<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
				<f ok>
					htmlwrite (content.getbuffer(),content.getsize());
					glocal.more = more;
				</f>
				</call>
			}	
		}
	</f>
	</call>
}
<mod>
static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, string &text)
{
	glocal CONNECT_INFO *con = &con;
	glocal string *text = &text;
	glocal int ret = 0;
	text.clear();
	<call bod_client_readfile_bob>(con,w_session.c_str(),filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
			glocal.ret = -1;
		}else{
			(*glocal.text) = string((const char*)content.getbuffer(),content.getsize());
			glocal bool more = more;
			while (glocal.more && glocal.ret != -1){
				<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
				<f ok>
					if (!success){
						glocal.ret = -1;
						htmlprintf ("Can't read file: %s\n",msg);
					}else{
						(*glocal.text) += string((const char*)content.getbuffer(),content.getsize());
					}
					glocal.more = more;
				</f>
				</call>
			}	
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>

static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, W_SSTRING &text)
{
	string tmp;
	int ret = index_loadfile(con,filename,tmp);
	text = tmp;
	return ret;
}

</mod>
static void index_format_large_text(const BOB_TYPE &content)
{
	string tmp = string((const char*)content.getbuffer(),content.getsize());
	tmp = index_format_shortmsg (tmp.c_str());
	htmlwrite (tmp.c_str(),tmp.size());
}
<mod>
static void index_popup (CONNECT_INFO &con, const char *content, FILE_TYPE file_type, PARAM_STRING filepath)
{
	glocal CONNECT_INFO *con = &con;
	const char *path = filepath.ptr;
	if (content[0] != '\0'){
		tlmpweb_doctype ("text/html",0);
		const char *pt = content;
		while (*pt != '\0'){
			pt = format_line (pt);
			if (*pt == '\n'){
				htmlout ("<br>\n");
				pt++;
			}
		}
	}else if (file_is_sound(file_type)){
		htmlprintf ("<audio controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"audio/%s\">\n"
			"</audio>"
			,tlmpweb_curpage(),step_image,path,tbftype[file_type]);
	}else if (file_is_video(file_type)){
		htmlprintf ("<video width=\"800\" height=\"600\" controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"video/mp4\">\n"
			"Your browser does not support the video tag.\n"
			"</video>\n"
			,tlmpweb_curpage(),step_image,path);
	}else if (file_is_image(file_type)){
		htmlprintf ("<img width=800 src=%s?webstep=%u&image=%s>"
			,tlmpweb_curpage(),step_image,path);
	}else if (file_is_text(file_type)){
		<call bod_client_readfile_bob>(con,w_session.c_str(),path,"",false);
		<f ok>
			if (!success){
				htmlprintf ("Can't read file: %s\n",msg);
			}else{
				index_format_large_text (content);
				glocal bool more = more;
				while (glocal.more){
					<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
					<f ok>
						index_format_large_text (content);
						glocal.more = more;
					</f>
					</call>
				}	
			}
		</f>
		</call>
	}
}
</mod>
<mod>
static void index_markview (CONNECT_INFO &con, PARAM_STRING fname)
{
	<call bod_client_markview>(con,w_session.c_str(),fname);
	<f ok>
	</f>
	</call>
}
</mod>

<mod>
static void index_show_shortmsg(
	CONNECT_INFO &con,
	CONNECT_INFO &con_sess,
	const string &table,
	PARAM_STRING groupname,
	PARAM_STRING groupowner)
{
	glocal CONNECT_INFO *con = &con;
	glocal CONNECT_INFO *con_sess = &con_sess;
	glocal const char *groupname = groupname.ptr;
	glocal const char *groupowner = groupowner.ptr;
	if (offsets[table] == 0){
		index_markview (con,string_f("/msgs/%s/short-inbox/%s",glocal.groupowner,glocal.groupname));
	}
	<call webtable>(ID_TALK,table,"100%",currents[table],offsets[table],5);
	<f click>
		tlmpweb_flushheader();
		<call bod_client_list_talk>(*glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,noline,1);
		<f ok>
			if (messages.size()!=1){
				htmlprintf ("Internal error: %s\n",msg);
			}else{
				auto &m = messages[0];
				//htmlprintf ("uuid=%s<p>\n",m.uuid);
				index_popup (*glocal.con,m.content,m.file_type,string_f("/msgs/%s/short-inbox/%s/%s",glocal.groupowner,glocal.groupname,m.uuid));
			}
		</f>
		</call>
	</f>
	<f load>
		glocal unsigned rownum = nbskip;
		sethead (MSG_U(H_TALK,"From\tSubmit"));
		<call bod_client_list_talk>(*glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,nbskip,nblines);
		<f ok>
			if (!success){
				htmlprintf ("Error: %s %s<br>",internal_error?"Internal error":"",msg);
			}else{
				for (auto &m:messages){
					const char *func = "Popup";
					string path = string_f("/msgs/%s/short-inbox/%s/%s",glocal.groupowner,glocal.groupname,m.uuid);
					if (file_is_sound(m.file_type)){
						glocal.webtable.setclickopt (true,func,"400,100");
					}else if (file_is_video(m.file_type)){
						glocal.webtable.setclickopt (true,func,"800,800");
					}else if (file_is_image(m.file_type)){
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),"image"));
					}else if (file_is_text(m.file_type)){
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),"text"));
					}
					if (strcmp(m.from,userinfo.name.c_str())==0){
						glocal.webtable.setrow ("sep",glocal.rownum,"\t%s"
							,m.submit);
					}else{
						glocal.webtable.setrow ("sep",glocal.rownum,"<img width=30 src=%s?webstep=%u&image=/projects/%s/public/mini-photo.jpg>%s\t%s"
							,tlmpweb_curpage(),step_image,m.from,m.from
							,m.submit);
					}
					if (m.content[0] != '\0'){
						string tmp = index_format_shortmsg (m.content,5);
						glocal.webtable.setrow("image",glocal.rownum,"\t%s\a",tmp.c_str());
					}else if (file_is_sound(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,"\t<audio controls>\n"
							"<source src=\"%s?webstep=%u&image=%s\" type=\"audio/%s\">\n"
							"</audio>\a"
							,tlmpweb_curpage(),step_image,path.c_str(),tbftype[m.file_type]);
					}else if (file_is_image(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,"\t<img width=100 src=%s?webstep=%u&image=%s>\a\a\a"
							,tlmpweb_curpage(),step_image,path.c_str());
					}else if (file_is_video(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,
							"\t<video width=\"200\" height=\"200\" controls>\n"
							"<source src=\"%s?webstep=%u&image=%s\" type=\"video/mp4\">\n"
							"Your browser does not support the video tag.\n"
							"</video>\a"
							,tlmpweb_curpage(),step_image,path.c_str());
					}else if (file_is_text(m.file_type)){
						// Large text file
						<call bod_client_readfile_bob>(*glocal.con,w_session.c_str(),path,"",true);
						<f ok>
							if (!success){
								htmlprintf (MSG_U(E_CANTREADFILE,"Can't read file: %s\n"),msg);
							}else{
								string tmp = string((const char*)content.getbuffer(),content.getsize());
								tmp = index_format_shortmsg (tmp.c_str(),5);
								glocal.webtable.setrow("image",glocal.rownum,"\t%s\a",tmp.c_str());
							}
						</f>
						</call>
					}
					glocal.rownum++;
				}
			}
		</f>
		</call>
	</f>
	</call>
}
</mod>

/*
	Define a form field to edit the access of a group within a list
*/
static void index_field_access (_F_form *c, W_VAR &var)
{
	c->field_list (var,"");
	c->field_list_item ("",MSG_U(I_INHERIT,"inherit"));
	c->field_list_item ("R",MSG_U(I_READONLY,"read-only"));
	c->field_list_item ("W",MSG_U(I_READWRITE,"read-write"));
	c->field_list_end();
}
static void index_field_group (_F_form *c, W_VAR &var, const vector<string> &groups)
{
	c->field_list (var,"");
	c->field_list_item("","");
	for (auto &s:groups) c->field_list_item (s.c_str(),s.c_str());
	c->field_list_end();
}


/*
	Update a group definition in a list
*/
<mod>
static void index_set_group (CONNECT_INFO &con, W_SSTRING &list, const char *group, const char *access, bool &fail)
{
	glocal bool fail = false;
	glocal const char *groupname = group;
	<call bod_client_set_group>(con,w_session.c_str(),list.c_str(),glocal.groupname,access,"");
	<f ok>
		if (!success){
			htmlprintf (MSG_U(E_UPDGROUP,"Failure to update group %s: %s<br>\n"),glocal.groupname,msg);
			glocal.fail = true;
		}
	</f>
	</call>
	if (glocal.fail) fail = true;
}
</mod>
static void index_set_group (CONNECT_INFO &con, W_SSTRING &list, W_SSTRING &group, W_SSTRING &access, vector<string> &groups, bool &fail)
{
	const char *groupname = group.c_str();
	if (groupname[0] != '\0'){
		groups.push_back(groupname);
		index_set_group (con,list,groupname,access.c_str(),fail);
	}
}

static void index_delete_new_from_old(const vector<string> &news, vector<string> &old)
{
	for (auto &n:news){
		auto p = find(old.begin(),old.end(),n);
		if (p != old.end()){
			old.erase(p);
		}
	}
}
<mod>
static ENTRY_TYPE index_entrytype(CONNECT_INFO &con,PARAM_STRING path, FILEINFO &info)
{
	glocal FILEINFO *info = &info;
	<call bod_client_stat>(con,w_session.c_str(),path,"");
	<f ok>
		(*glocal.info) = file;
	</f>
	</call>
	return info.type;
}
</mod>
static ENTRY_TYPE index_entrytype(CONNECT_INFO &con,PARAM_STRING path)
{
	FILEINFO info;
	return index_entrytype(con,path,info);
}
static bool profile_formactive (_F_webtabs &c, W_SSTRING &var, const char *state)
{
	static const char *adding = "__add__";
	if (w_add.isset()){
		c.setstate(adding);
	}else if (var.isset()){
		c.setstate(var.c_str());
	}else if (state[0] != '\0'){
		if (strcmp(state,adding)==0){
			w_add.setinitval("1");
		}else{
			var.setinitval(state);
		}
	}
	return var.isset() || w_add.isset();
}
/*
	Format the path of a mail
*/
static string index_format_mail_fname(const MESSAGE_receive &m)
{
	string fname;
	if (m.role[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s/%s",m.manager,m.project,m.role,m.uuid);
	}else if (m.manager[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s",m.manager,m.project,m.uuid);
	}else{
		fname = string_f ("/msgs/%s/inbox/%s",userinfo.name.c_str(),m.uuid);
	}	
	return fname;
}
#if 0
/*
	Compute/Guess the number of lines that can be displayed
*/
static unsigned index_suggested_lines (const char *id, unsigned defval, int cheat)
{
	unsigned ret = defval;
	unsigned height,width;
	tlmpweb_gettablegeometry(id,height,width);
	if (height > 0){	
		unsigned fontsize = tlmpweb_fontsize();
		if (fontsize > 0){
			ret = height/(fontsize+cheat)-2;
		}
	}
	tlmp_error ("suggested_lines id=%s ret=%d defval=%d\n",id,ret,defval);
	return ret;
}
#endif
<mod>
extern "C" void webmain_real()
{
	glocal bool account_confirmed = false;
	glocal CONNECT_INFO con;
	glocal CONNECT_INFO con_sess;
	glocal.con.port = "/dev/bod.sock";
	glocal.con.secret = "foo";
	glocal.con_sess.port = "/dev/sessiond.sock";
	glocal.con_sess.secret = "foo";
	glocal vector<DOCUMENT_POINTER> docpointers;
	for (unsigned i=0; i<SECTION_NBSECTIONS; i++) glocal.docpointers.push_back(DOCUMENT_POINTER());
	if (tlmpweb_isrobot()) w_robot = 1;
	// debug
	if (0){
		<call savefile>("/tmp/environ.log",false);
		<f dowrite>
			extern char **environ;
			char **ptenv = environ;
			while (*ptenv != NULL){
				fprintf (fout,"%s\n",*ptenv);
				ptenv++;
			}
			return 0;
		</f>
		</call>
	}
	{
		<call savefile>("/tmp/agent.log",true);
		<f dowrite>
			string ip = tlmpweb_getip();
			const char *pt = getenv ("HTTP_USER_AGENT");
			if (pt == NULL){
				fprintf (fout,"%s: robot=%u HTTP_USER_AGENT null\n",ip.c_str(),w_robot.getval());
			}else{
				fprintf (fout,"%s: robot=%u HTTP_USER_AGENT %s\n",ip.c_str(),w_robot.getval(),pt);
			}
			return 0;
		</f>
		</call>
	}
	
	const char *ptsession = tlmpweb_getcookie("session");
	if (ptsession == NULL){
		<call bod_client_createsession>(glocal.con);
		<f ok>
			w_session = sessionid;
			websession_setcookie("session",sessionid,time(NULL)+48*60*60);
		</f>
		</call>
	}else{
		w_session=ptsession;
		trli_getsessioninfo(glocal.con,glocal.con_sess,glocal.docpointers);
	}
	if (w_session.empty()) return;
	
	webtable_ctrloutput();
	<obj WEBCONTEXT wctx>();
	<f savetablegeometry>
		VAR var;
		var.name = "geometry";
		for (auto &v:tb){
			SNAMEVAL val;
			val.sname = "id";
			val.sval = v.id.c_str();
			var.vals.push_back(val);
			val.sname = "height";
			val.sval = string_f("%u",v.height);
			var.vals.push_back(val);
			val.sname = "width";
			val.sval = string_f("%u",v.width);
			var.vals.push_back(val);
		}
		<call bo_sessiond_client_setvar>(glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) tlmp_error ("Can't set variable geometry: %s\n",msg);
		</f>
		</call>
	</f>
	<f settablecoor>
		/*
			We avoid poluting the session manager with fake request.
			So we make sure the request is associated with a real or possible webtable
			We do the markview at the same time.
		*/
		glocal bool valid = false;
		if (tableid[0] == '/'){
			glocal const char *dir = tableid;
			<call bod_client_listdir>(glocal.con,w_session.c_str(),tableid,"",false,current_row,1);
			<f ok>
				if (files.size()==1){
					glocal.valid = true;
					string fname = string_f("%s/%s",glocal.dir,files[0].name);
					index_markview (glocal.con,fname);
				}
			</f>
			</call>
		}else if (strncmp(tableid,"inbox",5)==0){
			const char *project = tableid+5;
			if (strcmp(project,"INBOX")==0) project = "";
			<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",project,false,current_row,1);
			<f ok>
				if (messages.size()==1){
					glocal.valid = true;
					string fname = index_format_mail_fname(messages[0]);
					index_markview (glocal.con,fname);
				}
			</f>
			</call>
		}else if (strncmp(tableid,"list:",5)==0){
			const char *tab = tableid+5;
			if (strcmp(tab,"projects")==0
				|| strcmp(tab,"groups")==0
				|| strcmp(tab,"contacts")==0){
				glocal.valid = true;
			}
		}else if (strncmp(tableid,"tab:",4)==0){
			const char *tab = tableid+4;
			if (strcmp(tab,"projects")==0
				|| strcmp(tab,"mails")==0
				|| strcmp(tab,"talk")==0){
				glocal.valid = true;
			}
		}else if (strncmp(tableid,"talk",4)==0){
			vector<string> tb;
			int n = str_splitline (tableid+4,':',tb);
			if (n == 2){
				<call bod_client_list_talk>(glocal.con,w_session.c_str(),"",tb[1],tb[0],current_row,1);
				<f ok>
					if (messages.size()==1){
						glocal.valid = true;
					}
				</f>
				</call>
			}
		}
		if (glocal.valid){
			unsigned &cur = currents[tableid];
			unsigned &off = offsets[tableid];
			if (current_row_set && cur != current_row){
				cur = current_row;
				web_updatecurrents(glocal.con_sess);
			}
			if (offset_set && off != offset){
				off = offset;
				web_updateoffsets(glocal.con_sess);
			}
		}else{
			tlmp_error ("settablerow unknown tableid %s\n",tableid);
		}
	</f>
	<f recordform>
		VAR var;
		var.name = "currentform";
		for (auto &v:forms){
			SNAMEVAL val;
			val.sname = "id";
			val.sval  = v.formid;
			var.vals.push_back(val);
			for (auto &vv:v.variables){
				val.sname = "var";
				val.sval = vv->getname();
				var.vals.push_back(val);
			}
		}
		<call bo_sessiond_client_setvar> (glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) tlmp_error (MSG_U(E_SAVECURFORM,"Can't save active form state: %s\n"),msg);
		</f>
		</call>
	</f>
	<f restoreform>
		glocal int ret = -1;
		glocal const char *formid = formid;
		<call bod_client_form_readvar>(glocal.con,w_session.c_str(),formid);
		<f ok>
			if (!success){
				tlmp_error (MSG_U(E_RESTOREFORM,"Can't restore active form state %s: %s\n"),glocal.formid,msg);
			}else{
				if (vars.size() > 0){
					glocal.ret = 0;
					for (auto &v:vars){
						tlmpweb_setvar (v.name,v.val);
					}
				}	
			}
		</f>
		</call>
		return glocal.ret;
	</f>
	<f deleteform>
		glocal const char *formid = formid;
		<call bod_client_form_deletevar>(glocal.con,w_session.c_str(),formid);
		<f ok>
			if (!success) tlmp_error ("deleteform %s: %s\n",glocal.formid,msg);
		</f>
		</call>
	</f>
	<f deleteallform>
		<call bod_client_form_deleteall>(glocal.con,w_session.c_str());
		<f ok>
			if (!success) tlmp_error ("deleteallform: %s\n",msg);
		</f>
		</call>
	</f>
	<f saveform>
		if (currentforms.size() > 0){
			for (auto &form:currentforms){
				FORMVARS f;
				glocal const char *id = form.id.c_str();
				f.id = form.id;
				for (auto &v:form.vars){
					FORMVAR var;
					var.name = v;
					var.val = t_varstr(v.c_str());
					f.vars.push_back(var);
				}
				<call bod_client_form_savevar>(glocal.con,w_session.c_str(),f);
				<f ok>
					if (!success) tlmp_error (MSG_U(E_SAVEFORM,"saveform currentform %s: %s\n"),glocal.id,msg);
				</f>
				</call>
			}
		}
	</f>
	<f webtableinit>
		if (strncmp(tableid,"list:",5)==0 || strncmp(tableid,"inbox",5)==0){
			c.settableparms ("border=0");
		}else{
			c.settableparms ("border=0");
		}
		c.setthparms ("align=left bgcolor=lightgray","");
		c.setrowstyle ("sep","bgcolor=ghostwhite");
		c.setrowstyle ("sep+current","bgcolor=lightblue");
		c.setrowstyle ("white","bgcolor=white");
		c.setrowstyle ("white+current","bgcolor=lightblue");
		c.setrowstyle ("whitebold","bgcolor=white><b>\b</b>");
		c.setrowstyle ("whitebold+current","bgcolor=lightblue><b>\b</b>");
		c.setrowstyle ("image","bgcolor=white align=center");
	</f>
	</obj>
	<call websteps>();
	<f setstep>
		if (w_session.empty() && step > 2){
			step = 1;
		}else if (userinfo.name.empty() && step != 2 && step != 3){
			step = 1;
		}
	</f>
	<f step1>
		bolixo_title ("",this);
		if (userinfo.name.size() == 0){
			// Anonymous, present public news ?
			/- So far no public content
		}else{
			/- <table border=0 height=100% width=100%>
			/- <tr><td valign=top>
			glocal string prjdir = string_f ("/projects/%s/public/default",userinfo.name.c_str());
			<call vframe4>("title","","");
			<f top_left>
				htmlprintf ("<img width=200 src=%s?webstep=%u&image=%s/image.jpg>"
					,tlmpweb_curpage(),step_image,glocal.prjdir.c_str());
			</f>
			<f top>
				<call bod_client_readfile>(glocal.con,w_session.c_str(),string_f("%s/intro.html",glocal.prjdir.c_str()),"");
				<f ok>
					string tmp = index_format_shortmsg (content);
					htmlout (tmp);
				</f>
				</call>
			</f>
			<f body>
				/- Documents
			</f>
			<f left>
				//string table = string("talk")+"public";
				//index_show_shortmsg (glocal.con,glocal.con_sess,table,"public",userinfo.name);
			</f>
			</call>
			/- </table>
		}
	</f>
	<f step2> // Login
		<call form>("login");
		<f top>
			bolixo_title (MSG_U(T_LOGIN,"Login"),&glocal.websteps);
			if (glocal.account_confirmed){
				<?#I_ACCTCONFIRM Welcome
			 	<p>
				The account is now confirmed, you can log in
				?>
			}else{
				/-#I_HAVEACCT Already have an account, please login<p>
			}
		</f>
		<f setup>
			/- <table border=0 align=center>
			/-#I_EMAIL <tr><td>Enter your email<td>
			field_string (w_email,"size=60");
			/-#I_PASSWORD <tr><td>Password<td>
			field_password (w_password,"");
			/- <tr><td>
			button_submit (MSG_U(B_LOGIN,"Login"));
			/- </table>
		</f>
		<f validate>
			bool ret = false;
			if (w_email.is_filled()){
				if (w_password.is_empty()){
					/-#I_PASSWDREQ <font color=red>You must supply a password</font>
				}else{
					ret = true;
				}
			}else{
				/-#I_PROVIDEEMAIL <font color=red>Please provide an email</font>
			}
			return ret;
		</f>
		<f process>
			glocal bool fail = false;
			<call bod_client_login>(glocal.con,w_session.c_str(),w_email.c_str(),w_password.c_str());
			<f ok>
				if (success){
					trli_getsessioninfo(glocal.con,glocal.con_sess,glocal.docpointers);
					glocal.websteps.gotostep(1);
				}else{
					/-#I_LOGINFAILED <font color=red>Login failed, invalid email or password</font>
					glocal.fail = true;
				}
			</f>
			</call>
			fail = glocal.fail;
		</f>
		</call>
	</f>
	<f step3> // Account creation
		glocal bool account_created = false;
		<call form>("createaccount");
		<f top>
			bolixo_title (MSG_U(T_CREATEACC,"Account creation"),&glocal.websteps);
			<?#I_NOACCOUNT No account ? Please create one.
			<p>
			Your email will only be used for the following reasons.
			<br>
			<ul>
			<li>Login.
			<li>Account confirmation.
			<li>Account modification confirmation.
			</ul>
			The only information shown on the web site is the nickname. Your email won't appear on the site.
			<p>
			See the
			?>
			printhref_raw ("/terms-of-use.html","terms of use",false);
			/-#I_MOREDETAILS &nbsp;for more details
		</f>
		<f setup>
			/- <table border=0 align=center>
			/-#I_NICKNAME <tr><td>Enter your nickname<td>
			field_string (new_nickname,"");
			/-#I_ENTERMAIL <tr><td>Enter your email<td>
			field_string (new_email,"");
			/-#I_ENTERPWD <tr><td>Password<td>
			field_password (new_password1,"");
			/-#I_CONFIRMPWD <tr><td>Confirm password<td>
			field_password (new_password2,"");
			/- <tr><td>
			button_submit (MSG_U(B_ACCACCOUNT,"Add account"));
			/- </table>
		</f>
		<f validate>
			bool ret = true;
			if (new_nickname.is_empty()){
				/-#E_NEEDNICKMAME <font color=red>Please provide a nickname</font>
				ret = false;
 			}else if (new_email.is_empty()){
				/-#E_NEEDEMAIL <font color=red>Please provide an email</font>
				ret = false;
			}else if (new_password1.is_empty()){
				/-#E_NEEDPWD <font color=red>Please enter a password</font>
				ret = false;
			}else if (strcmp(new_password1.c_str(),new_password2.c_str())!=0){
				/-#E_PWDMISMATCH <font color=red>Passwords do not match</font>
				ret = false;
			}
			return ret;
		</f>
		<f process>
			glocal bool fail = false;
			<call bod_client_adduser>(glocal.con,w_session.c_str(),new_nickname.c_str(),new_email.c_str(),new_password1.c_str(),tlmpweb_getlang());
			<f ok>
				if (confirmid[0] == '\0'){
					glocal.fail = true;
					/-#E_CREATACCT <font color=red>Account creation failure</font>
					htmlout (msg);
					/- </font>
				}else{
					glocal.account_created = true;
				}
			</f>
			</call>
			fail = glocal.fail;
		</f>
		</call>
		if (glocal.account_created){
			bolixo_title (MSG_R(T_CREATEACC),&glocal.websteps);
			<?#I_ACCTCREATED
			The account has been created
			<br>
			A confirmation email has been sent.
			<br>
			Once you received the email click on the link.
			This will complete the account creation process
			?>
		}

	</f>
	<f step4> // Logout
		tlmpweb_deleteallform();
		<call bod_client_logout>(glocal.con,w_session.c_str());
		<f ok>
			userinfo.reset();	//trli_getsessioninfo(glocal.con,glocal.con_sess);
			bolixo_title ("",&glocal.websteps);
			/-#I_HOPESEEYOU <p><p><p><p><table witdth=100%><tr><td align=center>Hope to see you again</table>
		</f>
		</call>
	</f>
	<f step5> // Send an image or video
		index_sendfile (glocal.con,w_image.c_str(),"image/jpeg");
	</f>	
	<f step6> // 
	</f>
	<f step7> // TAB Projects
		//HTMLDEBUG d1("t1");
		//HTMLDEBUG d2("t2");
		bolixo_title (MSG_R(M_PROJECTS),this);
		static unsigned size[5]={15,35,50,0,0};
		<call webtabs>(MSG_R(M_PROJECTS),tabs,size);
		<f documents>
			sethelp();
			// List projects
			static const char *id = "tab:projects";
			<call webtable>(id,"100%",currents[id]);
			<f load>
				sethead (MSG_U(H_PROJECTS,"Owner\tProject"));
				<call bod_client_list_inboxes>(glocal.con,w_session.c_str(),"",false);
				<f ok>
					unsigned rownum=0;
					for (auto &inb:inboxes){
						string id = string_f("%s/%s",inb.manager,inb.project);
						const char *style = "white";
						if (glocal.webtabs.selected(id)) glocal.webtable.setcurrent(rownum);
						string add = string_f("webtab_add=1:%s/%s",inb.manager,inb.project);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow (style,rownum,"%s\t%s",inb.manager,inb.project);
						rownum++;
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f docmain>
			glocal const char *id = id;
			glocal string path = string_f ("/projects/%s",id);
			{
			DIV f; f.id(TAB_FORM).print();
			<call form>(formid);
			<f top>
				/- <table border=0>
			</f>
			<f bottom>
				/- </table>
			</f>
			<f setup>
				/- <tr><td>
				/-#I_NEW_FOLDER New folder
				/- &nbsp;
				field_string (w_folder,"size=30");
				/- <tr><td>
				url_self (string_f("webtab_add=2:%s%c%ld~%s",glocal.id,WEBTAB_MARK,time(NULL),MSG_U(I_NEWDOC,"New_document"))
					,MSG_U(I_CREATENEWDOC,"Create a new document"));
				/- <tr><td>
				/-#I_UPLOADFILE Upload file
				/- &nbsp;
				field_file (w_upload);
				/- <td>
				button_submit();
			</f>
			<f validate>
				return true;
			</f>
			<f process>
				glocal bool fail = false;
				if (strcmp(w_folder.c_str(),"")!=0){
					string filepath = string_f("%s/%s",glocal.path.c_str(),w_folder.c_str());
					<call bod_client_mkdir>(glocal.con,w_session.c_str(),filepath);
					<f ok>
						if (!success){
							glocal.fail = true;
							htmlprintf (MSG_U(E_CREATEFOLDER,"Can't create folder: %s<br>\n"),msg);
						}else{
							w_folder.setempty();
						}
					</f>
					</call>
				}
				if (strcmp(w_upload.c_str(),"")!=0){
					const char *tempname = tlmpweb_getfilename(w_upload);
					string filepath = string_f("%s/%s",glocal.path.c_str(),w_upload.c_str());
					<call sendfile>(filepath,tempname,glocal.fail);
					<f start>
						<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),filepath,content,more);
						<f ok>
							glocal.sendfile.sethandle(handle);
							glocal.sendfile.setresult(success,msg);
						</f>
						</call>
					</f>
					<f rest>
						<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
						<f ok>
							glocal.sendfile.setresult(success,msg);
						</f>
						</call>
					</f>
					</call>
				}
				keepediting = true;
				fail = glocal.fail;
			</f>
			</call>
			}
			<call webtable>(ID_PROJECT,glocal.path,"100%",currents[glocal.path],offsets[glocal.path],5);
			<f click>
				tlmpweb_flushheader();
				<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,noline,1);
				<f ok>
					if (files.size()!=1){
						htmlprintf (MSG_U(E_INTERNAL,"Internal error: %s\n"),msg);
					}else{
						auto &f = files[0];
						glocal FILE_TYPE file_type = f.file_type;
						glocal string fname = string_f("%s/%s",glocal.path.c_str(),f.name);
						if (file_is_text(f.file_type)){
							if (f.islarge){
								index_sendfile (glocal.con,glocal.fname,"text/html");
							}else{
								<call bod_client_readfile>(glocal.con,w_session.c_str(),glocal.fname,"");
								<f ok>
									if (!success){
										index_popup (glocal.con,msg,glocal.file_type,glocal.fname);
									}else{
										index_popup (glocal.con,content,glocal.file_type,glocal.fname);
									}
								</f>
								</call>
							}
						}else{
							index_popup (glocal.con,"",f.file_type,glocal.fname);
						}
					}
				</f>
				</call>
			</f>
			<f load>
				glocal unsigned rownum = nbskip;
				sethead (MSG_U(H_FOLDER,"\tModified\tOwner\tSize\tName"));
				<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,nbskip,nblines);
				<f ok>
					if (!success) htmlprintf (MSG_U(E_READDIR,"Can't read directory %s: %s<br>\n"),glocal.path.c_str(),msg);
					const char *func = "Popup";
					for (auto &f:files){
						string path = string_f ("%s/%s",glocal.id,f.name);
						if (bolixo_isdir(f.type)){
							glocal.webtable.setclickopt (true,"",string_f("webtab_add=1:%s",path.c_str()));
						}else if (file_is_image(f.file_type)){
							glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),f.name));
						}else if (file_is_video(f.file_type)){
							glocal.webtable.setclickopt (true,func,"800,800");
						}else if (file_is_sound(f.file_type)){
							glocal.webtable.setclickopt (true,func,"350,50");
						}else if (file_is_text(f.file_type)){
							glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),f.name));
						}
						if (glocal.webtabs.selected(path)) glocal.webtable.setcurrent(glocal.rownum);
						static const char *tbviewed[]={"new","&nbsp;&nbsp;&nbsp;","mod"};
						glocal.webtable.setrow ("white",glocal.rownum,"%s\t%s\t%s/%s:%s\t%u\t%s"
							,tbviewed[f.viewed]
							,f.modified
							,f.owner,f.listname,f.listmode,f.size
							,f.name);
						glocal.rownum++;
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f doctype2>
			glocal const char *filename = id;
			glocal string path = string_f("/projects/%s",glocal.filename);
			glocal bool newdocument = false;
			FILEINFO info;
			if (index_entrytype(glocal.con,glocal.path,info)==ENTRY_DIR){
				glocal.newdocument = true;
				info.file_type = FILE_TEXT;
			}
			if (strcmp(id,"help")==0){
				DIV d("webtable"); d.print();
				index_doc(glocal.docpointers[SECTION_PROJECT],section_project);
			}else if (file_is_image(info.file_type)){
				DIV d("webtable"); d.print();
				htmlprintf (MSG_R(I_DOCNAME),glocal.filename);
				/- <br>
				htmlprintf ("<img width=100%% src=%s?webstep=%u&image=%s>"
					,tlmpweb_curpage(),step_image,glocal.path.c_str());
			}else if (info.file_type == FILE_TEXT){
				<call form>(formid);
				<f top>
				</f>
				<f bottom>
				</f>
				<f load>
					if (!glocal.newdocument){
						index_loadfile(glocal.con,glocal.path,w_content);
					}
				</f>
				<f setup>
					{
						DIV f; f.id(TAB_FORM).print();
						/- <table width=100% border=0>
						/- <tr><td valign=top align=left>
						if (glocal.newdocument){
							/-#I_NEWDOCNAME New document name&nbsp;
							field_string (w_filename,"size=30");	
						}else{
							htmlprintf (MSG_U(I_DOCNAME,"Document name:&nbsp;<font size=+4>%s</font>"),glocal.filename);
						}
						/- <td valign=top align=right>
						button_submit(MSG_U(B_SAVE,"Save"));
						/- </table>
					}
					field_textarea(w_content,ID_PRJTEXT,-100,"style=\"border:none\"");
				</f>
				<f validate>
					bool ret = true;
					if (glocal.newdocument){
						if (strcmp(w_filename.c_str(),"")==0){
							/- You must provide a file name
							ret = false;
						}else if (index_entrytype(glocal.con,string_f("%s/%s",glocal.path.c_str(),w_filename.c_str()))!=ENTRY_NONE){
							/- Document already exist
							ret = false;
						}
					}
					return ret;
				</f>
				<f process>
					<call sendfile_var>(glocal.path,w_content,fail);	
					<f start>
						if (glocal.newdocument){
							glocal.path = string_f("%s/%s",glocal.path.c_str(),w_filename.c_str());
							<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),glocal.path,content,more);
							<f ok>
								glocal.sendfile_var.setresult(success,msg);
								glocal.sendfile_var.sethandle(handle);
							</f>
							</call>
						}else{
							<call bod_client_modifyfile_bob>(glocal.con,w_session.c_str(),filepath,content,more);
							<f ok>
								glocal.sendfile_var.setresult(success,msg);
								glocal.sendfile_var.sethandle(handle);
							</f>
							</call>
						}
					</f>
					<f rest>
						<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
						<f ok>
							glocal.sendfile_var.setresult(success,msg);
						</f>
						</call>
					</f>
					</call>
					if (!fail){
						if (glocal.newdocument){
							glocal.webtabs.setid (string_f("%s/%s",glocal.filename,w_filename.c_str()));
							glocal.webtabs.settitle (w_filename.c_str());
							glocal.webtabs.redotab();
							resetstate();
							// We have to mark this document as viewed (we just created it)
							index_markview (glocal.con,glocal.path);
						}else{
							keepediting = true;
						}
					}
				</f>
				</call>
			}
		</f>
		</call>
		/- </table>
	</f>
	<f step8> // TAB Mails
		bolixo_title (MSG_U(T_MAILS,"Mails"),this);
		static unsigned size[5]={15,45,40,0,0};
		<call webtabs>("mails",tabs,size);
		<f documents>
			sethelp();
			static const char *id = "tab:mails";
			<call webtable>(id,"100%",currents[id]);
			<f load>
				sethead (MSG_U(H_INBOXES,"Owner\tProject"));
				setclickopt (true,"",string_f("webtab_add=1:INBOX~%s",MSG_R(I_INBOX)));
				if (glocal.webtabs.selected("INBOX")) setcurrent(0);
				setrow ("white",0,"\t%s",MSG_U(I_INBOX,"INBOX"));
				<call bod_client_list_inboxes>(glocal.con,w_session.c_str(),"",true);
				<f ok>
					unsigned rownum=1;
					for (auto s:inboxes){
						string add = string_f("webtab_add=1:%s",s.project);
						//url_self (add.c_str(),"%s",s.role);
						if (glocal.webtabs.selected(s.project)) glocal.webtable.setcurrent(rownum);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow("white",rownum,"%s\t%s",s.manager,s.project);
						rownum++;
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f docmain>
			glocal const char *project = id;
			if (strcmp(id,"INBOX")==0) glocal.project = "";
			string inbox = string("inbox") + id;
			<call webtable>(ID_MAIL,inbox,"100%",currents[inbox],offsets[inbox],5);
			<f click>
				// This code is never called
				tlmpweb_flushheader();
				<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",glocal.project,false,noline,1);
				<f ok>
					if (messages.size()!=1){
						htmlprintf ("Internal error: %s\n",msg);
					}else{
						htmlprintf ("title=%s<p>\n",messages[0].title);
						string path = index_format_mail_fname(messages[0]);
						<call bod_client_readfile>(glocal.con,w_session.c_str(),path,"");
						<f ok>
							const char *pt = content;
							while (*pt != '\0'){
								const char *start = pt;
								while (*pt != '\0' && *pt != '\n') pt++;
								htmlwrite (start,pt-start);
								htmlout ("<br>\n");
								if (*pt == '\n') pt++;
							}
						</f>
						</call>
					}
				</f>
				</call>
			</f>
			<f load>
				glocal unsigned rownum = nbskip;
				sethead (MSG_U(H_MAILS,"From\tManager\tProject\tRole\tSubmit\tTitle"));
				<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",glocal.project,false,nbskip,nblines);
				<f ok>
					if (!success){
						htmlprintf ("Error: %d %s<br>",internal_error,msg);
					}else{
						for (auto &m:messages){
							string path = index_format_mail_fname(m);
							glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s"
								,path.c_str(),m.from));
							if (glocal.webtabs.selected(path)) glocal.webtable.setcurrent(glocal.rownum);
							const char *style = m.viewed != VIEWED_OK ? "whitebold" : "white";
							glocal.webtable.setrow (style,glocal.rownum,"%s\t%s\t%s\t%s\t%s\t%s"
								,m.from
								,m.manager
								,m.project
								,m.role
								,m.submit
								,m.title);
							glocal.rownum++;
						}
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f doctype2>
			DIV d("webtable"); d.print();
			if (strcmp(id,"help")==0){
				index_doc(glocal.docpointers[SECTION_MAILS],section_mails);
			}else{
				glocal const char *id = id;
				glocal const char *from = title;
				<call bod_client_readfile>(glocal.con,w_session.c_str(),id,"");
				<f ok>
					vector<string> tb;
					int n = str_splitline (glocal.id,'/',tb);
					/- <table border=0>
					if (n >= 5 && strcmp(tb[3].c_str(),"inbox")!=0){
						if (n >= 6){
							htmlprintf ("<tr><td><b>%s</b><td>%s<td>/<td>%s<td>/<td>%s\n",MSG_U(I_PROJECT,"Project"),tb[2].c_str(),tb[3].c_str(),tb[4].c_str());
						}else{
							htmlprintf ("<tr><td><b>%s</b><td>%s<td>/<td>%s\n",MSG_R(I_PROJECT),tb[2].c_str(),tb[3].c_str());
						}
					}
					htmlprintf ("<tr><td><b>%s</b><td colspan=6>%s\n",MSG_U(I_FROM,"From"),glocal.from);
					htmlprintf ("<tr><td><b>%s</b><td colspan=6>%s\n",MSG_U(I_TITLE,"Title"),info.title);
					htmlprintf ("<tr><td><b>%s</b><td colspan=6>%s\n",MSG_U(I_DATE,"Date"),info.modified);
					/- </table>
					/- <p>
					const char *pt = content;
					while (*pt != '\0'){
						const char *start = pt;
						while (*pt != '\0' && *pt != '\n') pt++;
						htmlout (start,pt-start);
						htmlout ("<br>\n");
						if (*pt == '\n') pt++;
					}
				</f>
				</call>
			}
		</f>
		</call>
		///- </table>
	</f>
	<f step9>	// TAB Talks
		bolixo_title (MSG_U(T_TALKS,"Talks"),this);
		static unsigned size[5]={15,40,45,0,0};
		<call webtabs>("talks",tabs,size);
		<f documents>
			sethelp();
			static const char *id = "tab:talk";
			<call webtable>(id,"100%",currents[id]);
			<f load>
				sethead (MSG_U(H_TALKS,"Proprio\tGroupe"));
				<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",false);
				<f ok>
					unsigned rownum = 0;
					for (auto &g:groups){
						string id = string_f("%s:%s",g.owner,g.name);
						string add = string_f("webtab_add=1:%s:%s",g.owner,g.name);
						if (glocal.webtabs.selected(id)) glocal.webtable.setcurrent(rownum);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow ("white",rownum,"%s\t%s",g.owner,g.name);
						rownum++;
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f docmain>
			vector<string> tb;
			int n = str_splitline (id,':',tb);
			if (n != 2) return;
			glocal string groupowner = tb[0];
			glocal string groupname = tb[1];
			DIV tab; tab.dispflex().flowcol().print();
			DIV f; f.id(string_f("%s-form",ID_TALK.c_str())).flexfixe().print();
			<call form>(formid);
			<f top>
				/- <table border=0>
			</f>
			<f bottom>
				/- </table>
			</f>
			<f setup>
				/- <tr><td height=1% colspan=3>
				field_textarea (w_content,5,60,"");
				/- <tr><td height=1%>
				field_file (w_upload);
				/- <td>
				button_submit (MSG_U(B_SEND,"Send"));
			</f>
			<f validate>
				return true;
			</f>
			<f process>
				glocal bool fail = false;
				if (w_content.size() > 0){
					BOB_TYPE bob;
					bob.setbuffer (w_content.c_str(),w_content.size(),false);
					<call bod_client_sendtalk>(glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,bob,false);
					<f ok>
						if (!success){
							htmlprintf (MSG_U(E_CANTSEND,"Can't send: %s<br>\n"),msg);
							glocal.fail = true;
						}
					</f>
					</call>
					w_content.setempty();
				}
				if (strcmp(w_upload.c_str(),"")!=0){
					const char *tempname = tlmpweb_getfilename(w_upload);
					<call sendfile>("",tempname,glocal.fail);
					<f start>
						<call bod_client_sendtalk>(glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner
							,content,more);
						<f ok>
							glocal.sendfile.sethandle (handle);
							glocal.sendfile.setresult (success,msg);
						</f>
						</call>
					</f>
					<f rest>
						<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
						<f ok>
							glocal.sendfile.setresult (success,msg);
						</f>
						</call>
					</f>
					</call>
					if (!fail) w_upload.setempty();
				}
				fail = glocal.fail;
				keepediting = true;
			</f>
			</call>
			f.end();
			DIV ff; ff.flexgrow().print();
			string table = string("talk")+id;
			index_show_shortmsg (glocal.con,glocal.con_sess,table,glocal.groupname,glocal.groupowner);
			/- </table>
		</f>
		<f doctype2>
			FILEINFO info;
			index_entrytype(glocal.con,id,info);
			DIV d("webtable"); d.print();
			if (strcmp(id,"help")==0){
				index_doc(glocal.docpointers[SECTION_TALK],section_talk);
			}else if (file_is_image(info.file_type)){
				htmlprintf ("<img width=100%% src=%s?webstep=%u&image=%s>"
					,tlmpweb_curpage(),step_image,id);
			}else if (file_is_text(info.file_type)){
				/- <table border=0>
				vector<string> tb;
				int n=str_splitline(id,'/',tb);
				if (n == 6){	
					htmlprintf ("<tr><td><b>%s</b><td>%s<td>%s\n",MSG_U(I_TALKGROUP,"Group")
						,tb[2].c_str(),tb[4].c_str());
				}
				htmlprintf ("<tr><td><b>%s</b><td>%s\n",MSG_U(I_TALKFROM,"From"),info.owner.c_str());
				/- </table><p>
				<call bod_client_readfile>(glocal.con,w_session.c_str(),id,"");
				<f ok>
					string tmp = index_format_shortmsg (content);
					htmlout (tmp);
				</f>
				</call>
			}
		</f>
		</call>
	</f>
	<f step10> // Confirm user
		if (w_confirm.is_empty()){
			/-#E_REACHMISS You have reach this web page by mistake. Sorry!
		}else{
			<call bod_client_confirmuser>(glocal.con,w_confirm.c_str());
			<f ok>
				if (success){
					glocal.account_confirmed = true;
					glocal.websteps.gotostep(step_login);
				}else{
					bolixo_title ("",&glocal.websteps);
					htmlprintf (MSG_U(E_CONFIRMFAILED,"Account confirmation failed: %s\n"),msg);
				}
			</f>
			</call>
		}
			
	</f>
	<f step11> // TAB Profile
		bolixo_title (MSG_U(T_PROFILE,"Profile"),this);
		vector<string> t={
			string_f("Account~%s",MSG_U(T_ACCOUNT,"Account")),
			string_f("Interests~%s",MSG_U(T_INTERESTS,"Interests")),
			string_f("Contacts~%s",MSG_U(T_CONTACTS,"Contacts")),
			string_f("Projects~%s",MSG_U(T_PROJECTS,"Projects")),
			string_f("Groups~%s",MSG_U(T_GROUPS,"Groups"))};
		static unsigned size[5]={0,60,40,0,0};
		<call webtabs>("profile",t,tabs,size);
		<f doctype2>
			DIV f("webtable"); f.print();
			if (strcmp(id,"helpgroups")==0){
				index_doc(glocal.docpointers[SECTION_GROUPS],section_groups);
			}else if (strcmp(id,"helpprojects")==0){
				index_doc(glocal.docpointers[SECTION_PROJECTS],section_projects);
			}else if (strcmp(id,"helpcontacts")==0){
				index_doc(glocal.docpointers[SECTION_CONTACTS],section_contacts);
			}else if (strcmp(id,"helpaccount")==0){
				index_doc(glocal.docpointers[SECTION_ACCOUNT],section_account);
			}
		</f>
		<f docmain>
			sethelp("helpprojects",MSG_U(I_HELPPROJECTS,"Projects"));
			glocal const char *state = state;
			if (strcmp(id,"Projects")==0){
				<call vframe2h>(30);
				<f left>
					url_self ("add=1",MSG_U(I_CREATELIST,"Create a new project"));
					/- <p>
					<call webtable>("list:projects","100%",currents["list:projects"]);
					<f load>
						sethead (MSG_U(H_PROF_PROJECTS,"Project\tMembers\tAccess"));
						<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
						<f ok>
							unsigned rownum=0;
							for (auto &l:lists){
								if (l.name[0] != '#'){
									string add = string_f("list=%s",l.name);
									glocal.webtable.setclickopt (true,"",add);
									glocal.webtable.setrow ("sep",rownum,"%s\t%s\a",l.name,l.description);
									glocal.webtable.setclickopt (false,"","");
									for (unsigned i=0; i<l.groups.size(); i++){
										glocal.webtable.setrow("white",-1,"\t%s\t%s",l.groups[i],l.access[i]);
									}
								}
								rownum++;
							}
							
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (profile_formactive (glocal.webtabs,w_list,glocal.state)){
						<call form>(string_f("project:%s",w_add==1 ? "" : w_list.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							if (w_add != 1) htmlprintf (MSG_U(T_PROJECT,"<tr><td>Project<td><font size=+2>%s</font><p>\n"),w_list.c_str());
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
							<f ok>
								for (auto &l:lists){
									if (strcmp(l.name,w_list.c_str())==0){
										w_desc = l.description;
										for (unsigned i=0; i<l.groups.size(); i++){
											const char *group = l.groups[i];
											string access = toupper(l.access[i]);
											if (i==0){
												w_group1 = group;
												w_access1 = access;
											}else if (i==1){
												w_group2 = group;
												w_access2 = access;
											}else if (i==2){
												w_group3 = group;
												w_access3 = access;
											}else if (i==3){
												w_group4 = group;
												w_access4 = access;
											}
										}
										break;
									}
								}
							</f>
							</call>
						</f>
						<f setup>
							glocal vector<string> groups;
							// PATCH: Group contacts is not returned by list_groups
							// For the public group, it is necessary. Maybe other projects would
							// need access to special group contact...
							if (strcmp(w_list.c_str(),"public")==0) glocal.groups.push_back("contacts");
							<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
							<f ok>
								for (auto &g:groups) glocal.groups.push_back(g.name);
							</f>
							</call>
							if (w_add == 1){
								/-#I_PRJ_PROJECT <tr><td>Project&nbsp;<td>
								field_string (w_list,"size=30");
								field_hidden(w_add);
							}else{
								field_hidden(w_list);
							}
							/-#I_PRJ_DESCRIPTION <tr><td>Description&nbsp;<td>
							field_string (w_desc,"size=60");
							/- <tr><td>&nbsp;
							/-#I_PRJ_MEMBERS <tr><td valign=top>Members<td><table border=0>
							/-#I_PRJ_GROUP <tr><th>Group<th>Access
							/- <tr><td>
							index_field_group (this,w_group1,glocal.groups);
							/- <td>
							index_field_access (this,w_access1);
							/- <tr><td>
							index_field_group (this,w_group2,glocal.groups);
							/- <td>
							index_field_access (this,w_access2);
							/- <tr><td>
							index_field_group (this,w_group3,glocal.groups);
							/- <td>
							index_field_access (this,w_access3);
							/- <tr><td>
							index_field_group (this,w_group4,glocal.groups);
							/- <td>
							index_field_access (this,w_access4);
							/- </table>
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							bool ret = true;
							if (strcmp(w_desc.c_str(),"a")==0){
								ret = false;
								/- <font color=red>a is not allowed</font>
								/- <br>
							}
							return ret;
						</f>
						<f process>
							glocal bool fail = false;
							if (w_add == 1){
								<call bod_client_create_group_list>(glocal.con,w_session.c_str(),w_list.c_str(),"");
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf ("Can't create list: %s\n",msg);
									}
								</f>
								</call>
							}
							if (!glocal.fail){
								glocal vector<string> oldgroups;
								<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
								<f ok>
									for (auto &l:lists){
										if (strcmp(l.name,w_list.c_str())==0){
											for (auto g:l.groups) glocal.oldgroups.push_back(g);
											break;
										}
									}
								</f>
								</call>
								<call bod_client_set_list_desc>(glocal.con,w_session.c_str(),w_list.c_str(),w_desc.c_str(),"");
								<f ok>
									if (!success){
										/- error
										glocal.fail = true;
									}
								</f>
								</call>
								vector<string> newgroups;
								index_set_group (glocal.con,w_list,w_group1,w_access1,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group2,w_access2,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group3,w_access3,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group4,w_access4,newgroups,glocal.fail);
								if (!glocal.fail){
									// We have to remove the groups that are gone
									index_delete_new_from_old(newgroups,glocal.oldgroups);
									// what remains in oldgroups have to be deleted (setting access to - does this)
									for (auto &g:glocal.oldgroups) index_set_group (glocal.con,w_list,g.c_str(),"-",glocal.fail);
								}
							}
							fail = glocal.fail;
							if (!fail){
								if (w_add == 0){
									keepediting = true;
									reload();
								}
								w_add = 0;
							}
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strcmp(id,"Groups")==0){
				sethelp("helpgroups",MSG_U(I_HELPGROUPS,"Groups"));
				<call vframe2h>(30);
				<f left>
					url_self ("add=1",MSG_U(I_CREATEGROUP,"Create a new group"));
					/- <p>
					<call webtable>("list:groups","100%",currents["list:groups"]);
					<f load>
						sethead (MSG_U(H_GROUPS,"Group\tMembers\tAccess\tRole"));
						<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
						<f ok>
							unsigned rownum=0;
							for (auto &g:groups){
								string add = string_f("group=%s",g.name);
								glocal.webtable.setclickopt (true,"",add);
								glocal.webtable.setrow ("sep",rownum,"%s\t%s\a\a",g.name,g.description);
								glocal.webtable.setclickopt (false,"","");
								for (unsigned i=0; i<g.users.size(); i++){
									glocal.webtable.setrow("white",-1,"\t%s\t%s\t%s",g.users[i],g.access[i],g.roles[i]);
								}
								rownum++;
							}
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (profile_formactive (glocal.webtabs,w_group,glocal.state)){
						<call form>(string_f("group:%s",w_add==1 ? "" : w_group.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							if (w_add != 1) htmlprintf ("<tr><td>Group<td><font size=+2>%s</font><p>\n",w_group.c_str());
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
							<f ok>
								for (auto &g:groups){
									if (strcmp(g.name,w_group.c_str())==0){
										w_desc = g.description;
										w_content = "";
										for (unsigned i=0; i<g.users.size(); i++){
											w_content.appendf ("%s:%s:%s\n",g.users[i],g.access[i],g.roles[i]);
										}
										break;
									}
								}
							</f>
							</call>
						</f>
						<f setup>
							if (w_add == 1){
								/-#I_GROUP <tr><td>Group&nbsp;<td>
								field_string (w_group,"size=30");
								field_hidden(w_add);
							}else{
								field_hidden(w_group);
							}
							/-#I_DESCRIPTION <tr><td>Description&nbsp;<td>
							field_string (w_desc,"size=60");
							/- <tr><td>&nbsp;
							/-#I_MEMBERS <tr><td valign=top>Members<td>
							field_textarea (w_content,20,60,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							bool ret = true;
							return ret;
						</f>
						<f process>
							glocal bool fail = false;
							if (w_add == 1){
								<call bod_client_create_group>(glocal.con,w_session.c_str(),w_group.c_str(),"");
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf (MSG_U(E_CANTCREATEGROUP,"Can't create group: %s<br>\n"),msg);
									}
								</f>
								</call>
							}
							if (!glocal.fail){
								glocal vector<string> oldusers;
								<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
								<f ok>
									for (auto &g:groups){
										if (strcmp(g.name,w_group.c_str())==0){
											for (auto u:g.users) glocal.oldusers.push_back(u);
											break;
										}
									}
								</f>
								</call>
								<call bod_client_set_group_desc>(glocal.con,w_session.c_str(),w_group.c_str(),w_desc.c_str(),"");
								<f ok>
									if (!success){
										htmlprintf (MSG_U(E_CANTSETGROUPDESC,"Can't set group description: %s<br>\n"),msg);
										glocal.fail = true;
									}
								</f>
								</call>
								vector<string> newusers,newaccesses,newroles;
								const char *pt = w_content.c_str();
								while (*pt != '\0'){
									string word;
									pt = str_copyword(word,pt);
									vector<string> tb;
									int n = str_splitline(word.c_str(),':',tb);
									if (n > 0){
										while (tb.size() < 3) tb.push_back("");
										newusers.push_back (tb[0]);
										newaccesses.push_back(tb[1]);
										newroles.push_back(tb[2]);
									}
								}
								for (unsigned i=0; !glocal.fail && i<newusers.size(); i++){
									glocal const char *user = newusers[i].c_str();
									<call bod_client_set_member>(glocal.con,w_session.c_str(),w_group.c_str()
										,glocal.user,newaccesses[i].c_str(),newroles[i].c_str(),"");
									<f ok>
										if (!success){
											glocal.fail = true;
											htmlprintf (MSG_U(E_CANTSETMEMBER,"Can't set member %s: %s\n"),glocal.user,msg);
										}
									</f>
									</call>
								}
								if (!glocal.fail){
									// We have to remove the groups that are gone
									index_delete_new_from_old(newusers,glocal.oldusers);
									// what remains in oldusers have to be deleted (setting access to - does this)
									for (auto &g:glocal.oldusers){
										glocal const char *user = g.c_str();
										<call bod_client_set_member>(glocal.con,w_session.c_str(),w_group.c_str()
											,glocal.user,"-","","");
										<f ok>
											if (!success){
												glocal.fail = true;
												htmlprintf (MSG_U(E_CANTDELMEMBER,"Can't delete member %s: %s\n"),glocal.user,msg);
											}
										</f>
										</call>
									}
								}
							}
							fail = glocal.fail;
							if (!fail){
								if (w_add == 0){
									keepediting = true;
									reload();
								}
								w_add = 0;
							}
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strcmp(id,"Contacts")==0){
				sethelp("helpcontacts",MSG_U(I_HELPCONTACTS,"Contacts"));
				<call vframe2h>(30);
				<f left>
					{
					DIV f; f.id(TAB_FORM).bg("yellow").print();
					url_self ("add=1",MSG_U(I_NEWCONTACT,"Send a new contact request"));
					// /- <p>
					}
					static const string id = "list:contacts";
					<call webtable>(ID_CONTACT,id,"100%",currents[id],offsets[id],10);
					<f load>
						sethead (MSG_U(H_CONTACTS,"User\tDate\tStatus"));
						<call bod_client_contact_list>(glocal.con,w_session.c_str(),"",nbskip,nblines);
						<f ok>
							static const char *tbstatus[]={MSG_U(I_WAITING,"waiting"),MSG_U(I_ACCEPTED,"accepted"),MSG_U(I_REJECTED,"rejected")};
							unsigned rownum = 0;
							for (auto &c:contacts){
								glocal.webtable.setclickopt (true,"",string_f("user=%u:%s",rownum,c.user));
								glocal.webtable.setrow("white",rownum,"%s\t%s\t%s",c.user,c.reqdate,tbstatus[c.status]);
								rownum++;
							}
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (w_add == 1){
						glocal bool done = false;
						<call form>("contact");
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							/- <table border=0>
							/- <tr><td><td>
							/-#I_SENDCONTACT <h2>Send a contact request</h2>
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f setup>
							field_hidden (w_add);
							/-#I_TOCONTACT <tr><td>Person to contact<td>
							field_string (w_user,"size=30");
							/-#I_MESSAGE <tr><td valign=top>Message<td>
							field_textarea (w_content,10,60,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							return true;
						</f>
						<f process>
							glocal bool fail = false;
							<call bod_client_contact_request>(glocal.con,w_session.c_str(),"",w_user.c_str(),w_content.c_str());
							<f ok>
								if (!success){
									glocal.fail = true;
									htmlprintf (MSG_U(E_CONTACTFAIL,"Contact request failed: %s<br>\n"),msg);
								}else{
									glocal.done = true;
								}
							</f>
							</call>
							fail = glocal.fail;
						</f>
						</call>
						if (glocal.done){
							/-#I_CONTACTSENT Contact request sent!
						}
					}else if (w_user.isset()){
						glocal bool done = false;
						glocal CONTACT_STATUS status = CONTACT_WAITING;
						glocal string user;
						const char *pt = strchr(w_user.c_str(),':');
						if (pt != NULL) glocal.user = pt+1;
						<call form>(string_f("managecontact:%s",w_user.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							/- <tr><td><td>
							/-#I_MANAGECONTACT <h2>Manage a contact</h2>
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							unsigned rownum = atoi(w_user.c_str());
							<call bod_client_contact_list>(glocal.con,w_session.c_str(),"",rownum,1);
							<f ok>
								if (contacts.size() == 1){
									auto &c = contacts[0];
									w_content = c.message;
								}
							</f>
							</call>
						</f>
						<f setup>
							field_hidden(w_user);
							/- <tr><td>
							/-#I_REQUESTFROM Request from
							/- <td>
							htmlout (glocal.user);
							htmlout (MSG_R(I_MESSAGE));
							field_textarea(w_content,5,60,"readonly");
							/- <tr><td>
							/-#I_ACCEPTREQ Accept request
							/- <td>
							field_radio(w_accept,"accept",true,"");
							/- <tr><td>
							/-#I_REFUSEREQ Refuse request
							/- <td>
							field_radio(w_accept,"reject",false,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							return true;
						</f>
						<f process>
							glocal bool fail = false;
							if (strcmp(w_accept.c_str(),"accept")==0){
								glocal.status = CONTACT_ACCEPTED;
							}else if (strcmp(w_accept.c_str(),"reject")==0){
								glocal.status = CONTACT_REJECTED;
							}else{
								glocal.fail = true;
								/- Invalid input ???
							}
							if (!glocal.fail){
								<call bod_client_contact_manage>(glocal.con,w_session.c_str(),"",glocal.user.c_str(),glocal.status);
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf ("operation failed: %s<br>\n",msg);
									}else{
										glocal.done = true;
									}
								</f>
								</call>
							}
							fail = glocal.fail;
						</f>
						</call>
						if (glocal.done){
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0><tr><td>
							/-#I_CONTACTDONE Contact request processed!
							/- <p>
							if (glocal.status == CONTACT_ACCEPTED){
								htmlprintf (MSG_U(I_FROMNOWON,"From now on, you can communicate with user %s<br>\n"),glocal.user.c_str());
								htmlprintf (MSG_U(I_MAKEMEMBER,"You can make user %s member of your groups<br>\n"),glocal.user.c_str());
								/-#I_HEMAKEMEMBER and he can make you member of his groups.
							}
							/- </table></table>
						}
					}
				</f>
				</call>
			}else if (strcmp(id,"Account")==0){
				glocal string status = "&nbsp;";
				sethelp("helpaccount",MSG_U(I_HELPACCOUNT,"Account"));
				<call form>("configaccount");
				<f top>
					/- <table border=0>
					htmlprintf ("<tr><td colspan=2>%s",glocal.status.c_str());
				</f>
				<f bottom>
					/- </table>
				</f>
				<f load>
					<call bod_client_config_read>(glocal.con,w_session.c_str(),"");
					<f ok>
						w_lang = config.lang;
						w_public_view = config.public_view;
						w_public_dir = config.public_dir;
					</f>
					</call>
				</f>
				<f setup>
					/-#I_LANG <tr><td>Language<td>
					field_list (w_lang,"");
					field_list_item ("eng",MSG_U(I_ENGLISH,"English"));
					field_list_item ("fr",MSG_U(I_FRENCH,"French"));
					field_list_end();
					/-#I_ENABLEPUB <tr><td>Enable public view<td>
					field_checkbox (w_public_view,"");
					/-#I_PUBFOLDER <tr><td>Public folder<td>
					field_list (w_public_dir,"");
					<call bod_client_listdir>(glocal.con,w_session.c_str(),string_f("/projects/%s/public",userinfo.name.c_str())
						,"",false,0,100);
					<f ok>
						for (auto &f:files){
							if (bolixo_isdir(f.type)){
								glocal.form.field_list_item (f.name,f.name);
							}
						}
					</f>
					</call>
					/- <tr><td>
					button_submit();
				</f>
				<f validate>
					return true;
				</f>
				<f process>
					glocal bool fail = false;
					CONFIG config;
					config.lang = w_lang.c_str();
					config.public_view = w_public_view;
					config.public_dir = w_public_dir.c_str();
					<call bod_client_config_write>(glocal.con,w_session.c_str(),"",config);
					<f ok>
						if (!success){
							glocal.fail = true;
							htmlprintf (MSG_U(E_CANTSAVECONFIG,"Can't save configuration: %s\n"),msg);
						}else{
							translat_selectlang (w_lang.c_str());
							glocal.status = MSG_U(I_CONFIGUPDATED,"Configuration updated");
						}
					</f>
					</call>
					fail = glocal.fail;
					keepediting = true;
				</f>
				</call>
			}
		</f>
		</call>
	</f>
	<f step12> // Documentation
		bolixo_title (MSG_R(M_DOCUM),this);
		index_doc(glocal.docpointers[SECTION_NONE],section_none);
	</f>
	<f step13>
	</f>
	<f step14>
	</f>
	<f step15>
	</f>
	</call>
	if (w_webtab_add.isset() || w_webtab.isset()){
		// Save the webtabs state to the session manager
		VAR var;
		var.name = "webtabs";
		for (auto &v:tabs){
			for (auto &t:v.second){
				SNAMEVAL val;
				val.sname = string_f("%s:%c:%s",v.first.c_str(),t.type+'1',t.tab.c_str());
				val.sval = string_f("f=%u,s=%s,t=%s,l=%d",t.selorder,t.state.c_str()
					,t.title.c_str(),t.locked);
				var.vals.push_back(val);
			}
		}
		<call bo_sessiond_client_setvar>(glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) htmlprintf ("Can't set variable webtabs: %s\n",msg);
		</f>
		</call>
	}
	{
		// Save the position in the document
		bool one_changed = false;
		for (auto &d:glocal.docpointers){
			if (d.ischanged()){
				one_changed = true;
			}
		}
		if (one_changed){
			VAR var;
			var.name = "document";
			for (auto &d:glocal.docpointers){
				unsigned nos = 1;
				for (auto s:d.tb){
					SNAMEVAL val;
					val.sname = string_f("s%u",nos++);
					val.sval = string_f("%u",s);
					var.vals.push_back(val);
				}
			}
			<call bo_sessiond_client_setvar>(glocal.con_sess,w_session.c_str(),var);
			<f ok>
				if (!success) htmlprintf ("Can't set variable document: %s\n",msg);
			</f>
			</call>
		}
	}
	/- </div>
	// Script to make sure the webtabs tabs use the full height of the screen
	// Then it takes the webtables and grows them too.
	<?
	<script>
		document.onreadystatechange = function () {
			var state = document.readyState;
			if (state == 'interactive') {
				fixsize();
			} else if (state == 'complete') {
				//initOnCompleteLoad();
			}
		};
		var t = document.getElementById('head').offsetHeight;
		var diff = window.innerHeight-t;
		document.getElementById("tab").style.height=diff;
		function allDescendants (node,total) {
			//console.log ("Enter " + node.className + " " + node.id);
			for (var i = 0; i < node.childNodes.length; i++) {
				var child = node.childNodes[i];
				if (child.id != null
					&& (child.id == "tabs"
						|| child.id == "tab_form"
						|| child.id == "webtable-top")){
					total += child.offsetHeight;
					console.log ("child.id=" + child.id + " total="+total+" height="+child.offsetHeight);
				}else{
					if (child.className == "webtable"){
						console.log ("Set webtable total="+total);
						child.style.height = diff - total;
						break;
					}
					total = allDescendants(child,total);
				}
			}
			return total;
		}
		function fixsize(){
			var tabs = document.getElementsByClassName("tabs");
			console.log ("tabs.length=" + tabs.length);
			var i;
			for (i=0; i<tabs.length; i++){
				allDescendants (tabs[i],0);
			}
			var tables = document.getElementsByClassName('webtable');
			console.log ("ready " + document.readyState);
			for (i = 0; false && i < tables.length; i++) {
				var table = tables[i];
				if (table.id != "" && table.id != "doctype0" && table.id != "doctype1"){
					var top = document.getElementById("webtable-top");
					var toph = 0;
					if (top != null){
						toph = top.offsetHeight;
					}
					var form = document.getElementById("tab_form");
					var formh = 0;
					if (form != null){
						formh = form.offsetHeight;
					}
					var newh = diff - toph - formh;
					//if (table.id == "project") table.style.height = newh-35;
					console.log ("upd2:" + table.id + "=" + toph + "=" + formh + "="+ newh);
				}
			}
			for (i = 0; i < tables.length; i++) {
				var table = tables[i];
				console.log (table.id+" "+table.offsetHeight+" "+table.offsetWidth);
			}
		}
	</script>
	?>
}
</mod>

extern "C" void tlmp_initmod()
{
	translat_load ("bolixo");
}

<mod>
extern "C" void webmain()
{
	if (w_test == 1){
		/-ok
		return;
	}
	long long start = fdpass_getnow();
	<call tcpconnect>("unix:","/tmp/stop.sock",1);
	<f init>
	</f>
	<f oneline>
		webmain_real();
		end=true;
	</f>
	<f fail>
		webmain_real();
	</f>
	<f end>
	</f>
	</call>
	long long end = fdpass_getnow();
	glocal long long diff = end - start;
	<call savefile>("/tmp/duration",true);
	<f dowrite>
		fprintf (fout,"%s?%s: %Ld.%06Ld\n"
			,tlmpweb_curpage(),getenv ("QUERY_STRING")
			,glocal.diff/1000000,glocal.diff%1000000);
		return 0;
	</f>
	</call>
}
</mod>

