#include <stdarg.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include <string.h>
#include <tlmpweb.h>
#include <tlmpnet.h>
#include <tlmplib.h>
#include <tlmpdoc.h>
#include <trlitool.h>
#include <string>
#include <algorithm>
#include "util.h"
#define DEFINE_TBFTYPE
#include "../bolixo.h"
#include "../bolixo.m"
#include <linuxconf/translat.h>

using namespace std;

#include "../proto/bod_client.protoch"
#include "../proto/bo-sessiond_client.protoch"

static const char *newscolor = "green";

static string w_session;
static W_SSTRING w_lang("lang");
static W_SSTRING w_public_dir("public_dir");
static W_UNSIGNED w_public_view("public_view");

static W_SSTRING w_folder("folder");
static W_SSTRING w_upload("upload");
static W_SSTRING w_accept("accept");
static W_SSTRING w_user("user");
static W_SSTRING w_list("list");
static W_SSTRING w_group("group");
static W_UNSIGNED w_add("add");
static W_SSTRING w_desc("desc");
static W_SSTRING w_group1("group1");
static W_SSTRING w_group2("group2");
static W_SSTRING w_group3("group3");
static W_SSTRING w_group4("group4");
static W_SSTRING w_access1("access1");
static W_SSTRING w_access2("access2");
static W_SSTRING w_access3("access3");
static W_SSTRING w_access4("access4");

static W_SSTRING w_image("image");
extern W_SSTRING w_webtable;
static W_UNSIGNED w_offset ("offset");
static map<string,unsigned> offsets;
static map<string,unsigned> currents;
struct WEBTAB{
	string tab;	// Name of this tab withing the webtab
	string flags;
	string state;
	WEBTAB(){}
	WEBTAB(PARAM_STRING _tab, PARAM_STRING args){
		tab  = _tab.ptr;
		vector<string> tb;
		str_splitline(args.ptr,',',tb);
		for (auto &v:tb){
			if (strncmp(v.c_str(),"f=",2)==0){
				flags = v.substr(2);
			}else if (strncmp(v.c_str(),"s=",2)==0){
				state = v.substr(2);
			}
		}
	}
	bool operator < (const WEBTAB &n) const {
		return tab < n.tab;
	}
};
static map<string,vector<WEBTAB>> tabs;
void webtab_init (const vector<SNAMEVAL_receive> &vals)
{
	for (auto &s:vals){
		// Split the name
		const char *pt = strchr(s.sname,':');
		if (pt != NULL){
			tabs[string(s.sname,pt)].push_back(WEBTAB(pt+1,s.sval));
		}
	}
}

static W_UNSIGNED w_order ("order");
static unsigned order = 0;
static W_UNSIGNED w_test("test");
static W_UNSIGNED w_robot("robot");
static W_SSTRING w_email("email");
static W_SSTRING w_password("password");

static W_SSTRING new_nickname("nickname");
static W_SSTRING new_email ("new_email");
static W_SSTRING new_password1 ("new_password1");
static W_SSTRING new_password2 ("new_password2");

static W_SSTRING w_content("content");
static W_SSTRING w_filename("filename");
static W_SSTRING w_confirm("confirm");

static const int step_main=1;
static const int step_login=2;
static const int step_adduser=3;
static const int step_logout=4;
static const int step_image=5;
// 6 unused
static const int step_projects=7;
static const int step_mails=8;
static const int step_talks=9;
static const int step_confirm=10;
static const int step_profile=11;
static const int step_doc=12;

static W_UNSIGNED w_webtab("webtab");
static W_SSTRING  w_webtab_add("webtab_add");

#define _TLMP_webtabs
struct _F_webtabs {
	bool redo;
	string curid;		// ID of the active tab
	string curstate;	// State of the active TAB
	_F_webtabs(){
		redo = false;
	}
	void setid (PARAM_STRING id);	// Change the ID of the active TAB
	void setstate (PARAM_STRING val);// Record some value for the active TAB
	void redotab ();		// Ask webtabs to redraw the current TAB
	#define _F_webtabs_docstyle1(x) void x docstyle1(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_docstyle1( )=0;
	#define _F_webtabs_docstyle2(x) void x docstyle2(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_docstyle2( );
	#define _F_webtabs_docstyle3(x) void x docstyle3(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_docstyle3( );
	#define _F_webtabs_docstyle4(x) void x docstyle4(const char *id, const char *formid, const char *state)
	virtual _F_webtabs_docstyle4( );
};
void _F_webtabs::setid (PARAM_STRING id)
{
	curid = id.ptr;
}
void _F_webtabs::setstate (PARAM_STRING state)
{
	curstate = state.ptr;
}
void _F_webtabs::redotab ()
{
	redo = true;
}
static string toupper (const char *s)
{
	string ret;
	while (*s != '\0'){
		ret += toupper(*s);
		s++;
	}
	return ret;
}
static void webtab_href_c (const char *title, const char *href, const char *color)
{
	htmlprintf ("<a href=\"#\" style=\"text-decoration:none\" onclick=formsubmit(\"%s\")><table bgcolor=\"%s\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>\n"
		,href,color,title);
}
static void webtab_aref_selected (const char *title, int tab)
{
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	webtab_href_c (title,href.c_str(),"#220022");
}
static void webtab_href (const char *title, PARAM_STRING href)
{
	webtab_href_c(title, href.ptr,"#33cc33");
}
static void webtab_aref (const char *title, int tab)
{
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	webtab_href (title,href);
}
void _F_webtabs::docstyle2(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::docstyle3(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::docstyle4(const char *id, const char *formid, const char *state)
{
}
struct TABSEL {
	string id;
	unsigned no;	// Position in tabs
	TABSEL(){
		no = 0;
	}
};
#define WEBTAB_MARK '*'
<mod>
static void webtabs(_F_webtabs &c,
	const char *name,
	map<string,vector<WEBTAB>> &alltabs,
	bool may_delete)
{
	vector<WEBTAB> &tabs = alltabs[name];
	glocal bool may_delete = may_delete;
	if (w_webtab_add.isset()){
		// We are either adding a new tab or selecting an existing one.
		// While we look if the tab already exist, we de-select the others
		string id = w_webtab_add.c_str();
		bool found = false;
		for (auto &t:tabs){
			if (t.tab == id){
				found = true;
				t.flags = "sel";
			}else{
				t.flags.clear();
			}
		}
		if (!found){
			tabs.push_back(WEBTAB(id,"f=sel"));
			sort (tabs.begin(),tabs.end());
		}
		w_webtab = 0;
	}
	if (may_delete && w_webtab > 0 && (w_webtab & 1)==0){
		// A click on the X to delete one tab
		unsigned delete_tab = (w_webtab-1) / 2;
		unsigned nbtab = tabs.size();
		if (delete_tab < nbtab){
			// If the deleted tab is currently selected (active)
			// we must select another one.
			if (tabs[delete_tab].flags == "sel"){
				for (auto &t:tabs) t.flags.clear();
				if (delete_tab > 0){
					tabs[delete_tab-1].flags = "sel";
				}else if (delete_tab < nbtab-1){
					tabs[delete_tab+1].flags = "sel";
				}
			}
			const char *id = tabs[delete_tab].tab.c_str();
			tlmpweb_deleteform(id);
			tabs.erase (tabs.begin()+delete_tab);
			w_webtab = 0;
		}
	}
	glocal vector<WEBTAB> *tabs = &tabs;
	glocal const char *name = name;
	glocal TABSEL sel;
	// Assign the selected tab if none is selected
	{
		TABSEL default_sel;
		unsigned no = 1;
		for (auto &t:tabs){
			const char *tabname = t.tab.c_str();
			if (default_sel.id.size() == 0){
				default_sel.id = tabname;
				default_sel.no = no;
			}
			bool is_sel = t.flags == "sel";
			if (w_webtab > 0){
				if (w_webtab == no){
					glocal.sel.id = tabname;
					glocal.sel.no = no;
					t.flags = "sel";
				}else{
					t.flags.clear();
				}
			}else{
				if (is_sel){
					glocal.sel.id = tabname;
					glocal.sel.no = no;
				}
			}
			no+=2;
		}
		if (glocal.sel.id.size()==0){
			glocal.sel.id = default_sel.id;
			glocal.sel.no = default_sel.no;
		}
	}
	bool draw_ok = true;
	if (!tlmpweb_get_output_state()){
		// PATCH
		// This is a trick to allow the webtable::click system to work
		// inside a vframe2h. We assume this is only used on the right side for now.
		draw_ok = false;
	}

	// We draw the tab content before drawing the tabs because the tabs may change
	vector<string> lines;
	if (draw_ok) tlmpweb_pushgrab(lines);
	if (glocal.sel.id.size() > 0){
		WEBTAB *ptt = NULL;
		for (auto &t:tabs){
			if (t.tab == glocal.sel.id){
				ptt = &t;
				break;
			}
		}
		while (1){
			w_webtab = glocal.sel.no;
			FORM_HIDDEN t(w_webtab);
			const char *id = glocal.sel.id.c_str();
			const char *id_2 = id+2;
			const char *end = strchr(id_2,WEBTAB_MARK);
			string tmp;
			if (end != NULL){
				tmp = string(id_2,end-id_2);
				id_2 = tmp.c_str();
			}
			c.curid = id_2;
			c.curstate = ptt->state;
			const char *state = ptt->state.c_str();
			if (strncmp(id,"1:",2)==0){
				c.docstyle1(id_2,id,state);
			}else if (strncmp(id,"2:",2)==0){
				c.docstyle2(id_2,id,state);
			}else if (strncmp(id,"3:",2)==0){
				c.docstyle3(id_2,id,state);
			}else if (strncmp(id,"4:",2)==0){
				c.docstyle4(id_2,id,state);
			}else{
				c.docstyle1(id,id,state);
			}
			if (!draw_ok) break;
			// setid or setstate was called;
			ptt->tab = string(id,2)+c.curid;
			ptt->state = c.curstate;
			glocal.sel.id = ptt->tab;
			if (!c.redo) break;
			c.redo = false;
			lines.clear();
		}
				
	}
	if (draw_ok){
		tlmpweb_popgrab();
		// height=100%
		/- <table border=0 width=100% height=100%>
		/- <tr><td height=1% valign=top>
		<call button_row>(0,"white");
		<f draw>
			unsigned no = 1;
			for (auto &t:*glocal.tabs){
				split();
				const char *name = t.tab.c_str();
				bool is_sel = glocal.sel.no == no;
				if (is_sel){
					webtab_aref_selected (name,no);
				}else{
					webtab_aref (name,no);
				}
				if (glocal.may_delete){
					split();
					webtab_aref("x",no+1);
				}
				no += 2;
			}
		</f>
		</call>
		/- <tr><td valign=top height=99%>
		htmlout (lines);
		///- allo
		/- </table>
	}
}
</mod>
void webtabs(_F_webtabs &c,
	const char *name,
	map<string,vector<WEBTAB>> &tabs)
{
	webtabs (c,name,tabs,true);
}
void webtabs(_F_webtabs &c,
	const char *name,
	const vector<string> &starttabs,
	map<string,vector<WEBTAB>> &alltabs)
{
	vector<WEBTAB> &tabs = alltabs[name];
	for (auto &s:starttabs){
		bool found = false;
		for (auto &w:tabs){
			if (s == w.tab){
				found = true;
				break;
			}
		}
		if (!found){
			tabs.push_back(WEBTAB(s,""));
		}
	}
	webtabs (c,name,alltabs,false);
}
struct _F_sendfile_common {
	string handle;
	bool success;
	void sethandle (PARAM_STRING handle);
	void setresult (bool success, PARAM_STRING msg);
};
void _F_sendfile_common::sethandle (PARAM_STRING _handle)
{
	handle = _handle.ptr;
}
void _F_sendfile_common::setresult (bool _success, PARAM_STRING msg)
{
	success = _success;
	if (!success) htmlprintf ("sendfile failed: %s<br>\n",msg.ptr);
}

#define _TLMP_sendfile
struct _F_sendfile: public _F_sendfile_common {
	#define _F_sendfile_start(x) void x start(const char *filepath, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_start( )=0;
	#define _F_sendfile_rest(x) void x rest(const string &handle, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_rest( )=0;
};

static void sendfile(_F_sendfile &c, PARAM_STRING filepath, PARAM_STRING localfile, bool &fail)
{
	c.success = true;
	FILE *fin = fopen (localfile.ptr,"r");
	if (fin == NULL){
		htmlprintf ("Internal error reading temp file: :%s:<br>\n",localfile.ptr);
		fail = true;
	}else{
		char buf[40000];
		size_t nb = fread (buf,1,sizeof(buf),fin);
		bool more = (nb == sizeof(buf));
		c.start (filepath.ptr,BOB_TYPE(buf,nb,false),more);
		if (more && c.success){
			if (c.handle.empty()){
				tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
				htmlprintf ("Internal error, sendfile has not handle<br>\n");
			}else{
				while (more && c.success){
					nb = fread (buf,1,sizeof(buf),fin);
					more = (nb == sizeof(buf));
					c.rest (c.handle,BOB_TYPE(buf,nb,false),more);
				}
			}
		}
		fclose (fin);
	}
	if (!c.success) fail = true;
}
#define _TLMP_sendfile_var
struct _F_sendfile_var: public _F_sendfile_common {
	#define _F_sendfile_var_start(x) void x start(const char *filepath, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_var_start( )=0;
	#define _F_sendfile_var_rest(x) void x rest(const string &handle, const BOB_TYPE &content, bool more)
	virtual _F_sendfile_var_rest( )=0;
};
static void sendfile_var(_F_sendfile_var &c, PARAM_STRING filepath, const W_SSTRING &var_content, bool &fail)
{
	const char *content = var_content.c_str();
	c.success = true;
	unsigned len = strlen(content);
	unsigned nb = len;
	bool more = false;
	if (nb > 40000){
		nb = 40000;
		more = true;
	}
	c.start (filepath.ptr,BOB_TYPE(content,nb,false),more);
	if (more && c.success){
		if (c.handle.empty()){
			tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
			htmlprintf ("Internal error, sendfile has not handle<br>\n");
		}else{
			unsigned offset = nb;
			while (offset < len && c.success){
				nb = len - offset;
				more = false;
				if (nb > 40000){
					nb = 40000;
					more = true;
				}
				c.rest (c.handle,BOB_TYPE(content+offset,nb,false),more);
				offset += nb;
			}
		}
	}
	if (!c.success) fail = true;
}
	

static void show_buttons_right(_F_websteps *c)
{
	int step = c->getcurstep();
	/- <table border=0 cellspacing=0>
	/- <tr>
		
	bool is_user = userinfo.name.size() > 0;
	if (!is_user){
		if (step != step_login && step != step_adduser){
			/- <td>
			/- <font size=4 color=lightgray>
			htmlprintf (MSG_U(I_ANONYMOUS,"Anonymous, for your eyes only"));
			/- </font>
			/- <td>&nbsp;
			/- <td>
			print_aref (MSG_U(I_LOGIN,"Login"),step_login);
			/- <td>&nbsp;
			/- <td align=center>
			/- <font size=4 color=black>or</font>
			/- <td>&nbsp;
			/- <td>
			print_aref (MSG_U(I_CREATEACCT,"Create account"),step_adduser);
		}
	}
	if (userinfo.is_admin){
		/- <td>
		string tmp = string_f ("href=%s/admin.hc style=\"text-decoration:none\"",tlmpweb_curdir());
		print_href("Admin menu",tmp);
	}
	if (is_user){
		/- <td>
		print_aref (MSG_U(I_LOGOUT,"Logout"),step_logout);
		/- <td>&nbsp;
		/- <td>
		/- <font size=4 color=lightgray>
		htmlprintf (MSG_U(I_WELCOME,"Welcome %s"),userinfo.name.c_str());
		int nb = 40 - userinfo.name.size() - 8; 
		for (int i=0; i<nb; i++){
			htmlprintf ("&nbsp;");
		}
		/- </font>
	}
	/- </table>
}


static void show_buttons_context(_F_websteps *c)
{
	#if 0
	int step = c->getcurstep();
	/- <table border=0 cellspacing=0 width=100%>
	/- <tr>
		
	/- <td align=right>
	/- <table border=0>
	/- <td align=right>
	printhref ("/about.html","About bolixo.org",true);
	/- </table>
	/- </table>
	#endif
}
static unsigned subject = 0;
const unsigned max_subject=7;

static void print_button (const char *title, int step, int curstep)
{
	if (step == curstep){
		print_aref_selected (title,step);
	}else{
		print_aref (title,step);
	}
}
struct CURRENTFORM{
	string id;
	vector<string> vars;
};
static CURRENTFORM currentform;
<mod>
static void bolixo_title (const char *title, _F_websteps *c)
{
	glocal int step = c->getcurstep();

	string tmp = string_f ("Bolixo: %s",title);
	tlmpweb_title (tmp.c_str());
	util_google_code();
	util_defstyles();
	tlmpweb_body("white",NULL);
	/- <table border=0 height=100% width=100%><tr><td height=5%>
	htmlprintf ("<table width=100%% bgcolor=%s cellspacing=0><tr><td align=left>\n",newscolor);
		/- <table border=0><tr><td><a href=/7s.html style=\"text-decoration:none\"><img src=/favicon.ico></a></td><td align=left>
		htmlout ("<a href=/index.hc style=\"text-decoration:none\"><font size=15 color=\"white\">Bolixo.org</font></a>&nbsp;&nbsp;&nbsp;");
		/- <td>
		if (userinfo.name.empty()) printhref ("/about.html",MSG_U(I_ABOUT,"<font color=white>A peer to peer open social media</font>"),true);
		/- </td></tr></table>
	/- </td><td align=right valign=top>
	show_buttons_right (c);
	/- </td></tr>
	/- <tr><td align=left>
	if (w_robot == 0 && userinfo.name.size() > 0){
		<call button_row>(0,"white");
		<f draw>
			split();
			print_button (MSG_U(M_MAIN,"Main"),1,glocal.step);
			split();
			print_button (MSG_U(M_TALK,"Talk"),step_talks,glocal.step);
			split();
			print_button (MSG_U(M_MAIL,"Mail"),step_mails,glocal.step);
			split();
			print_button (MSG_U(M_PROJECTS,"Projects"),step_projects,glocal.step);
			split();
			print_button (MSG_U(M_PROFILE,"Profile"),step_profile,glocal.step);
			split();
			print_button (MSG_U(M_DOCUM,"Documentation"),step_doc,glocal.step);
		</f>
		</call>
	}else{
	}
	/- <td align=right>
	show_buttons_context (c);
	/- </tr></table>
	/- <tr><td height=95%>
}
</mod>
<mod>
static bool valid_context (CONNECT_INFO &con, _F_websteps *c, const char *subject, bool check_news, bool check_proof)
{
	glocal bool ret = true;
	if (userinfo.name.empty()){
		bolixo_title ("",c);
		/- <p>You must be logged to
		printf ("%s<p>\n",subject);
		/- You do not have an account, just create one (top right button).
		/- <br>
		/- It takes one minute.
		/- <p>
		/- See the 
		printhref_raw ("/terms-of-use.html","terms of use",false);
		/- &nbsp;for more details.
		glocal.ret = false;
	}
	return glocal.ret;
}
</mod>

static void trli_initvar (VAR &var, PARAM_STRING name, PARAM_STRING val)
{
	var.name = name.ptr;
	SNAMEVAL sval;
	sval.sval = val.ptr;
	var.vals.push_back(sval);
}

<mod>
static void trli_getsessioninfo(CONNECT_INFO &con, CONNECT_INFO &con_sess, DOCUMENT_POINTER &docpointer)
{
	glocal CONNECT_INFO *con = &con;
	glocal DOCUMENT_POINTER *docpointer = &docpointer;
	<call bo_sessiond_client_getsessioninfovars>(con_sess,w_session.c_str());
	<f ok>
		if (success){
			userinfo.lang = lang;
			if (lang[0] != '\0') translat_selectlang (lang);
			userinfo.name = name;
			userinfo.is_admin = admin;
			for (auto &var:vars){
				if (strcmp(var.name,"subject")==0 && var.vals.size()==1) subject=atoi(var.vals[0].sval);
				if (strcmp(var.name,"order")==0 && var.vals.size()==1) order=atoi(var.vals[0].sval);
				if (strcmp(var.name,"offsets")==0){
					for (auto &s:var.vals) offsets[s.sname] = atoi(s.sval);
				}else if (strcmp(var.name,"currents")==0){
					for (auto &s:var.vals) currents[s.sname] = atoi(s.sval);
				}else if (strcmp(var.name,"webtabs")==0){
					webtab_init (var.vals);
				}else if (strcmp(var.name,"document")==0){
					unsigned s1=0,s2=0,s3=0,s4=0;
					for (auto &v:var.vals){
						if (strcmp(v.sname,"s1")==0){
							s1 = atoi(v.sval);
						}else if (strcmp(v.sname,"s2")==0){
							s2 = atoi(v.sval);
						}else if (strcmp(v.sname,"s3")==0){
							s3 = atoi(v.sval);
						}else if (strcmp(v.sname,"s4")==0){
							s4 = atoi(v.sval);
						}
					}
					glocal.docpointer->set(s1,s2,s3,s4);
					glocal.docpointer->resetchanged();
						
				}else if (strcmp(var.name,"currentform")==0){
					for (auto &v:var.vals){
						if (strcmp(v.sname,"id")==0){
							currentform.id = v.sval;
						}else if (strcmp(v.sname,"var")==0){
							currentform.vars.push_back(v.sval);
						}
					}
				}
			}
			// Refresh the cookie so it is valid for 2 more days
			websession_setcookie("session",w_session.c_str(),time(NULL)+48*60*60);
		}else{
			userinfo.reset();
			<call bod_client_createsession>(*glocal.con);
			<f ok>
				w_session = sessionid;
				websession_setcookie("session",sessionid,time(NULL)+48*60*60);
			</f>
			</call>
		}
	</f>
	</call>
}
</mod>

static void button_validate(int step)
{
	htmlprintf ("<input type=\"submit\" value=\"Validate\" formaction=\"%s?webstep=%d&validate=1\">\n"
		,tlmpweb_curpage(),step);
}

<mod>
static void web_updateoffsets(CONNECT_INFO &con_sess)
{
	if (w_webtable.isset() && w_offset.isset()){
		if (offsets[w_webtable.c_str()] != w_offset){
			offsets[w_webtable.c_str()] = w_offset;
			VAR var;
			var.name = "offsets";
			for (auto &v:offsets){
				SNAMEVAL val;
				val.sname = v.first;
				val.sval = string_f ("%u",v.second);
				var.vals.push_back(val);
			}
			<call bo_sessiond_client_setvar>(con_sess,w_session.c_str(),var);
			<f ok>
				if (!success) printf ("Can't set variable offset: %s\n",msg);
			</f>
			</call>
		}
	}
}
</mod>
<mod>
static void web_updatecurrents(CONNECT_INFO &con_sess)
{
	VAR var;
	var.name = "currents";
	for (auto &v:currents){
		SNAMEVAL val;
		val.sname = v.first;
		val.sval = string_f ("%u",v.second);
		var.vals.push_back(val);
	}
	<call bo_sessiond_client_setvar>(con_sess,w_session.c_str(),var);
	<f ok>
		if (!success) printf ("Can't set variable current: %s\n",msg);
	</f>
	</call>
}
</mod>

/*
	Format a short message, remove the signature
*/
static string index_format_shortmsg (const char *txt, unsigned nblines)
{
	string ret;
	unsigned pos=0;
	unsigned noline=0;
	if (nblines == 0) nblines=(unsigned)-1;
	while (*txt != '\0' && noline < nblines){
		if (strncmp(txt,"------\n",7)==0){
			break;
		}else if (*txt == '<'){
			ret += "&lt;";
		}else if (*txt == '>'){
			ret += "&gt;";
		}else if (*txt == '\n'){
			ret += "<br>\n";
			pos=0;
			noline++;
		}else if (*txt == '\t'){
			unsigned nb = 4 - (pos%4);
			for (unsigned i=0; i<nb; i++) ret += "&nbsp;";
		}else{
			ret += *txt;
			pos++;
		}
		txt++;
	}
	return ret;
}
static string index_format_shortmsg (const char *txt)
{
	return index_format_shortmsg (txt,0);
}
<mod>
static void index_sendfile (CONNECT_INFO &con, PARAM_STRING filename, const char *filetype)
{
	glocal CONNECT_INFO *con = &con;
	glocal const char *filetype = filetype;
	<call bod_client_readfile_bob>(con,w_session.c_str(),filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
		}else{
			tlmpweb_doctype (glocal.filetype,size);
			htmlwrite (content.getbuffer(),content.getsize());
			glocal bool more = more;
			while (glocal.more){
				<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
				<f ok>
					htmlwrite (content.getbuffer(),content.getsize());
					glocal.more = more;
				</f>
				</call>
			}	
		}
	</f>
	</call>
}
<mod>
static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, string &text)
{
	glocal CONNECT_INFO *con = &con;
	glocal string *text = &text;
	glocal int ret = 0;
	text.clear();
	<call bod_client_readfile_bob>(con,w_session.c_str(),filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
			glocal.ret = -1;
		}else{
			(*glocal.text) = string((const char*)content.getbuffer(),content.getsize());
			glocal bool more = more;
			while (glocal.more && glocal.ret != -1){
				<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
				<f ok>
					if (!success){
						glocal.ret = -1;
						htmlprintf ("Can't read file: %s\n",msg);
					}else{
						(*glocal.text) += string((const char*)content.getbuffer(),content.getsize());
					}
					glocal.more = more;
				</f>
				</call>
			}	
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>

static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, W_SSTRING &text)
{
	string tmp;
	int ret = index_loadfile(con,filename,tmp);
	text = tmp;
	return ret;
}

</mod>
static void index_format_large_text(const BOB_TYPE &content)
{
	string tmp = string((const char*)content.getbuffer(),content.getsize());
	tmp = index_format_shortmsg (tmp.c_str());
	htmlwrite (tmp.c_str(),tmp.size());
}
<mod>
static void index_popup (CONNECT_INFO &con, const char *content, FILE_TYPE file_type, PARAM_STRING filepath)
{
	glocal CONNECT_INFO *con = &con;
	const char *path = filepath.ptr;
	if (content[0] != '\0'){
		tlmpweb_doctype ("text/html",0);
		const char *pt = content;
		while (*pt != '\0'){
			pt = format_line (pt);
			if (*pt == '\n'){
				htmlout ("<br>\n");
				pt++;
			}
		}
	}else if (file_is_sound(file_type)){
		htmlprintf ("<audio controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"audio/%s\">\n"
			"</audio>"
			,tlmpweb_curpage(),step_image,path,tbftype[file_type]);
	}else if (file_is_video(file_type)){
		htmlprintf ("<video width=\"800\" height=\"600\" controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"video/mp4\">\n"
			"Your browser does not support the video tag.\n"
			"</video>\n"
			,tlmpweb_curpage(),step_image,path);
	}else if (file_is_image(file_type)){
		htmlprintf ("<img width=800 src=%s?webstep=%u&image=%s>"
			,tlmpweb_curpage(),step_image,path);
	}else if (file_is_text(file_type)){
		<call bod_client_readfile_bob>(con,w_session.c_str(),path,"",false);
		<f ok>
			if (!success){
				htmlprintf ("Can't read file: %s\n",msg);
			}else{
				index_format_large_text (content);
				glocal bool more = more;
				while (glocal.more){
					<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
					<f ok>
						index_format_large_text (content);
						glocal.more = more;
					</f>
					</call>
				}	
			}
		</f>
		</call>
	}
}
</mod>

<mod>
static void index_show_shortmsg(
	CONNECT_INFO &con,
	CONNECT_INFO &con_sess,
	const string &table,
	PARAM_STRING groupname,
	PARAM_STRING groupowner)
{
	glocal CONNECT_INFO *con = &con;
	glocal CONNECT_INFO *con_sess = &con_sess;
	glocal const char *groupname = groupname.ptr;
	glocal const char *groupowner = groupowner.ptr;
	<call webtable>(table,"100%",currents[table],offsets[table],5);
	<f click>
		tlmpweb_flushheader();
		<call bod_client_list_talk>(*glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,noline,1);
		<f ok>
			if (messages.size()!=1){
				htmlprintf ("Internal error: %s\n",msg);
			}else{
				auto &m = messages[0];
				//htmlprintf ("uuid=%s<p>\n",m.uuid);
				index_popup (*glocal.con,m.content,m.file_type,string_f("/msgs/%s/short-inbox/%s/%s",glocal.groupowner,glocal.groupname,m.uuid));
			}
		</f>
		</call>
	</f>
	<f load>
		glocal unsigned rownum = nbskip;
		sethead (MSG_U(H_TALK,"From\tSubmit"));
		<call bod_client_list_talk>(*glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,nbskip,nblines);
		<f ok>
			if (!success){
				htmlprintf ("Error: %s %s<br>",internal_error?"Internal error":"",msg);
			}else{
				for (auto &m:messages){
					const char *func = "Popup";
					const char *funcopt = "400,100";
					if (file_is_image(m.file_type) || file_is_video(m.file_type)){
						funcopt = "800,800";
					}
					glocal.webtable.setclickopt (true,func,funcopt);
					if (strcmp(m.from,userinfo.name.c_str())==0){
						glocal.webtable.setrow ("sep",glocal.rownum,"\t%s"
							,m.submit);
					}else{
						glocal.webtable.setrow ("sep",glocal.rownum,"<img width=30 src=%s?webstep=%u&image=/projects/%s/public/mini-photo.jpg>%s\t%s"
							,tlmpweb_curpage(),step_image,m.from,m.from
							,m.submit);
					}
					string path = string_f("/msgs/%s/short-inbox/%s/%s",glocal.groupowner,glocal.groupname,m.uuid);
					if (m.content[0] != '\0'){
						string tmp = index_format_shortmsg (m.content,5);
						glocal.webtable.setrow("image",glocal.rownum,"\t%s\a",tmp.c_str());
					}else if (file_is_sound(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,"\t<audio controls>\n"
							"<source src=\"%s?webstep=%u&image=%s\" type=\"audio/%s\">\n"
							"</audio>\a"
							,tlmpweb_curpage(),step_image,path.c_str(),tbftype[m.file_type]);
					}else if (file_is_image(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,"\t<img width=100 src=%s?webstep=%u&image=%s>\a\a\a"
							,tlmpweb_curpage(),step_image,path.c_str());
					}else if (file_is_video(m.file_type)){
						glocal.webtable.setrow("image",glocal.rownum,
							"\t<video width=\"200\" height=\"200\" controls>\n"
							"<source src=\"%s?webstep=%u&image=%s\" type=\"video/mp4\">\n"
							"Your browser does not support the video tag.\n"
							"</video>\a"
							,tlmpweb_curpage(),step_image,path.c_str());
					}else if (file_is_text(m.file_type)){
						// Large text file
						<call bod_client_readfile_bob>(*glocal.con,w_session.c_str(),path,"",true);
						<f ok>
							if (!success){
								htmlprintf (MSG_U(E_CANTREADFILE,"Can't read file: %s\n"),msg);
							}else{
								string tmp = string((const char*)content.getbuffer(),content.getsize());
								tmp = index_format_shortmsg (tmp.c_str(),5);
								glocal.webtable.setrow("image",glocal.rownum,"\t%s\a",tmp.c_str());
							}
						</f>
						</call>
					}
					glocal.rownum++;
				}
			}
		</f>
		</call>
	</f>
	</call>
}
</mod>

/*
	Define a form field to edit the access of a group within a list
*/
static void index_field_access (_F_form *c, W_VAR &var)
{
	c->field_list (var,"");
	c->field_list_item ("",MSG_U(I_INHERIT,"inherit"));
	c->field_list_item ("R",MSG_U(I_READONLY,"read-only"));
	c->field_list_item ("W",MSG_U(I_READWRITE,"read-write"));
	c->field_list_end();
}
static void index_field_group (_F_form *c, W_VAR &var, const vector<string> &groups)
{
	c->field_list (var,"");
	c->field_list_item("","");
	for (auto &s:groups) c->field_list_item (s.c_str(),s.c_str());
	c->field_list_end();
}


/*
	Update a group definition in a list
*/
<mod>
static void index_set_group (CONNECT_INFO &con, W_SSTRING &list, const char *group, const char *access, bool &fail)
{
	glocal bool fail = false;
	glocal const char *groupname = group;
	<call bod_client_set_group>(con,w_session.c_str(),list.c_str(),glocal.groupname,access,"");
	<f ok>
		if (!success){
			htmlprintf (MSG_U(E_UPDGROUP,"Failure to update group %s: %s<br>\n"),glocal.groupname,msg);
			glocal.fail = true;
		}
	</f>
	</call>
	if (glocal.fail) fail = true;
}
</mod>
static void index_set_group (CONNECT_INFO &con, W_SSTRING &list, W_SSTRING &group, W_SSTRING &access, vector<string> &groups, bool &fail)
{
	const char *groupname = group.c_str();
	if (groupname[0] != '\0'){
		groups.push_back(groupname);
		index_set_group (con,list,groupname,access.c_str(),fail);
	}
}

static void index_delete_new_from_old(const vector<string> &news, vector<string> &old)
{
	for (auto &n:news){
		auto p = find(old.begin(),old.end(),n);
		if (p != old.end()){
			old.erase(p);
		}
	}
}
<mod>
static ENTRY_TYPE index_entrytype(CONNECT_INFO &con,PARAM_STRING path)
{
	glocal ENTRY_TYPE ret = ENTRY_NONE;
	<call bod_client_stat>(con,w_session.c_str(),path,"");
	<f ok>
		glocal.ret = file.type;
	</f>
	</call>
	return glocal.ret;
}
</mod>
static bool profile_formactive (_F_webtabs &c, W_SSTRING &var, const char *state)
{
	static const char *adding = "__add__";
	if (w_add.isset()){
		c.setstate(adding);
	}else if (var.isset()){
		c.setstate(var.c_str());
	}else if (state[0] != '\0'){
		if (strcmp(state,adding)==0){
			w_add.setinitval("1");
		}else{
			var.setinitval(state);
		}
	}
	return var.isset() || w_add.isset();
}
/*
	Format the path of a mail
*/
static string index_format_mail_fname(const MESSAGE_receive &m)
{
	string fname;
	if (m.role[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s/%s",m.manager,m.project,m.role,m.uuid);
	}else if (m.manager[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s",m.manager,m.project,m.uuid);
	}else{
		fname = string_f ("/msgs/%s/inbox/%s",userinfo.name.c_str(),m.uuid);
	}	
	return fname;
}
<mod>
extern "C" void webmain_real()
{
	glocal bool account_confirmed = false;
	glocal CONNECT_INFO con;
	glocal CONNECT_INFO con_sess;
	glocal.con.port = "/dev/bod.sock";
	glocal.con.secret = "foo";
	glocal.con_sess.port = "/dev/sessiond.sock";
	glocal.con_sess.secret = "foo";
	glocal DOCUMENT_POINTER docpointer;
	if (tlmpweb_isrobot()) w_robot = 1;
	// debug
	if (0){
		<call savefile>("/tmp/environ.log",false);
		<f dowrite>
			extern char **environ;
			char **ptenv = environ;
			while (*ptenv != NULL){
				fprintf (fout,"%s\n",*ptenv);
				ptenv++;
			}
			return 0;
		</f>
		</call>
	}
	{
		<call savefile>("/tmp/agent.log",true);
		<f dowrite>
			string ip = tlmpweb_getip();
			const char *pt = getenv ("HTTP_USER_AGENT");
			if (pt == NULL){
				fprintf (fout,"%s: robot=%u HTTP_USER_AGENT null\n",ip.c_str(),w_robot.getval());
			}else{
				fprintf (fout,"%s: robot=%u HTTP_USER_AGENT %s\n",ip.c_str(),w_robot.getval(),pt);
			}
			return 0;
		</f>
		</call>
	}
	
	const char *ptsession = tlmpweb_getcookie("session");
	if (ptsession == NULL){
		<call bod_client_createsession>(glocal.con);
		<f ok>
			w_session = sessionid;
			websession_setcookie("session",sessionid,time(NULL)+48*60*60);
		</f>
		</call>
	}else{
		w_session=ptsession;
		trli_getsessioninfo(glocal.con,glocal.con_sess,glocal.docpointer);
	}
	if (w_session.empty()) return;
	
	web_updateoffsets (glocal.con_sess);
	webtable_ctrloutput();
	<obj WEBCONTEXT wctx>();
	<f settablerow>
		unsigned &cur = currents[tableid];
		if (cur != current_row){
			/*
				We avoid poluting the session manager with fake request.
				So we make sure the request is associated with a real or possible webtable
				We do the markview at the same time.
			*/
			glocal bool valid = false;
			if (tableid[0] == '/'){
				glocal const char *dir = tableid;
				<call bod_client_listdir>(glocal.con,w_session.c_str(),tableid,"",false,current_row,1);
				<f ok>
					if (files.size()==1){
						glocal.valid = true;
						string fname = string_f("%s/%s",glocal.dir,files[0].name);
						<call bod_client_markview>(glocal.con,w_session.c_str(),fname);
						<f ok>
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strncmp(tableid,"inbox",5)==0){
				const char *project = tableid+5;
				if (strcmp(project,"INBOX")==0) project = "";
				<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",project,false,current_row,1);
				<f ok>
					if (messages.size()==1){
						glocal.valid = true;
						string fname = index_format_mail_fname(messages[0]);
						<call bod_client_markview>(glocal.con,w_session.c_str(),fname);
						<f ok>
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strncmp(tableid,"list:",5)==0){
				const char *tab = tableid+5;
				if (strcmp(tab,"projects")==0
					|| strcmp(tab,"groups")==0
					|| strcmp(tab,"contacts")==0){
					glocal.valid = true;
				}
			}else if (strncmp(tableid,"talk",4)==0){
				vector<string> tb;
				int n = str_splitline (tableid+4,':',tb);
				if (n == 2){
					<call bod_client_list_talk>(glocal.con,w_session.c_str(),"",tb[1],tb[0],current_row,1);
					<f ok>
						if (messages.size()==1){
							glocal.valid = true;
						}
					</f>
					</call>
				}
			}
			if (glocal.valid){
				cur = current_row;
				web_updatecurrents(glocal.con_sess);
			}else{
				tlmp_error ("settablerow unknown tableid %s\n",tableid);
			}
		}
	</f>
	<f recordform>
		VAR var;
		var.name = "currentform";
		SNAMEVAL val;
		val.sname = "id";
		val.sval  = formid;
		var.vals.push_back(val);
		for (auto &v:variables){
			val.sname = "var";
			val.sval = v->getname();
			var.vals.push_back(val);
		}
		<call bo_sessiond_client_setvar> (glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) tlmp_error (MSG_U(E_SAVECURFORM,"Can't save active form state: %s\n"),msg);
		</f>
		</call>
	</f>
	<f restoreform>
		glocal int ret = -1;
		<call bod_client_form_readvar>(glocal.con,w_session.c_str(),formid);
		<f ok>
			if (!success){
				tlmp_error (MSG_U(E_RESTOREFORM,"Can't restore active form state %s: %s\n"),currentform.id.c_str(),msg);
			}else{
				if (vars.size() > 0){
					glocal.ret = 0;
					for (auto &v:vars){
						tlmpweb_setvar (v.name,v.val);
					}
				}	
			}
		</f>
		</call>
		return glocal.ret;
	</f>
	<f deleteform>
		glocal const char *formid = formid;
		<call bod_client_form_deletevar>(glocal.con,w_session.c_str(),formid);
		<f ok>
			if (!success) tlmp_error ("deleteform %s: %s\n",glocal.formid,msg);
		</f>
		</call>
	</f>
	<f deleteallform>
		<call bod_client_form_deleteall>(glocal.con,w_session.c_str());
		<f ok>
			if (!success) tlmp_error ("deleteallform: %s\n",msg);
		</f>
		</call>
	</f>
	<f saveform>
		if (currentform.id.size() > 0){
			FORMVARS f;
			f.id = currentform.id;
			for (auto &v:currentform.vars){
				FORMVAR var;
				var.name = v;
				var.val = t_varstr(v.c_str());
				f.vars.push_back(var);
			}
			<call bod_client_form_savevar>(glocal.con,w_session.c_str(),f);
			<f ok>
				if (!success) tlmp_error (MSG_U(E_SAVEFORM,"saveform currentform %s: %s\n"),currentform.id.c_str(),msg);
			</f>
			</call>
		}
	</f>
	<f webtableinit>
		if (strncmp(tableid,"list:",5)==0){
			c.settableparms ("border=0");
		}else{
			c.settableparms ("border=1");
		}
		c.setthparms ("align=left bgcolor=lightgray","");
		c.setrowstyle ("sep","bgcolor=ghostwhite");
		c.setrowstyle ("sep+current","bgcolor=lightblue");
		c.setrowstyle ("white","bgcolor=white");
		c.setrowstyle ("white+current","bgcolor=lightblue");
		c.setrowstyle ("whitebold","bgcolor=white><b>\b</b>");
		c.setrowstyle ("whitebold+current","bgcolor=lightblue><b>\b</b>");
		c.setrowstyle ("image","bgcolor=white align=center");
	</f>
	</obj>
	<call websteps>();
	<f setstep>
		if (w_session.empty() && step > 2){
			step = 1;
		}else if (userinfo.name.empty() && step != 2 && step != 3){
			step = 1;
		}
	</f>
	<f step1>
		bolixo_title ("",this);
		if (userinfo.name.size() == 0){
			// Anonymous, present public news ?
			/- So far no public content
		}else{
			/- <table border=0 height=100% width=100%>
			/- <tr><td valign=top>
			glocal string prjdir = string_f ("/projects/%s/public/default",userinfo.name.c_str());
			<call vframe4>("title","","");
			<f top_left>
				htmlprintf ("<img width=200 src=%s?webstep=%u&image=%s/image.jpg>"
					,tlmpweb_curpage(),step_image,glocal.prjdir.c_str());
			</f>
			<f top>
				<call bod_client_readfile>(glocal.con,w_session.c_str(),string_f("%s/intro.html",glocal.prjdir.c_str()),"");
				<f ok>
					string tmp = index_format_shortmsg (content);
					htmlout (tmp);
				</f>
				</call>
			</f>
			<f body>
				/- Documents
			</f>
			<f left>
				string table = string("talk")+"public";
				index_show_shortmsg (glocal.con,glocal.con_sess,table,"public",userinfo.name);
			</f>
			</call>
			/- </table>
		}
	</f>
	<f step2> // Login
		<call form>("login");
		<f top>
			bolixo_title (MSG_U(T_LOGIN,"Login"),&glocal.websteps);
			if (glocal.account_confirmed){
				<?#I_ACCTCONFIRM Welcome
			 	<p>
				The account is now confirmed, you can log in
				?>
			}else{
				/-#I_HAVEACCT Already have an account, please login<p>
			}
		</f>
		<f setup>
			/- <table border=0 align=center>
			/-#I_EMAIL <tr><td>Enter your email<td>
			field_string (w_email,"size=60");
			/-#I_PASSWORD <tr><td>Password<td>
			field_password (w_password,"");
			/- <tr><td>
			button_submit (MSG_U(B_LOGIN,"Login"));
			/- </table>
		</f>
		<f validate>
			bool ret = false;
			if (w_email.is_filled()){
				if (w_password.is_empty()){
					/-#I_PASSWDREQ <font color=red>You must supply a password</font>
				}else{
					ret = true;
				}
			}else{
				/-#I_PROVIDEEMAIL <font color=red>Please provide an email</font>
			}
			return ret;
		</f>
		<f process>
			glocal bool fail = false;
			<call bod_client_login>(glocal.con,w_session.c_str(),w_email.c_str(),w_password.c_str());
			<f ok>
				if (success){
					trli_getsessioninfo(glocal.con,glocal.con_sess,glocal.docpointer);
					glocal.websteps.gotostep(1);
				}else{
					/-#I_LOGINFAILED <font color=red>Login failed, invalid email or password</font>
					glocal.fail = true;
				}
			</f>
			</call>
			fail = glocal.fail;
		</f>
		</call>
	</f>
	<f step3> // Account creation
		glocal bool account_created = false;
		<call form>("createaccount");
		<f top>
			bolixo_title (MSG_U(T_CREATEACC,"Account creation"),&glocal.websteps);
			<?#I_NOACCOUNT No account ? Please create one.
			<p>
			Your email will only be used for the following reasons.
			<br>
			<ul>
			<li>Login.
			<li>Account confirmation.
			<li>Account modification confirmation.
			</ul>
			The only information shown on the web site is the nickname. Your email won't appear on the site.
			<p>
			See the
			?>
			printhref_raw ("/terms-of-use.html","terms of use",false);
			/-#I_MOREDETAILS &nbsp;for more details
		</f>
		<f setup>
			/- <table border=0 align=center>
			/-#I_NICKNAME <tr><td>Enter your nickname<td>
			field_string (new_nickname,"");
			/-#I_ENTERMAIL <tr><td>Enter your email<td>
			field_string (new_email,"");
			/-#I_ENTERPWD <tr><td>Password<td>
			field_password (new_password1,"");
			/-#I_CONFIRMPWD <tr><td>Confirm password<td>
			field_password (new_password2,"");
			/- <tr><td>
			button_submit (MSG_U(B_ACCACCOUNT,"Add account"));
			/- </table>
		</f>
		<f validate>
			bool ret = true;
			if (new_nickname.is_empty()){
				/-#E_NEEDNICKMAME <font color=red>Please provide a nickname</font>
				ret = false;
 			}else if (new_email.is_empty()){
				/-#E_NEEDEMAIL <font color=red>Please provide an email</font>
				ret = false;
			}else if (new_password1.is_empty()){
				/-#E_NEEDPWD <font color=red>Please enter a password</font>
				ret = false;
			}else if (strcmp(new_password1.c_str(),new_password2.c_str())!=0){
				/-#E_PWDMISMATCH <font color=red>Passwords do not match</font>
				ret = false;
			}
			return ret;
		</f>
		<f process>
			glocal bool fail = false;
			<call bod_client_adduser>(glocal.con,w_session.c_str(),new_nickname.c_str(),new_email.c_str(),new_password1.c_str());
			<f ok>
				if (confirmid[0] == '\0'){
					glocal.fail = true;
					/-#E_CREATACCT <font color=red>Account creation failure</font>
					htmlout (msg);
					/- </font>
				}else{
					glocal.account_created = true;
				}
			</f>
			</call>
			fail = glocal.fail;
		</f>
		</call>
		if (glocal.account_created){
			bolixo_title (MSG_R(T_CREATEACC),&glocal.websteps);
			<?#I_ACCTCREATED
			The account has been created
			<br>
			A confirmation email has been sent.
			<br>
			Once you received the email click on the link.
			This will complete the account creation process
			?>
		}

	</f>
	<f step4> // Logout
		tlmpweb_deleteallform();
		<call bod_client_logout>(glocal.con,w_session.c_str());
		<f ok>
			userinfo.reset();	//trli_getsessioninfo(glocal.con,glocal.con_sess);
			bolixo_title ("",&glocal.websteps);
			/-#I_HOPESEEYOU <p><p><p><p><table witdth=100%><tr><td align=center>Hope to see you again</table>
		</f>
		</call>
	</f>
	<f step5> // Send an image or video
		index_sendfile (glocal.con,w_image.c_str(),"image/jpeg");
	</f>	
	<f step6> // 
	</f>
	<f step7> // TAB Projects
		//HTMLDEBUG d1("t1");
		//HTMLDEBUG d2("t2");
		glocal string curtab;
		bolixo_title (MSG_R(M_PROJECTS),this);
		<call vframe2h>(10);
		<f left>
			// List projects
			<call webtable>("list:Projects","100%");
			<f load>
				sethead (MSG_U(H_PROJECTS,"Owner\tProject"));
				<call bod_client_list_inboxes>(glocal.con,w_session.c_str(),"",false);
				<f ok>
					for (auto &inb:inboxes){
						string id = string_f("%s/%s",inb.manager,inb.project);
						const char *style = "white";
						if (id == glocal.curtab){
							style = "white+current";
						}else if (strncmp(id.c_str(),glocal.curtab.c_str(),id.size())==0
							&& glocal.curtab[id.size()] == '/'){
							// Edit a document inside a project
							style = "white+current";
						}
						string add = string_f("webtab_add=1:%s/%s",inb.manager,inb.project);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow (style,0,"%s\t%s",inb.manager,inb.project);
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f right>
			<call webtabs>(MSG_R(M_PROJECTS),tabs);
			<f docstyle1>
				glocal.curtab = id;
				glocal const char *id = id;
				glocal string path = string_f ("/projects/%s",id);
				//htmlprintf ("Project %s<br>\n",glocal.path.c_str());
				<call form>(formid);
				<f top>
					/- <table border=0>
				</f>
				<f bottom>
					/- </table>
				</f>
				<f setup>
					/- <tr><td>
					/-#I_NEW_FOLDER New folder
					/- &nbsp;
					field_string (w_folder,"size=30");
					/- <tr><td>
					url_self (string_f("webtab_add=2:%s%c%ld",glocal.id,WEBTAB_MARK,time(NULL)),MSG_U(I_CREATENEWDOC,"Create a new document"));
					/- <tr><td>
					/-#I_UPLOADFILE Upload file
					/- &nbsp;
					field_file (w_upload);
					/- <tr><td>
					button_submit();
				</f>
				<f validate>
					return true;
				</f>
				<f process>
					glocal bool fail = false;
					if (strcmp(w_folder.c_str(),"")!=0){
						string filepath = string_f("%s/%s",glocal.path.c_str(),w_folder.c_str());
						<call bod_client_mkdir>(glocal.con,w_session.c_str(),filepath);
						<f ok>
							if (!success){
								glocal.fail = true;
								htmlprintf (MSG_U(E_CREATEFOLDER,"Can't create folder: %s<br>\n"),msg);
							}else{
								w_folder.setempty();
							}
						</f>
						</call>
					}
					if (strcmp(w_upload.c_str(),"")!=0){
						const char *tempname = tlmpweb_getfilename(w_upload);
						string filepath = string_f("%s/%s",glocal.path.c_str(),w_upload.c_str());
						<call sendfile>(filepath,tempname,glocal.fail);
						<f start>
							<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),filepath,content,more);
							<f ok>
								glocal.sendfile.sethandle(handle);
								glocal.sendfile.setresult(success,msg);
							</f>
							</call>
						</f>
						<f rest>
							<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
							<f ok>
								glocal.sendfile.setresult(success,msg);
							</f>
							</call>
						</f>
						</call>
					}
					keepediting = true;
					fail = glocal.fail;
				</f>
				</call>
				//HTMLDEBUG ("table",true);
				<call webtable>(glocal.path,"60%",currents[glocal.path],offsets[glocal.path],20);
				<f click>
					tlmpweb_flushheader();
					<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,noline,1);
					<f ok>
						if (files.size()!=1){
							htmlprintf (MSG_U(E_INTERNAL,"Internal error: %s\n"),msg);
						}else{
							auto &f = files[0];
							glocal FILE_TYPE file_type = f.file_type;
							glocal string fname = string_f("%s/%s",glocal.path.c_str(),f.name);
							if (file_is_text(f.file_type)){
								if (f.islarge){
									index_sendfile (glocal.con,glocal.fname,"text/html");
								}else{
									<call bod_client_readfile>(glocal.con,w_session.c_str(),glocal.fname,"");
									<f ok>
										if (!success){
											index_popup (glocal.con,msg,glocal.file_type,glocal.fname);
										}else{
											index_popup (glocal.con,content,glocal.file_type,glocal.fname);
										}
									</f>
									</call>
								}
							}else{
								index_popup (glocal.con,"",f.file_type,glocal.fname);
							}
						}
					</f>
					</call>
				</f>
				<f load>
					glocal unsigned rownum = nbskip;
					sethead (MSG_U(H_FOLDER,"Type\tEventdate\tModified\tOwner\tSize\tName"));
					<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,nbskip,nblines);
					<f ok>
						if (!success) htmlprintf (MSG_U(E_READDIR,"Can't read directory %s: %s<br>\n"),glocal.path.c_str(),msg);
						const char *func = "Popup";
						for (auto &f:files){
							string path = string_f ("%s/%s",glocal.id,f.name);
							if (bolixo_isdir(f.type)){
								glocal.webtable.setclickopt (true,"",string_f("webtab_add=1:%s",path.c_str()));
							}else if (file_is_image(f.file_type) || file_is_video(f.file_type)){
								glocal.webtable.setclickopt (true,func,"800,800");
							}else if (file_is_sound(f.file_type)){
								glocal.webtable.setclickopt (true,func,"350,50");
							}else if (file_is_text(f.file_type)){
								glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s",path.c_str()));
							}
							const char *style = f.viewed != VIEWED_OK ? "whitebold" : "white";
							glocal.webtable.setrow (style,glocal.rownum,"%c%s\t%s\t%s\t%s/%s:%s\t%u\t%s"
								,tbtype[f.type],tbftype[f.file_type]
								,f.eventdate,f.modified
								,f.owner,f.listname,f.listmode,f.size
								,f.name);
							glocal.rownum++;
						}
					</f>
					</call>
				</f>
				</call>
			</f>
			<f docstyle2>
				glocal.curtab = id;
				glocal const char *filename = id;
				glocal string path = string_f("/projects/%s",glocal.filename);
				glocal bool newdocument = false;
				if (index_entrytype(glocal.con,glocal.path)==ENTRY_DIR) glocal.newdocument = true;
				<call form>(formid);
				<f top>
					/- <table border=0 height=100%>
				</f>
				<f bottom>
					/- </table>
				</f>
				<f load>
					if (!glocal.newdocument){
						index_loadfile(glocal.con,glocal.path,w_content);
					}
				</f>
				<f setup>
					/- <tr><td align=left>
					if (glocal.newdocument){
						/-#I_NEWDOCNAME New document name&nbsp;
						field_string (w_filename,"size=30");	
					}else{
						htmlprintf (MSG_U(I_DOCNAME,"Document name:&nbsp;<font size=+1>%s</font>"),glocal.filename);
					}
					/- <td align=right>
					button_submit(MSG_U(B_SAVE,"Save"));
					/- <tr><td colspan=2>
					field_textarea(w_content,50,120,"");
				</f>
				<f validate>
					bool ret = true;
					if (glocal.newdocument){
						if (strcmp(w_filename.c_str(),"")==0){
							/- You must provide a file name
							ret = false;
						}else if (index_entrytype(glocal.con,string_f("%s/%s",glocal.path.c_str(),w_filename.c_str()))!=ENTRY_NONE){
							/- Document already exist
							ret = false;
						}
					}
					return ret;
				</f>
				<f process>
					<call sendfile_var>(glocal.path,w_content,fail);	
					<f start>
						if (glocal.newdocument){
							<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),string_f("%s/%s",glocal.path.c_str(),w_filename.c_str()),content,more);
							<f ok>
								glocal.sendfile_var.setresult(success,msg);
								glocal.sendfile_var.sethandle(handle);
							</f>
							</call>
						}else{
							<call bod_client_modifyfile_bob>(glocal.con,w_session.c_str(),filepath,content,more);
							<f ok>
								glocal.sendfile_var.setresult(success,msg);
								glocal.sendfile_var.sethandle(handle);
							</f>
							</call>
						}
					</f>
					<f rest>
						<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
						<f ok>
							glocal.sendfile_var.setresult(success,msg);
						</f>
						</call>
					</f>
					</call>
					if (!fail){
						if (glocal.newdocument){
							glocal.webtabs.setid (string_f("%s/%s",glocal.filename,w_filename.c_str()));
							glocal.webtabs.redotab();
							resetstate();
						}else{
							keepediting = true;
						}
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		</call>
		/- </table>
	</f>
	<f step8> // TAB Mails
		glocal string curtab;
		bolixo_title (MSG_U(T_MAILS,"Mails"),this);
		<call vframe2h>(10);
		<f left>
			<call webtable>("list:mail","100%");
			<f load>
				sethead (MSG_U(H_INBOXES,"Owner\tProject"));
				setclickopt (true,"","webtab_add=1:INBOX");
				const char *style = glocal.curtab == "INBOX" ? "white+current" : "white";
				setrow (style,0,"\t%s",MSG_U(I_INBOX,"INBOX"));
				<call bod_client_list_inboxes>(glocal.con,w_session.c_str(),"",true);
				<f ok>
					for (auto s:inboxes){
						const char *style = strcmp(s.project,glocal.curtab.c_str())==0 ? "white+current" : "white";
						string add = string_f("webtab_add=1:%s",s.project);
						//url_self (add.c_str(),"%s",s.role);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow(style,0,"%s\t%s",s.manager,s.project);
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f right>
			<call webtabs>("mails",tabs);
			<f docstyle1>
				glocal.curtab = id;
				glocal const char *project = id;
				if (strcmp(id,"INBOX")==0) glocal.project = "";
				string inbox = string("inbox") + id;
				<call webtable>(inbox,"60%",currents[inbox],offsets[inbox],20);
				<f click>
					// This code is never called
					tlmpweb_flushheader();
					<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",glocal.project,false,noline,1);
					<f ok>
						if (messages.size()!=1){
							htmlprintf ("Internal error: %s\n",msg);
						}else{
							htmlprintf ("title=%s<p>\n",messages[0].title);
							string path = index_format_mail_fname(messages[0]);
							<call bod_client_readfile>(glocal.con,w_session.c_str(),path,"");
							<f ok>
								const char *pt = content;
								while (*pt != '\0'){
									const char *start = pt;
									while (*pt != '\0' && *pt != '\n') pt++;
									htmlwrite (start,pt-start);
									htmlout ("<br>\n");
									if (*pt == '\n') pt++;
								}
							</f>
							</call>
						}
					</f>
					</call>
				</f>
				<f load>
					glocal unsigned rownum = nbskip;
					sethead (MSG_U(H_MAILS,"From\tManager\tProject\tRole\tSubmit\tTitle"));
					<call bod_client_list_msgs>(glocal.con,w_session.c_str(),"",glocal.project,false,nbskip,nblines);
					<f ok>
						if (!success){
							htmlprintf ("Error: %d %s<br>",internal_error,msg);
						}else{
							for (auto &m:messages){
								string path = index_format_mail_fname(m);
								glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s"
									,path.c_str()));
								const char *style = m.viewed != VIEWED_OK ? "whitebold" : "white";
								glocal.webtable.setrow (style,glocal.rownum,"%s\t%s\t%s\t%s\t%s\t%s"
									,m.from
									,m.manager
									,m.project
									,m.role
									,m.submit
									,m.title);
								glocal.rownum++;
							}
						}
					</f>
					</call>
				</f>
				</call>
			</f>
			<f docstyle2>
				//htmlprintf ("title=%s<p>\n",messages[0].title);
				<call bod_client_readfile>(glocal.con,w_session.c_str(),id,"");
				<f ok>
					htmlprintf ("%s: %s<br>\n",MSG_U(I_TITLE,"Title"),info.title);
					/- <p>
					const char *pt = content;
					while (*pt != '\0'){
						const char *start = pt;
						while (*pt != '\0' && *pt != '\n') pt++;
						htmlout (start,pt-start);
						htmlout ("<br>\n");
						if (*pt == '\n') pt++;
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		</call>
		/- </table>
	</f>
	<f step9>	// TAB Talks
		glocal string curtab;
		bolixo_title (MSG_U(T_TALKS,"Talks"),this);
		<call vframe2h>(10);
		<f left>
			<call webtable>("list:talk","100%");
			<f load>
				sethead (MSG_U(H_TALKS,"Proprio\tGroupe"));
				<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",false);
				<f ok>
					for (auto &g:groups){
						string id = string_f("%s:%s",g.owner,g.name);
						const char *style = id == glocal.curtab ? "white+current" : "white";
						string add = string_f("webtab_add=1:%s:%s",g.owner,g.name);
						glocal.webtable.setclickopt (true,"",add);
						glocal.webtable.setrow (style,0,"%s\t%s",g.owner,g.name);
					}
				</f>
				</call>
			</f>
			</call>
		</f>
		<f right>
			<call webtabs>("talks",tabs);
			<f docstyle1>
				glocal.curtab = id;
				vector<string> tb;
				int n = str_splitline (id,':',tb);
				if (n != 2) return;
				glocal string groupowner = tb[0];
				glocal string groupname = tb[1];
				/- <table border=0 align=left width=40%>
				<call form>(formid);
				<f setup>
					/- <tr><td colspan=2>
					field_textarea (w_content,5,60,"");
					/- <tr><td>
					field_file (w_upload);
					/- <td>
					button_submit (MSG_U(B_SEND,"Send"));
				</f>
				<f validate>
					return true;
				</f>
				<f process>
					glocal bool fail = false;
					if (w_content.size() > 0){
						BOB_TYPE bob;
						bob.setbuffer (w_content.c_str(),w_content.size(),false);
						<call bod_client_sendtalk>(glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner,bob,false);
						<f ok>
							if (!success){
								htmlprintf (MSG_U(E_CANTSEND,"Can't send: %s<br>\n"),msg);
								glocal.fail = true;
							}
						</f>
						</call>
						w_content.setempty();
					}
					if (strcmp(w_upload.c_str(),"")!=0){
						const char *tempname = tlmpweb_getfilename(w_upload);
						<call sendfile>("",tempname,glocal.fail);
						<f start>
							<call bod_client_sendtalk>(glocal.con,w_session.c_str(),"",glocal.groupname,glocal.groupowner
								,content,more);
							<f ok>
								glocal.sendfile.sethandle (handle);
								glocal.sendfile.setresult (success,msg);
							</f>
							</call>
						</f>
						<f rest>
							<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
							<f ok>
								glocal.sendfile.setresult (success,msg);
							</f>
							</call>
						</f>
						</call>
						if (!fail) w_upload.setempty();
					}
					fail = glocal.fail;
					keepediting = true;
				</f>
				</call>
				/- <tr><td colspan=2>
				string table = string("talk")+id;
				index_show_shortmsg (glocal.con,glocal.con_sess,table,glocal.groupname,glocal.groupowner);
				/- </table>
			</f>
			</call>
		</f>
		</call>
		/- </table>
	</f>
	<f step10> // Confirm user
		if (w_confirm.is_empty()){
			/-#E_REACHMISS You have reach this web page by mistake. Sorry!
		}else{
			<call bod_client_confirmuser>(glocal.con,w_confirm.c_str());
			<f ok>
				if (success){
					glocal.account_confirmed = true;
					glocal.websteps.gotostep(step_login);
				}else{
					bolixo_title ("",&glocal.websteps);
					htmlprintf (MSG_U(E_CONFIRMFAILED,"Account confirmation failed: %s\n"),msg);
				}
			</f>
			</call>
		}
			
	</f>
	<f step11> // TAB Profile
		bolixo_title (MSG_U(T_PROFILE,"Profile"),this);
		/- <table border=0 width=100% height=100%>
		/- <tr><td>
		vector<string> t={MSG_U(T_ACCOUNT,"Account"),MSG_U(T_INTERESTS,"Interests"),MSG_U(T_CONTACTS,"Contacts"),MSG_U(T_PROJECTS,"Projects"),MSG_U(T_GROUPS,"Groups")};
		<call webtabs>("profile",t,tabs);
		<f docstyle1>
			glocal const char *state = state;
			if (strcmp(id,MSG_R(T_PROJECTS))==0){
				<call vframe2h>(20);
				<f left>
					url_self ("add=1",MSG_U(I_CREATELIST,"Create a new project"));
					/- <p>
					<call webtable>("list:projects","100%",currents["list:projects"]);
					<f load>
						sethead (MSG_U(H_PROF_PROJECTS,"Project\tMembers\tAccess"));
						<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
						<f ok>
							unsigned rownum=0;
							for (auto &l:lists){
								if (l.name[0] != '#'){
									string add = string_f("list=%s",l.name);
									glocal.webtable.setclickopt (true,"",add);
									glocal.webtable.setrow ("sep",rownum,"%s\t%s\a",l.name,l.description);
									glocal.webtable.setclickopt (false,"","");
									for (unsigned i=0; i<l.groups.size(); i++){
										glocal.webtable.setrow("white",-1,"\t%s\t%s",l.groups[i],l.access[i]);
									}
								}
								rownum++;
							}
							
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (profile_formactive (glocal.webtabs,w_list,glocal.state)){
						<call form>(string_f("project:%s",w_list.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							if (w_add != 1) htmlprintf (MSG_U(T_PROJECT,"<tr><td>Project<td><font size=+2>%s</font><p>\n"),w_list.c_str());
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
							<f ok>
								for (auto &l:lists){
									if (strcmp(l.name,w_list.c_str())==0){
										w_desc = l.description;
										for (unsigned i=0; i<l.groups.size(); i++){
											const char *group = l.groups[i];
											string access = toupper(l.access[i]);
											if (i==0){
												w_group1 = group;
												w_access1 = access;
											}else if (i==1){
												w_group2 = group;
												w_access2 = access;
											}else if (i==2){
												w_group3 = group;
												w_access3 = access;
											}else if (i==3){
												w_group4 = group;
												w_access4 = access;
											}
										}
										break;
									}
								}
							</f>
							</call>
						</f>
						<f setup>
							glocal vector<string> groups;
							// PATCH: Group contacts is not returned by list_groups
							// For the public group, it is necessary. Maybe other projects would
							// need access to special group contact...
							if (strcmp(w_list.c_str(),"public")==0) glocal.groups.push_back("contacts");
							<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
							<f ok>
								for (auto &g:groups) glocal.groups.push_back(g.name);
							</f>
							</call>
							if (w_add == 1){
								/-#I_PRJ_PROJECT <tr><td>Project&nbsp;<td>
								field_string (w_list,"size=30");
								field_hidden(w_add);
							}else{
								field_hidden(w_list);
							}
							/-#I_PRJ_DESCRIPTION <tr><td>Description&nbsp;<td>
							field_string (w_desc,"size=60");
							/- <tr><td>&nbsp;
							/-#I_PRJ_MEMBERS <tr><td valign=top>Members<td><table border=0>
							/-#I_PRJ_GROUP <tr><th>Group<th>Access
							/- <tr><td>
							index_field_group (this,w_group1,glocal.groups);
							/- <td>
							index_field_access (this,w_access1);
							/- <tr><td>
							index_field_group (this,w_group2,glocal.groups);
							/- <td>
							index_field_access (this,w_access2);
							/- <tr><td>
							index_field_group (this,w_group3,glocal.groups);
							/- <td>
							index_field_access (this,w_access3);
							/- <tr><td>
							index_field_group (this,w_group4,glocal.groups);
							/- <td>
							index_field_access (this,w_access4);
							/- </table>
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							bool ret = true;
							if (strcmp(w_desc.c_str(),"a")==0){
								ret = false;
								/- <font color=red>a is not allowed</font>
								/- <br>
							}
							return ret;
						</f>
						<f process>
							glocal bool fail = false;
							if (w_add == 1){
								<call bod_client_create_group_list>(glocal.con,w_session.c_str(),w_list.c_str(),"");
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf ("Can't create list: %s\n",msg);
									}
								</f>
								</call>
							}
							if (!glocal.fail){
								glocal vector<string> oldgroups;
								<call bod_client_list_lists>(glocal.con,w_session.c_str(),"");
								<f ok>
									for (auto &l:lists){
										if (strcmp(l.name,w_list.c_str())==0){
											for (auto g:l.groups) glocal.oldgroups.push_back(g);
											break;
										}
									}
								</f>
								</call>
								<call bod_client_set_list_desc>(glocal.con,w_session.c_str(),w_list.c_str(),w_desc.c_str(),"");
								<f ok>
									if (!success){
										/- error
										glocal.fail = true;
									}
								</f>
								</call>
								vector<string> newgroups;
								index_set_group (glocal.con,w_list,w_group1,w_access1,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group2,w_access2,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group3,w_access3,newgroups,glocal.fail);
								index_set_group (glocal.con,w_list,w_group4,w_access4,newgroups,glocal.fail);
								if (!glocal.fail){
									// We have to remove the groups that are gone
									index_delete_new_from_old(newgroups,glocal.oldgroups);
									// what remains in oldgroups have to be deleted (setting access to - does this)
									for (auto &g:glocal.oldgroups) index_set_group (glocal.con,w_list,g.c_str(),"-",glocal.fail);
								}
							}
							fail = glocal.fail;
							if (!fail){
								if (w_add == 0){
									keepediting = true;
									reload();
								}
								w_add = 0;
							}
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strcmp(id,MSG_R(T_GROUPS))==0){
				<call vframe2h>(20);
				<f left>
					url_self ("add=1",MSG_U(I_CREATEGROUP,"Create a new group"));
					/- <p>
					<call webtable>("list:groups","100%",currents["list:groups"]);
					<f load>
						sethead (MSG_U(H_GROUPS,"Group\tMembers\tAccess\tRole"));
						<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
						<f ok>
							unsigned rownum=0;
							for (auto &g:groups){
								string add = string_f("group=%s",g.name);
								glocal.webtable.setclickopt (true,"",add);
								glocal.webtable.setrow ("sep",rownum,"%s\t%s\a\a",g.name,g.description);
								glocal.webtable.setclickopt (false,"","");
								for (unsigned i=0; i<g.users.size(); i++){
									glocal.webtable.setrow("white",-1,"\t%s\t%s\t%s",g.users[i],g.access[i],g.roles[i]);
								}
								rownum++;
							}
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (profile_formactive (glocal.webtabs,w_group,glocal.state)){
						<call form>(string_f("group:%s",w_group.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							if (w_add != 1) htmlprintf ("<tr><td>Group<td><font size=+2>%s</font><p>\n",w_group.c_str());
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
							<f ok>
								for (auto &g:groups){
									if (strcmp(g.name,w_group.c_str())==0){
										w_desc = g.description;
										w_content = "";
										for (unsigned i=0; i<g.users.size(); i++){
											w_content.appendf ("%s:%s:%s\n",g.users[i],g.access[i],g.roles[i]);
										}
										break;
									}
								}
							</f>
							</call>
						</f>
						<f setup>
							if (w_add == 1){
								/-#I_GROUP <tr><td>Group&nbsp;<td>
								field_string (w_group,"size=30");
								field_hidden(w_add);
							}else{
								field_hidden(w_group);
							}
							/-#I_DESCRIPTION <tr><td>Description&nbsp;<td>
							field_string (w_desc,"size=60");
							/- <tr><td>&nbsp;
							/-#I_MEMBERS <tr><td valign=top>Members<td>
							field_textarea (w_content,20,60,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							bool ret = true;
							return ret;
						</f>
						<f process>
							glocal bool fail = false;
							if (w_add == 1){
								<call bod_client_create_group>(glocal.con,w_session.c_str(),w_group.c_str(),"");
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf (MSG_U(E_CANTCREATEGROUP,"Can't create group: %s<br>\n"),msg);
									}
								</f>
								</call>
							}
							if (!glocal.fail){
								glocal vector<string> oldusers;
								<call bod_client_list_groups>(glocal.con,w_session.c_str(),"",true);
								<f ok>
									for (auto &g:groups){
										if (strcmp(g.name,w_group.c_str())==0){
											for (auto u:g.users) glocal.oldusers.push_back(u);
											break;
										}
									}
								</f>
								</call>
								<call bod_client_set_group_desc>(glocal.con,w_session.c_str(),w_group.c_str(),w_desc.c_str(),"");
								<f ok>
									if (!success){
										htmlprintf (MSG_U(E_CANTSETGROUPDESC,"Can't set group description: %s<br>\n"),msg);
										glocal.fail = true;
									}
								</f>
								</call>
								vector<string> newusers,newaccesses,newroles;
								const char *pt = w_content.c_str();
								while (*pt != '\0'){
									string word;
									pt = str_copyword(word,pt);
									vector<string> tb;
									int n = str_splitline(word.c_str(),':',tb);
									if (n > 0){
										while (tb.size() < 3) tb.push_back("");
										newusers.push_back (tb[0]);
										newaccesses.push_back(tb[1]);
										newroles.push_back(tb[2]);
									}
								}
								for (unsigned i=0; !glocal.fail && i<newusers.size(); i++){
									glocal const char *user = newusers[i].c_str();
									<call bod_client_set_member>(glocal.con,w_session.c_str(),w_group.c_str()
										,glocal.user,newaccesses[i].c_str(),newroles[i].c_str(),"");
									<f ok>
										if (!success){
											glocal.fail = true;
											htmlprintf (MSG_U(E_CANTSETMEMBER,"Can't set member %s: %s\n"),glocal.user,msg);
										}
									</f>
									</call>
								}
								if (!glocal.fail){
									// We have to remove the groups that are gone
									index_delete_new_from_old(newusers,glocal.oldusers);
									// what remains in oldusers have to be deleted (setting access to - does this)
									for (auto &g:glocal.oldusers){
										glocal const char *user = g.c_str();
										<call bod_client_set_member>(glocal.con,w_session.c_str(),w_group.c_str()
											,glocal.user,"-","","");
										<f ok>
											if (!success){
												glocal.fail = true;
												htmlprintf (MSG_U(E_CANTDELMEMBER,"Can't delete member %s: %s\n"),glocal.user,msg);
											}
										</f>
										</call>
									}
								}
							}
							fail = glocal.fail;
							if (!fail){
								if (w_add == 0){
									keepediting = true;
									reload();
								}
								w_add = 0;
							}
						</f>
						</call>
					}
				</f>
				</call>
			}else if (strcmp(id,MSG_R(T_CONTACTS))==0){
				<call vframe2h>(20);
				<f left>
					url_self ("add=1",MSG_U(I_NEWCONTACT,"Send a new contact request"));
					/- <p>
					static const string id = "list:contacts";
					<call webtable>(id,"100%",currents[id],offsets[id],30);
					<f load>
						sethead (MSG_U(H_CONTACTS,"User\tDate\tStatus"));
						<call bod_client_contact_list>(glocal.con,w_session.c_str(),"",nbskip,nblines);
						<f ok>
							static const char *tbstatus[]={MSG_U(I_WAITING,"waiting"),MSG_U(I_ACCEPTED,"accepted"),MSG_U(I_REJECTED,"rejected")};
							unsigned rownum = 0;
							for (auto &c:contacts){
								glocal.webtable.setclickopt (true,"",string_f("user=%u:%s",rownum,c.user));
								glocal.webtable.setrow("white",rownum,"%s\t%s\t%s",c.user,c.reqdate,tbstatus[c.status]);
								rownum++;
							}
						</f>
						</call>
					</f>
					</call>
				</f>
				<f right>
					if (w_add == 1){
						glocal bool done = false;
						<call form>("contact");
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							/- <table border=0>
							/- <tr><td><td>
							/-#I_SENDCONTACT <h2>Send a contact request</h2>
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f setup>
							field_hidden (w_add);
							/-#I_TOCONTACT <tr><td>Person to contact<td>
							field_string (w_user,"size=30");
							/-#I_MESSAGE <tr><td valign=top>Message<td>
							field_textarea (w_content,10,60,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							return true;
						</f>
						<f process>
							glocal bool fail = false;
							<call bod_client_contact_request>(glocal.con,w_session.c_str(),"",w_user.c_str(),w_content.c_str());
							<f ok>
								if (!success){
									glocal.fail = true;
									htmlprintf (MSG_U(E_CONTACTFAIL,"Contact request failed: %s<br>\n"),msg);
								}else{
									glocal.done = true;
								}
							</f>
							</call>
							fail = glocal.fail;
						</f>
						</call>
						if (glocal.done){
							/-#I_CONTACTSENT Contact request sent!
						}
					}else if (w_user.isset()){
						glocal bool done = false;
						glocal CONTACT_STATUS status = CONTACT_WAITING;
						glocal string user;
						const char *pt = strchr(w_user.c_str(),':');
						if (pt != NULL) glocal.user = pt+1;
						<call form>(string_f("managecontact:%s",w_user.c_str()));
						<f top>
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0>
							/- <tr><td><td>
							/- <h2>Manage a contact</h2>
						</f>
						<f bottom>
							/- </table></table>
						</f>
						<f load>
							unsigned rownum = atoi(w_user.c_str());
							<call bod_client_contact_list>(glocal.con,w_session.c_str(),"",rownum,1);
							<f ok>
								if (contacts.size() == 1){
									auto &c = contacts[0];
									w_content = c.message;
								}
							</f>
							</call>
						</f>
						<f setup>
							field_hidden(w_user);
							/- <tr><td>Request from<td>
							htmlout (glocal.user);
							/- <tr><td valign=top>Message<td>
							field_textarea(w_content,5,60,"readonly");
							/- <tr><td>Accept request<td>
							field_radio(w_accept,"accept",true,"");
							/- <tr><td>Refuse request<td>
							field_radio(w_accept,"reject",false,"");
							/- <tr><td>
							button_submit();
						</f>
						<f validate>
							return true;
						</f>
						<f process>
							glocal bool fail = false;
							if (strcmp(w_accept.c_str(),"accept")==0){
								glocal.status = CONTACT_ACCEPTED;
							}else if (strcmp(w_accept.c_str(),"reject")==0){
								glocal.status = CONTACT_REJECTED;
							}else{
								glocal.fail = true;
								/- Invalid input ???
							}
							if (!glocal.fail){
								<call bod_client_contact_manage>(glocal.con,w_session.c_str(),"",glocal.user.c_str(),glocal.status);
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf ("operation failed: %s<br>\n",msg);
									}else{
										glocal.done = true;
									}
								</f>
								</call>
							}
							fail = glocal.fail;
						</f>
						</call>
						if (glocal.done){
							/- <table border=0><tr><td>&nbsp;&nbsp;&nbsp;<td><table border=0><tr><td>
							/- Contact request processed!<p>
							if (glocal.status == CONTACT_ACCEPTED){
								htmlprintf ("From now on, you can communicate with user %s<br>\n",w_user.c_str());
								htmlprintf ("You can make user %s member of your groups<br>\n",w_user.c_str());
								/- and he can make you member of his groups.
							}
							/- </table></table>
						}
					}
				</f>
				</call>
			}else if (strcmp(id,MSG_R(T_ACCOUNT))==0){
				glocal string status = "&nbsp;";
				<call form>("configaccount");
				<f top>
					/- <table border=0>
					htmlprintf ("<tr><td colspan=2>%s",glocal.status.c_str());
				</f>
				<f bottom>
					/- </table>
				</f>
				<f load>
					<call bod_client_config_read>(glocal.con,w_session.c_str(),"");
					<f ok>
						w_lang = config.lang;
						w_public_view = config.public_view;
						w_public_dir = config.public_dir;
					</f>
					</call>
				</f>
				<f setup>
					/-#I_LANG <tr><td>Language<td>
					field_list (w_lang,"");
					field_list_item ("eng",MSG_U(I_ENGLISH,"English"));
					field_list_item ("fr",MSG_U(I_FRENCH,"French"));
					field_list_end();
					/-#I_ENABLEPUB <tr><td>Enable public view<td>
					field_checkbox (w_public_view,"");
					/-#I_PUBFOLDER <tr><td>Public folder<td>
					field_list (w_public_dir,"");
					<call bod_client_listdir>(glocal.con,w_session.c_str(),string_f("/projects/%s/public",userinfo.name.c_str())
						,"",false,0,100);
					<f ok>
						for (auto &f:files){
							if (bolixo_isdir(f.type)){
								glocal.form.field_list_item (f.name,f.name);
							}
						}
					</f>
					</call>
					/- <tr><td>
					button_submit();
				</f>
				<f validate>
					return true;
				</f>
				<f process>
					glocal bool fail = false;
					CONFIG config;
					config.lang = w_lang.c_str();
					config.public_view = w_public_view;
					config.public_dir = w_public_dir.c_str();
					<call bod_client_config_write>(glocal.con,w_session.c_str(),"",config);
					<f ok>
						if (!success){
							glocal.fail = true;
							htmlprintf (MSG_U(E_CANTSAVECONFIG,"Can't save configuration: %s\n"),msg);
						}else{
							translat_selectlang (w_lang.c_str());
							glocal.status = MSG_U(I_CONFIGUPDATED,"Configuration updated");
						}
					</f>
					</call>
					fail = glocal.fail;
					keepediting = true;
				</f>
				</call>
			}
		</f>
		</call>
		/- </table>
		/- </table>
	</f>
	<f step12> // Documentation
		bolixo_title (MSG_R(M_DOCUM),this);
		extern void bolixo_doc (DOCUMENT_POINTER &);
		bolixo_doc(glocal.docpointer);
	</f>
	<f step13>
	</f>
	<f step14>
	</f>
	<f step15>
	</f>
	</call>
	if (w_webtab_add.isset() || w_webtab.isset()){
		// Save the webtabs state to the session manager
		VAR var;
		var.name = "webtabs";
		for (auto &v:tabs){
			for (auto &t:v.second){
				SNAMEVAL val;
				val.sname = v.first + ':' + t.tab;
				val.sval = string_f("f=%s,s=%s",t.flags.c_str(),t.state.c_str());
				var.vals.push_back(val);
			}
		}
		<call bo_sessiond_client_setvar>(glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) htmlprintf ("Can't set variable webtabs: %s\n",msg);
		</f>
		</call>
	}
	if (glocal.docpointer.ischanged()){
		// Save the position in the document
		VAR var;
		var.name = "document";
		unsigned nos = 1;
		for (auto s:glocal.docpointer.tb){
			SNAMEVAL val;
			val.sname = string_f("s%u",nos++);
			val.sval = string_f("%u",s);
			var.vals.push_back(val);
		}
		<call bo_sessiond_client_setvar>(glocal.con_sess,w_session.c_str(),var);
		<f ok>
			if (!success) htmlprintf ("Can't set variable document: %s\n",msg);
		</f>
		</call>
	}
}
</mod>

extern "C" void tlmp_initmod()
{
	translat_load ("bolixo");
}

<mod>
extern "C" void webmain()
{
	if (w_test == 1){
		/-ok
		return;
	}
	long long start = fdpass_getnow();
	<call tcpconnect>("unix:","/tmp/stop.sock",1);
	<f init>
	</f>
	<f oneline>
		webmain_real();
		end=true;
	</f>
	<f fail>
		webmain_real();
	</f>
	<f end>
	</f>
	</call>
	long long end = fdpass_getnow();
	glocal long long diff = end - start;
	<call savefile>("/tmp/duration",true);
	<f dowrite>
		fprintf (fout,"%s?%s: %Ld.%06Ld\n"
			,tlmpweb_curpage(),getenv ("QUERY_STRING")
			,glocal.diff/1000000,glocal.diff%1000000);
		return 0;
	</f>
	</call>
}
</mod>

