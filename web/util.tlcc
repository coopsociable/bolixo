#include <string.h>
#include <time.h>
#include <tlmpweb.h>
#include <tlmplib.h>
#include <trlitool.h>
#include <string>
#include <tlmpweb.h>
#include "util.h"
#include "../bolixo.h"

using namespace std;

#define bo_sessiond_client_test_NOTNEED
#define bo_sessiond_client_getsessioninfovars_NOTNEED
#define bod_client_createsession_NOTNEED
#define bod_client_login_NOTNEED
#define bod_client_logout_NOTNEED
#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED
#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_delfile_NOTNEED
#define bod_client_undelete_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED
#define bod_client_mkdir_NOTNEED
#define bod_client_rmdir_NOTNEED
#define bod_client_listdir_NOTNEED
#define bod_client_stat_NOTNEED
#define bod_client_set_access_NOTNEED
#define bod_client_markview_NOTNEED
#define bod_client_create_group_list_NOTNEED
#define bod_client_create_group_NOTNEED
#define bod_client_set_group_NOTNEED
#define bod_client_set_member_NOTNEED
#define bod_client_delete_list_NOTNEED
#define bod_client_delete_group_NOTNEED
#define bod_client_list_lists_NOTNEED
#define bod_client_list_groups_NOTNEED
#define bod_client_list_inboxes_NOTNEED
#define bod_client_list_msgs_NOTNEED
#define bod_client_sendmsg_NOTNEED
#define bod_client_sendmsg_project_NOTNEED
#define bod_client_replymsg_NOTNEED
#define bod_client_replymsg_project_NOTNEED
#define bod_client_sendattach_NOTNEED
#define bod_client_create_project_dir_NOTNEED
#define bod_client_verifysign_NOTNEED
#define bod_client_sendtalk_NOTNEED
#define bod_client_list_talk_NOTNEED
#define bod_client_contact_list_NOTNEED
#define bod_client_public_checkuser_NOTNEED
#define bod_client_public_listdir_NOTNEED
#define bod_client_public_list_talk_NOTNEED
#define bod_client_config_write_NOTNEED
#define bod_client_config_read_NOTNEED
#define bod_client_contact_manage_NOTNEED
#define bod_client_contact_request_NOTNEED
#define bod_client_sendtalk_file_NOTNEED
#define bod_client_set_group_desc_NOTNEED
#define bod_client_set_list_desc_NOTNEED
#define bod_client_form_readvar_NOTNEED
#define bod_client_form_savevar_NOTNEED
#define bod_client_form_deletevar_NOTNEED
#define bod_client_form_deleteall_NOTNEED
#define bod_client_interest_set_NOTNEED
#define bod_client_interest_unset_NOTNEED
#define bod_client_interest_list_NOTNEED
#define bod_client_interest_check_NOTNEED
#define bod_client_info_read_NOTNEED
#define bod_client_info_write_NOTNEED
#define bod_client_systempubkey_NOTNEED
#define bod_client_systemsign_NOTNEED

#include "../proto/bod_client.protoch"

#define bo_sessiond_client_getsessioninfo_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#include "../proto/bo-sessiond_client.protoch"


W_UNSIGNED w_robot ("robot");
#if 0
static string w_session;
USERINFO userinfo;
<mod>
static void trli_getsessioninfo(CONNECT_INFO &con, CONNECT_INFO &con_sess, const char *varname, unsigned &varval)
{
	glocal const char *varname = varname;
	glocal unsigned *varval = &varval;
	glocal CONNECT_INFO *con = &con;
	<call bo_sessiond_client_getsessioninfovars>(con_sess,w_session.c_str());
	<f ok>
		if (success){
			userinfo.lang = lang;
			userinfo.name = name;
			userinfo.is_admin = admin;
			for (auto &var:vars){
				if (strcmp(var.name,glocal.varname)==0){
					if (var.vals.size()==1) *glocal.varval = atoi(var.vals[0].sval);
					break;
				}
			}
		}else{
			userinfo.reset();
			<call bod_client_createsession>(*glocal.con);
			<f ok>
				w_session = sessionid;
				websession_setcookie("session",sessionid,time(NULL)+48*60*60);
			</f>
			</call>
		}
	</f>
	</call>
}
</mod>

<mod>
int util_getsessioninfo (CONNECT_INFO &con, CONNECT_INFO &con_sess,string &session, const char *varname, unsigned &varval)
{
	if (tlmpweb_isrobot()) w_robot = 1;
	// debug
	{
		<call savefile>("/tmp/agent.log",true);
		<f dowrite>
			const char *pt = getenv ("HTTP_USER_AGENT");
			if (pt == NULL){
				fprintf (fout,"HTTP_USER_AGENT null\n");
			}else{
				fprintf (fout,"robot=%u HTTP_USER_AGENT %s\n",w_robot.getval(),pt);
			}
			return 0;
		</f>
		</call>
	}
	const char *ptsession = tlmpweb_getcookie("session");
	if (ptsession == NULL){
		<call bod_client_createsession>(con);
		<f ok>
			w_session = sessionid;
			websession_setcookie("session",sessionid,time(NULL)+48*60*60);
		</f>
		</call>
	}else{
		w_session=ptsession;
		trli_getsessioninfo(con,con_sess,varname,varval);
	}
	session = w_session;
	if (w_session.empty()) return -1;
	return 0;
}
</mod>
#endif
void draw_tab (
	unsigned width,		// TAB width or 0 (computed from the title)
	unsigned height,
	const char *fill,	// Fill color
	const char *fill_in, 	// Fill color for mouseover
	bool close,		// Close the path or not
	const char *title,
	bool drawx,		// Put an X at the end (normally to close the TAB)
	PARAM_STRING href,	// URL when the TAB is clicked
	PARAM_STRING xref)	// URL when the X is clicked
{
	static STATIC_ID alloc_id;
	unsigned id = alloc_id++;
	if (width == 0){
		width = strlen(title)*9;
		if (drawx) width += 25;
	}
	htmlprintf ("<svg width=%u height=%u>\n",width,height);
	htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill2('tabrect%u','tabsrect%u','%s')"
		" onmouseout=changefill2('tabrect%u','tabsrect%u','%s')>\n"
		,href.ptr,id,id,fill_in,id,id,fill);
	htmlprintf ("<path id=tabrect%u fill='%s' stroke=black stroke-width=1\n",id,fill);
	htmlout ("d=\"\n");
	htmlprintf ("M0,%u\n",height);
	htmlout ("H1\n");
	htmlout ("V10\n");
	htmlout ("C1,0 10,0 20,0\n");
	htmlprintf ("H%u\n",width-12);
	htmlprintf ("C%u,0 %u,0 %u,5\n",width-10,width-2,width-2);
	htmlprintf ("V%u\n",height);
	htmlprintf ("H%u\n",width);
	if (close) htmlout ("z\n");
	htmlout ("\"/>\n");
	htmlprintf ("\t<text x=10 y=%u class=small>%s</text>\n",height-10,title);
	htmlout ("</a>\n");
	if (drawx){
		unsigned x=width-20;
		unsigned y=height-10;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('tabxrect%u','#D0D0D0') onmouseout=changefill('tabxrect%u','none')>\n",xref.ptr,id,id);
		// First rect is there to make the a tag larger. fill=none does not work. So we have to give it the same color
		// as the tab and changefill2 will change the color of the tab and this rect.
		// The second rect is used to highlit the X
		htmlprintf ("<rect id='tabsrect%u' x=%u y=%u width=18 height=25 fill=%s />\n",id,x-5,2,fill);
		htmlprintf ("<rect id='tabxrect%u' x=%u y=%u rx=2 ry=2 width=14 height=14 fill=none />\n",id,x-3,y-11);
		htmlprintf ("<path stroke=black stroke-width=1 d='M%u,%u l8,8 M%u,%u l8,-8'/>\n",x,y-8,x,y);
		htmlout ("</a>\n");
	}
	htmlout ("</svg>\n");
}
// Same thing with no X
void draw_tab (unsigned width, unsigned height, const char *fill, const char *fill_in, bool close, const char *title, PARAM_STRING href)
{
	draw_tab (width,height,fill,fill_in,close,title,false,href,"");
}
void draw_left_arrow(bool visible, PARAM_STRING xref)
{
	htmlout ("<svg width=20 height=30>\n");
	if (visible){
		static unsigned id=0;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('larrow%u','#D0D0D0') onmouseout=changefill('larrow%u','none')>\n",xref.ptr,id,id);
		htmlprintf ("<rect id='larrow%u' x=2 y=2 rx=2 ry=2 width=16 height=26 fill=none />\n",id);
		id++;
	}
	const char *color = visible ? "black" : "white";
	htmlprintf ("<path fill=%s stroke=%s stroke-width=1 d='M4,15 L12,8 L12,22 z' />\n",color,color);
	if (visible) htmlout ("</a>\n");
	// Always put the underline
	htmlout ("<path stroke=black stroke-width=1 d='M0,30 l20,0'/>\n");
	htmlout ("</svg>\n");	
}
void draw_right_arrow(bool visible, PARAM_STRING xref)
{
	htmlout ("<svg width=20 height=30>\n");
	if (visible){
		static unsigned id=0;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('rarrow%u','#D0D0D0') onmouseout=changefill('rarrow%u','none')>\n",xref.ptr,id,id);
		htmlprintf ("<rect id='rarrow%u' x=2 y=2 rx=2 ry=2 width=16 height=26 fill=none />\n",id);
		id++;
	}
	const char *color = visible ? "black" : "white";
	htmlprintf ("<path fill=%s stroke=%s stroke-width=1 d='M16,15 L8,8 L8,22 z' />\n",color,color);
	if (visible) htmlout ("</a>\n");
	// Always put the underline
	htmlout ("<path stroke=black stroke-width=1 d='M0,30 l20,0'/>\n");
	htmlout ("</svg>\n");	
}

static void print_href_c (const char *title, PARAM_STRING href, const char *color)
{
	bool close = strcmp(color,"white")==0 ? false : true;
	draw_tab (0,30,color,color,close,title,href);
}
void print_href (const char *title, PARAM_STRING href)
{
	print_href_c(title, href,"#EAEAEA");	//"#33cc33");
}
void print_aref (const char *page, const char *title, int step)
{
	string href = string_f ("%s?webstep=%d",page,step);
	print_href (title,href);
}
void print_aref (const char *title, int step)
{
	print_aref (tlmpweb_curpage(),title,step);
}
void print_aref_selected (const char *page, const char *title, int step)
{
	string href = string_f ("%s?webstep=%d",page,step);
	print_href_c (title,href,"white");
}
void print_aref_selected (const char *title, int step)
{
	print_aref_selected (tlmpweb_curpage(),title,step);
}
void print_aref_selected (const char *page, const char *title, int step, W_VAR &var)
{
	SSTRING val;
	var.getvalstr(val);
	string href = string_f ("%s?webstep=%d&%s=%s",page,step,var.getname(),val.c_str());
	print_href_c (title,href,"#220022");
}
void print_aref_selected (const char *title, int step, W_VAR &var)
{
	print_aref_selected (tlmpweb_curpage(),title,step,var);
}
void print_aref (const char *page, const char *title, int step, W_VAR &var)
{
	SSTRING val;
	var.getvalstr(val);
	string href = string_f ("%s?webstep=%d&%s=%s",page,step,var.getname(),val.c_str());
	print_href (title,href);
}
void print_aref (const char *title, int step, W_VAR &var)
{
	print_aref (tlmpweb_curpage(),title,step,var);
}
void print_aref (const char *title, int step, W_VAR &var1, W_VAR &var2)
{
	SSTRING val1,val2;
	var1.getvalstr(val1);
	var2.getvalstr(val2);
	string href = string_f ("%s?webstep=%d&%s=%s&%s=%s",tlmpweb_curpage(),step
		,var1.getname(),val1.c_str()
		,var2.getname(),val2.c_str());
	print_href (title,href);
}
void print_aref (const char *title, int step, W_VAR &var1, const char *varname2, const char *val2)
{
	SSTRING val1;
	var1.getvalstr(val1);
	string href = string_f ("%s?webstep=%d&%s=%s&%s=%s",tlmpweb_curpage(),step
		,var1.getname(),val1.c_str()
		,varname2,val2);
	print_href (title,href);
}
void print_aref (const char *title, int step, W_VAR &var1, W_VAR &var2, W_VAR &var3)
{
	SSTRING val1,val2,val3;
	var1.getvalstr(val1);
	var2.getvalstr(val2);
	var3.getvalstr(val3);
	string href = string_f ("%s?webstep=%d&%s=%s&%s=%s&%s=%s",tlmpweb_curpage(),step
		,var1.getname(),val1.c_str()
		,var2.getname(),val2.c_str()
		,var3.getname(),val3.c_str());
	print_href (title,href);
}
const char *format_line (const char *s)
{
	while (*s != '\0' && *s != '\n'){
		char car = *s++;
		if (car == '<'){
			htmlout ("&lt;");
		}else if (car == '>'){
			htmlout ("&gt;");
		}else{
			htmlout (car);
		}
	}
	return s;
}
const char *format_url (const char *s)
{
	if (strncmp(s,"http://",7)!=0 && strncasecmp(s,"https://",8)!=0) htmlout ("http://");
	return format_line (s);
}

void format_href(const char *s)
{
	htmlout ("<a href=");
	format_url(s);
	htmlout (">");
	if (strlen(s) > 50){
		string tmp = string(s,80) + "...";
		format_url(tmp.c_str());
	}else{
		format_url(s);
	}
	htmlout("</a>");
}

void format_content (const char *s, int nbline, bool &more)
{
	more = false;
	bool ol_on = false;
	bool ul_on = false;
	bool quote_on = false;
	int noline = 0;
	while (*s != '\0' && noline < nbline){
		if (*s == '\n'){
			if (ul_on){
				htmlout ("</ul>");
				ul_on = false;
			}else if (ol_on){
				htmlout ("</ol>");
				ol_on = false;
			}else if (quote_on){
				htmlout ("</blockquote>");
				quote_on = false;
			}
			htmlout ("<p>\n");
			s++;
			noline++;
		}else{
			const char *closing = "";
			if (*s == '*'){
				if (ol_on){
					ol_on = false;
					htmlout ("</ol>");
				}
				if (!ul_on){
					htmlout ("<ul>");
					ul_on = true;
				}
				htmlout ("<li>");
				s++;
			}else if (*s == '#'){
				if (ul_on){
					htmlout ("</ul>");
					ul_on = false;
				}
				if (!ol_on){
					htmlout ("<ol>");
					ol_on = true;
				}
				htmlout ("<li>");
				s++;
			}else if (*s == '?'){
				s++;
				while (*s == ' ') s++;
				htmlout ("<a href=\"");
				format_url (s);
				htmlout ("\">");
				s = format_url (s);
				htmlout ("</a>");
			}else if (*s == '!'){
				s++;
				if (*s == '!'){
					s++;
					htmlout ("<h2>");
					closing = "</h2>";
				}else{
					htmlout ("<strong>");
					closing = "</strong>";
				}
			}else if (*s == '>'){
				quote_on=true;
				s++;
				htmlout ("<blockquote>");
			}
			s = format_line (s);
			noline++;
			htmlout (closing);
			if (*s == '\n'){
				s++;
				htmlout ('\n');
			}
		}
	}
	if (ul_on){
		htmlout ("</ul>");
	}
	if (ol_on){
		htmlout ("</ol>");
	}
	if (*s != '\0') more = true;
}
void format_content (const char *s)
{
	bool more;
	format_content(s,10000,more);
}
void formatting_tips()
{
	printhref ("/marker.html","Formatting tips",false);
}

void util_google_code()
{
	#if 0
	htmlout ("<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n");
	htmlout ("<script>\n");
	htmlout ("   (adsbygoogle = window.adsbygoogle || []).push({\n");
	htmlout ("    google_ad_client: \"ca-pub-8720824140107899\",\n");
	htmlout ("    enable_page_level_ads: true\n");
	htmlout ("  });\n");
	htmlout ("</script>\n");
	#endif
}
void util_defstyles()
{
	htmlout ("<style>\n"
		"a{\n"
		"   text-decoration: none;\n"
		"}"
		"table{\n"
		"   border-radius: 5px;\n"
		"   border-spacing : 0;\n"
		"   border-collapse : collapse;\n"
		" }\n"
		"blockquote{\n"
		"   font-style: italic;\n"
		"   font-size: 18px;\n"
		"   margin-left: 32px;\n"
		"   font-family: Consolas, \"Times New Roman\", Verdana;\n"
		"   border-left: 4px solid #CCC;\n"
		"   padding-left: 8px;\n"
		"}\n"
		".small { font: normal 13px ; file: gray;}\n"
		" </style>\n"
		);
	tlmpweb_setscripts();
}

void printhref(const char *url, const char *text)
{
	htmlprintf ("<a href=\"%s\"><table bgcolor=\"#33cc33\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",url,text);
}
void printhref_selected(const char *url, const char *text)
{
	htmlprintf ("<a href=\"%s\"><table bgcolor=\"#220022\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",url,text);
}
void printhref(const char *url, const char *text, bool largewindow)
{
	if (w_robot){
		htmlprintf ("<a href=\"%s\">%s</a>",url,text);
	}else{
		const char *script = largewindow ? "popup_large" : "popup_small";
		htmlprintf ("<a href=\"#\" onclick=%s(\"%s\")><table bgcolor=\"#33cc33\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",script,url,text);
	}
}
void printhref_raw(const char *url, const char *text, bool largewindow)
{
	if (w_robot){
		htmlprintf ("<a href=\"%s\">%s</a>",url,text);
	}else{
		const char *script = largewindow ? "popup_large" : "popup_small";
		htmlprintf ("<a href=\"#\" onclick=%s(\"%s\")>%s</a>",script,url,text);
	}
}
void print_date (PARAM_STRING pdate)
{
	const char *date = pdate.ptr;
	if (strlen(date)==19){
		int year = atoi(date);
		int month = atoi(date+5);
		int day = atoi(date+8);
		int hour = atoi(date+11);
		int minu = atoi(date+14);
		const char *ampm = "AM";
		if (hour > 12){
			hour -= 12;
			ampm="PM";
		}
		static const char *tbmonth[]={"January","February","March","April","May","June","July","August","September","October","November","December"};
		htmlprintf (" %s %d %04d @%d:%02d%s ",tbmonth[month-1],day,year,hour,minu,ampm);
	}
}

void util_formanchor()
{
	htmlprintf ("<a name=\"form\">\n");
}
void button_preview(int step)
{
	htmlprintf ("<input type=\"submit\" value=\"Preview\" formaction=\"%s?webstep=%d&preview=1#form\">\n"
		,tlmpweb_curpage(),step);
}
void button_row(_F_button_row &c, int border, const char *bgcolor, bool alignleft)
{
	vector<string> left_lines;
	tlmpweb_pushgrab(left_lines);
	c.align="left";
	c.draw();
	tlmpweb_popgrab();
	vector<string> right_lines;
	tlmpweb_pushgrab(right_lines);
	c.align="right";
	c.spliton = false;
	c.draw_right();
	tlmpweb_popgrab();
	if (left_lines.size() > 0 || right_lines.size()>0){
		DIV cols; cols.dispflex().flowrow();
		if (!alignleft) cols.sfloat("right");
		cols.print();
		if (c.href_arrow_left.size() > 0){
			DIV col; col.flexfixe().print();
			draw_left_arrow(c.arrow_left_visible,c.href_arrow_left);
		}
		{
			DIV col; col.flexgrow().overflow("hidden").print();
			DIV d; d.dispflex().flowrow().bg("none").overflow("hidden").print();
			if (left_lines.size() > 0){
				htmlout (left_lines);
				htmlout ("</div>\n");
			}
			// Draw a line to the end. We draw a very long line since we do not
			// know exactly the width of the TAB. The overflow hidden above hides
			// this.
			if (c.endline){
				htmlout ("<div>\n");
				htmlout ("<svg width=2000 height=30>\n");
				htmlout ("<path stroke=black stroke-width=1 d='M0,30 h2000' />\n");
				htmlout ("</svg>\n");
				htmlout ("</div>\n");
			}
		}
		if (c.href_arrow_right.size() > 0){
			DIV col; col.flexfixe().print();
			draw_right_arrow(c.arrow_right_visible,c.href_arrow_right);
		}
		DIV end; end.flexfixe().print();
		if (right_lines.size() > 0){
			htmlout (right_lines);
			htmlout ("</div>\n");
		}
	}
}
void button_row(_F_button_row &c, int border, const char *bgcolor)
{
	button_row(c,border,bgcolor,true);
}
void button_row(_F_button_row &c, int border)
{
	button_row (c,border,"white",true);
}
void button_row(_F_button_row &c)
{
	button_row(c,0,"white",true);
}
void _F_button_row::draw_right()
{
}
void _F_button_row::split()
{
	if (spliton) htmlout ("</div>\n");
	htmlout ("<div>\n");
	spliton = true;
	//	htmlprintf ("<td align=%s>\n",align);
}
void _F_button_row::drawendline()
{
	endline = true;
}
void _F_button_row::drawleftarrow (PARAM_STRING href, bool visible)
{
	arrow_left_visible = visible;
	href_arrow_left = href.ptr;
}
void _F_button_row::drawrightarrow (PARAM_STRING href, bool visible)
{
	arrow_right_visible = visible;
	href_arrow_right = href.ptr;
}
static const char *tbtype[]={
        "text/html",	//FILE_UNKNOWN,
        "text/html",	//FILE_TEXT,
	"audio/mp3",	//FILE_SOUND_MP3,
	"audio/ogg",	//FILE_SOUND_OGG,
	"image/jpeg",	//FILE_IMAGE_JPG,
	"image/png",	//FILE_IMAGE_PNG,
	"image/gig",	//FILE_IMAGE_GIF,
	"video/mpeg"	 //FILE_VIDEO,
};
<mod>
static void util_sendfile_common(CONNECT_INFO &con, const READINFO_receive &info, const BOB_TYPE &content, bool more, const char *handle, const char *session)
{
	glocal CONNECT_INFO *con = &con;
	tlmpweb_setmodified(info.modified);
	tlmpweb_doctype (tbtype[info.file_type],info.size);
	htmlwrite (content.getbuffer(),content.getsize());
	glocal bool more = more;
	while (glocal.more){
		<call bod_client_readmore>(*glocal.con,session,handle);
		<f ok>
			htmlwrite (content.getbuffer(),content.getsize());
			glocal.more = more;
			//tlmp_error ("readmore success=%d msg=%s\n",success,msg);
		</f>
		</call>
	}
}
</mod>	
<mod>
void util_sendfile (CONNECT_INFO &con, PARAM_STRING session, PARAM_STRING filename)
{
	glocal CONNECT_INFO *con = &con;
	glocal const char *session = session.ptr;
	<call bod_client_readfile_bob>(con,session,filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
		}else{
			util_sendfile_common(*glocal.con,info,content,more,handle,glocal.session);
		}
	</f>
	</call>
}
</mod>
/*
	Send a file using the public api.
	The file is /username/file. We accept also username/file.
	So we extract the username
*/
<mod>
int util_sendpublicfile (CONNECT_INFO &con, PARAM_STRING filename)
{
	glocal int ret = -1;
	glocal CONNECT_INFO *con = &con;
	const char *pt = filename.ptr;
	if (*pt == '/') pt++;
	const char *start = pt;
	pt = strchr(pt,'/');
	if (pt != NULL){
		glocal string username;
		glocal.username = string(start,pt-start);
		<call bod_client_public_readfile>(con,glocal.username,pt,0);
		<f ok>
			if (!success){
				tlmp_error ("Can't read public file for user %s: %s\n",glocal.username.c_str(),msg);
			}else{
				glocal.ret = 0;
				util_sendfile_common(*glocal.con,info,content,more,handle,"public");
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

string util_flipspaces(PARAM_STRING src)
{
	string ret = src.ptr;
	for (auto &c:ret){
		if (c == ' ') c = '_';
	}
	return ret;
}
