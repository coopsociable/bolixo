/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <stdio.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpweb.h>
#include "trlitool.h"
#include "../bolixo.h"
#include "../instrument.h"
#include "../proto/bod_client.protoch"
#include "../proto/webapi.protoh"
#include <tlmp/translat.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include "util.h"

extern "C" void tlmp_initmod()
{
	translat_load ("bolixo");
}
static vector<CONNECT_INFO> tbcon;
static vector<CONNECT_INFO> tbcon_pub;
static vector<CONNECT_INFO> tbcon_sess;
extern "C" void webmain_init()
{
	const int max_conhandles=50;
	util_init_tbcon (tbcon,max_conhandles,"/dev/bod.sock");
	util_init_tbcon (tbcon_pub,max_conhandles,"/dev/bod-pubkey.sock");
	util_init_tbcon (tbcon_sess,max_conhandles,"/dev/sessiond.sock");
	#if 0
	int fd1=0;
	for (auto t:{&tbcon,&tbcon_pub,&tbcon_sess}){
		for (auto &con:*t){
			if (con.fd == -1) fd1++;
		}
	}
	if (fd1 > 0) tlmp_warning ("fd1=%d\n",fd1);
	#endif
}

<mod>
static void webmain_real(int handle)
{
	glocal CONNECT_INFO con;
	glocal CONNECT_INFO con_pubkey;
	glocal CONNECT_INFO con_sess;

	util_copy_con_info (tbcon,handle,glocal.con,"/dev/bod.sock");
	util_copy_con_info (tbcon_pub,handle,glocal.con_pubkey,"/dev/bod-pubkey.sock");
	util_copy_con_info (tbcon_sess,handle,glocal.con_sess,"/dev/sessiond.sock");

	bool endserver,endclient;
	REQUEST_JSON_INFO req;
	const char *json = tlmpweb_getpost();
	tlmpweb_flushheader();
	<call webapi>(NULL, req, json, strlen(json), endserver, endclient);
	<f test>
		rep_test (true,"ok");
	</f>
	<f login>	// email password = success:b sessionid
		glocal bool success = false;
		glocal string sessionid;
		<call bod_client_createsession>(glocal.con);
		<f ok>
			glocal.sessionid = sessionid;
		</f>
		</call>
		if (glocal.sessionid.size() > 0){
			<call bod_client_login>(glocal.con,glocal.sessionid,email,password);
			<f ok>
				glocal.success = success;
			</f>
			</call>
		}
		if (!glocal.success) glocal.sessionid.clear();
		rep_login (glocal.success,glocal.sessionid);
	</f>
	<f logout>	// sessionid
		<call bod_client_logout>(glocal.con,sessionid);
		<f ok>
		</f>
		</call>
	</f>
	<f addfile>	// sessionid name content = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_addfile>(glocal.con,sessionid,name,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_addfile(glocal.success,glocal.msg);
	</f>
	<f addfile_bob> // sessionid name content:o more:b owner = success:b handle msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		glocal string handle;
		<call bod_client_addfile_bob>(glocal.con,sessionid,name,content,more,owner);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.handle = handle;
		</f>
		</call>
		rep_addfile_bob(glocal.success,glocal.handle,glocal.msg);
	</f>
	<f appendfile>	// sessionid handle content:o more:b = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_appendfile>(glocal.con,sessionid,handle,content,more);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_appendfile(glocal.success,glocal.msg);
	</f>
	<f delfile>	// sessionid name = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_delfile>(glocal.con,sessionid,name);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_delfile(glocal.success,glocal.msg);
	</f>
	<f undelete>	// sessionid dirname = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_undelete>(glocal.con,sessionid,dirname);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_undelete(glocal.success,glocal.msg);
	</f>
	<f modifyfile>	// sessionid name content = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_modifyfile>(glocal.con,sessionid,name,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_modifyfile(glocal.success,glocal.msg);
	</f>
	<f modifyfile_bob>	// sessionid name content:o more:b owner = success:b handle msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		glocal string handle;
		<call bod_client_modifyfile_bob>(glocal.con,sessionid,name,content,more,owner);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.handle = handle;
		</f>
		</call>
		rep_modifyfile_bob(glocal.success,glocal.handle,glocal.msg);
	</f>
	<f rename>	// sessionid oldname newname = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_rename>(glocal.con,sessionid,oldname,newname);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_rename(glocal.success,glocal.msg);
	</f>
	<f copy>	// sessionid srcname srcdate dstname = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_copy>(glocal.con,sessionid,srcname,srcdate,dstname);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_copy(glocal.success,glocal.msg);
	</f>
	<f readfile>	// sessionid name threshold = success:b msg content
		glocal string msg = "Internal error";
		glocal bool success = false;
		glocal string content;
		glocal READINFO info;
		<call bod_client_readfile>(glocal.con,sessionid,name,threshold);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.content = content;
			glocal.info = info;
		</f>
		</call>
		rep_readfile(glocal.success,glocal.msg,glocal.content,glocal.info);
	</f>
	<f readfile_bob>	// sessionid name threshold nomore:b = success:b msg content:o info:U{READINFO} handle more:b
		glocal string msg = "Internal error";
		glocal bool success = false;
		glocal BOB_TYPE content;
		glocal string handle;
		glocal bool more=false;
		glocal READINFO info;
		<call bod_client_readfile_bob>(glocal.con,sessionid,name,threshold,nomore);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.content = content;
			glocal.info = info;
			glocal.handle = handle;
			glocal.more = more;
		</f>
		</call>
		rep_readfile_bob(glocal.success,glocal.msg,glocal.content,glocal.info,glocal.handle,glocal.more);
	</f>
	<f readmore>	// sessionid handle = success:b msg content:o more:b
		glocal string msg = "Internal error";
		glocal bool success = false;
		glocal BOB_TYPE content;
		glocal string handle;
		glocal bool more=false;
		<call bod_client_readmore>(glocal.con,sessionid,handle);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.content = content;
			glocal.more = more;
		</f>
		</call>
		rep_readmore(glocal.success,glocal.msg,glocal.content,glocal.more);
	</f>
	<f mkdir>	// sessionid name = success:b msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_mkdir>(glocal.con,sessionid,name);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_mkdir(glocal.success,glocal.msg);
	</f>
	<f rmdir>	// sessionid name = success:b  msg
		glocal string msg = "Internal error";
		glocal bool success = false;
		<call bod_client_rmdir>(glocal.con,sessionid,name);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_rmdir(glocal.success,glocal.msg);
	</f>
	<f listdir>	// sessionid name threshold history:b offset:u nb:u = success:b msg files:U{WEB_FILEINFO}v
		glocal bool success=false;
		glocal string msg;
		glocal vector<FILEINFO> files;
		<call bod_client_listdir>(glocal.con,sessionid,name,threshold,history,offset,nb);
		<f ok>
			glocal.success = success;
			for (auto &d:files){
				glocal.files.push_back(d);
			}
		</f>
		</call>
		rep_listdir (glocal.success,glocal.msg,glocal.files);
	</f>
	<f stat>	// sessionid name threshold = success:b msg file:U{WEB_FILEINFO}
		glocal bool success = false;
		glocal string msg;
		glocal FILEINFO file;
		<call bod_client_stat>(glocal.con,sessionid,name,threshold);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.file = file;
		</f>
		</call>
		rep_stat (glocal.success,glocal.msg,glocal.file);
	</f>
	<f set_access>	// sessionid name username listowner listname listmode owner = success:b msg
		<call bod_client_set_access>(glocal.con,sessionid,name,username,listowner,listname,listmode,owner);
		<f ok>
			glocal.webapi.rep_set_access (success,msg);
		</f>
		</call>
	</f>
	<f markview>	// sessionid name = success:b msg
		<call bod_client_markview>(glocal.con_pubkey,sessionid,name);
		<f ok>
			glocal.webapi.rep_markview(success,msg);
		</f>
		</call>
	</f>
	<f verifysign> // nickname msg = status:e{ERR_CODE} msg
		<call bod_client_verifysign>(glocal.con,nickname,msg);
		<f ok>
			glocal.webapi.rep_verifysign(status,msg);
		</f>
		</call>
	</f>
	<f getpubkey> // nickname = pubkey
		<call bod_client_getpubkey>(glocal.con_pubkey,nickname);
		<f ok>
			glocal.webapi.rep_getpubkey(success,pubkey);
		</f>
		</call>
	</f>
	<f registernode> // nodename = success:b msg
		<call bod_client_registernode>(glocal.con,nodename);
		<f ok>
			glocal.webapi.rep_registernode(success,msg);
		</f>
		</call>
	</f>
	<f nodelogin>	// nodename = success:b msg session
		<call bod_client_nodelogin>(glocal.con,nodename);
		<f ok>
			glocal.webapi.rep_nodelogin(success,msg,session);
		</f>
		</call>
	</f>
	<f nodepass>	// session sign = success:b msg
		<call bod_client_nodepass>(glocal.con,session,sign);
		<f ok>
			glocal.webapi.rep_nodepass(success,msg);
		</f>
		</call>
	</f>
	<f remotelogin>	// user = success:b msg sessionid
		<call bod_client_remotelogin>(glocal.con,user);
		<f ok>
			glocal.webapi.rep_remotelogin(success,msg,sessionid);
		</f>
		</call>
	</f>
	<f remotepass>	// sessionid user sign = success:b msg
		<call bod_client_remotepass>(glocal.con,sessionid,user,sign);
		<f ok>
			glocal.webapi.rep_remotepass(success,msg);
		</f>
		</call>
	</f>
	<f remote_interest_set> // sessionid user = success:b msg
		<call bod_client_remote_interest_set>(glocal.con,sessionid,user);
		<f ok>
			glocal.webapi.rep_remote_interest_set(success,msg);
		</f>
		</call>
	</f>
	<f remote_interest_unset> // sessionid user = success:b msg
		<call bod_client_remote_interest_unset>(glocal.con,sessionid,user);
		<f ok>
			glocal.webapi.rep_remote_interest_unset(success,msg);
		</f>
		</call>
	</f>
	<f list_inboxes> // sessionid owner = success:b msg inboxes:U{INBOX}v
		glocal bool success = false;
		glocal string msg;
		glocal vector<INBOX> inboxes;
		<call bod_client_list_inboxes>(glocal.con,sessionid,owner,showroles,list_own_projects);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &i:inboxes) glocal.inboxes.push_back(i);
		</f>
		</call>
		rep_list_inboxes (glocal.success,glocal.msg,glocal.inboxes);
	</f>
	<f list_msgs>	// sessionid owner project deleted:b offset:u nb:u = success:b msg messages:U{MESSAGE}v
		glocal bool success = false;
		glocal string msg;
		glocal vector<MESSAGE> messages;
		<call bod_client_list_msgs>(glocal.con,sessionid,owner,project,deleted,offset,nb);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &m:messages) glocal.messages.push_back(m);
		</f>
		</call>
		rep_list_msgs (glocal.success,glocal.msg,glocal.messages);
	</f>
	<f sendmsg>	// sessionid owner recipients:v title content = success:b msg msgid
		glocal bool success = false;
		glocal string msg;
		glocal string msgid;
		<call bod_client_sendmsg>(glocal.con,sessionid,owner,recipients,title,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.msgid = msgid;
		</f>
		</call>
		rep_sendmsg (glocal.success,glocal.msg,glocal.msgid);
	</f>
	<f sendmsg_project> // sessionid owner manager project role title content = success:b msg msgid
		glocal bool success = false;
		glocal string msg;
		glocal string msgid;
		<call bod_client_sendmsg_project>(glocal.con,sessionid,owner,manager,project,role,title,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.msgid = msgid;
		</f>
		</call>
		rep_sendmsg_project (glocal.success,glocal.msg,glocal.msgid);
	</f>
	<f replymsg> 	// sessionid owner msgid recipients:v title content = success:b msg replyid
		glocal bool success = false;
		glocal string msg;
		glocal string replyid;
		<call bod_client_replymsg>(glocal.con,sessionid,owner,msgid,recipients,title,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.replyid = replyid;
		</f>
		</call>
		rep_replymsg (glocal.success,glocal.msg,glocal.replyid);
	</f>
	<f replymsg_project>	// sessionid owner manager project role msgid title content = success:b msg replyid
		glocal bool success = false;
		glocal string msg;
		glocal string replyid;
		<call bod_client_replymsg_project>(glocal.con,sessionid,owner,manager,project,role,msgid,title,content);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.replyid = replyid;
		</f>
		</call>
		rep_replymsg_project (glocal.success,glocal.msg,glocal.replyid);
	</f>
	<f sendattach>	// sessionid owner msgid content:o more:b = success:b msg handle
		glocal bool success = false;
		glocal string msg;
		glocal string handle;
		<call bod_client_sendattach>(glocal.con,sessionid,owner,msgid,content,more);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.handle = handle;
		</f>
		</call>
		rep_sendattach (glocal.success,glocal.msg,glocal.handle);
	</f>
	<f sendtalk>	// sessionid owner groupname groupowner content:o more:b name sign createdby = success:b msg handle
		glocal bool success = false;
		glocal string msg;
		glocal string handle;
		<call bod_client_sendtalk>(glocal.con,sessionid,owner,to,groupname,groupowner,content,more,name,sign,createdby);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.handle = handle;
		</f>
		</call>
		rep_sendtalk (glocal.success,glocal.msg,glocal.handle);
	</f>
	<f sendtalk_file>	// sessionid owner groupname groupowner filename filedate = success:b msg
		glocal bool success = false;
		glocal string msg;
		<call bod_client_sendtalk_file>(glocal.con,sessionid,owner,to,groupname,groupowner,filename,filedate);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
		</f>
		</call>
		rep_sendtalk_file (glocal.success,glocal.msg);
	</f>
	<f list_talk>	// sessionid owner groupname groupowner fulltext:v offset:u nb:u = success:b msg messages:U{MESSAGE}v deletes:b
		glocal bool success = false;
		glocal string msg;
		glocal vector<SHORTMSG> messages;
		glocal bool deletes = false;
		glocal unsigned total = 0;
		glocal unsigned nbnew = 0;
		<call bod_client_list_talk>(glocal.con,sessionid,owner,groupname,groupowner,fulltext,offset,nb,firstseen);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			glocal.deletes = deletes;
			glocal.total = total;
			glocal.nbnew = nbnew;
			for (auto &m:messages) glocal.messages.push_back(m);
		</f>
		</call>
		rep_list_talk (glocal.success,glocal.msg,glocal.messages,glocal.deletes,glocal.total,glocal.nbnew);
	</f>
	<f public_listdir>	// username dirpath offset:u nb:u = success:b msg files:U{FILEINFO}v
		glocal bool success = false;
		glocal string msg;
		glocal vector<FILEINFO> files;
		<call bod_client_public_listdir>(glocal.con,username,dirpath,offset,nb);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &f:files) glocal.files.push_back(f);
		</f>
		</call>
		rep_public_listdir(glocal.success,glocal.msg,glocal.files);
	</f>
	<f public_readfile>	// username filepath offset:u = success:b msg content:o more:b size:u
		// glocal FILE *fout = fopen ("/tmp/log","a");
		//fprintf (glocal.fout,"%s %s %u\n",username,filepath,offset);
		//fflush (glocal.fout);
		<call bod_client_public_readfile>(glocal.con,username,filepath,offset);
		<f ok>
			//fprintf (glocal.fout,"success %d msg=%s more=%d size=%u\n",success,msg,more,info.size);
			//fflush (glocal.fout);
			glocal.webapi.rep_public_readfile(success,msg,content,more,info.size);
		</f>
		</call>
		//fclose (glocal.fout);
	</f>
	<f public_list_talk>	// username offset:u nb:u = success:b msg messages:U{SHORTMSG}v
		<call bod_client_public_list_talk>(glocal.con,username,offset,nb);
		<f ok>
			vector<SHORTMSG> msgs;
			for (auto &m:messages) msgs.push_back(m);
			glocal.webapi.rep_public_list_talk(success,msg,msgs);
		</f>
		</call>
	</f>
	<f systempubkey>
		<call bod_client_systempubkey>(glocal.con_pubkey);
		<f ok>
			glocal.webapi.rep_systempubkey(pubkey);
		</f>
		</call>
	</f>
	<f config_read>	// sessionid owner = success:b msg config:U{CONFIG}
		<call bod_client_config_read>(glocal.con,sessionid,owner);
		<f ok>
			glocal.webapi.rep_config_read(success,msg,config);
		</f>
		</call>
	</f>
	<f config_write> // sessionid owner config:U{CONFIG} = success:b msg
		<call bod_client_config_write>(glocal.con,sessionid,owner,config);
		<f ok>
			glocal.webapi.rep_config_write(success,msg);
		</f>
		</call>
	</f>
	<f contact_request> // sessionid owner user intro = success:b msg
		<call bod_client_contact_request>(glocal.con,sessionid,owner,user,intro);
		<f ok>
			glocal.webapi.rep_contact_request(success,msg);
		</f>
		</call>
	</f>
	<f contact_remove> // sessionid owner user = success:b msg
		<call bod_client_contact_remove>(glocal.con,sessionid,owner,user);
		<f ok>
			glocal.webapi.rep_contact_remove(success,msg);
		</f>
		</call>
	</f>
	<f contact_manage> //sessionid owner user status:e{CONTACT_STATUS} = success:b msg
		<call bod_client_contact_manage>(glocal.con,sessionid,owner,user,status);
		<f ok>
			glocal.webapi.rep_contact_manage(success,msg);
		</f>
		</call>
	</f>
	<f contact_list> // sessionid owner to_me:b contact offset:u nb:u = success:b msg contacts:U{CONTACT}v
		glocal vector<CONTACT> contacts;
		glocal bool success = false;
		glocal string msg;
		<call bod_client_contact_list>(glocal.con,sessionid,owner,to_me,contact,offset,nb);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &c:contacts) glocal.contacts.push_back(c);
		</f>
		</call>
		rep_contact_list(glocal.success,glocal.msg,glocal.contacts);
	</f>
	<f list_lists> // sessionid owner = success:b msg lists:U{LIST}v
		glocal bool success = false;
		glocal string msg;
		glocal vector<LIST> lists;
		<call bod_client_list_lists>(glocal.con,sessionid,owner);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &l:lists) glocal.lists.push_back(l);
		</f>
		</call>
		rep_list_lists (glocal.success,glocal.msg,glocal.lists);
	</f>
	<f list_groups> // sessionid owner only_owner:b = success:b msg groups:U{GROUP}v
		glocal bool success = false;
		glocal string msg;
		glocal vector<GROUP> groups;
		<call bod_client_list_groups>(glocal.con,sessionid,owner,only_owner);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto &g:groups) glocal.groups.push_back(g);
		</f>
		</call>
		rep_list_groups (glocal.success,glocal.msg,glocal.groups);
	</f>
	<f list_members> // sessionid owner listname = success:b msg members:v
		glocal bool success = false;
		glocal string msg;
		glocal vector<string> members;
		<call bod_client_list_members>(glocal.con,sessionid,owner,listname);
		<f ok>
			glocal.success = success;
			glocal.msg = msg;
			for (auto m:members) glocal.members.push_back(m);
		</f>
		</call>
		rep_list_members (glocal.success,glocal.msg,glocal.members);
	</f>
	<f list_contacts> // sessionid owner = success:b msg members:v
		<call bod_client_list_contacts>(glocal.con,sessionid,owner);
		<f ok>
			glocal.webapi.rep_list_contacts(success,msg,members);
		</f>
		</call>
	</f>
	<f create_group_list> // sessionid listname owner = success:b msg
		<call bod_client_create_group_list>(glocal.con,sessionid,listname,owner);
		<f ok>
			glocal.webapi.rep_create_group_list(success,msg);
		</f>
		</call>
	</f>
	<f create_group> // sessionid groupname owner = success:b msg
		<call bod_client_create_group>(glocal.con,sessionid,groupname,owner);
		<f ok>
			glocal.webapi.rep_create_group(success,msg);
		</f>
		</call>
	</f>
	<f delete_group> // sessionid groupname owner = success:b msg
		<call bod_client_delete_group>(glocal.con,sessionid,groupname,owner);
		<f ok>
			glocal.webapi.rep_delete_group(success,msg);
		</f>
		</call>
	</f>
	<f delete_list> // sessionid listname owner = success:b msg
		<call bod_client_delete_list>(glocal.con,sessionid,listname,owner);
		<f ok>
			glocal.webapi.rep_delete_list(success,msg);
		</f>
		</call>
	</f>
	<f set_group>	//  sessionid listname groupname defaultaccess owner = success:b msg
		<call bod_client_set_group>(glocal.con,sessionid,listname,groupname,defaultaccess,owner);
		<f ok>
			glocal.webapi.rep_set_group(success,msg);
		</f>
		</call>
	</f>
	<f set_member> // sessionid groupname user access role owner = success:b msg
		<call bod_client_set_member>(glocal.con,sessionid,groupname,user,access,role,owner);
		<f ok>
			glocal.webapi.rep_set_member(success,msg);
		</f>
		</call>
	</f>
	<f playstep>	// sessionid owner path docnum:u steps:U{VARVAL}v uispecs:U{DOC_UI_SPECS} = success:b msg res:U{VARVAL}v more:b handle
		glocal vector<VARVAL> res;
		glocal string msg;
		vector<VARVAL> lsteps;
		glocal bool more = false;
		glocal string handle;
		for (auto &s:steps) lsteps.push_back(s);
		<call bod_client_playstep>(glocal.con,"webapi",sessionid,owner,path,docnum,lsteps,uispecs);
		<f ok>
			if (!success){
				glocal.msg = msg;
			}else{
				glocal.more = more;
				glocal.handle = handle;
				for (auto &r:res) glocal.res.push_back(r);
			}
		</f>
		</call>
		if (glocal.msg.size() > 0){
			glocal.res.clear();
			rep_playstep (false,glocal.msg,glocal.res,false,"");
		}else{
			rep_playstep (true,"",glocal.res,glocal.more,glocal.handle);
		}
	</f>
	<f playstep_more>	// sessionid owner path handle = success:b msg res:U{VARVAL}v more:b
		glocal vector<VARVAL> res;
		glocal string msg;
		glocal bool more = false;
		<call bod_client_playstep_more>(glocal.con,sessionid,owner,path,handle);
		<f ok>
			if (!success){
				glocal.msg = msg;
			}else{
				glocal.more = more;
				for (auto &r:res) glocal.res.push_back(r);
			}
		</f>
		</call>
		if (glocal.msg.size() > 0){
			glocal.res.clear();
			rep_playstep_more (false,glocal.msg,glocal.res,false);
		}else{
			rep_playstep_more (true,"",glocal.res,glocal.more);
		}
	</f>
	<f invalid>
		tlmp_warning ("webapi: invalid request");
	</f>
	</call>
}
</mod>
<mod>
extern "C" void webmain(int handle)
{
	glocal handle;
	#ifdef INSTRUMENT
		toggle_instrument_file (false);
		toggle_instrument_file (true);
	#endif
	<call tcpconnect>("unix:","/tmp/stop.sock",1);
	<f init>
	</f>
	<f oneline>
		webmain_real(glocal.handle);
		end=true;
	</f>
	<f fail>
		webmain_real(glocal.handle);
	</f>
	<f end>
	</f>
	</call>
	#ifdef INSTRUMENT
		toggle_instrument_file (false);
	#endif
}
</mod>
