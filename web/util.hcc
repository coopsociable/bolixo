/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <string.h>
#include <time.h>
#include <sys/stat.h>
#include <tlmpweb.h>
#include <tlmplib.h>
#include <trlitool.h>
#include <string>
#include <tlmpweb.h>
#include <set>
#define DEFINE_TBFTYPE
#include "../bolixo.h"
#define DEFINE_USERINFO
#include "util.h"
#include <translat.h>
#include "../bolixo.m"
#include <helper.h>
#define INSTRUMENT_EXTERN
#include "../instrument.h"
#include "w_var.h"
#include "steps.h"

using namespace std;
USERLOGINFO userinfo;
string w_session;

#define bo_sessiond_client_test_NOTNEED
#define bo_sessiond_client_getsessioninfovars_NOTNEED
#define bo_sessiond_client_getsessioninfovars_v2_NOTNEED
#define bo_sessiond_client_waitevent_NOTNEED
#define bo_sessiond_client_setnotify_NOTNEED
#define bo_sessiond_client_ping_NOTNEED
#define bod_client_createsession_NOTNEED
#define bod_client_login_NOTNEED
#define bod_client_logout_NOTNEED
#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED
#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_delfile_NOTNEED
#define bod_client_undelete_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED
#define bod_client_mkdir_NOTNEED
#define bod_client_rmdir_NOTNEED
#define bod_client_listdir_NOTNEED
#define bod_client_set_access_NOTNEED
#define bod_client_create_group_list_NOTNEED
#define bod_client_create_group_NOTNEED
#define bod_client_set_group_NOTNEED
#define bod_client_set_member_NOTNEED
#define bod_client_delete_list_NOTNEED
#define bod_client_delete_group_NOTNEED
#define bod_client_list_lists_NOTNEED
#define bod_client_list_groups_NOTNEED
#define bod_client_list_inboxes_NOTNEED
#define bod_client_list_msgs_NOTNEED
#define bod_client_sendmsg_NOTNEED
#define bod_client_sendmsg_project_NOTNEED
#define bod_client_replymsg_NOTNEED
#define bod_client_replymsg_project_NOTNEED
#define bod_client_sendattach_NOTNEED
#define bod_client_create_project_dir_NOTNEED
#define bod_client_verifysign_NOTNEED
#define bod_client_sendtalk_NOTNEED
#define bod_client_list_talk_NOTNEED
#define bod_client_contact_list_NOTNEED
#define bod_client_public_checkuser_NOTNEED
#define bod_client_public_listdir_NOTNEED
#define bod_client_public_list_talk_NOTNEED
#define bod_client_config_write_NOTNEED
#define bod_client_config_read_NOTNEED
#define bod_client_contact_manage_NOTNEED
#define bod_client_contact_request_NOTNEED
#define bod_client_sendtalk_file_NOTNEED
#define bod_client_set_group_desc_NOTNEED
#define bod_client_set_list_desc_NOTNEED
#define bod_client_form_readvar_NOTNEED
#define bod_client_form_savevar_NOTNEED
#define bod_client_form_deletevar_NOTNEED
#define bod_client_form_deleteall_NOTNEED
#define bod_client_interest_set_NOTNEED
#define bod_client_interest_unset_NOTNEED
#define bod_client_interest_list_NOTNEED
#define bod_client_interest_check_NOTNEED
#define bod_client_info_read_NOTNEED
#define bod_client_info_write_NOTNEED
#define bod_client_systempubkey_NOTNEED
#define bod_client_systemsign_NOTNEED
#define bod_client_registernode_NOTNEED
#define bod_client_getpubkey_NOTNEED
#define bod_client_remotelogin_NOTNEED
#define bod_client_remotepass_NOTNEED
#define bod_client_nodelogin_NOTNEED
#define bod_client_nodepass_NOTNEED
#define bod_client_remote_interest_set_NOTNEED
#define bod_client_remote_interest_unset_NOTNEED
#define bod_client_sendtalk_anon_NOTNEED
#define bod_client_list_contacts_NOTNEED
#define bod_client_get_notification_NOTNEED
#define bod_client_set_notification_NOTNEED
#define bod_client_playstep_NOTNEED
#define bod_client_playstep_more_NOTNEED
#define bod_client_set_members_NOTNEED
#define bod_client_contact_remove_NOTNEED
#define bod_client_waitevent_NOTNEED
#define bod_client_list_members_NOTNEED
#include "../proto/bod_client.protoch"

#define bo_sessiond_client_getsessioninfo_NOTNEED
#define bo_sessiond_client_setvar_NOTNEED
#include "../proto/bo-sessiond_client.protoch"
W_UNSIGNED w_robot ("robot");
W_UNSIGNED w_showmsg ("showmsg");
W_SSTRING w_file("file");
static float small_size=0.9;
static unsigned draw_tab_height()
{
	unsigned fontsize = tlmpweb_fontsize();
	unsigned height = fontsize*1.3*small_size;
	if (height < 20) height = 20;
	return height+2;	// Keep some space at the top
}
unsigned draw_tab (
	const char *id_suffix,	// id suffix to assemble the ID of the SVG path
	unsigned width,		// TAB width or 0 (computed from the title)
	const char *fill,	// Fill color
	const char *fill_in, 	// Fill color for mouseover
	bool close,		// Close the path or not
	const char *title,
	bool drawx,		// Put an X at the end (normally to close the TAB)
	PARAM_STRING href,	// URL when the TAB is clicked
	PARAM_STRING xref)	// URL when the X is clicked
{
	unsigned height = draw_tab_height();
	static STATIC_ID alloc_id;
	unsigned idnum = alloc_id++;
	/- <script>
	if (idnum == 0){
		htmlout ("var tabcolor=[];\n");
	}
	string id = string_f("tabrect%s",id_suffix);
	string ids = string_f("tabsrect%s",id_suffix);
	htmlprintf ("tabcolor['%s'] = '%s';\n",id.c_str(),fill);
	/- </script>
	if (width == 0){
		width = tlmpweb_displaylen(title,small_size)+5;	// See the .small css entry above
								// +5 because the server fonts do not match perfectly
		if (drawx){
			width += 10+5+15;
		}else{
			// We put 10 pixels on each side
			width += 10+10;
		}
	}
	htmlprintf ("<svg width=%u height=%u>\n",width,height);
	htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill2('%s','%s','%s')"
		" onmouseout=changefill2('%s','%s',tabcolor['%s'])"
		,href.ptr,id.c_str(),ids.c_str(),fill_in,id.c_str(),ids.c_str(),id.c_str());
	if (drawx){
		// For mobile, it is difficult (impossible) to reach the X to close a tab. So we do not even try to draw it.
		// But we use a trick. We use the oncontextmenu, normally used to popup a ... context menu.
		// But this menu would only hold one option: close tab.
		// To activate a context menu, you have to put your finger on the tab and wait. The single
		// line menu appears below, hidden by your finger.
		// On instead of poping a menu, we execute the action
		htmlprintf (" oncontextmenu='formsubmit(\"%s\"); return false;'",xref.ptr);
	}
	htmlprintf (">\n<path id='%s' fill='%s' stroke=black stroke-width=1\n",id.c_str(),fill);
	htmlout ("d=\"\n");
	htmlprintf ("M0,%u\n",height);
	htmlout ("H1\n");
	htmlout ("V12\n");
	htmlout ("Q1,2 12,2\n");
	htmlprintf ("H%u\n",width-12);
	htmlprintf ("Q%u,2 %u,12\n",width-2,width-2);
	htmlprintf ("V%u\n",height);
	htmlprintf ("H%u\n",width);
	if (close) htmlout ("z\n");
	htmlout ("\"/>\n");
	htmlprintf ("\t<text x=10 y=%u class=small>%s</text>\n",height-tlmpweb_fontsize()/4-1,title);
	htmlout ("</a>\n");
	if (drawx && !tlmpweb_ismobile()){
		unsigned x=width-17;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('tabxrect%u','#D0D0D0') onmouseout=changefill('tabxrect%u','none')>\n",xref.ptr,idnum,idnum);
		// First rect is there to make the a tag larger. fill=none does not work. So we have to give it the same color
		// as the tab and changefill2 will change the color of the tab and this rect.
		// The second rect is used to highlit the X
		htmlprintf ("<rect id='%s' x=%u y=%u width=16 height=%u fill=%s />\n",ids.c_str(),x-5,4,height-6,fill);
		unsigned hmiddle = height/2+2;
		unsigned h14 = height-8;
		unsigned h8=height/3;
		if (h8 & 1) h8++;	// Make sure h8 is even.
		htmlprintf ("<rect id='tabxrect%u' x=%u y=%u rx=2 ry=2 width=%u height=%u fill=none />\n",idnum,x-3,4,h14,height-4);
		htmlprintf ("<path stroke=black stroke-width=1 d='M%u,%u l%u,%u M%u,%u l%u,-%u'/>\n"
			,x,hmiddle-h8/2,h8,h8
			,x,hmiddle+h8/2,h8,h8);
		htmlout ("</a>\n");
	}
	htmlout ("</svg>\n");
	return width;
}
// Same thing with no X
unsigned draw_tab (const char *id_suffix, unsigned width, const char *fill, const char *fill_in, bool close, const char *title, PARAM_STRING href)
{
	return draw_tab (id_suffix,width,fill,fill_in,close,title,false,href,"");
}
void draw_left_arrow(bool visible, PARAM_STRING xref)
{
	unsigned height = draw_tab_height();
	htmlprintf ("<svg width=20 height=%u>\n",height);
	if (visible){
		static STATIC_ID alloc_id;
		unsigned id=alloc_id++;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('larrow%u','#D0D0D0') onmouseout=changefill('larrow%u','none')>\n",xref.ptr,id,id);
		htmlprintf ("<rect id='larrow%u' x=2 y=2 rx=2 ry=2 width=16 height=%u fill=none />\n",id,height-4);
	}
	const char *color = visible ? "black" : "white";
	unsigned h2=height/2;
	htmlprintf ("<path fill=%s stroke=%s stroke-width=1 d='M4,%u L12,%u L12,%u z' />\n",color,color,h2,h2-8,h2+8);
	if (visible) htmlout ("</a>\n");
	// Always put the underline
	htmlprintf ("<path stroke=black stroke-width=1 d='M0,%u l20,0'/>\n",height);
	htmlout ("</svg>\n");	
}
void draw_right_arrow(bool visible, PARAM_STRING xref)
{
	unsigned height = draw_tab_height();
	htmlprintf ("<svg width=20 height=%u>\n",height);
	if (visible){
		static STATIC_ID alloc_id;
		unsigned id=alloc_id++;
		htmlprintf ("<a href='#' onclick=formsubmit('%s') onmouseover=changefill('rarrow%u','#D0D0D0') onmouseout=changefill('rarrow%u','none')>\n",xref.ptr,id,id);
		htmlprintf ("<rect id='rarrow%u' x=2 y=2 rx=2 ry=2 width=16 height=%u fill=none />\n",id,height-4);
	}
	const char *color = visible ? "black" : "white";
	unsigned h2=height/2;
	htmlprintf ("<path fill=%s stroke=%s stroke-width=1 d='M16,%u L8,%u L8,%u z' />\n",color,color,h2,h2-8,h2+8);
	if (visible) htmlout ("</a>\n");
	// Always put the underline
	htmlprintf("<path stroke=black stroke-width=1 d='M0,%u l20,0'/>\n",height);
	htmlout ("</svg>\n");	
}

static void print_href_c (const char *id_suffix, const char *title, PARAM_STRING href, const char *color, bool close)
{
	draw_tab (id_suffix,0,color,color,close,title,href);
}
void print_href (const char *id_suffix,const char *title, PARAM_STRING href, bool notify)
{
	print_href_c(id_suffix,title, href,notify ? "orange" : "#EAEAEA",true);
}
void print_aref (const char *id_suffix, const char *page, const char *title, int step, bool notify)
{
	string href = string_f ("%s?webstep=%d",page,step);
	print_href (id_suffix,title,href,notify);
}
void print_aref (const char *id_suffix,const char *title, int step, bool notify)
{
	print_aref (id_suffix,tlmpweb_curpage(),title,step,notify);
}
void print_aref_selected (const char *id_suffix, const char *page, const char *title, int step, bool notify)
{
	string href = string_f ("%s?webstep=%d",page,step);
	print_href_c (id_suffix,title,href,notify ? "orange" : "white", false);
}
void print_aref_selected (const char *id_suffix, const char *title, int step, bool notify)
{
	print_aref_selected (id_suffix,tlmpweb_curpage(),title,step,notify);
}
const char *format_line (const char *s)
{
	while (*s != '\0' && *s != '\n'){
		char car = *s++;
		if (car == '<'){
			htmlout ("&lt;");
		}else if (car == '>'){
			htmlout ("&gt;");
		}else{
			htmlout (car);
		}
	}
	return s;
}
const char *format_url (const char *s)
{
	if (strncmp(s,"http://",7)!=0 && strncasecmp(s,"https://",8)!=0) htmlout ("http://");
	return format_line (s);
}

void format_href(const char *s)
{
	htmlout ("<a href=");
	format_url(s);
	htmlout (">");
	if (strlen(s) > 50){
		string tmp = string(s,80) + "...";
		format_url(tmp.c_str());
	}else{
		format_url(s);
	}
	htmlout("</a>");
}

void format_content (const char *s, int nbline, bool &more)
{
	more = false;
	bool ol_on = false;
	bool ul_on = false;
	bool quote_on = false;
	int noline = 0;
	while (*s != '\0' && noline < nbline){
		if (*s == '\n'){
			if (ul_on){
				htmlout ("</ul>");
				ul_on = false;
			}else if (ol_on){
				htmlout ("</ol>");
				ol_on = false;
			}else if (quote_on){
				htmlout ("</blockquote>");
				quote_on = false;
			}
			htmlout ("<p>\n");
			s++;
			noline++;
		}else{
			const char *closing = "";
			if (*s == '*'){
				if (ol_on){
					ol_on = false;
					htmlout ("</ol>");
				}
				if (!ul_on){
					htmlout ("<ul>");
					ul_on = true;
				}
				htmlout ("<li>");
				s++;
			}else if (*s == '#'){
				if (ul_on){
					htmlout ("</ul>");
					ul_on = false;
				}
				if (!ol_on){
					htmlout ("<ol>");
					ol_on = true;
				}
				htmlout ("<li>");
				s++;
			}else if (*s == '?'){
				s++;
				while (*s == ' ') s++;
				htmlout ("<a href=\"");
				format_url (s);
				htmlout ("\">");
				s = format_url (s);
				htmlout ("</a>");
			}else if (*s == '!'){
				s++;
				if (*s == '!'){
					s++;
					htmlout ("<h2>");
					closing = "</h2>";
				}else{
					htmlout ("<strong>");
					closing = "</strong>";
				}
			}else if (*s == '>'){
				quote_on=true;
				s++;
				htmlout ("<blockquote>");
			}
			s = format_line (s);
			noline++;
			htmlout (closing);
			if (*s == '\n'){
				s++;
				htmlout ('\n');
			}
		}
	}
	if (ul_on){
		htmlout ("</ul>");
	}
	if (ol_on){
		htmlout ("</ol>");
	}
	if (*s != '\0') more = true;
}
void format_content (const char *s)
{
	bool more;
	format_content(s,10000,more);
}
void formatting_tips()
{
	printhref ("/marker.html","Formatting tips",false);
}

void util_google_code()
{
	#if 0
	htmlout ("<script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"></script>\n");
	htmlout ("<script>\n");
	htmlout ("   (adsbygoogle = window.adsbygoogle || []).push({\n");
	htmlout ("    google_ad_client: \"ca-pub-8720824140107899\",\n");
	htmlout ("    enable_page_level_ads: true\n");
	htmlout ("  });\n");
	htmlout ("</script>\n");
	#endif
}
static unsigned mobile_body_font_size=300;
static unsigned mobile_input_font_size=50;
static unsigned mobile_button_font_size=80;

void util_setmobilespecs (unsigned body_font_size, unsigned input_font_size, unsigned button_font_size)
{
	mobile_body_font_size = body_font_size;
	mobile_input_font_size = input_font_size;
	mobile_button_font_size = button_font_size;
}
/*
	The experimental flag is set in the web container in /etc/bolixonode.conf.
	It is on in the development version.
	This allows for development of long and complex features, kept invisibles from users
	until they are ready.
*/
static bool experimental=false;
void util_set_experimental()
{
	experimental = true;
}
bool util_experimental()
{
	return experimental;
}
/*
	Javascript needed at the end of the HTML
*/
void util_endscript(PARAM_STRING urlparam)
{
	// Script to make sure the webtabs tabs use the full height of the screen
	// Then it takes the webtables and grows them too.
	<?
	<script>
		var inside_onread = false;
		document.onreadystatechange = function () {
			if (!inside_onread){
				inside_onread = true;
				var state = document.readyState;
				if (state == 'interactive') {
					fixsize();
				} else if (state == 'complete') {
					/- tlmpweb_position_popup_js();
				}
				inside_onread = false;
			}
		};
		var diff = 0;
		function allDescendants (node,total) {
			//console.log ('Enter ' + node.className + ' ' + node.id);
			if (node.className == "tabs" || node.className == "subtabs"){
				var bord=(node.offsetHeight-node.clientHeight);
				//var style = node.currentStyle || window.getComputedStyle(node);
				var style = window.getComputedStyle(node);
				var margins = parseInt(style.marginTop,10) + parseInt(style.marginBottom,10);
				var paddings = parseInt(style.paddingTop,10) + parseInt(style.paddingBottom,10);
				total += bord + margins + paddings;
				console.log ("border cls=" + node.className + " node.id=" + node.id + " total="+total+" bord="+bord + " margins="+margins+ " paddings="+paddings);
				if (node.className == "subtabs"){
					console.log ("Set subtabs "+node.id+" total="+total+" oldheight="+node.offsetHeight);
					node.style.height = diff - total;
				}
			}
			var last_webtable = null;
			for (var i = 0; i < node.childNodes.length; i++) {
				var child = node.childNodes[i];
				if (child.id != null
					&& (child.id == "tabs"
						|| child.id == "tab_form"
						|| child.id == "webtable-top")){
					var add = child.offsetHeight;
					var style = window.getComputedStyle(child);
					add += parseInt(style.getPropertyValue('margin-top'),10);
					add += parseInt(style.getPropertyValue('margin-bottom'),10);
					var border_width = style.getPropertyValue('border-top-width');
				
					if (child.id == "tab_form") add += 2;	// Bug scrollbar ???
					console.log ("child.id="+child.id+" add="+add+" border-width="+border_width);
					total += add;
					if (last_webtable != null){
						console.log ("last_webtable "+last_webtable.id+"="+add);
						console.log ("last Set webtable "+last_webtable.id+" total="+total+" oldheight="+last_webtable.offsetHeight);
						last_webtable.style.height = diff - total;
					}
					console.log ("child.id=" + child.id + " total="+total+" height="+child.offsetHeight);
				}else{
					if (child.id != null && child.id == "vframe2h"){
						var bord=(child.offsetWidth-child.clientWidth);
						total += bord;
						console.log ("border child.id=" + child.id + " total="+total+" border="+bord);
						total = allDescendants(child,total);
					}else if (child.className == "webtable" || child.className == "textgrow"){
						console.log ("Set webtable "+child.id+" total="+total+" oldheight="+child.offsetHeight);
						child.style.height = diff - total;
						last_webtable = child;
						//break;
					}else{
						total = allDescendants(child,total);
					}
				}
			}
			return total;
		}
		function fixsize(){
			document.getElementById('main').style.height = window.innerHeight-1;
			var t = document.getElementById('head').offsetHeight;
			diff = window.innerHeight-t-3;
			console.log ("diff="+diff+" offsetHeight="+t);
			document.getElementById('body').style.height = diff-1;
			var tabs = document.getElementsByClassName("tabs");
			for (var i=0; i<tabs.length; i++){
				var node = tabs[i];
				var style = node.currentStyle || window.getComputedStyle(node);
				var margins = parseInt(style.marginTop,10);
				margins += parseInt(style.marginBottom,10);
				node.style.height = diff-2-margins;
			}
			console.log ('tabs.length=' + tabs.length);
			var i;
			for (i=0; i<tabs.length; i++){
				allDescendants (tabs[i],0);
			}
			var tables = document.getElementsByClassName('webtable');
			for (i = 0; i < tables.length; i++) {
				var table = tables[i];
				console.log (table.id+" "+table.offsetHeight+" "+table.offsetWidth);
			}
	
	?>
	webtable_setscroll();
	if (!tlmpweb_isrobot() && tlmpweb_some_geometry_missing()){
		if (tlmpweb_is_repost()){
			tlmp_error ("util_endscript geometry_missing repost=1");
		}else if (0){
			tlmp_warning ("some geometry missing");
		}else{
			const char *sep1 = "?";
			const char *sep2 = "&";
			if (urlparam.ptr[0] == '\0'){
				sep1 = sep2 = "";
			}
			//tlmp_warning ("geometry_missing formsubmit, doing repost\n");
			htmlprintf ("formsubmit(\"%s%s%s&repost=1\");\n",tlmpweb_curpage(),sep1,urlparam.ptr);
		}
	}
	<?
		}
	</script>
	?>
}
void util_meta()
{
	htmlout ("<meta name=\"mobile-web-app-capable\" content=\"yes\">\n");
}

void util_defstyles()
{
	unsigned body_font_size=85;
	unsigned input_font_size=100;
	unsigned button_font_size=90;
	unsigned input_checkbox=1;
	bool ismobile = tlmpweb_ismobile();
	if (ismobile){
		body_font_size = mobile_body_font_size;
		input_font_size = mobile_input_font_size;
		button_font_size = mobile_button_font_size;
		small_size = 1.0;
		input_checkbox = 3;
	}
	htmlout ("<style>\n");
	htmlprintf ("body{\n"
		"	font-family: verdana,arial,tahoma,helvetica,sans-serif;\n"
		"	font-size: %u%%;\n"
		"}\n",body_font_size);
	htmlprintf ("input,select{\n"
		"	font-family: verdana,arial,tahoma,helvetica,sans-serif;\n"
		"	font-size: %u%%;\n"
		"}\n",input_font_size);
	htmlprintf ("input[type=submit] {\n"
		"	font-size: %u%%;\n"
		"}\n",button_font_size);
	htmlprintf ("input[type=checkbox],input[type=radio] {\n"
		"	transform: scale(%u);\n"
		"}\n",input_checkbox);
	htmlprintf (
		"textarea{\n"
		"	font-family: verdana,arial,tahoma,helvetica,sans-serif;\n"
		"	resize: none;\n"
		"	font-size: %u%%;\n"
		"}\n",input_font_size);
	htmlout (
		".button-wrapper {\n"
		"	display: block;\n"
		"	text-align: center;\n"
		"}\n"
		".button {\n"
		"	background-color: DodgerBlue;\n"
		"	border: none;\n"
		"	border-radius: 1em;\n"
		"	color: #fff;\n"
		"	padding: .3em .8em;\n"
		"	font-size: 0.9em;\n"
		"	box-shadow: 2px 2px 2px rgba(0,0,0,0.2);\n"
		"	text-decoration: none;\n"
		"	width: auto;\n"
		"	display: inline-block;\n"
		"	vertical-align: middle;\n"
		"}\n"
		".button:hover {\n"
		"	background-color: lightskyblue;\n"
		"}\n"
		".button:active {\n"
		"	background-color: lightskyblue;\n"
		"	transform: translateY(0.25em);\n"
		"}\n"

		"table, tr, td {\n"
		"	text-size-adjust: none;\n"
		"	font-size: 1em;\n"
		"}\n"
		"a{\n"
		"	overflow-wrap: break-word;\n"
		"	text-decoration: none;\n"
		"}\n"
		"table{\n"
		"	border-radius: 5px;\n"
		"	border-spacing : 0;\n"
		"	border-collapse : collapse;\n"
		"}\n"
		"blockquote{\n"
		"	font-style: italic;\n"
		"	font-size: 18px;\n"
		"	margin-left: 32px;\n"
		"	font-family: Consolas, \"Times New Roman\", Verdana;\n"
		"	border-left: 4px solid #CCC;\n"
		"	padding-left: 8px;\n"
		"}\n"
		"#date0_7b{\n"
		"	font-size: 0.8em;\n"
		"	color: white;\n"
		"}\n"
		"#date0_7{\n"
		"	font-size: 0.8em;\n"
		"}\n"
		".smsg {\n"
		"	text-size-adjust: none;\n"
		"	font-size: 1em;\n"
		"	display: block;\n"
		"	background-color: #F0F0F0;\n"
		"	border-radius: 10px;\n"
		"	padding-left: 5px;\n"
		"	padding-right: 5px;\n"
		"	padding-top: 5px;\n"
		"	padding-bottom: 5px;\n"
		"	overflow-wrap: break-word;\n"
		"	word-break: break-word;\n"
		"}\n"
		);
	htmlprintf (
		".small {\n"
		"	font-size: %0.2fem;\n"
		"	file: gray;\n"
		"}\n",small_size);
	htmlout("</style>\n");
	tlmpweb_setscripts();
	htmlout ("<script>\n");
	if (tlmpweb_ismobile()){
		htmlout (
			"document.addEventListener('touchstart', handleTouchStart, false);\n"
			"document.addEventListener('touchmove', handleTouchMove, false);\n"
			"document.addEventListener('touchend', handleTouchEnd, false);\n"
			"\n"
			"var swipelefthref = null;\n"
			"var swiperighthref = null;\n"
			"var smallswipelefthref = null;\n"
			"var smallswiperighthref = null;\n"
			"var swipeStart = null;\n"
			"var xDown = null;\n"
			"var xDiff = null;\n"
			"var yDown = null;\n"
			"var yDiff = null;\n"
			"var tabswipe = null;\n"
			"var tabelm = '';\n"
			"\n"
			"function getTouches(evt) {\n"
			"	return evt.touches ||\n"		// browser API
			"		evt.originalEvent.touches;\n"	// jQuery
			"}\n"
			"\n"
			"function handleTouchStart(evt) {\n"
			"	const firstTouch = getTouches(evt)[0];\n"
			"	xDown = firstTouch.clientX;\n"
			"	yDown = firstTouch.clientY;\n"
			"	var d = new Date();\n"
			"	var elm = event.target || event.srcElement;\n"
			"	tabswipe=0;\n"
			"	if (elm != null && elm.id.substring(0,7)=='tabrect'){\n"
			"		tabswipe=1;\n"
			"		tabelm='&tabelm='+elm.id;\n"
			"	}\n"
			"	swipeStart = d.getTime();\n"
			"}\n"                                                
			"function handleTouchEnd(evt) {\n"
			//"	console.log ('END xDiff = ' + xDiff);\n"
			"	var d = new Date();\n"
			"	var duration = d.getTime() - swipeStart;\n"
			"	if (duration > 500){\n"
					// Do nothing
			"	}else if (tabswipe == 1){\n"
			"		if (xDiff > 0){\n"
						// small right swipe
			"			if (smallswiperighthref) formsubmit(smallswiperighthref);\n"
			"		}else if (xDiff < 0){\n"
						// small left swipe
			"			if (smallswipelefthref) formsubmit(smallswipelefthref);\n"
			"		}\n"
			"	}else if (Math.abs(yDiff) < 100){\n"
			"		if (xDiff > 400){\n"
						// right swipe
			"			if (swiperighthref) formsubmit(swiperighthref+tabelm);\n"
			"		}else if (xDiff < -400){\n"
						// left swipe
			"			if (swipelefthref) formsubmit(swipelefthref+tabelm);\n"
			"		}\n"
			"	}\n"
			"	xDown = null;\n"
			"	yDown = null;\n"
			"}\n"                                                
			"\n"
			"function handleTouchMove(evt) {\n"
			"	if ( ! xDown || ! yDown ) {\n"
			"		return;\n"
			"	}\n"
			"\n"
			"	var last = evt.touches.length-1;\n"
			"	var xUp = evt.touches[last].clientX;\n"
			"	var yUp = evt.touches[last].clientY;\n"
			"\n"
			"	xDiff = xDown - xUp;\n"
			"	yDiff = yDown - yUp;\n"
			//"	console.log ('xd '+xDown + ' ' + xUp + ' ' + xDiff+ ' ' + last);\n"
			"\n"
			"}\n"
			);
	}
	htmlout (
		"function dropmenu(dropdown,menu,width){\n"
		"	var drop = document.getElementById(dropdown);\n"
		"	var dot = document.getElementById(menu);\n"
		"	var atags = drop.getElementsByTagName('a');\n"
		"	for (var i = 0; i < atags.length; i++) {\n"
		"		var child = atags[i];\n"
		"		child.classList.remove ('hide');\n"
		"		child.classList.add ('show');\n"
		"		child.style.color = 'black';\n"
		"	}\n"
		"	drop.style.minWidth = width;\n"
		"	var rect = dot.getBoundingClientRect();\n"
		"	drop.style.left = rect.right - width - 10;\n"
		"	drop.style.top = rect.bottom;\n"
		"	drop.classList.toggle('show');\n"
		"	return false;\n"
		"}\n"
		"function viewintab(href){\n"
		"	window.open(href,'_blank');\n"
		"	window.focus();\n"
		"	return false;\n"
		"}\n"
		"function openintab(event,href){\n"
		"	if (event.which == 1){\n"
		"		window.open(href,'_blank');\n"
		"	}else if (event.which == 2){\n"
		"		viewintab(href);\n"
		"	}\n"
		"	event.stopPropagation();\n"
		"	return false;\n"
		"}\n"
		"function subformsubmit(event,href){\n"
		"	event.stopPropagation();\n"
		"	formsubmit(href);\n"
		"	return false;\n"
		"}\n"
		);
	htmlout ("</script>\n");
}
/*
	Draw the dot menu (3 bar in fact :-) ) only. No action or script attached.
*/
void util_draw_dotmenu(const char *id_menu, bool is_active, bool notify)
{
	unsigned height = draw_tab_height();
	unsigned width = height;
	unsigned thick = 2;
	unsigned line_y = height/4;
	unsigned skip_y = height/4;
	unsigned line_x1 = 5;
	unsigned line_x2 = width-5;
	if (tlmpweb_ismobile()){
		width *= 2;
		thick = 4;
		line_x1 = 20;
		line_x2 = width-20;
	}
	htmlprintf ("<svg width=%u height=%u>\n",width,height);
	htmlprintf ("<rect id='rect%s' stroke=black stroke-width=1 x=0 y=0 width=%u height=%u fill=%s />\n",id_menu,width,height,notify ? "orange" : "white");
	for (int i=0; i<3; i++){
		htmlprintf ("<line x1=%u y1=%u x2=%u y2=%u style='stroke:black;stroke-width:%u'></line>\n"
			,line_x1,line_y,line_x2,line_y,thick);
		line_y += skip_y;
	}
	htmlprintf ("<path stroke=%s stroke-width=2 d='M0,%u h%u' />",is_active ? "white" : "black",height,width);
	htmlout ("</svg>");
}
/*
	Draw a 3 dots menu and the associated popup.
*/
void util_dotmenu (const vector<DOTMENU> &menu, bool is_active, bool notify)
{
	static const char *id_dropdown = "dropdown-dot";
	static const char *id_menu = "dotmenu";
	unsigned popup_width = 0;
	{
		DIV d("dropdown"); d.print();
		DIV dd("dropdown-content",id_dropdown); dd.print();
		for (auto &m:menu){
			htmlprintf ("<a href='#' onclick=formsubmit('%s?webstep=%u')>%s</a>\n",tlmpweb_curpage(),m.step,m.menu);
			unsigned menu_width = tlmpweb_displaylen(m.menu)+20;
			if (menu_width > popup_width) popup_width = menu_width;
		}
	}

	DIV d; d.id(id_menu).print();
	htmlprintf ("<a href=# onclick='return dropmenu(\"%s\",\"%s\",%u);'>\n",id_dropdown,id_menu,popup_width);
	util_draw_dotmenu (id_menu,is_active,notify);
	htmlout ("</a>\n");
}

void printhref(const char *url, const char *text)
{
	htmlprintf ("<a href=\"%s\"><table bgcolor=\"#33cc33\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",url,text);
}
void printhref_selected(const char *url, const char *text)
{
	htmlprintf ("<a href=\"%s\"><table bgcolor=\"#220022\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",url,text);
}
void printhref(const char *url, const char *text, bool largewindow)
{
	if (w_robot){
		htmlprintf ("<a href=\"%s\">%s</a>",url,text);
	}else{
		const char *script = largewindow ? "popup_large" : "popup_small";
		htmlprintf ("<a href=\"#\" onclick=%s(\"%s\")><table bgcolor=\"#33cc33\"><tr><td style=\"padding:5px\"><font size=4 color=white>&nbsp;%s&nbsp;</font></table></a>",script,url,text);
	}
}
void printhref_raw(const char *url, const char *text, bool largewindow)
{
	if (w_robot){
		htmlprintf ("<a href=\"%s\">%s</a>",url,text);
	}else{
		const char *script = largewindow ? "popup_large" : "popup_small";
		htmlprintf ("<a href=\"#\" onclick=%s(\"%s\")>%s</a>",script,url,text);
	}
}
string format_date (unsigned format, PARAM_STRING pdate)
{
	static TRANS_NOTLOAD *tbmonth[]={P_MSG_U(I_JANUARY,"Jan"),P_MSG_U(I_FEBRUARY,"Feb"),P_MSG_U(I_MARCH,"Mar")
		,P_MSG_U(I_APRIL,"Apr"),P_MSG_U(I_MAY,"May"),P_MSG_U(I_JUNE,"Jun")
		,P_MSG_U(I_JULY,"Jul"),P_MSG_U(I_AUGUST,"Aug"),P_MSG_U(I_SEPTEMBER,"Sep")
		,P_MSG_U(I_OCTOBER,"Oct"),P_MSG_U(I_NOVEMBER,"Nov"),P_MSG_U(I_DECEMBER,"Dec")};
	const char *date = pdate.ptr;
	if (format != 0){
		return date;
	}else if (strlen(date)==19){
		int year = atoi(date);
		int month = atoi(date+5);
		int day = atoi(date+8);
		int hour = atoi(date+11);
		int minu = atoi(date+14);
		const char *ampm = "AM";
		if (hour > 12){
			hour -= 12;
			ampm="PM";
		}
		return string_f (" %s %d %04d @%d:%02d%s",tbmonth[month-1]->get(),day,year,hour,minu,ampm);
	}else if (strlen(date)==10){
		int year = atoi(date);
		int month = atoi(date+5);
		int day = atoi(date+8);
		return string_f (" %s %d %04d",tbmonth[month-1]->get(),day,year);
	}else{
		return date;
	}
}
string format_time (unsigned format, PARAM_STRING ptime)
{
	const char *time = ptime.ptr;
	if (format != 0){
		return string(time,5);
	}else if (strlen(time)==8){
		int hour = atoi(time);
		int minu = atoi(time+3);
		const char *ampm = "AM";
		if (hour > 12){
			hour -= 12;
			ampm="PM";
		}
		return string_f ("%d:%02d%s",hour,minu,ampm);
	}else{
		return time;
	}
}

void util_formanchor()
{
	htmlprintf ("<a name=\"form\">\n");
}
void button_row(_F_button_row &c, int border, const char *bgcolor, bool alignleft)
{
	vector<GRABLINE> left_lines;
	tlmpweb_pushgrab(left_lines);
	c.align="left";
	c.draw();
	tlmpweb_popgrab();
	vector<GRABLINE> right_lines;
	tlmpweb_pushgrab(right_lines);
	c.align="right";
	c.spliton = false;
	c.draw_right();
	tlmpweb_popgrab();
	if (left_lines.size() > 0 || right_lines.size()>0){
		DIV cols; cols.dispflex().flowrow();
		if (!alignleft) cols.sfloat("right");
		cols.print();
		if (c.href_arrow_left.size() > 0){
			DIV col; col.flexfixe().print();
			draw_left_arrow(c.arrow_left_visible,c.href_arrow_left);
		}
		{
			DIV col; col.flexgrow().overflow("hidden").print();
			DIV d; d.dispflex().flowrow().bg("none").overflow("hidden").print();
			if (left_lines.size() > 0){
				htmlout (left_lines);
				htmlout ("</div>\n");
			}
			if (c.endline){
				htmlout ("<div>\n");
				unsigned height = draw_tab_height();
				htmlprintf ("<svg width=%u height=%u>\n",c.endline_width,height);
				htmlprintf ("<path stroke=black stroke-width=1 d='M0,%u h%u' />\n",height,c.endline_width);
				htmlout ("</svg>\n");
				htmlout ("</div>\n");
			}
		}
		if (c.href_arrow_right.size() > 0){
			DIV col; col.flexfixe().print();
			draw_right_arrow(c.arrow_right_visible,c.href_arrow_right);
		}
		DIV end; end.flexfixe().print();
		if (right_lines.size() > 0){
			htmlout (right_lines);
			htmlout ("</div>\n");
		}
	}
}
void button_row(_F_button_row &c, int border, const char *bgcolor)
{
	button_row(c,border,bgcolor,true);
}
void button_row(_F_button_row &c, int border)
{
	button_row (c,border,"white",true);
}
void button_row(_F_button_row &c)
{
	button_row(c,0,"white",true);
}
void _F_button_row::draw_right()
{
}
void _F_button_row::reset()
{
	spliton = false;
	tlmpweb_resetgrab();
}
void _F_button_row::split()
{
	if (spliton) htmlout ("</div>\n");
	htmlout ("<div>\n");
	spliton = true;
}
void _F_button_row::drawendline(unsigned width)
{
	endline_width = width;
	endline = true;
}
void _F_button_row::drawleftarrow (PARAM_STRING href, bool visible)
{
	arrow_left_visible = visible;
	href_arrow_left = href.ptr;
}
void _F_button_row::drawrightarrow (PARAM_STRING href, bool visible)
{
	arrow_right_visible = visible;
	href_arrow_right = href.ptr;
}
static const char *tbhttptype[]={
        "application/octet-stream",	//FILE_UNKNOWN
        "text/html",	//FILE_TEXT
	"audio/mp3",	//FILE_SOUND_MP3
	"audio/ogg",	//FILE_SOUND_OGG
	"image/jpeg",	//FILE_IMAGE_JPG
	"image/png",	//FILE_IMAGE_PNG
	"image/gig",	//FILE_IMAGE_GIF
	"video/mpeg",	//FILE_VIDEO
	"application/octet-stream",	//FILE_DOC_SUDOKU
	"application/octet-stream",	//FILE_DOC_CHECKER
	"application/octet-stream",	//FILE_DOC_CHESS
	"application/octet-stream",	//FILE_DOC_TICTACTO
	"application/octet-stream",	//FILE_ZIP
	"application/octet-stream",	//FILE_TGZ
	"application/octet-stream",	//FILE_DOC_WORDPROC
	"application/octet-stream",	//FILE_DOC_WHITEBOARD
	"video/webm",	//FILE_WEBM
	"image/tiff",	//FILE_IMAGE_TIFF
	"application/pdf",	//FILE_PDF
	"application/octet-stream",	//FILE_DOC_CALC
	"application/octet-stream",	//FILE_DOC_PHOTOS
	"application/octet-stream",	//FILE_DOC_VIDCONF
	"audio/x-wav",			// FILE_SOUND_WAV
};
static_assert(sizeof(tbhttptype)/sizeof(tbhttptype[0])==FILE_TYPE_LAST,"tbhttptype is incomplete");
<mod>
static void util_sendfile_common(CONNECT_INFO &con, const READINFO_receive &info, const BOB_TYPE &content, bool more, const char *handle, const char *session)
{
	glocal CONNECT_INFO *con = &con;
	tlmpweb_setmodified(info.modified);
	tlmpweb_setexpire(time(NULL)+365*24*60*60);	// Expires in one year
	tlmpweb_doctype (tbhttptype[info.file_type],info.size);
	htmlwrite (content.getbuffer(),content.getsize());
	glocal bool more = more;
	while (glocal.more){
		<call bod_client_readmore>(*glocal.con,session,handle);
		<f ok>
			htmlwrite (content.getbuffer(),content.getsize());
			glocal.more = more;
			//tlmp_error ("readmore success=%d msg=%s\n",success,msg);
		</f>
		</call>
	}
}
</mod>	

static int util_sendfile (const char *fname)
{
	int ret = -1;
	FILE *fin = fopen (fname,"r");
	if (fin != NULL){
		struct stat64 st;
		time_t mod = 0;
		unsigned size = 0;
		if (fstat64(fileno(fin),&st)!=-1){
			size = st.st_size;
			mod = st.st_mtime;
		}
		tlmpweb_setmodified(mod);
		tlmpweb_doctype ("image/jpeg",size);
		char buf[64*1024];
		int n;
		while ((n=fread(buf,1,sizeof(buf),fin))>0){
			htmlwrite(buf,n);
		}
		fclose (fin);
		ret = 0;
	}
	return ret;
}
<mod>
int util_sendfile (CONNECT_INFO &con, PARAM_STRING session, PARAM_STRING filename)
{
	glocal int ret = -1;
	glocal CONNECT_INFO *con = &con;
	glocal const char *session = session.ptr;
	glocal bool is_mini_photo = strstr(filename.ptr,"/public/mini-photo.jpg")!=nullptr;
	glocal bool is_photo = strstr(filename.ptr,"/public/photo.jpg")!=nullptr;
	<call bod_client_readfile_bob>(con,session,filename,"",false);
	<f ok>
		if (success){
			glocal.ret = 0;
			util_sendfile_common(*glocal.con,info,content,more,handle,glocal.session);
		}else if (glocal.is_mini_photo){
			glocal.ret = util_sendfile("/var/www/html/no-mini-photo.jpg");
		}else if (glocal.is_photo){
			glocal.ret = util_sendfile("/var/www/html/no-photo.jpg");
		}else{
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>
/*
	Send a file using the public api.
	The file is /username/file. We accept also username/file.
	So we extract the username
*/
<mod>
int util_sendpublicfile (CONNECT_INFO &con, PARAM_STRING filename)
{
	glocal int ret = -1;
	glocal CONNECT_INFO *con = &con;
	const char *pt = filename.ptr;
	if (*pt == '/') pt++;
	const char *start = pt;
	pt = strchr(pt,'/');
	if (pt != NULL){
		glocal const char *filename = pt;
		glocal string username = string(start,pt-start);
		<call bod_client_public_readfile>(con,glocal.username,pt,0);
		<f ok>
			if (!success){
				if (strcmp(glocal.filename,"/project/photo.jpg")==0){
					glocal.ret = util_sendfile ("/var/www/html/no-photo.jpg");
				}else if (strcmp(glocal.filename,"/project/mini-photo.jpg")==0){
					glocal.ret = util_sendfile ("/var/www/html/no-mini-photo.jpg");
				}
				if (glocal.ret != 0) tlmp_warning ("Can't read public file %s for user %s: %s\n",glocal.filename,glocal.username.c_str(),msg);
			}else{
				glocal.ret = 0;
				util_sendfile_common(*glocal.con,info,content,more,handle,"public");
			}
		</f>
		</call>
	}
	return glocal.ret;
}
</mod>

string util_flipspaces(PARAM_STRING src)
{
	string ret = src.ptr;
	for (auto &c:ret){
		if (c == ' ') c = '_';
	}
	return ret;
}
/*
	Extract a URL (if found) from a line.
	Return true if it was a URL.
*/
static bool util_is_url(const char *txt, const char *&end,string &url)
{
	bool ret = false;
	const char *pt;
	if (is_start_any_ofnc(txt,pt,"http://","https://")){
		pt = txt;
		while (*pt > ' ' && is_not_in(*pt,'"','>',',',')')) pt++;
		// A URL can't end with a period
		if (pt > txt && pt[-1] == '.') pt--;
		url = string(txt,pt-txt);
		end = pt;
		ret = true;
	}
	return ret;
}
/*
	Create a link to an internal part of the application using subformsubmit.
	This works inside content being itself clickable.
*/
string util_subformsubmit (PARAM_STRING link, PARAM_STRING text)
{
	return string_f("<span style=color:blue;cursor:pointer onclick=subformsubmit(event,\"%s?%s\")>%s</span>\n"
		,tlmpweb_curpage(),link.ptr,text.ptr);
}
/*
	Format and print a <span> ... </span> with openitab()
*/
void util_print_span(PARAM_STRING url)
{
	htmlprintf ("<span style=color:blue;cursor:pointer onclick=openintab(event,'%s')>%s</span>\n",url.ptr,url.ptr);
}
/*
	Format a <span> ... </span> with openitab()
*/
static string util_span(PARAM_STRING url)
{
	return string_f("<span style=color:blue;cursor:pointer onmouseup=openintab(event,'%s')>%s</span>",url.ptr,url.ptr);
}
/*
	Format an open <span> ... with openitab()
	(no closing </span>
*/
static string util_open_span(PARAM_STRING url)
{
	return string("<span style=color:blue;cursor:pointer onmouseup=openintab(event,'") + url.ptr + "') >";
}
void util_clickable_img (PARAM_STRING url, const char *image_width, unsigned border)
{
	htmlout ("<span style=color:blue");
	htmlout (" onmouseup=openintab(event,'");
	htmlout (url.ptr);
	htmlout ("')");
	htmlprintf ("><img width=%s border=%u src=%s>",image_width,border,url.ptr);
	htmlout ("</span>");
}
/*
	Create the HTML for a clickable image (using javascript openintab())
*/
string util_clickable_img (PARAM_STRING url, unsigned image_width)
{
	string ret;
	ret.reserve(500);
	ret = util_open_span(url);
	ret += string_f("<img width=%u src=",image_width);
	ret += url.ptr;
	ret += '>';
	ret += "</span>";
	return ret;
}
/*
	Remove the dot at the end of a string
*/
static void util_remove_dot(string &line, string &dot)
{
	if (line.size() > 0){
		dot.clear();
		auto last = line.size()-1;
		if (line[last] == '.'){
			// The line ends with a period. It is probably not part of the ID.
			line.resize(last);
			dot = ".";
		}
	}
}

#define UTF8_ONE_BYTE_MASK 0b10000000
#define UTF8_ONE_BYTE_COUNT 0

#define UTF8_TWO_BYTE_MASK 0b11100000
#define UTF8_TWO_BYTE_COUNT 0b11000000

#define UTF8_THREE_BYTE_MASK 0b11110000
#define UTF8_THREE_BYTE_COUNT 0b11100000

#define UTF8_FOUR_BYTE_MASK 0b11111000
#define UTF8_FOUR_BYTE_COUNT 0b11110000

// This one could use a better name, I just don't know a better one (yet?)
#define UTF8_OTHER_MASK 0b00111111

static size_t utf8_codepoint_size(uint8_t text)
{
	if((text & UTF8_ONE_BYTE_MASK) == UTF8_ONE_BYTE_COUNT) {
		return 1;
	}

	if((text & UTF8_TWO_BYTE_MASK) == UTF8_TWO_BYTE_COUNT) {
		return 2;
	}

	if((text & UTF8_THREE_BYTE_MASK) == UTF8_THREE_BYTE_COUNT) {
        	return 3;
	}
	return 4;
}
/*
	Copy a local link (user/project/document)
	Return the pointer
*/
static const char *util_copy_locallink(const char *txt, string &doc, string &dot)
{
	const char *start = txt;
	while (*txt > ' ' && is_not_in(*txt,'"','\'','<','>',',','=','&')) txt++;
	doc = string(start,txt-start);
	util_remove_dot (doc,dot);
	return txt;
}
static const char *util_name_from_path(const string &doc)
{
	const char *name = strrchr(doc.c_str(),'/');
	if (name == nullptr){
		name = doc.c_str();
	}else{
		name++;
	}
	return name;
}
// Present a video in a span
static string util_span_video(const string &url, unsigned image_width)
{
	string ret;
	ret += util_open_span(url);
	ret += string_f ("<video width=%u controls preload=none>\n"
		"<source src=\"%s\" type=\"video/mp4\">\n"
		"Your browser does not support the video tag.\n"
		"</video>\n"
		,image_width,url.c_str());
	ret += "</span>";
	return ret;
}
// Validate that a document exist and has the proper type
static void util_validate_doc (
	CONNECT_INFO &con,
	const string &doc,
	string &errmsg,			// Will contain the error message if any
	bool (*check)(FILE_TYPE file_type),
	const char *filenottype)	// Error message
{
	FILEINFO info;
	ENTRY_TYPE type = util_entrytype(con,string_f("/projects/%s",doc.c_str()),info);
	if (type == ENTRY_DIR){
		errmsg = string_f(MSG_U(E_ISDIR,"Tag %s: %s is a folder\n"),"_IMG",doc.c_str());
	}else if (is_not_in(type,ENTRY_FILE,ENTRY_DOCUMENT)){
		errmsg = string_f(MSG_U(E_NOTFOUND,"Tag %s: document %s does not exist\n"),"_IMG",doc.c_str());
	}else if (!check(info.file_type)){
		errmsg = string_f(filenottype,doc.c_str());
	}
}

/*
	Format a short message, remove the signature
	Escapes < and >
	Supports ? for URL

	if validate is true, does some validation. Errors are reported in errmsg.
*/
string util_format_shortmsg (
	PARAM_STRING msg,
	unsigned nblines,
	size_t size,
	unsigned image_width,
	bool validate,
	CONNECT_INFO &con,
	string &errmsg)
{
	const char *txt = msg.ptr;
	string ret;
	ret.reserve(nblines > 0 ? nblines*100 : 1000);
	unsigned pos=0;
	unsigned noline=0;
	if (nblines == 0) nblines=(unsigned)-1;
	while (*txt != '\0' && noline < nblines){
		if (*txt == '\n'){
			ret += "<br>\n";
			pos=0;
			noline++;
		}else{
			const char *pt;
			string url;
			if (util_is_url(txt,pt,url)){
				ret += util_span (string(txt,pt-txt));
				txt = pt-1;
			}else if (*txt == '<'){
				if (is_start_any_ofnc(txt,pt,"<br>","<sup>","</sup>","<sub>","</sub>","<em>","</em>","<strong>","</strong>","<b>","</b>")){
					while (txt < pt) ret += *txt++;
					txt--;	// There is a txt++ at the end of the loop.
				}else{
					ret += "&lt;";
				}
			}else if (*txt == '>'){
				ret += "&gt;";
			}else if (*txt == '\t'){
				unsigned nb = 4 - (pos%4);
				for (unsigned i=0; i<nb; i++) ret += "&nbsp;";
			}else if (is_start_any_of(txt,pt,"_IMG=")){
				txt = pt;
				if (util_is_url(txt,pt,url)){
					txt = pt;
					ret += util_clickable_img(url,image_width);
				}else{
					string doc,dot;
					txt = util_copy_locallink(txt,doc,dot);
					if (doc.size()==0){
						ret += "_IMG=";
					}else{
						url = string_f("%s?webstep=%d&image=/projects/%s"
							,tlmpweb_curpage(),step_image,doc.c_str());
						ret += util_clickable_img(url,image_width);
						ret += dot;
						if (validate){
							util_validate_doc(con,doc,errmsg,file_is_image,MSG_R(E_FILENOTIMAGE));
						}
					}
				}
				txt--;
			}else if (is_start_any_of(txt,pt,"_VIDEO=")){
				txt = pt;
				if (util_is_url(txt,pt,url)){
					txt = pt;
					ret += util_span_video(url,image_width);
				}else{
					string doc,dot;
					txt = util_copy_locallink(txt,doc,dot);
					if (doc.size()==0){
						ret += "_VIDEO=";
					}else{
						url = string_f("%s?webstep=%d&image=/projects/%s"
							,tlmpweb_curpage(),step_image,doc.c_str());
						ret += util_span_video(url,image_width);
						ret += dot;
						if (validate){
							util_validate_doc(con,doc,errmsg,file_is_video,MSG_U(E_FILENOTVIDEO,"File %s is not a video"));
						}
					}
				}
				txt--;
			}else if (is_start_any_of(txt,pt,"_IFRAME=")){
				txt = pt;
				if (util_is_url(txt,pt,url)){
					txt = pt;
					ret += util_open_span(url);
					ret += "<div style=\"position:relative;padding-top:56.25%;\">\n";
					ret += string_f ("<iframe\n"
						"style=\"position:absolute;top:0;left:0;width:100%%;height:100%%;\"\n"
						"src=\"%s\"\n"
						"allowfullscreen"
						"></iframe>\n"
						,url.c_str());
					ret += "</div></span>";
				}else{
					ret += "_IFRAME=";
				}
				txt--;
			}else if (is_start_any_of(txt,pt,"_HELP=")){
				txt = pt;
				while (isalpha(*txt)) txt++;
				string tmp(pt,txt-pt);
				ret += string_f("<span style=color:blue;cursor:pointer onclick=subformsubmit(event,\"%s?webstep=%d&topic=%s\")>%s</span>\n"
					,tlmpweb_curpage(),step_doctopic,tmp.c_str(),MSG_U(I_LINK,"link"));
				txt--;
			}else if (is_start_any_of(txt,pt,"_DOC=")){
				txt = pt;
				string doc,dot;
				txt = util_copy_locallink(txt,doc,dot);
				if (doc.size() == 0){
					ret += "_DOC=";
					if (validate){
						errmsg = MSG_U(E_NODOCSPECIFIED,"Tag _DOC, no document specified");
					}
				}else{
					const char *name = util_name_from_path(doc);
					ret += string_f("<span style=color:blue;cursor:pointer onclick=subformsubmit(event,\"%s?webstep=%d&webtab_add=2:%s~%s\")>%s</span>\n"
						,tlmpweb_curpage(),step_projects,doc.c_str(),name,doc.c_str());
					ret += dot;
					if (validate){
						FILEINFO info;
						ENTRY_TYPE type = util_entrytype(con,string_f("/projects/%s",doc.c_str()),info);
						if (type == ENTRY_DIR){
							errmsg = string_f(MSG_R(E_ISDIR),"_DOC",doc.c_str());
						}else if (is_not_in(type,ENTRY_FILE,ENTRY_DOCUMENT)){
							errmsg = string_f(MSG_R(E_NOTFOUND),"_DOC",doc.c_str());
						}
					}
				}
				txt--;
			}else if (is_start_any_of(txt,pt,"_USER=")){
				txt = pt;
				while (*txt > ' ' && is_not_in(*txt,'"','>',',')) txt++;
				string user(pt,txt-pt);
				string dot;
				util_remove_dot (user,dot);
				if (user.size() == 0){
					ret += "_USER=";
				}else{
					ret += " ";
					if (user == "admin"){
						// admin is not in the contact list of everyone, but has a public page
						ret += "<img src=/public/admin/project/mini-photo.jpg>";
					}else{
						string dir = string_f("/projects/%s/public",user.c_str());
						unsigned mini_image_width = tlmpweb_ismobile() ? 60 : 40;
						ret += util_mini_img(step_image,mini_image_width,dir,"mini-photo.jpg","");
					}
					string add = string_f("webstep=%d&webtab_add=1:%s:inbox~%s&recipients2=%s"
						,step_talks,userinfo.name.c_str(),MSG_R(I_SHORTINBOX),user.c_str());
					ret += " ";
					ret += util_subformsubmit(add,user);
					ret += dot;
				}
				txt--;
			}else{
				size_t sizecar = utf8_codepoint_size(*txt);
				while (sizecar > 0){
					ret += *txt++;
					sizecar--;
				}
				txt--;
				pos++;
			}
		}
		txt++;
	}
	if (*txt != '\0' || (size != 0 && size != strlen(msg.ptr))){
		if (ret.size() > 0 && ret[ret.size()-1] != '\n') ret += "<br>\n";
		ret += "...";
	}
	return ret;
}
string util_format_shortmsg (PARAM_STRING msg, unsigned nblines, size_t size, unsigned image_width)
{
	string errmsg;
	CONNECT_INFO con;
	return util_format_shortmsg (msg,nblines,size,image_width,false,con,errmsg);
}
string util_format_shortmsg (PARAM_STRING txt, unsigned image_width)
{
	return util_format_shortmsg (txt,0,0,image_width);
}

// Send an HTML document. Does some remaping of relative URLs. Prevent scripting as well.
void _F_public_page::sendhtml (const BOB_TYPE &content)
{
	string tmp((const char*)content.getbuffer(),content.getsize());
	const char *txt = tmp.c_str();
	const char *tosend = txt;
	while (*txt != '\0'){
		if (*txt == '<'){
			// Check if this is  <script>
			const char *pt = txt+1;
			while (isspace(*pt)) pt++;
			if (strncasecmp(pt,"script",6)==0){
				if (tosend < txt) htmlout (tosend,txt-tosend);
				htmlout ("&lt;");
				txt++;
				tosend = txt;	
			}else{
				txt++;
			}
		}else{
			bool is_href = strncmp(txt,"href=",5)==0;
			if (strncmp(txt,"src=",4)==0 || is_href){
				if (is_href){
					txt += 5;
				}else{
					txt += 4;
				}
				char space = ' ';	// Spaces are not part of the URL unless there is a quote
				if (*txt == '"' || *txt == '\''){
					txt++;
					space = '\0';
				}
				if (is_start_any_ofnc(txt,NONEED,"http:","https:") || *txt == '/'){
					txt++;
				}else{
					const char *pt = txt;
					while (*pt > space && is_not_in(*pt,'"','\'','>')) pt++;
					string url(txt,pt-txt);
					string newurl = projecturl (url,"",!is_href);
					if (tosend < txt) htmlout (tosend,txt-tosend);
					htmlout (newurl);
					txt = pt;
					tosend = txt;
				}
			}else{
				txt++;
			}
		}
	}
	if (tosend < txt) htmlout (tosend,txt-tosend);
}
/*
	Display the public page of a user either in the front-end (preview mode) or in the public.hc page
*/
void public_page (_F_public_page &c)
{
	c.process();
}
static void util_urls (_F_public_page &c, const SHORTMSG &m, string &content, bool large)
{
	string url = c.msgurl(m.uuid,m.submit);
	unsigned width = 300;
	const char *percent = "";
	if (tlmpweb_ismobile()){
		if (large){
			width = 100;
			percent = "%";
		}else{
			width = 700;
		}
	}else if (large){
		width = 800;
	}
	if (m.content[0] != '\0'){
		content = util_format_shortmsg (m.content,width);
	}else if (file_is_sound(m.file_type)){
		content = string_f("<audio controls>\n"
			"<source src=\"%s\" type=\"audio/%s\">\n"
			"</audio>"
			,url.c_str(),tbftype[m.file_type]);
	}else if (file_is_image(m.file_type)){
		content = string_f("<img width=%u%s src=%s>",width,percent,url.c_str());
	}else if (file_is_video(m.file_type)){
		const char *extension = m.file_type == FILE_WEBM ? "webm" : "mp4";
		content = string_f(
			"<video width=\"%u%s\" height=\"%u%s\" controls preload=none>\n"
			"<source src=\"%s\" type=\"video/%s\">\n"
			"Your browser does not support the video tag.\n"
			"</video>"
			,width,percent,width,percent,url.c_str(),extension);
	}
}
<mod>
static void public_messages(_F_public_page &c, CONNECT_INFO &con, PARAM_STRING user)
{       
        glocal CONNECT_INFO *con = &con;
        glocal _F_public_page *c = &c;
        glocal const char *user = user.ptr;

	DIV d(TAB_SUBTABS);
	if (!tlmpweb_ismobile()) d.borderradius(5).border(1,"black").paddings(5,5).vpaddings(5,5);
	d.h(100).bg("white").print();
	<call webtable>(WEBID("talkpublic"));
	<f click>
		util_defstyles();
		tlmpweb_body("white",NULL);
		vector<SHORTMSG> messages;
		if (glocal.c->list_talk(noline,1,messages) != -1){
			auto &m = messages[0];
			string content;
			util_urls(*glocal.c,m,content,true);
			htmlout (content);
		}
	</f>
	<f load>
		setrowstyle ("hline","bgcolor=gray valign=top");
		setrowstyle ("sep","bgcolor=ghostwhite valign=top");
		setrowstyle ("sep+current","bgcolor=lightblue valign=top");
		setrowstyle ("sep1","bgcolor=white valign=top");
		setrowstyle ("sep1+current","bgcolor=lightblue valign=top");
		setthparms ("align=left bgcolor=lightgray","");
		setrowstyle ("white","bgcolor=white");
		sethead  ("%s\a",MSG_U(H_MESSAGES,"Messages"));
		glocal unsigned rownum = nbskip;
		unsigned offset=0;
		static const char *func = "Popup";
		while (1){
			glocal bool more = false;
			vector<SHORTMSG> messages;
			if (glocal.c->list_talk(offset,50,messages) != -1){
				string day;
				static const char *line_styles[]={"sep","sep1"};
				unsigned line_style = 0;
				for (auto &m:messages){
					string now = m.submit.substr(0,10);
					if (now != day){
						day = now;
						glocal.webtable.setclickopt (true,"","");
						glocal.webtable.setrow("hline",-1,"<div id=date0_7b>%s</div>\a\a",format_date(0,day).c_str());
						line_style=0;
					}
					const char *style = line_styles[line_style];
					line_style++;
					if (line_style == 2) line_style = 0;
					if (file_is_sound(m.file_type)){
						glocal.webtable.setclickopt (true,func,"400,100");
					}else if (file_is_video(m.file_type)){
						glocal.webtable.setclickopt (true,func,"800,800");
					}else if (file_is_image(m.file_type)){
						glocal.webtable.setclickopt (true,func,"800,800");
					}else{
						glocal.webtable.setclickopt (true,func,"800,300");
					}
					string time = string_f("<div id=date0_7>%s</div>",format_time(0,m.submit.substr(11)).c_str());
					string path = string_f("/msgs/%s/short-inbox/public/%s",glocal.user,m.uuid.c_str());
					string content;
					if (m.content.size() != 0){
						content = string_f("<div class=smsg>%s</div>",util_format_shortmsg (m.content,0,m.size,100).c_str());
					}else{
						util_urls(*glocal.c,m,content,false);
					}
					glocal.webtable.setrow (style,glocal.rownum,"%s\t%s",time.c_str(),content.c_str());
					glocal.rownum++;
				}
				glocal.more = messages.size() == 50;
			}else{
				break;
			}
			if (!glocal.more) break;
			offset += 50;
		}
	</f>
	</call>
}
</mod>
static void public_top_left(_F_public_page &c, const char *website)
{
	DIV d; d.h(100).w(100).dispflex().flowrow().print();
	DIV dd; dd.margins(0,5).print();
	if (website[0] != '\0') htmlprintf ("<a href=%s>",website);
	htmlprintf ("<img width=40 src=%s>\n",c.projecturl("/mini-photo.jpg","",true).c_str());
	if (website[0] != '\0') htmlout ("</a>\n");
	dd.end();
	dd.print();
	if (website[0] != '\0') htmlprintf ("<a href=%s>",website);
	htmlprintf ("<img width=100 src=%s>\n",c.projecturl("/photo.jpg","",true).c_str());
	if (website[0] != '\0') htmlout ("</a>\n");
}
static string dirserver="https://bolixo.org";
static string nodename;
static string nodeurl;

void util_setnodeurl(PARAM_STRING url)
{
	const char *pt = url.ptr;
	nodeurl = pt;
	if (strncasecmp(pt,"http://",7)==0){
		pt+=7;
	}else if (strncasecmp(pt,"https://",8)==0){
		pt+=8;
	}
	nodename = pt;
}
const char *util_getnodename()
{
	return nodename.c_str();
}
const char *util_getnodeurl()
{
	return nodeurl.c_str();
}
void util_setdirserver(PARAM_STRING dir)
{
	dirserver = dir.ptr;
}
const char *util_getdirserver()
{
	return dirserver.c_str();
}
static bool nonstrict = false;	// Mode for HTTPS connections
void util_setnonstrict(bool mode)
{
	nonstrict = mode;
}
bool util_getnonstrict()
{
	return nonstrict;
}
const int fontsize_std=25;
const int fontsize_mobile=50;
static void public_top(const char *user, const char *interest)
{
	bool mobile = tlmpweb_ismobile();
	htmlprintf ("<table border=0 width=100%%><tr><td align=center><span style='font-size:%dpx;'>%s@%s</span>\n"
		,mobile ? fontsize_mobile : fontsize_std
		,user,util_getnodename());
	if (!mobile){
		htmlprintf ("<td align=right><a href=%s><img src=/bolixo.png></a>\n",dirserver.c_str());
		htmlprintf ("<tr><td>%s\n",util_format_shortmsg(interest,100).c_str());
	}
	htmlout ("</table>\n");
}
<mod>
static void public_display_full (
	_F_public_page &c,
	CONNECT_INFO &con,
	PARAM_STRING user,
	const vector<FILEINFO> &files,
	PARAM_STRING website,
	PARAM_STRING interest,
	PARAM_STRING bg)	// Background-image paramater for the body
{
	glocal con;
	glocal c;
	glocal const char *user = user.ptr;
	glocal files;
	glocal const char *website = website.ptr;
	glocal const char *interest = interest.ptr;
	glocal bool mobile = tlmpweb_ismobile();
	if (w_file.isset()){
		BOB_TYPE content;
		if (glocal.c.readfile(w_file.c_str(),content)!=-1){
			DIV f; f.id(TAB_FORM).bg("#a0a0a0").paddings(5,5).vpaddings(5,5).vmargins(5,0).print();
			string hidden;
			form_gethidden(hidden);
			//htmlprintf ("<a style='font-size:1.5em;' href=%s?%s><img src=/back.png style='width:40px;'>page principale</a>\n",tlmpweb_curpage(),hidden.c_str());
			htmlprintf ("<a  href=%s?%s><span style='font-size:%dpx;'>%s</span></a>\n"
				,tlmpweb_curpage(),hidden.c_str()
				,glocal.mobile ? fontsize_mobile : fontsize_std, MSG_U(I_MAINPAGE,"Main page"));
			f.end();
			DIV d("webtable","pagebody"); d.w(100).autoscroll().print();
			glocal.c.sendhtml(content);
		}
	}else{
		unsigned vframe_topleft_width=20;
		unsigned vframe_top_height=12;
		glocal bool display_messages = true;
		glocal bool display_content = true;
		int leftwidth=30;
		if (glocal.mobile){
			vframe_topleft_width=0;
			vframe_top_height=6;
			if (w_showmsg.isset()){
				leftwidth=100;
				glocal.display_content = false;
			}else{
				leftwidth=0;
				glocal.display_messages = false;
			}
		}
		<call vframe4>(vframe_topleft_width,vframe_top_height,leftwidth);
		<f top>
			public_top(glocal.user,glocal.interest);
		</f>
		<f top_left>
			if (!glocal.mobile){
				DIV d; d.w(100).vmargins(0,20).print();
				public_top_left (glocal.c,glocal.website);
			}
		</f>
		<f left>
			if (glocal.display_messages){
				if (glocal.mobile){
					DIV f; f.id(TAB_FORM).bg("#a0a0a0").paddings(5,5).vpaddings(5,5).vmargins(5,0).print();
					string hidden;
					form_gethidden(hidden);
					htmlprintf ("<a href=%s?%s><span style='font-size:%dpx;'>%s </span><img src=/new.png height=50></a><br>\n"
						,tlmpweb_curpage(),hidden.c_str(),fontsize_mobile,MSG_U(I_CONTENT,"Content"));
				}
				FORM_HIDDEN showmsg(w_showmsg);
				public_messages(glocal.c,glocal.con,glocal.user);
			}
		</f>
		<f body>
			if (!glocal.display_content) return;
			DIV d("webtable","pubbody"); d.w(100).autoscroll().print();
			if (glocal.mobile){
				DIV f; f.id(TAB_FORM).bg("#a0a0a0").paddings(5,5).vpaddings(5,5).vmargins(5,0).print();
				string hidden;
				form_gethidden(hidden);
				htmlprintf ("<a href=%s?%s&showmsg=1><img src=/back.png height=50><span style='font-size:%dpx'> %s</span></a><br>\n"
					,tlmpweb_curpage(),hidden.c_str(),fontsize_mobile,MSG_U(I_MESSAGES,"Messages"));
			}
			webtable_request_scroll("pubbody");
			bool guide = false;
			bool index_html = false;
			bool index_txt = false;
			for (auto &f:glocal.files){
				if (f.name == "guide.tpl"){
					guide = true;
					break;
				}else if (f.name == "index.html"){
					index_html = true;
					break;
				}else if (f.name == "index.txt"){
					index_txt = true;
					break;
				}
			}
			if (guide){
				BOB_TYPE content;
				if (glocal.c.readfile("guide.tpl",content)!=-1){
					string tmp((const char *)content.getbuffer(),content.getsize());
					const char *txt = tmp.c_str();
					while (*txt != '\0'){
						txt = str_skip(txt);
						string name;
						while (*txt > ' ') name += *txt++;
						if (name.size() > 0){
							BOB_TYPE ct2;
							if (glocal.c.readfile(name,ct2)!=-1){
								glocal.c.sendhtml(ct2);
							}
						}
					}
				}
			}else if (index_html){
				BOB_TYPE content;
				if (glocal.c.readfile("index.html",content)!=-1){
					glocal.c.sendhtml(content);
				}
			}else if (index_txt){
				BOB_TYPE content;
				if (glocal.c.readfile("index.txt",content)!=-1){
					glocal.c.sendhtml(content);
				}
			}else{
				for (auto &f:glocal.files){
					if (file_is_image(f.file_type)){
						htmlprintf ("<img width=100%% src=%s>\n",glocal.c.projecturl(f.name,f.modified,true).c_str());
					}else if (file_is_video(f.file_type)){
					}else if (file_is_sound(f.file_type)){
					}else if (file_is_text(f.file_type)){
						BOB_TYPE content;
						if (glocal.c.readfile(f.name,content)!=-1){
							glocal.c.sendhtml(content);
						}
					}
				}
			}
		</f>
		</call>
	}
}
</mod>
/*
	Display only the short messages
*/
<mod>
static void public_display_base(
	_F_public_page &c,
	CONNECT_INFO &con,
	PARAM_STRING user,
	PARAM_STRING website,
	PARAM_STRING interest,
	PARAM_STRING bg_top,	// Backgroup-image for the who top
	PARAM_STRING bg_body)	// Background-image paramater for the body
{
	glocal con;
	glocal c;
	glocal const char *user = user.ptr;
	glocal const char *website = website.ptr;
	glocal const char *interest = interest.ptr;
	unsigned vframe_topleft_width=20;
	unsigned vframe_top_height=12;
	if (tlmpweb_ismobile()){
		vframe_topleft_width=0;
		vframe_top_height=6;
	}
	<call vframe3>(vframe_topleft_width,vframe_top_height,bg_top,bg_body);
	<f top>
		public_top(glocal.user,glocal.interest);
	</f>
	<f top_left>
		public_top_left (glocal.c,glocal.website);
	</f>
	<f body>
		DIV d("subtabs","base_messages"); d.w(tlmpweb_ismobile() ? 100: 50).marginauto().print();
		public_messages(glocal.c,glocal.con,glocal.user);
	</f>
	</call>
}
</mod>
// Display the public page of the user
<mod>
void public_display (
	_F_public_page &c,
	CONNECT_INFO &con,
	PARAM_STRING user,
	bool pubdir,
	PARAM_STRING website,
	PARAM_STRING interest)
{
	vector<FILEINFO> files;
	if (pubdir && c.listdir("/",0,20,files)==-1){
	}else{
		// Remove photo related files
		bool some_files = false;
		string bg_top = "linear-gradient(to right,lightgray,white,lightgray)";
		string bg_body(bg_top);
		for (auto f=files.begin(); f!=files.end(); ){
			if (f->name == "background.jpg"){
				bg_body = string_f("url(\"%s%s\")",util_getnodeurl(),c.projecturl(f->name,f->modified,true).c_str());
				f = files.erase(f);
			}else if (is_any_of(f->name,"photo.jpg","mini-photo.jpg")){
				f = files.erase(f);
			}else{
				if (bolixo_isfile(f->type)) some_files = true;
				f++;
			}
		}
		//tlmp_error ("bg_body=%s\n",bg_body.c_str());
		if (some_files){
			public_display_full (c,con,user,files,website,interest,bg_top);
		}else{
			public_display_base (c,con,user,website,interest,bg_top,bg_body);
		}
	}
}
</mod>
/*
	Read the secret used to communicate with internal service
*/
<mod>
string util_readsecret()
{
	glocal string ret;
	<call loadfile>("/etc/secret",true);
	<f oneline>
		glocal.ret = line;
		return 0;
	</f>
	</call>
	return glocal.ret;
}
</mod>
string toupper (PARAM_STRING ss)
{
	const char *s = ss.ptr;
	string ret;
	while (*s != '\0'){
		ret += toupper(*s);
		s++;
	}
	return ret;
}
/*
	Format the path of a mail
*/
string index_format_mail_fname(const MESSAGE_receive &m, PARAM_STRING username)
{
	string fname;
	if (m.role[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s/%s",m.manager,m.project,m.role,m.uuid);
	}else if (m.manager[0] != '\0'){
		fname = string_f ("/msg-projects/%s/%s/%s",m.manager,m.project,m.uuid);
	}else{
		fname = string_f ("/msgs/%s/inbox/%s",username.ptr,m.uuid);
	}	
	return fname;
}
<mod>
void util_delnotify(CONNECT_INFO &con_sess, PARAM_STRING id)
{
	auto f = userinfo.notifies.find(id.ptr);
	if (f != userinfo.notifies.end()){
		userinfo.notifies.erase(f);
		<call bo_sessiond_client_delnotify>(con_sess,w_session.c_str(),id);
		<f ok>
		</f>
		</call>
	}
}
</mod>
void util_delnotify(CONNECT_INFO &con_sess, PARAM_STRING prefix, PARAM_STRING id)
{
	string tmp = string_f("%s:%s",prefix.ptr,id.ptr);
	util_delnotify(con_sess,tmp);
}
<mod>
ENTRY_TYPE util_entrytype(CONNECT_INFO &con,PARAM_STRING path, FILEINFO &info)
{
	glocal info;
	<call bod_client_stat>(con,w_session.c_str(),path,"");
	<f ok>
		glocal.info = file;
	</f>
	</call>
	return info.type;
}
</mod>
ENTRY_TYPE util_entrytype(CONNECT_INFO &con,PARAM_STRING path)
{
	FILEINFO info;
	return util_entrytype(con,path,info);
}

void _F_sendfile_common::sethandle (PARAM_STRING _handle)
{
	handle = _handle.ptr;
}
void _F_sendfile_common::setresult (bool _success, PARAM_STRING msg)
{
	success = _success;
	if (!success) errmsg = msg.ptr;
}
void sendfile(_F_sendfile &c, PARAM_STRING filepath, PARAM_STRING localfile, bool &fail, string &errmsg)
{
	c.success = true;
	FILE *fin = fopen (localfile.ptr,"r");
	if (fin == NULL){
		htmlprintf ("Internal error reading temp file: :%s:<br>\n",localfile.ptr);
		fail = true;
	}else{
		char buf[40000];
		size_t nb = fread (buf,1,sizeof(buf),fin);
		bool more = (nb == sizeof(buf));
		c.start (filepath.ptr,BOB_TYPE(buf,nb,false),more);
		if (more && c.success){
			if (c.handle.empty()){
				tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
				htmlprintf ("Internal error, sendfile has not handle<br>\n");
			}else{
				while (more && c.success){
					nb = fread (buf,1,sizeof(buf),fin);
					more = (nb == sizeof(buf));
					c.rest (c.handle,BOB_TYPE(buf,nb,false),more);
				}
			}
		}
		fclose (fin);
	}
	if (!c.success){
		errmsg = c.errmsg;
		fail = true;
	}
}
void sendfile(_F_sendfile &c, PARAM_STRING filepath, PARAM_STRING localfile, bool &fail)
{
	string errmsg;
	sendfile (c,filepath,localfile,fail,errmsg);
	if (errmsg.size() > 0) htmlprintf ("sendfile failed: %s<br>\n",errmsg.c_str());
}
void sendfile_var(_F_sendfile_var &c, PARAM_STRING filepath, PARAM_STRING var_content, bool &fail, string &errmsg)
{
	const char *content = var_content.ptr;
	c.success = true;
	unsigned len = strlen(content);
	unsigned nb = len;
	bool more = false;
	if (nb > 40000){
		nb = 40000;
		more = true;
	}
	c.start (filepath.ptr,BOB_TYPE(content,nb,false),more);
	if (more && c.success){
		if (c.handle.empty()){
			tlmp_error ("sendfile: handle is empty for file %s\n",filepath.ptr);
			htmlprintf ("Internal error, sendfile has not handle<br>\n");
		}else{
			unsigned offset = nb;
			while (offset < len && c.success){
				nb = len - offset;
				more = false;
				if (nb > 40000){
					nb = 40000;
					more = true;
				}
				c.rest (c.handle,BOB_TYPE(content+offset,nb,false),more);
				offset += nb;
			}
		}
	}
	if (!c.success){
		errmsg = c.errmsg;
		fail = true;
	}
}
void sendfile_var(_F_sendfile_var &c, PARAM_STRING filepath, PARAM_STRING var_content, bool &fail)
{
	string errmsg;
	sendfile_var (c,filepath,var_content,fail,errmsg);
	if (errmsg.size() > 0) htmlprintf ("sendfile_var failed: %s<br>\n",errmsg.c_str());
}
/*
	Format an <img tag for a mini photo
*/
string util_mini_img(unsigned step, unsigned width, PARAM_STRING dirpath, PARAM_STRING filename, PARAM_STRING date)
{
	string tmp = util_flipspaces(date);
	const char *sep = "/";
	if (dirpath.ptr[0] == '\0') sep = "";
	return string_f ("<img style='border-radius: 50%%;' width=%u src=%s?webstep=%u&image=%s%s%s&mod=%s>"
		,width,tlmpweb_curpage(),step,dirpath.ptr,sep,filename.ptr,tmp.c_str());
}
/*
	Format an <img tag for an image
*/
string util_img(unsigned step, unsigned width, PARAM_STRING dirpath, PARAM_STRING filename, PARAM_STRING date)
{
	string tmp = util_flipspaces(date);
	const char *sep = "/";
	if (dirpath.ptr[0] == '\0') sep = "";
	return string_f ("<img width=%u style='image-orientation:from-image;object-fit:contain;' src=%s?webstep=%u&image=%s%s%s&mod=%s>"
		,width,tlmpweb_curpage(),step,dirpath.ptr,sep,filename.ptr,tmp.c_str());
}
string util_img(unsigned step, const char *style, PARAM_STRING filepath, PARAM_STRING date)
{
	string tmp = util_flipspaces(date);
	return string_f ("<img style='width:100%%;image-orientation:from-image;object-fit:contain;%s' src=%s?webstep=%u&image=%s&mod=%s>"
		,style,tlmpweb_curpage(),step,filepath.ptr,tmp.c_str());
}
static void index_format_large_text(const BOB_TYPE &content)
{
	string tmp = string((const char*)content.getbuffer(),content.getsize());
	tmp = util_format_shortmsg (tmp.c_str(),800);
	htmlwrite (tmp.c_str(),tmp.size());
}
<mod>
void util_popup (CONNECT_INFO &con, int step, const char *content, FILE_TYPE file_type, PARAM_STRING modified, PARAM_STRING from, PARAM_STRING filepath)
{
	glocal CONNECT_INFO *con = &con;
	const char *path = filepath.ptr;
	util_defstyles();
	tlmpweb_body("white",NULL);
	DIV d; d.w(100).h(100).dispflex().flowcol().print();
	DIV dd; dd.flexfixe().w(100).print();
	htmlprintf ("%s: %s<br>\n",MSG_R(I_FROM),from.ptr);
	htmlprintf ("%s: %s<br>\n",MSG_R(I_DATE),format_date(userinfo.dateformat,modified).c_str());
	dd.end();
	dd.flexfixe().w(100).h(95).vpaddings(5,5).bordertop(1,"black").print();	
	DIV ddd; ddd.marginauto().w(99).print();	
	if (content[0] != '\0'){
		htmlout (util_format_shortmsg (content,800));
	}else if (file_is_sound(file_type)){
		htmlprintf ("<audio controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"audio/%s\">\n"
			"</audio>"
			,tlmpweb_curpage(),step,path,tbftype[file_type]);
	}else if (file_is_video(file_type)){
		const char *extension = file_type == FILE_WEBM ? "webm" : "mp4";
		htmlprintf ("<video width=\"800\" height=\"600\" controls>\n"
			"<source src=\"%s?webstep=%u&image=%s\" type=\"video/%s\">\n"
			"Your browser does not support the video tag.\n"
			"</video>\n"
			,tlmpweb_curpage(),step,path,extension);
	}else if (file_is_image(file_type)){
		string img = util_img (step,"",path,modified);
		htmlout (img);
	}else if (file_is_text(file_type)){
		<call bod_client_readfile_bob>(con,w_session.c_str(),path,"",false);
		<f ok>
			if (!success){
				htmlprintf ("Can't read file: %s\n",msg);
			}else{
				index_format_large_text (content);
				glocal bool more = more;
				while (glocal.more){
					<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
					<f ok>
						index_format_large_text (content);
						glocal.more = more;
					</f>
					</call>
				}	
			}
		</f>
		</call>
	}
}
</mod>
void util_popup (CONNECT_INFO &con, const char *content, FILE_TYPE file_type, PARAM_STRING modified, PARAM_STRING from, PARAM_STRING filepath)
{
	util_popup (con,step_image,content,file_type,modified,from,filepath);
}
<mod>
void util_markview (CONNECT_INFO &con, PARAM_STRING fname)
{
	<call bod_client_markview>(con,w_session.c_str(),fname);
	<f ok>
	</f>
	</call>
}
</mod>
