#include <tlmpweb.h>
#include <tlmplib.h>
#include <trlitool.h>
#include "util.h"
#include "webtabs.h"
#include "../bolixo.m"
#include <algorithm>
#include <deque>

using namespace std;

static W_UNSIGNED w_webtab("webtab");
static W_SSTRING  w_webtab_add("webtab_add");

bool _F_webtabs::selected(PARAM_STRING id)
{
	return selected_id == id.ptr;
}
void _F_webtabs::setid (PARAM_STRING id)
{
	if (curtab->tab != id.ptr){
		curtab->tab = id.ptr;
		changed = true;
	}
}
void _F_webtabs::sethelp ()
{
	help_id = "help";
	help_title = MSG_U(I_HELP,"Help");
}
void _F_webtabs::sethelp (PARAM_STRING id, PARAM_STRING title)
{
	help_id = id.ptr;
	help_title = title.ptr;
}
void _F_webtabs::settitle (PARAM_STRING title)
{
	if (curtab->title != title.ptr){
		curtab->title = title.ptr;
		changed = true;
	}
}
void _F_webtabs::setstate (PARAM_STRING state)
{
	if (curtab->state != state.ptr){
		curtab->state = state.ptr;
		changed = true;
	}
}
const char *_F_webtabs::getstate () const
{
	return curtab->state.c_str();
}
void _F_webtabs::redotab ()
{
	redo = true;
}
void _F_webtabs::addtab (PARAM_STRING id, PARAM_STRING title_txt)
{
	const char *ptid = id.ptr;
	const char *pt = ptid;
	WEBTAB_TYPE type = WEBTAB_TYPE1;
	if (isdigit(pt[0]) && pt[1] == ':'){
		type = (WEBTAB_TYPE)(pt[0]-'1');
		pt+=2;
		ptid = pt;
	}
	string title;
	if (title_txt.ptr[0] == '\0'){
		title = ptid;
	}else{
		title = title_txt.ptr;
	}
	bool found = false;
	for (auto &t:*tabs){
		if (t.type == type){
			if (t.tab == ptid){
				found = true;
				t.selorder = ++maxsel;
				selected_id = t.tab;
				added_tab = type;
			}
		}
	}
	if (!found){
		added_tab = type;
		WEBTAB w(type,ptid,title,"");
		w.selorder = ++maxsel;
		tabs->push_back(w);
		selected_id = ptid;
		// hack, do not sort the first locked tabs.
		for (auto t=tabs->begin(); t!= tabs->end(); t++){
			if (!t->locked){
				sort (t,tabs->end());
				break;
			}
		}
	}
	changed = true;
}
static unsigned webtab_href_c (const char *title, int tab, int nox, const char *color, const char *color_in, bool close)
{
	unsigned ret = 0;
	string hidden;
	form_gethidden(hidden);
	const char *sep = hidden.size() > 0 ? "&" : "";
	string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,tab);
	if (nox != 0){
		string xref = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,nox);
		ret = draw_tab (0,color,color_in,close,title,true,href,xref);
	}else{
		ret = draw_tab (0,color,color_in,close,title,href);
	}
	return ret;
}
static unsigned webtab_aref_selected (const char *title, int tab, int nox)
{
	return webtab_href_c (title,tab,nox,"white","#F0F0F0",false);
}
static unsigned webtab_aref (const char *title, int tab, int nox)
{
	return webtab_href_c (title,tab,nox,"#EAEAEA","#E0E0E0",true);
}
void _F_webtabs::documents()
{
}
void _F_webtabs::doctype2(const char *id, const char *formid, const char *state, const char *title)
{
}
void _F_webtabs::doctype3(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::doctype4(const char *id, const char *formid, const char *state)
{
}
void _F_webtabs::init()
{
}
struct TABSEL {
	string id;
	unsigned no;	// Position in tabs
	TABSEL(){
		no = 0;
	}
};
<mod>
static void webtabs(_F_webtabs &c,
	const char *name,
	map<string,WEBTAB_CTRL> &alltabs,
	bool may_delete,
	unsigned size[5])
{
	bool is_mobile = tlmpweb_ismobile();
	WEBTAB_CTRL &ctrl = alltabs[name];
	c.tabs = &ctrl.tabs;
	glocal bool may_delete = may_delete;
	c.maxsel = -1;
	for (auto &t:ctrl.tabs){
		if (t.selorder > c.maxsel) c.maxsel = t.selorder;
	}
	c.selected_id = "";
	c.init();
	if (w_webtab_add.isset()){
		// We are either adding a new tab or selecting an existing one.
		// While we look if the tab already exist, we de-select the others
		// The variable may contains two selections separated by a comma. This is
		// used by the documentation to jump into the application and bring
		// with it the help screen
		vector<string> tb;
		str_splitline(w_webtab_add.c_str(),',',tb);
		for (auto &s:tb){
			const char *ptid = s.c_str();
			const char *title = ptid;
			string id;
			const char *pt = strchr(ptid,'~');
			if (pt != NULL){
				id = string(ptid,pt-ptid);
				ptid = id.c_str();
				title = pt+1;
			}
			c.addtab (ptid,title);
		}
	}
	if (may_delete && w_webtab > 0 && (w_webtab & 1)==0){
		// A click on the X to delete one tab
		unsigned delete_tab = (w_webtab-1) / 2;
		unsigned nbtab = c.tabs->size();
		if (delete_tab < nbtab){
			WEBTAB &tab = (*c.tabs)[delete_tab];
			WEBTAB_TYPE type = tab.type;
			const char *id = tab.tab.c_str();
			tlmpweb_deleteform(id);
			c.tabs->erase (c.tabs->begin()+delete_tab);
			w_webtab = 0;
			// Count the number of TABS remaining of this type
			// Ajust the offset to have one visible
			unsigned count=0;
			for (auto &t:*c.tabs){
				if (t.type == type) count++;
			}
			unsigned &offset = ctrl.offsets[type];
			if (offset > 0 && count <= offset) offset--;
			c.changed = true;
		}
	}
	// Manage the left and right arrows
	if (w_webtab >= 1000 && w_webtab < 1004){
		unsigned &v = ctrl.offsets[w_webtab-1000];
		if (v > 0) v--;
		c.changed = true;
	}else if (w_webtab >= 2000 && w_webtab < 2004){
		ctrl.offsets[w_webtab-2000]++;
		c.changed = true;
	}
	glocal WEBTAB_CTRL *ctrl = &ctrl;
	glocal vector<WEBTAB> *tabs = c.tabs;
	glocal bool changed = false;
	// w_webtab let the user select the active tab, in any type
	{
		unsigned no = 1;
		struct MAXTAB{
			unsigned no;
			int selorder;
			MAXTAB(){
				no = 0;
				selorder = -1;
			}
		} maxtabs[4];
			
		for (auto &t:ctrl.tabs){
			MAXTAB &maxt = maxtabs[t.type];
			if (t.selorder > maxt.selorder){
				maxt.no = no;
				maxt.selorder = t.selorder;
			}
			no += 2;
		}
		no = 1;	
		for (auto &t:ctrl.tabs){
			if (w_webtab == no){
				// Check if this is already the active tab
				MAXTAB &maxt = maxtabs[t.type];
				if (t.selorder != maxt.selorder || no != maxt.no){
					t.selorder = ++c.maxsel;
					c.selected_id = t.tab;
					c.changed = true;
				}
				break;
			}
			no+=2;
		}
	}
	bool draw_ok = true;
	if (!tlmpweb_get_output_state()){
		// PATCH
		// This is a trick to allow the webtable::click system to work
		// inside a vframe2h. We assume this is only used on the right side for now.
		draw_ok = false;
	}

	// We draw the tabs content before drawing the tabs because the tabs may change
	// the content of the tab
	vector<GRABLINE> lines[4];
	c.added_tab = -1;
	/*
		This is a little magic thing here... The typeorder variable below.

		(little note. When the webtabs system was designed, we tought that 4 areas could be needed. It never happened.
		 We use 2 or 3 area:
		 Area 0 generally holds a list (groups, projects).
		 Area 1 holds tabs of the viewed items in area 0.
		 Area 2 holds tabs of viewed document in area 1.
		 Area 3, so far has not been used.
		)

		Normally, the tab area are processed in reverse order. The idea is that some event in one area (say the rightmost)
		might influence the presentation of the documents on the left. For example, in one project tab, you create a
		document. After entering some content, you hit save. Now 2 things happen. The document is created in the proper
		folder and the tab name changes.

		Since the folder content will be printed after the document event happen (save), it will properly show the new document name.
		This is what the typeorder does.

		Now, what about the dropdown menus. Without the reordering below for dropdown (webtable_is_dropdown()),
		something spectacular goes on.
		Here is an example. Go in the public project and create a document and save it. Now while the document is
		displayed, use the right click to bring the dropdown menu. Select the "preview help". Now click back on your
		document. Oops!!! The document is empty. It is still there in the database, but on the screen, it is empty.
		Close the tab and click on the document in the folder and it will appear normally.

		What is going on ?

		Here is how documents/forms are preserved while you navigate in bolixo. Each time you click on something, all
		forms are submitted silently (see the formsubmit javascript function). Once received, they are stored in the
		temp database uinsg each active form id and the sessionid.

		After every action, (once all HTML has been sent) the list of active forms are stored in the session manager. This list
		is used for the next "formsubmit".

		During the HTML production (server side), each visited form register itself as an active form. So here is the sequence
		with the dropdown example below with order 3,2,1,0.

		1-formsubmit is executed on the browser. It sends all active form, including the content of the document.
		2-Since the document is visible in the right section, it is displayed first (the HTML is produced) and
		  it register itself as one active form.
		3-Later the dropdown action is perform. It request to create a new tab in the right section, hiding
		  the tab of the document. The HTML associated with the document form is simply discared.
		4-The new page appears with the help tab.
		5-You click back on the document. formsubmit is executed and nothing is sent back from the browser
		  about this document, since it is not visible (the browser has no clue it even exists).
		6-The forms are received on the server side and saved to the temp database. At step 2, the document
		  has registered itself as one active form, so the system save the content in the database. Empty
		  content.

		So by changing the evaluation order when a dropdown is used, we evaluate the dropdown before the
		right section is evaluated. so the document form is never registered as active.
	*/
	deque<int> typeorder;
	if (webtable_is_dropdown()){
		typeorder={0,1,2,3};
	}else{
		typeorder={3,2,1,0};
	}
	while (typeorder.size() > 0){
		int type = typeorder.front();
		typeorder.pop_front();	
		WEBTAB *ptt = NULL;
		{
			int maxorder = -1;
			unsigned no = 1;
			for (auto &t:*c.tabs){
				if (t.type == type){
					if (t.selorder > maxorder){
						ptt = &t;
						maxorder = t.selorder;
					}
				}
				no+=2;
			}
		}
		if (ptt != NULL){
			lines[type].clear();
			if (draw_ok) tlmpweb_pushgrab(lines[type]);
			while (1){
				unsigned no=1;
				for (auto &t:*c.tabs){
					if (&t == ptt) w_webtab = no;
					no += 2;
				}
				//FORM_HIDDEN t(w_webtab);
				const char *id = ptt->tab.c_str();
				const char *formid = id;
				const char *end = strchr(id,WEBTAB_MARK);
				string tmp;
				if (end != NULL){
					tmp = string(id,end-id);
					id = tmp.c_str();
				}
				c.curtab = ptt;
				const char *state = ptt->state.c_str();
				if (type == WEBTAB_TYPE1){
					c.docmain(id,formid,state);
				}else if (type == WEBTAB_TYPE2){
					c.doctype2(id,formid,state,ptt->title.c_str());
				}else if (type == WEBTAB_TYPE3){
					c.doctype3(id,formid,state);
				}else if (type == WEBTAB_TYPE4){
					c.doctype4(id,formid,state);
				}else{
					c.docmain(id,id,state);
				}
				if (!draw_ok) break;
				if (!c.redo) break;
				c.redo = false;
				lines[type].clear();
			}
			if (draw_ok) tlmpweb_popgrab();
		}
		if (c.added_tab != -1){
			// We have to replay the tab
			typeorder.push_back(c.added_tab);
			c.added_tab = -1;
		} 
	}
	if (draw_ok){
		DIV sc; sc.w(100).dispflex().flowrow().align("stetch").bg("white").print();
		vector<GRABLINE> docs;
		tlmpweb_pushgrab(docs);
		c.documents();
		tlmpweb_popgrab();
		const unsigned margin = 5;
		static const char *mcolor = "white";	//"#F3F3F3";
		if (docs.size() > 0){
			DIV d("tabs","tabdoc"); d.flexfixe().bg(mcolor).align("stretch").w(size[0]).h(60).margins(margin,margin).print();
			htmlout(docs);
		}
		glocal const char *help_id = c.help_id.c_str();
		glocal const char *help_title = c.help_title.c_str();
		bool putborder = true;	// On each side of the first tab only
		for (unsigned type=0; type <4; type++){
			unsigned sz = size[type+1];
			if (sz != 0){
				glocal unsigned tab_width = 0;
				DIV dc; dc.flexfixe().w(sz).align("stretch").bg("white").print();
				WEBID tabname(string_f("%s-tab%u",name,type));
				unsigned tab_height=0;
				tlmpweb_gettablegeometry(tabname,tab_height,glocal.tab_width);
				if (glocal.tab_width == 0) glocal.tab_width = 2000;	// No need to correct TAB selection since
											// we do not know the exact TAB width
				DIV cc("tabs",tabname.c_str()); cc.dispflex().flowcol().bg(mcolor);
				if (putborder){
					cc.borderleft(1,"black");
					cc.borderright(1,"black");
					putborder = false;
				}
				cc.print();
				// Set an internal margin, inside borders
				DIV m; m.margins(margin,margin).bg("white").print();
				DIV top("","tabs"); top.align("flex-start").flexfixe().print();
				glocal unsigned type = type;
				glocal WEBTAB *ptsel = NULL;
				{
					int maxorder = -1;
					for (auto &t:*c.tabs){
						if (t.type == type){
							if (t.selorder > maxorder){
								glocal.ptsel = &t;
								maxorder = t.selorder;
							}
						}
					}
				}
				<call button_row>(0,"white");
				<f draw>
					{
						unsigned skip = glocal.ctrl->offsets[glocal.type];
						// Check if the current tab is hidden to the left (< skip)
						unsigned curtab = 0;
						for (auto &t:*glocal.tabs){
							if (t.type == glocal.type){
								if (&t == glocal.ptsel){
									break;
								}
								curtab++;
							}
						}
						if (curtab < skip){
							glocal.ctrl->offsets[glocal.type] = curtab;
							glocal.changed = true;
						}
					}
					string hidden;
					form_gethidden(hidden);
					const char *sep = hidden.size() > 0 ? "&" : "";
					while (1){
						// We do a loop until the "current" tab is fully visible
						unsigned no = 1;
						unsigned skip = glocal.ctrl->offsets[glocal.type];
						bool redo = false;
						{
							string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,1000+glocal.type);
							drawleftarrow(href,skip>0);
						}
						unsigned nbprinted = 0;
						unsigned width = 50;	// Reserve space for left and right arrows
						for (auto &t:*glocal.tabs){
							if (t.type == glocal.type){
								if (skip > 0){
									skip--;
								}else{
									nbprinted++;
									split();
									const char *name = t.title.c_str();
									if (name[0] == '\0'){
										name = t.tab.c_str();
									}
									if (isdigit(name[0]) && name[1] == ':') name += 2;
									int nodel = 0;
									if (!t.locked && glocal.may_delete){
										nodel = no+1;
									}
									if (&t == glocal.ptsel){
										width += webtab_aref_selected (name,no,nodel);
										if (width > glocal.tab_width){
											glocal.ctrl->offsets[glocal.type]++;
											glocal.changed = true;
											redo = true;
											break;
										}
									}else{
										width += webtab_aref (name,no,nodel);
									}
								}
							}
							no += 2;
						}
						{
							string href = string_f ("%s?%s%swebtab=%d",tlmpweb_curpage(),hidden.c_str(),sep,2000+glocal.type);
							drawrightarrow(href,width>glocal.tab_width);
						}
						if (glocal.tab_width == 0){
							// tab unknown
							drawendline(2000);
						}else if (width < glocal.tab_width){
							drawendline(glocal.tab_width-width);
						}
						if (!redo) break;
						reset();
					}
				</f>
				<f draw_right>
					if (glocal.help_id[0] != '\0'){
						split();
						url_self (string_f("webtab_add=2:%s~%s",glocal.help_id,glocal.help_title),"?");
						htmlout ("&nbsp;");
					}
				</f>
				</call>
				top.end();
				DIV mi; mi.bg("white").align("flex-start").flexgrow().print();
				htmlout (lines[type]);
				glocal.help_id = "";
			}
		}
	}
	if (c.changed || glocal.changed) tlmpweb_savetabs(alltabs);
}
</mod>
void webtabs(_F_webtabs &c,
	const char *name,
	map<string,WEBTAB_CTRL> &tabs,
	unsigned size[5])
{
	webtabs (c,name,tabs,true,size);
}
void webtabs(_F_webtabs &c,
	const char *name,
	const vector<string> &starttabs,
	map<string,WEBTAB_CTRL> &alltabs,
	unsigned size[5])
{
	WEBTAB_CTRL &ctrl = alltabs[name];
	vector<WEBTAB> &tabs = ctrl.tabs;
	for (auto &s:starttabs){
		bool found = false;
		string tmp;
		const char *tab = s.c_str();
		const char *title = "";
		const char *pt = strchr(tab,'~');
		if (pt != NULL){
			title = pt + 1;
			tmp = string(tab,pt-tab);
			tab = tmp.c_str();
		}
		for (auto &w:tabs){
			if (strcmp(tab,w.tab.c_str())==0){
				w.title = title;
				w.locked = true;
				found = true;
				break;
			}
		}
		if (!found){
			WEBTAB w(WEBTAB_TYPE1,tab,title,"");
			w.locked = true;
			tabs.push_back(w);
		}
	}
	webtabs (c,name,alltabs,true,size);
}

