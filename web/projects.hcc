/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <tlmpweb.h>
#include <tlmplib.h>
#include <trlitool.h>
#include <string>
#include <algorithm>
#include <set>
#include <functional>
#define DEFINE_USERINFO
#include "util.h"
#include "../bolixo.h"
#include "../bolixo.m"
#include "webtabs.h"
#include <tlmpdoc.h>
#include <tlmp/translat.h>
#include "document.h"
#undef INSTRUMENT
#include "../instrument.h"
#include "../proto/bod_client.protoch"
#include "w_var.h"
#include "steps.h"
#include "../helper.h"
#include "../documentd_req.h"

void index_doc (DOCUMENT_POINTER &pt, DOC_ID &jump, bool index);
void index_doc (DOCUMENT_POINTER &pt, DOC_ID &jump);
void index_paste(CONNECT_INFO &con, PARAM_STRING path);
void index_setpastemenu (_F_webtable *c, PARAM_STRING path);
void index_setcopyitem(CONNECT_INFO &con_sess, PARAM_STRING path, PARAM_STRING modified, PARAM_STRING name);

static W_UNSIGNED w_focus("focus");	// Used by callrefresh to set the focus
static W_SSTRING w_dialog("dialog");	// Used to request a dialog for a document or game
static W_SSTRING w_field1("field1");
static W_SSTRING w_field2("field2");
static W_SSTRING w_field3("field3");
static W_SSTRING w_field4("field4");
static W_SSTRING w_field5("field5");
static W_SSTRING w_field6("field6");
static W_UNSIGNED w_check1("check1");
static W_UNSIGNED w_check2("check2");

struct DIALOG_FIELD{
	string name;
	string value;
	DIALOG_FIELD(PARAM_STRING _name, PARAM_STRING _value)
		:name(_name.ptr), value(_value.ptr){}
};

<mod>
static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, string &text)
{
	glocal CONNECT_INFO *con = &con;
	glocal string *text = &text;
	glocal int ret = 0;
	text.clear();
	<call bod_client_readfile_bob>(con,w_session.c_str(),filename,"",false);
	<f ok>
		if (!success){
			htmlprintf ("Can't read file: %s\n",msg);
			glocal.ret = -1;
		}else{
			(*glocal.text) = string((const char*)content.getbuffer(),content.getsize());
			glocal bool more = more;
			while (glocal.more && glocal.ret != -1){
				<call bod_client_readmore>(*glocal.con,w_session.c_str(),handle);
				<f ok>
					if (!success){
						glocal.ret = -1;
						htmlprintf ("Can't read file: %s\n",msg);
					}else{
						(*glocal.text) += string((const char*)content.getbuffer(),content.getsize());
					}
					glocal.more = more;
				</f>
				</call>
			}	
		}
	</f>
	</call>
	return glocal.ret;
}
</mod>

static int index_loadfile(CONNECT_INFO &con, PARAM_STRING filename, W_SSTRING &text)
{
	string tmp;
	int ret = index_loadfile(con,filename,tmp);
	text = tmp;
	return ret;
}

<mod>
/*
	Check if a name was supplied for a new file. Assign one if none was provided.
	Check if the file already exists.

	If the file already exists and was supplied by the user, return "" and msg contains a message.
	The function iterate with a generated name until it finds one that does not exist.
*/
static string projects_autoname(CONNECT_INFO &con, PARAM_STRING dir, PARAM_STRING filename, const char *extension, string &name, string &msg)
{
	string ret;
	unsigned count=0;
	while (true){
		string tmp;
		const char *fname =  filename.ptr;
		if (fname[0] == '\0'){
			if (count == 0){
				tmp = string_f("%s.%s",MSG_U(I_NONAME,"noname"),extension);
			}else{
				tmp = string_f("%s-%u.%s",MSG_R(I_NONAME),count,extension);
			}
			fname = tmp.c_str();
		}
		ret = string_f("%s/%s",dir.ptr,fname);
		glocal bool found = false;
		<call bod_client_stat>(con,w_session.c_str(),ret,"");
		<f ok>
			if (success){
				glocal.found = true;
			}
		</f>
		</call>
		if (glocal.found){
			if (filename.ptr[0] != '\0'){
				msg = MSG_U(E_FILEEXIST,"File already exist"); 
				ret = "";
				break;
			}else{
				count++;
			}
		}else{
			name = fname;
			break;
		}
	}
	return ret;
}
</mod>
/*
	Send a private message to a player, inviting him to a game
*/
<mod>
static int projects_sendinvite(
	CONNECT_INFO &con,
	const char *session,
	const char *path,
	const char *gametype,
	const char *player,
	const char *otherplayer,
	const char *message,
	string &msg)
{
	glocal int ret = 0;
	glocal msg;
	string content;
	const char *docpath = path;
	const char *pt;
	if (is_start_any_of(path,pt,"/projects/")){
		docpath = pt;
	}
	if (userinfo.name == otherplayer){
		content = string_f(MSG_U(INVITEHIMSELF,"%s is inviting you %s against himself\nThe game is here: _DOC=%s\n")
			,userinfo.name.c_str(),gametype,docpath);
	}else{
		content = string_f(MSG_U(I_INVITEOTHER,"%s is inviting you %s against %s\nThe game is here: _DOC=%s\n")
			,userinfo.name.c_str(),gametype,otherplayer,docpath);
	}
	if (message[0] != '\0'){
		content += "\n";
		content += message;
	}
	BOB_TYPE bob;
	bob.setbuffer (content.c_str(),content.size(),false);
	vector<string> recipients;
	recipients.push_back(player);
	<call bod_client_sendtalk>(con,session,"",recipients,"","",bob,false,"","","");
	<f ok>
		if (!success){
			glocal.msg = msg;
			glocal.ret = -1;
		}
	</f>
	</call>
	return glocal.ret;

}
</mod>
static void projects_documents(
	CONNECT_INFO &con,
	CONNECT_INFO &con_sess,
	const char *formid,
	const char *id,
	unsigned tab_width,
	unsigned tab_height,
	_F_webtabs *webtabs,
	unsigned webstep,
	bool focus,
	const char *extraargs,
	const char *uicontext);

static void projects_popup_top()
{
	DIV a("popup","popup-id"); a.print();
	DIV d("popup-content","popup"); d.print();
	DIV dd; dd.dispflex().flowrow().print();
	DIV left; left.flexfixe().margins(10,10).vmargins(5,0).print();
	a.donotend();
	d.donotend();
	dd.donotend();
	left.donotend();
}
static void projects_popup_bottom()
{
	/- </div>
	tlmpweb_dialog_x();
	/- </div></div></div>
	tlmpweb_position_popup();
}
/*
	Return the project path of this document
*/
static string projects_getdir (PARAM_STRING path)
{
	string ret;
	auto tb = str_splitline (path.ptr,'/');
	if (tb.size() >= 4){
		ret = string_f("/%s/%s/%s",tb[1].c_str(),tb[2].c_str(),tb[3].c_str());
	}
	return ret;
}
/*
	Dialogs for documents and games
*/
<mod>
static void projects_dialogs (
	CONNECT_INFO &con,
	const char *dialog_name,
	const vector<DIALOG_FIELD> &fields,
	const char *session,
	PARAM_STRING path,
	unsigned docnum,
	const DOC_UI_SPECS &sp)
{
	glocal fields;
	glocal con;
	glocal session;
	glocal sp;
	glocal const char *path = path.ptr;
	glocal dialog_name;
	glocal vector<VARVAL> steps;
	FORM_HIDDEN h1(w_dialog);
	FORM_HIDDEN h2(w_mousex);
	FORM_HIDDEN h3(w_mousey);
	glocal string error;
	glocal unsigned maxskill=0;
	for (auto &f:fields){
		if (f.name == "maxskill"){
			glocal.maxskill=atoi(f.value.c_str());
		}
	}
	<call form>(dialog_name);
	<f top>
		projects_popup_top();
	</f>
	<f bottom>
		projects_popup_bottom();
	</f>
	<f load>
		if (strcmp(glocal.dialog_name,DIALOG_CHESS_CONFIG)==0){
			for (auto &f:glocal.fields){
				if (f.name == "player1"){
					if (f.value == CHESS_ROBOT){
						w_field1 = MSG_R(I_COMPUTER);
					}else{
						w_field1 = f.value;
					}
				}else if (f.name == "player2"){
					if (f.value == CHESS_ROBOT){
						w_field2 = MSG_R(I_COMPUTER);
					}else{
						w_field2 = f.value;
					}
				}else if (f.name == "name"){
					w_field4 = f.value;
				}else if (f.name == "timer"){
					w_field3 = f.value;
				}else if (f.name == "skill"){
					w_field6 = f.value;
				}
			}
		}else if (strcmp(glocal.dialog_name,DIALOG_IMBED)==0){
			for (auto &f:glocal.fields){
				if (f.name == "docid"){
					w_field1 = f.value;
				}else if (f.name == "region"){
					w_field2 = f.value;
				}
			}
		}
	</f>
	<f setup>
		if (strcmp(glocal.dialog_name,DIALOG_CHESS_CONFIG)==0){
			glocal vector<string> members;
			const char *owner = "";
			const char *listname = "";
			vector<string> tb;
			int n = str_splitline (glocal.path,'/',tb);
			if (n >= 4){
				owner = tb[2].c_str();
				listname = tb[3].c_str();
			}
			<call bod_client_list_members>(glocal.con,glocal.session,owner,listname);
			<f ok>
				for (auto m:members) glocal.members.push_back(m);
			</f>
			</call>
			sort (glocal.members.begin(),glocal.members.end());
			htmlprintf ("<center>%s</center>\n",MSG_U(T_CHESSCONFIG,"Chess configuration"));
			/- <p>
			/- <table border=0>
			htmlprintf ("<tr><td>%s<td>\n",MSG_U(F_GAMENAME,"Game name"));
			field_string(w_field4,"");
			/- <tr><td>&nbsp;
			htmlprintf ("<tr><td>%s<td>",MSG_R(I_WHITE));
			field_list (w_field1,"");
			field_list_item(MSG_U(I_COMPUTER,"'computer'"));
			for (auto &m:glocal.members) field_list_item(m.c_str());
			field_list_end();
			/-<tr><td><td>
			field_checkbox(w_check1,"");
			/-#I_INVITE Send invite
			/- <tr><td>&nbsp;
			htmlprintf ("<tr><td>%s<td>",MSG_R(I_BLACK));
			field_list (w_field2,"");
			field_list_item(MSG_R(I_COMPUTER));
			for (auto &m:glocal.members) field_list_item(m.c_str());
			field_list_end();
			/- <tr><td><td>
			field_checkbox(w_check2,"");
			htmlout(MSG_R(I_INVITE));
			/- <tr><td>&nbsp;
			htmlprintf ("<tr><td>%s<td>",MSG_U(I_INVITEMSG,"Message"));
			field_textarea(w_field5,5,tlmpweb_ismobile() ? 30 : 50,"");
			#if 0
				htmlprintf ("<tr><td>%s<td>",MSG_U(I_TIMER,"Timer"));
				field_string(w_field3,"");
			#endif
			htmlprintf ("<tr><td>%s<td>",MSG_U(I_COMPUTERSKILL,"Computer"));
			field_list(w_field6,"");
			static TRANS_NOTLOAD *tbskill[]={
				P_MSG_U(I_SKILLMINIMAL,"Minimal skill"),
				P_MSG_U(I_SKILLLOW,"Low skill"),
				P_MSG_U(I_SKILLMEDIUM,"Medium skill"),
				P_MSG_U(I_SKILLSTRONG,"Strong skill"),
				P_MSG_U(I_SKILLVSTRONG,"Very strong skill")
			};
			for (unsigned i=0; i<glocal.maxskill; i++){
				string id = string_f("%u",i);
				field_list_item(id.c_str(),tbskill[i]->get());
			}
			field_list_end();
			/- </table>
			/- <p>
			if (glocal.error.size() > 0){
				htmlprintf ("<span style=color:red; >%s</span><br>\n",glocal.error.c_str());
			}else{
				/- &nbsp;<br>
			}
			button_submit();
		}else if (strcmp(glocal.dialog_name,DIALOG_CHESS_NEWGAME)==0){
			/- <center>
			/-#T_ATTENTION Attention
			/- </center><br>
			<?#I_STARTNEWGAME You are starting a new game.
			<br>
			Are you sure ?
			<br>
			?>
			/- <br><center>
			button_submit(MSG_U(B_YES,"Yes"));	
			/- </center>
			/- <br>
		}else if (strcmp(glocal.dialog_name,DIALOG_WHITEBOARD_NEW)==0){
			/- <center>
			htmlout(MSG_R(T_ATTENTION));
			/- </center><br>
			<?#I_STARTNEWDOC You are restarting the document.
			<br>
			Are you sure ?
			<p>
			?>
			/- <table border=0><tr><td>
			/-#I_ERASEALLBOARDS  Erase all boards
			/- <td>
			field_radio (w_field1,"all",false,"");
			/- <tr><td>
			/-#I_ERASECURPAGE  Erase only the current board
			/- <td>
			field_radio (w_field1,"page",true,"");
			/- </table>
			/- <br><center>
			button_submit(MSG_R(B_YES));	
			/- </center>
			/- <br>
		}else if (strcmp(glocal.dialog_name,DIALOG_CALC_NEW)==0){
			/- <center>
			htmlout(MSG_R(T_ATTENTION));
			/- </center><br>
			htmlout (MSG_R(I_STARTNEWDOC));
			/- <br><center>
			button_submit(MSG_R(B_YES));	
			/- </center>
			/- <br>
		}else if (strcmp(glocal.dialog_name,DIALOG_CALC_INSCOLLINE)==0){
			/- <center>
			htmlout(MSG_U(T_INSERTCELLS,"Insert/Delete cells"));
			/- </center><br>
			/- <table border=0>
			/- <tr><td>
			field_radio (w_field1,"inslines",true,"");
			/- <td>
			htmlout (MSG_U(I_INSERTLINES,"Insert line"));
			/- <tr><td>
			field_radio (w_field1,"inscolumns",false,"");
			/- <td>
			htmlout (MSG_U(I_INSERTCOLUMNS,"Insert column"));
			/- <tr><td>
			field_radio (w_field1,"dellines",false,"");
			/- <td>
			htmlout (MSG_U(I_DELETELINES,"Delete line"));
			/- <tr><td>
			field_radio (w_field1,"delcolumns",false,"");
			/- <td>
			htmlout (MSG_U(I_DELETECOLUMNS,"Delete column"));
			#if 0
			/- <tr><td>
			field_checkbox (w_check1,"");
			/- <td> apply to single column/line
			#endif
			/- </table>
			/- <br><center>
			button_submit();	
			/- </center>
			/- <br>
		}else if (strcmp(glocal.dialog_name,DIALOG_IMBED)==0){
			/- <table border=0>
			/- <tr><td>
			/- document/game
			/- <td>
			field_string (w_field1,"");
			/- <tr><td>
			/- Region
			/- <td>
			field_string (w_field2,"");
			/- </table>
			if (glocal.error.size() > 0){
				htmlprintf ("<span style=color:red; >%s</span><br>\n",glocal.error.c_str());
			}else{
				/- &nbsp;<br>
			}
			button_submit();
		}
	</f>
	<f validate>
		glocal bool ret = true;
		if (strcmp(glocal.dialog_name,DIALOG_CHESS_CONFIG)==0){
			if (strcmp(w_field1.c_str(),w_field2.c_str())==0){
				glocal.error = MSG_U(E_SAMENAME,"The two players can't be the same");
			}else if (strcmp(w_field1.c_str(),MSG_R(I_COMPUTER))==0 && w_check1){
				glocal.error = MSG_U(E_INVITECOMPUTER,"You can't send an invite to the computer");
			}else if (strcmp(w_field2.c_str(),MSG_R(I_COMPUTER))==0 && w_check2){
				glocal.error = MSG_R(E_INVITECOMPUTER);
			}else if (strcmp(userinfo.name.c_str(),w_field1.c_str())==0 && w_check1){
				glocal.error = MSG_U(E_INVITEYOURSELF,"You can't invite yourself");
			}else if (strcmp(userinfo.name.c_str(),w_field2.c_str())==0 && w_check2){
				glocal.error = MSG_R(E_INVITEYOURSELF);
			}
		}else if (strcmp(glocal.dialog_name,DIALOG_IMBED)==0){
			string subdoc = string_f("%s/%s",projects_getdir(glocal.path).c_str(),w_field1.c_str());
			<call bod_client_stat> (glocal.con,glocal.session,subdoc,"");
			<f ok>
				if (!success){
					glocal.error = string_f(MSG_U(E_DOCNOTEXIST,"document %s does not exist"),w_field1.c_str());
				}else if (!file_is_doc(file.file_type)){
					glocal.error = string_f(MSG_U(E_NOTADOCUMENT,"File %s is not a document or game. Can't link/embed"),w_field1.c_str());
				}
			</f>
			</call>
		}
		return glocal.error.size() > 0 ? false : true;
	</f>
	<f process>
		VARVAL var;
		if (strcmp(glocal.dialog_name,DIALOG_CHESS_CONFIG)==0){
			var.var = "config";
			const char *player1 = w_field1.c_str();
			if (strcmp(player1,MSG_R(I_COMPUTER))==0) player1 = CHESS_ROBOT;
			const char *player2 = w_field2.c_str();
			if (strcmp(player2,MSG_R(I_COMPUTER))==0) player2 = CHESS_ROBOT;
			var.val = string_f("player1:%s\n",player1);
			var.val += string_f("player2:%s\n",player2);
			var.val += string_f("name:%s\n",w_field4.c_str());
			var.val += string_f("timer:%s\n",w_field3.c_str());
			var.val += string_f("skill:%s\n",w_field6.c_str());
			if (w_check1
				&& projects_sendinvite(glocal.con,glocal.session,glocal.path,MSG_U(I_PLAYCHESSGAME,"to play a chess game")
					,w_field1.c_str(),w_field2.c_str(),w_field5.c_str(),glocal.error)==-1){
				fail = true;
			}else if (w_check2
				&& projects_sendinvite(glocal.con,glocal.session,glocal.path,MSG_R(I_PLAYCHESSGAME)
					,w_field2.c_str(),w_field1.c_str(),w_field5.c_str(),glocal.error)==-1){
				fail = true;
			}
		}else if (is_any_of(glocal.dialog_name,DIALOG_CHESS_NEWGAME,DIALOG_CALC_NEW)){
			var.var = "resetgame";
		}else if (is_any_of(glocal.dialog_name,DIALOG_CHESS_NEWGAME,DIALOG_CALC_INSCOLLINE)){
			var.var = "inscolline";
			var.val = w_field1.c_str();
		}else if (strcmp(glocal.dialog_name,DIALOG_WHITEBOARD_NEW)==0){
			var.var = "resetgame";
			var.val = strcmp(w_field1.c_str(),"all")==0 ? "0" : "1";
		}else if (strcmp(glocal.dialog_name,DIALOG_IMBED)==0){
			var.var = "imbed";
			var.val += string_f("docid:%s\n",w_field1.c_str());
			var.val += string_f("region:%s\n",w_field2.c_str());
			// Send a test request (does nothing) to make sure the document is loaded in documentd
			string subdoc = string_f("%s/%s",projects_getdir(glocal.path).c_str(),w_field1.c_str());
			vector<VARVAL> steps;
			VARVAL test;
			test.var = "test";
			steps.push_back(test);
			<call bod_client_playstep>(glocal.con,glocal.session,"",subdoc,0,steps,glocal.sp);
			<f ok>
				if (!success) tlmp_error ("documentd imbed playstep error: %s",msg);
			</f>
			</call>
		}
		glocal.steps.emplace_back(var);
	</f>
	</call>
	if (glocal.steps.size() > 0){
		<call bod_client_playstep>(glocal.con,session,"",path,docnum,glocal.steps,sp);
		<f ok>
			for (auto &r:res){
				if (strcmp(r.var,VAR_CONTENT)==0){
					htmlout (r.val);
				}
			}
		</f>
		</call>
	}
}
</mod>
<mod>
void projects(CONNECT_INFO &con, CONNECT_INFO &con_sess, vector<DOCUMENT_POINTER> &docpointers)
{
	glocal con;
	glocal con_sess;
	glocal docpointers;
	static unsigned size[5]={15,35,50,0,0};
	<call webtabs>("Projects",tabs,size);
	<f documents>
		sethelp();
		// List projects
		static WEBID id("tab:projects");
		<call webtable>(id,currents[id.c_str()]);
		<f load>
			sethead (MSG_U(H_PROJECTS,"Owner\tProject"));
			<call bod_client_list_inboxes>(glocal.con,w_session.c_str(),"",false,true);
			<f ok>
				unsigned rownum=0;
				for (auto &inb:inboxes){
					string id = string_f("%s/%s",inb.manager,inb.project);
					const char *style = "white";
					if (glocal.webtabs.selected(id)) glocal.webtable.setcurrent(rownum);
					string add = string_f("webtab_add=1:%s/%s",inb.manager,inb.project);
					glocal.webtable.setclickopt (true,"",add);
					glocal.webtable.setrow (style,rownum,"%s\t%s",inb.manager,inb.project);
					rownum++;
				}
			</f>
			</call>
		</f>
		</call>
	</f>
	<f docmain>
		glocal const char *formid = formid;
		glocal const char *id = id;
		glocal string path = string_f ("/projects/%s",id);
		glocal bool is_public = false;
		glocal bool is_public_sub = false;
		glocal string errmsg;
		const char *pt = strchr(id,'/');
		if (pt != NULL){
			// is_public is true for the public project
			// and for sub-directories (direct child) of the public project
			if (strcmp(pt,"/public")==0){
				glocal.is_public = true;
			}else if (strncmp(pt,"/public/",8)==0 && strchr(pt+8,'/') == NULL){
				glocal.is_public = true;
				glocal.is_public_sub = true;
			}
		}
		{
			DIV f; f.id(TAB_FORM).bg("#a0a0a0").paddings(5,5).vpaddings(5,5).vmargins(5,0).borderradius(5).print();
			<call form>(formid);
			<f setup>
				DIV d; d.dispflex().flowcol().print();
				const unsigned vspace=tlmpweb_ismobile() ? 10: 3;
				const unsigned hspace=3;
				{
					DIV dd; dd.w(100).flexfixe().vmargins(vspace,0).print();
					DIV ddd; ddd.dispflex().flowrow().print();
					DIV dddd; dddd.flexfixe().margins(0,hspace).print();
					/-#I_CREATE Create
					dddd.end();
					dddd.flexfixe().margins(0,hspace).print();
					field_list (w_action,"");
					field_list_item ("","");
					field_list_item ("dir",MSG_U(I_NEW_FOLDER,"New folder"));
					field_list_item ("txt",MSG_U(I_TEXTFILE,"Text file"));
					if (util_experimental()){
						field_list_item ("doc",MSG_U(I_DOCUMENT,"Document"));
					}
					field_list_item ("clc",MSG_U(I_CALC,"Spreadsheet"));
					field_list_item ("whi",MSG_U(I_WHITEBOARD,"White board"));
					field_list_item ("chk",MSG_U(I_CHECKERSGAME,"Checkers game"));
					field_list_item ("chs",MSG_U(I_CHESSGAME,"Chess game"));
					field_list_item ("sud",MSG_U(I_SUDOKUGAME,"Sudoku game"));
					field_list_item ("tic",MSG_U(I_TICTACTOGAME,"Tic-Tac-Toe game"));
					field_list_end();
					dddd.end();
					dddd.flexfixe().margins(0,hspace).print();
					/-#I_NAME Name
					dddd.end();
					dddd.flexgrow().print();
					field_string (w_filename,"style=width:100%");
				}
				{
					DIV dd; dd.w(100).flexfixe().vmargins(vspace,0).print();
					DIV ddd; ddd.dispflex().flowrow().print();
					DIV dddd; dddd.flexfixe().margins(0,hspace).print();
					dddd.end();
					dddd.flexfixe().margins(0,hspace).print();
					field_file_title (w_upload,MSG_U(I_UPLOAD,"Upload"),"");
					dddd.end();
					dddd.flexfixe().marginleftauto().print();
					button_submit();
				}
				{
					DIV dd; dd.w(100).print();
					if (glocal.errmsg.size() > 0){
						/- <font color=red>
						htmlout (glocal.errmsg);
						/- </font>
					}else{
						/- &nbsp;
					}
				}
			</f>
			<f validate>
				return true;
			</f>
			<f process>
				glocal bool fail = false;
				const char *action = w_action.c_str();
				if (strcmp(action,"dir")==0){
					if (w_filename.size() == 0){
						glocal.fail = true;
						glocal.errmsg = MSG_U(I_NOFOLDERNAME,"No folder name provided");
					}else{
						string filepath = string_f("%s/%s",glocal.path.c_str(),w_filename.c_str());
						<call bod_client_mkdir>(glocal.con,w_session.c_str(),filepath);
						<f ok>
							if (!success){
								glocal.fail = true;
								glocal.errmsg = string_f (MSG_U(E_CREATEFOLDER,"Can't create folder: %s"),msg);
							}else{
								w_filename.setempty();
								w_action.setempty();
							}
						</f>
						</call>
					}
				}else if (is_any_of(w_action.c_str(),"chk","chs","sud","tic","txt","doc","whi","clc")){
					string msg;
					const char *magicline = "\n";
					if (strcmp(w_action.c_str(),"sud")==0){
						magicline = "boBOSUDO\n";
					}else if (strcmp(w_action.c_str(),"chk")==0){
						magicline = "boBOCHEC\n";
					}else if (strcmp(w_action.c_str(),"tic")==0){
						magicline = "boBOTICT\n";
					}else if (strcmp(w_action.c_str(),"chs")==0){
						magicline = "boBOCHES\n";
					}else if (strcmp(w_action.c_str(),"doc")==0){
						magicline = "boBOWORD\n";
					}else if (strcmp(w_action.c_str(),"whi")==0){
						magicline = "boBOWHIT\n";
					}else if (strcmp(w_action.c_str(),"clc")==0){
						magicline = "boBOCALC\n";
					}
					glocal string name;
					string path = projects_autoname(glocal.con,glocal.path,w_filename.c_str(),w_action.c_str(),glocal.name,glocal.errmsg);
					if (glocal.errmsg.size() > 0){
						glocal.fail = true;
					}else{
						<call sendfile_var>(path,magicline,glocal.fail,glocal.errmsg);
						<f start>
							<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),filepath,content,more,"");
							<f ok>
								glocal.sendfile_var.setresult(success,msg);
								if (success){
									w_filename.setempty();
									w_action.setempty();
									glocal.webtabs.addtab (string_f("2:%s/%s",glocal.id,glocal.name.c_str()),glocal.name);
								}
							</f>
							</call>
						</f>
						<f rest>
						</f>
						</call>
					}
				}
				if (strcmp(w_upload.c_str(),"")!=0 || w_name.is_filled()){
					// We test if the upload file name already exist. If this is the case
					// we create a popup dialog allowing the user to rename the file
					// Having form inside form is supported, but there is a catch. The
					// subform must have the same id as the parent (same argument for <call form>(id) )
					// And normally, it has to be a popup.
					// PATCH: There is currently a flaw in the implementation. The temporary file
					// uploaded will be deleted (and won't be re-uploaded). For now, we rename
					// it to /tmp/newfile. So it is preserved. This is not multi-user at all.
					// A better solution is needed.
					glocal bool ok = true;
					glocal string filepath = string_f("%s/%s",glocal.path.c_str(),w_upload.c_str());
					const char *tempname = tlmpweb_getfilename(w_upload);
					string newfile = string_f("/tmp/newfile.%s",w_session.c_str());
					if (w_name.is_filled()){
						tempname = newfile.c_str();
						glocal.filepath = string_f("%s/%s",glocal.path.c_str(),w_name.c_str());
					}
					if (util_entrytype(glocal.con,glocal.filepath)!=ENTRY_NONE){
						// This name already exist
						glocal string error;
						glocal.ok = false;
						if (rename (tempname,newfile.c_str())==-1){
							tlmp_warning ("rename failed");
						}
						tempname = newfile.c_str();
						<call form>(glocal.formid);
						<f top>
							projects_popup_top();
						</f>
						<f bottom>
							projects_popup_bottom();
						</f>
						<f load>
							w_name = w_upload.c_str();
						</f>
						<f setup>
							/- <center>
							htmlout (MSG_R(T_ATTENTION));
							/- </center><br>
							/- <table><tr><td>
							htmlout (MSG_R(F_NEWNAME));
							/- <td>
							field_string (w_name,"");
							/- <tr><td colspan=2>
							if (glocal.error.size()==0){
								/- &nbsp;
							}else{
								htmlprintf ("<span style='color:red;'>%s</span>\n",glocal.error.c_str());
							}
							/- <tr><td>
							button_submit();
							/- </table>
						</f>
						<f validate>
							bool ret = true;
							string newpath = string_f("%s/%s",glocal.path.c_str(),w_name.c_str());
							if (util_entrytype(glocal.con,newpath)!=ENTRY_NONE){
								glocal.error = MSG_R(E_FILEEXIST);
								ret = false;
							}
							return ret;
						</f>
						<f process>
							glocal.filepath = string_f("%s/%s",glocal.path.c_str(),w_name.c_str());
							glocal.ok = true;
						</f>
						</call>
					}
					if (glocal.ok){
						<call sendfile>(glocal.filepath,tempname,glocal.fail,glocal.errmsg);
						<f start>
							<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),filepath,content,more,"");
							<f ok>
								glocal.sendfile.sethandle(handle);
								glocal.sendfile.setresult(success,msg);
							</f>
							</call>
						</f>
						<f rest>
							<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
							<f ok>
								glocal.sendfile.setresult(success,msg);
							</f>
							</call>
						</f>
						</call>
						unlink (tempname);
					}else{
						glocal.fail = true;
					}
				}
				fail = glocal.fail;
				keepediting = true;
			</f>
			</call>
		}
		WEBID ID_PROJECT("project",id);
		<call webtable>(ID_PROJECT,currents[ID_PROJECT.c_str()],offsets[ID_PROJECT.c_str()],5);
		<f click>
			glocal unsigned dropmenu = dropmenu;
			if (dropmenu == MENU_HELPPREVIEW){
				glocal.webtabs.addtab("2:helppreview",MSG_U(I_HELPPREVIEW,"Preview"));
			}else if (dropmenu == MENU_UNDELETE){
				<call bod_client_undelete> (glocal.con,w_session.c_str(),glocal.path);
				<f ok>
					if (!success) htmlprintf (MSG_U(E_CANTUNDELETEENTRY,"Can't undelete: %s<br>\n"),msg);
				</f>
				</call>
			}else if (dropmenu == MENU_PASTE){
				index_paste(glocal.con,glocal.path);
			}else if (dropmenu == MENU_PREVIEW && glocal.is_public && noline == (unsigned)-1){
				glocal.webtabs.addtab(string_f("2:preview-%s",glocal.id),glocal.id);
			}else{
				<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,noline,1);
				<f ok>
					if (files.size()!=1){
						htmlprintf (MSG_U(E_INTERNAL,"Internal error: %s\n"),msg);
					}else{
						auto &f = files[0];
						glocal const char *name = f.name;
						glocal FILE_TYPE file_type = f.file_type;
						glocal string fname = string_f("%s/%s",glocal.path.c_str(),f.name);
						if (glocal.dropmenu == MENU_DELETE){
							glocal bool ok = false;
							if (f.type == ENTRY_FILE){
								<call bod_client_delfile> (glocal.con,w_session.c_str(),glocal.fname);
								<f ok>
									if (!success) htmlprintf (MSG_U(E_CANTDELETEENTRY,"Can't delete: %s<br>\n"),msg);
									glocal.ok = success;
								</f>
								</call>
							}else{
								<call bod_client_rmdir> (glocal.con,w_session.c_str(),glocal.fname);
								<f ok>
									if (!success) htmlprintf (MSG_U(E_CANTDELETEDIR,"Can't delete folder: %s<br>\n"),msg);
									glocal.ok = success;
								</f>
								</call>
							}
							if (glocal.ok) index_setcopyitem(glocal.con_sess,glocal.fname,f.eventdate,f.name);
						}else if (glocal.dropmenu == MENU_COPY){
							index_setcopyitem(glocal.con_sess,glocal.fname,f.eventdate,f.name);
						}else if (glocal.dropmenu == MENU_RENAME){
							glocal const char *oldname = f.name;
							glocal bool is_dir = bolixo_isdir(f.type);
							<call form>("rename");
							<f load>
								w_name = glocal.oldname;
							</f>
							<f setup>
								/- <table border=0>
								/- <tr><td>
								/-#F_OLDNAME Entry current name
								/- <td>
								htmlout(glocal.oldname);
								/- <tr><td>
								/-#F_NEWNAME New name
								/- <td>
								field_string (w_name,"");
								/- </table>
							</f>
							<f validate>
								return true;
							</f>
							<f process>
								glocal bool fail = false;
								string newname = string_f("%s/%s",glocal.path.c_str(),w_name.c_str());
								<call bod_client_rename>(glocal.con,w_session.c_str(),glocal.fname,newname.c_str());
								<f ok>
									if (!success){
										glocal.fail = true;
										htmlprintf (MSG_U(E_RENAME,"Rename failed: %s<br>\n"),msg);
									}
								</f>
								</call>
								fail = glocal.fail;
								if (!fail){
									string newid = string_f("%s/%s",glocal.id,w_name.c_str());
									const char *newname = glocal.is_dir ? newid.c_str():w_name.c_str();
									glocal.webtabs.replacetab(
										string_f("%s/%s",glocal.id,glocal.name)
										,newid
										,newname);
								}
							</f>
							</call>
						}else if (glocal.dropmenu == MENU_DOWNLOAD){
							tlmpweb_header ("Content-Disposition"," attachment; filename=%s",f.name);
							util_sendfile (glocal.con,w_session.c_str(),glocal.fname);
						}else if (glocal.dropmenu == MENU_PREVIEW){
							if (glocal.is_public && f.type == ENTRY_DIR){
								string tmp = string_f("%s/%s",glocal.id,f.name);
								glocal.webtabs.addtab(string_f("2:preview-%s",tmp.c_str()),tmp);
							}
						}else if (glocal.dropmenu == MENU_OPENINBTAB){
							if (bolixo_isdir(f.type)){
								htmlprintf (MSG_U(E_NOTAVAILDIR,"This function is not available for folders"));
							}else{
								/- <script>
								htmlprintf ("viewintab('%s?webstep=%d&document=%s/%s');\n"
									,tlmpweb_curpage(),step_fullscreen,glocal.id,f.name);
								/- </script>	
							}
						}else if (glocal.dropmenu != 0){
							if (file_is_text(f.file_type)){
								if (f.islarge){
									util_sendfile (glocal.con,w_session.c_str(),glocal.fname);
								}else{
									<call bod_client_readfile>(glocal.con,w_session.c_str(),glocal.fname,"");
									<f ok>
										if (!success){
											util_popup (glocal.con,msg,glocal.file_type,info.modified,info.owner,glocal.fname);
										}else{
											util_popup (glocal.con,content,glocal.file_type,info.modified,info.owner,glocal.fname);
										}
									</f>
									</call>
								}
							}
						}else if (f.file_type == FILE_PDF){
							util_sendfile (glocal.con,w_session.c_str(),glocal.fname);
						}else if(file_is_video(f.file_type) || file_is_sound(f.file_type)){
							tlmpweb_flushheader();
							util_popup (glocal.con,"",f.file_type,f.modified,f.owner,glocal.fname);
						}
					}
				</f>
				</call>
			}
		</f>
		<f load>
			glocal unsigned status_width=20;	// Size of the small icon at the start of each line (new,seen,modified)
			glocal unsigned rownum = nbskip;
			// Defines all posible options for dropdown
			adddrop_opt (MENU_COPY,MSG_U(M_COPY,"Copy"));
			index_setpastemenu (this,glocal.path);
			adddrop_opt (MENU_DELETE,MSG_U(M_DELETE,"Delete"));
			adddrop_opt (MENU_UNDELETE,MSG_U(M_UNDELETE,"Undelete"));
			adddrop_opt (MENU_RENAME,MSG_U(M_RENAME,"Rename"));
			adddrop_opt (MENU_DOWNLOAD,MSG_U(M_DOWNLOAD,"Download"));
			adddrop_opt (MENU_PREVIEW,MSG_U(M_PREVIEWPUB,"Public preview"));
			adddrop_opt (MENU_HELPPREVIEW,MSG_U(M_HELPPREVIEW,"Preview help"));
			adddrop_opt (MENU_OPENINBTAB,MSG_U(M_OPENINBROWSERTAB,"Open in browser tab"));
			
			if (!glocal.is_public) setdrop_hidden (MENU_HELPPREVIEW);
			if (glocal.is_public){
				glocal.webtable.setdrop_default({MENU_PASTE,MENU_PREVIEW,MENU_HELPPREVIEW});
			}else{
				glocal.webtable.setdrop_default({MENU_PASTE});
			}
			if (tlmpweb_ismobile()){
				hide_columns ({2,4});
				glocal.status_width=60;
				setdrop_hidden (MENU_OPENINBTAB);
			}else if (width != 0 && width < 400){
				hide_columns ({2,4});
			}
			sethead (MSG_U(H_FOLDER,"\tName\tModified\tOwner\tSize"));
			<call bod_client_listdir>(glocal.con,w_session.c_str(),glocal.path,"",false,nbskip,nblines);
			<f ok>
				if (!success) htmlprintf (MSG_U(E_READDIR,"Can't read directory %s: %s<br>\n"),glocal.path.c_str(),msg);
				if (!deletes) glocal.webtable.setdrop_disable(MENU_UNDELETE);
				const char *func = "Popup";
				for (auto &f:files){
					string path = string_f ("%s/%s",glocal.id,f.name);
					glocal.webtable.setdrop_hidden (MENU_PREVIEW);
					if (bolixo_isdir(f.type)){
						glocal.webtable.setdrop_disable (MENU_OPENINBTAB);
						glocal.webtable.setdrop_hidden (MENU_DOWNLOAD);
						if (glocal.is_public && !glocal.is_public_sub){
							glocal.webtable.setdrop_visible (MENU_PREVIEW);
						}
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=1:%s",path.c_str()));
					}else if (file_is_image(f.file_type)){
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),f.name));
					}else if (file_is_doc(f.file_type)){
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),f.name));
					}else if (file_is_video(f.file_type)){
						glocal.webtable.setclickopt (true,func,"800,800");
					}else if (file_is_sound(f.file_type)){
						glocal.webtable.setclickopt (true,func,"350,50");
					}else if (file_is_text(f.file_type)){
						glocal.webtable.setclickopt (true,"",string_f("webtab_add=2:%s~%s",path.c_str(),f.name));
					}else if (f.file_type == FILE_PDF){
						glocal.webtable.setclickopt (true,"viewintab","");
					}
					if (glocal.webtabs.selected(path)) glocal.webtable.setcurrent(glocal.rownum);
					//static TRANS_NOTLOAD *tbviewed[]={P_MSG_U(I_NEW,"new"),P_MSG_U(I_BLK,"&nbsp;&nbsp;&nbsp;"),P_MSG_U(I_MOD,"mod")};
					static const char *tbviewed[]={"new.png","seen.png","modified.png"};
					char sizestr[20];
					if (bolixo_isdir(f.type)){
						sizestr[0] = '\0';
					}else{
						snprintf (sizestr,sizeof(sizestr)-1,"%u",f.size);
					}
					glocal.webtable.setrow ("white",glocal.rownum,"<img width=%u src=/%s>\t%s%s\t%s\t%s/%s:%s\t%s"
						,glocal.status_width
						,tbviewed[f.viewed]
						,f.name,bolixo_isdir(f.type) ? "/" : ""
						,format_date(userinfo.dateformat,f.modified).c_str()
						,f.owner,f.listname,f.listmode,sizestr);
					glocal.rownum++;
				}
			</f>
			</call>
		</f>
		</call>
	</f>
	<f doctype2>
		glocal const char *formid = formid;
		glocal const char *filename = id;
		glocal string path = string_f("/projects/%s",glocal.filename);
		glocal bool newdocument = false;
		util_delnotify (glocal.con_sess,"Projects",id);
		FILEINFO info;
		if (util_entrytype(glocal.con,glocal.path,info)==ENTRY_DIR){
			glocal.newdocument = true;
			info.file_type = FILE_TEXT;
		}
		sethelp2();
		if (strcmp(id,"help")==0){
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_PROJECT],section_project);
		}else if (strcmp(id,"help2")==0){
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_documents);
		}else if (strcmp(id,"help_tictacto")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_tictacto);
		}else if (strcmp(id,"help_sudoku")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_sudoku);
		}else if (strcmp(id,"help_checkers")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_checker);
		}else if (strcmp(id,"help_chess")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_chess);
		}else if (strcmp(id,"help_wordproc")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_wordproc);
		}else if (strcmp(id,"help_whiteboard")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_whiteboard);
		}else if (strcmp(id,"help_calc")==0){
			glocal.docpointers[SECTION_DOCUMENTS].reset();
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_DOCUMENTS],section_calc);
		}else if (strcmp(id,"helppreview")==0){
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_PREVIEW],section_preview);
		}else if (strcmp(id,"helpmain")==0){
			DIV d("webtable"); d.print();
			index_doc(glocal.docpointers[SECTION_NONE],section_none);
		}else if (strncmp(id,"preview-",8)==0){
			glocal const char *base = id+8;
			glocal string groupowner;
			const char *pt = strchr(glocal.base,'/');
			if (pt != NULL) glocal.groupowner = string(glocal.base,pt-glocal.base);;
			DIV dd; dd.id(TAB_FORM).bg("#F1F1F1").paddings(5,5).print();
			htmlprintf (MSG_U(I_PREVIEW,"Preview of the folder %s"),glocal.base);
			/- <br>
			dd.end();
			// DIV d("wwebtable"); d.print();
			<call public_page>();
			<f list_talk>
				glocal vector<SHORTMSG> *msgs = &msgs;
				glocal int ret = -1;
				vector<string> fullt;
				<call bod_client_list_talk>(glocal.con,w_session.c_str(),"","public",glocal.groupowner,fullt,offset,nb,"");
				<f ok>
					if (success){
						glocal.ret = 0;
						glocal.msgs->clear();
						for (auto &m:messages) glocal.msgs->push_back(m);
					}
				</f>
				</call>
				return glocal.ret;
			</f>
			<f listdir>
				glocal int ret = -1;
				glocal vector<FILEINFO> *files = &files;
				string fname;
				if (strcmp(path.ptr,"/")==0){
					fname = string_f("/projects/%s",glocal.base);
				}else{
					fname = string_f("/projects/%s%s",glocal.base,path.ptr);
				}
				<call bod_client_listdir>(glocal.con,w_session.c_str(),fname,"",false,offset,nb);
				<f ok>
					if (success){
						glocal.ret = 0;
						glocal.files->clear();
						for (auto &f:files) glocal.files->push_back(f);
					}
				</f>
				</call>
				return glocal.ret;
			</f>
			<f readfile>
				glocal int ret = -1;
				glocal BOB_TYPE *content = &content;
				string fname = string_f("/projects/%s/%s",glocal.base,path.ptr);
				<call bod_client_readfile_bob>(glocal.con,w_session.c_str(),fname,"",true);
				<f ok>
					if (success){
						glocal.ret = 0;
						*glocal.content = content;
					}
				</f>
				</call>
				return glocal.ret;
			</f>
			<f projecturl>
				string ret;
				string tmp = util_flipspaces(modified.ptr);
				if (is_any_of(name.ptr,"/photo.jpg","/mini-photo.jpg")){
					// Those tow are located in the public folder directly
					ret = string_f("%s?webstep=%d&image=/projects/%s/public%s&mod=%s"
						,tlmpweb_curpage(),step_image,glocal.groupowner.c_str(),name.ptr,tmp.c_str());
				}else if (is_image){
					const char *slash = name.ptr[0] == '/' ? "" : "/";
					ret = string_f("%s?webstep=%d&image=/projects/%s%s%s&mod=%s"
						,tlmpweb_curpage(),step_image,glocal.base,slash,name.ptr,tmp.c_str());
				}else{
					string hidden;
					form_gethidden(hidden);
					ret = string_f("%s?file=%s&%s",tlmpweb_curpage(),name.ptr,hidden.c_str());
				}
				return ret;
			</f>
			<f msgurl>
				string ret;
				const char *pt = strchr(glocal.base,'/');
				if (pt != NULL){
					string user (glocal.base,pt-glocal.base);
					string tmp = util_flipspaces(modified.ptr);
					ret = string_f("%s?webstep=%d&image=/msgs/%s/short-inbox/public/%s&mod=%s"
						,tlmpweb_curpage(),step_image,user.c_str(),name.ptr,tmp.c_str());
				}
				return ret;
			</f>
			<f process>
				glocal string website;
				glocal string interest;
				<call bod_client_info_read>(glocal.con,w_session.c_str(),"");
				<f ok>
					if (success && info.publish){
						glocal.website = info.website;
						glocal.interest = info.interest;
					}
				</f>
				</call>
				public_display (*this,glocal.con,userinfo.name,true,glocal.website,glocal.interest);
			</f>
			<f sendfile>
				string fname = string_f("/projects/%s/%s",glocal.base,name.ptr);
				tlmp_error ("sendfile %s\n",fname.c_str());
				util_sendfile(glocal.con,w_session.c_str(),fname);
			</f>
			</call>
		}else if (info.file_type == FILE_TEXT){
			<call form>(formid);
			<f load>
				if (!glocal.newdocument){
					index_loadfile(glocal.con,glocal.path,w_content);
				}
			</f>
			<f setup>
				{
					DIV f; f.id(TAB_FORM).w(100).print();
					const unsigned vspace=3;
					DIV d; d.dispflex().flowrow().print();
					DIV dd; dd.flexfixe().vmargins(vspace,0).print();
					if (glocal.newdocument){
						/-#I_NEWDOCNAME Name&nbsp;
						field_string (w_filename,"size=25");	
					}else{
						const char *filename = glocal.filename;
						if (tlmpweb_ismobile()){
							const char *pt = strrchr(filename,'/');
							if (pt != NULL) filename = pt+1;
						}
						htmlprintf (MSG_U(I_DOCNAME,"Document name:&nbsp;%s"),filename);
					}
					dd.end();
					dd.flexgrow().print();
					DIV ddd; ddd.sfloatright().print();
					button_submit(MSG_U(B_SAVE,"Save"));
				}
				WEBID id ("prjtext",glocal.formid);
				field_textarea(w_content,id,-100,"style=\"border:none\"");
			</f>
			<f validate>
				bool ret = true;
				if (glocal.newdocument){
					if (strcmp(w_filename.c_str(),"")==0){
						/- You must provide a file name
						ret = false;
					}else if (util_entrytype(glocal.con,string_f("%s/%s",glocal.path.c_str(),w_filename.c_str()))!=ENTRY_NONE){
						/- Document already exist
						ret = false;
					}
				}
				return ret;
			</f>
			<f process>
				<call sendfile_var>(glocal.path,w_content.c_str(),fail);	
				<f start>
					if (glocal.newdocument){
						glocal.path = string_f("%s/%s",glocal.path.c_str(),w_filename.c_str());
						<call bod_client_addfile_bob>(glocal.con,w_session.c_str(),glocal.path,content,more,"");
						<f ok>
							glocal.sendfile_var.setresult(success,msg);
							glocal.sendfile_var.sethandle(handle);
						</f>
						</call>
					}else{
						<call bod_client_modifyfile_bob>(glocal.con,w_session.c_str(),filepath,content,more,"");
						<f ok>
							glocal.sendfile_var.setresult(success,msg);
							glocal.sendfile_var.sethandle(handle);
						</f>
						</call>
					}
				</f>
				<f rest>
					<call bod_client_appendfile>(glocal.con,w_session.c_str(),handle,content,more);
					<f ok>
						glocal.sendfile_var.setresult(success,msg);
					</f>
					</call>
				</f>
				</call>
				if (!fail){
					if (glocal.newdocument){
						WEBID oldid ("prjtext",glocal.formid);
						string newtabid = string_f("%s/%s",glocal.filename,w_filename.c_str());
						glocal.webtabs.setid (newtabid);
						glocal.webtabs.settitle (w_filename.c_str());
						glocal.webtabs.redotab();
						resetstate();
						// We have to mark this document as viewed (we just created it)
						util_markview (glocal.con,glocal.path);
						WEBID newid ("prjtext",newtabid);
						webtable_rename_scroll(oldid.c_str(),newid.c_str());
					}else{
						keepediting = true;
					}
				}
			</f>
			</call>
		}else{
			projects_documents(glocal.con,glocal.con_sess,formid,id,tab_width,tab_height,this,step_projects,selected(id),"","");
		}
	</f>
	</call>
}
</mod>
static void sethelp2(_F_webtabs *webtabs, PARAM_STRING id, PARAM_STRING title)
{
	if (webtabs != nullptr) webtabs->sethelp2(id,title);
}
<mod>
static void projects_documents(
	CONNECT_INFO &con,
	CONNECT_INFO &con_sess,
	const char *formid,
	const char *id,
	unsigned tab_width,
	unsigned tab_height,
	_F_webtabs *webtabs,
	unsigned webstep,	// Calling context
	bool focus,		// The document must have the focus
	const char *extraargs,
	const char *uicontext)	// empty if we are running in normal mode
				// full  if we are running fullscreen
				// task  if we are running in a miniature task overview
{
	glocal con;
	glocal con_sess;
	glocal const char *filename = id;
	glocal string path = string_f("/projects/%s",glocal.filename);
	FILEINFO info;
	util_entrytype(glocal.con,glocal.path,info);
	if (file_is_image(info.file_type)){
		DIV d("webtable"); d.print();
		DIV dd; dd.id(TAB_FORM).bg("#F1F1F1").paddings(5,5).print();
		htmlprintf (MSG_R(I_DOCNAME),glocal.filename);
		/- <br>
		dd.end();
		htmlout (util_img(step_image,"max-height:95%;",glocal.path,info.modified));
	}else if (file_is_doc(info.file_type)){
		glocal vector<DIALOG_FIELD> fields;	// Field definition and value for document dialogs
		const char *base_content_id = "doc";
		unsigned docnum = 0;
		if (info.file_type == FILE_DOC_TICTACTO){
			sethelp2 (webtabs,"help_tictacto",MSG_U(T_TICTACTO,"Tictacto"));
			base_content_id = "doc_tictacto";
		}else if (info.file_type == FILE_DOC_SUDOKU){
			sethelp2 (webtabs,"help_sudoku",MSG_U(T_SUDOKY,"Sudoku"));
			base_content_id = "doc_sudoku";
		}else if (info.file_type == FILE_DOC_CHECKER){
			sethelp2 (webtabs,"help_checkers",MSG_U(T_CHECKERS,"Checkers"));
			base_content_id = "doc_checkers";
		}else if (info.file_type == FILE_DOC_CHESS){
			sethelp2 (webtabs,"help_chess",MSG_U(T_CHESS,"Chess"));
			base_content_id = "doc_chess";
		}else if (info.file_type == FILE_DOC_WORDPROC){
			sethelp2 (webtabs,"help_wordproc",MSG_U(T_WORDPROC,"Document"));
			base_content_id = "doc_wordproc";
		}else if (info.file_type == FILE_DOC_WHITEBOARD){
			sethelp2 (webtabs,"help_whiteboard",MSG_U(T_WHITEBOARD,"WhiteBoard"));
			base_content_id = "doc_whiteboard";
		}else if (info.file_type == FILE_DOC_CALC){
			sethelp2 (webtabs,"help_calc",MSG_U(T_CALC,"Speadsheet"));
			base_content_id = "doc_calc";
		}
		string content_id = string_f("%s%s",uicontext,base_content_id);
		/- <script>
		/- var action_mousex=0;
		/- var action_mousey=0;
		/- function gameaction(event,action){
		/-  action_mousex=event.clientX;
		/-  action_mousey=event.clientY;
		/-  notesocket.send(action);
		/- }
		/- function callrefresh(){
		htmlprintf ("\tformsubmit('%s?webstep=%d&focus=1%s');\n",tlmpweb_curpage(),webstep,extraargs);
		/- }
		/- function calldialog(name){
		htmlprintf ("\tformsubmit('%s?webstep=%d%s&dialog='+name+'&mousex='+action_mousex+'&mousey='+action_mousey);\n"
			,tlmpweb_curpage(),webstep,extraargs);
		/- }
		/- </script>
		vector<VARVAL> steps;
		if (w_action.isset()){
			vector<string> tb;
			int n = str_splitline(w_action.c_str(),'=',tb);
			if (n == 2){
				VARVAL var;
				var.var = tb[0];
				var.val = tb[1];
				steps.push_back(var);
			}
		}
		{
			VARVAL var;
			var.var = REQ_PRINT;
			var.val = uicontext;
			steps.emplace_back(move(var));
		}
		if (focus || w_focus==1){
			VARVAL var;
			var.var = REQ_FOCUS;
			steps.emplace_back(move(var));
		}
		if (w_dialog.isset()){
			VARVAL var;
			var.var = REQ_GETFIELDS;
			var.val = w_dialog.c_str();
			steps.emplace_back(move(var));
		}
		DOC_UI_SPECS sp;
		sp.width = tab_width;
		sp.height = tab_height;
		sp.mobile = tlmpweb_ismobile();
		sp.fontsize = tlmpweb_fontsize();
		WEBID id(content_id);
		tlmpweb_gettablegeometry(id,sp.content_height,sp.content_width);
		//tlmp_warning ("doc geometry %s %u %u %u %u",glocal.path.c_str(),sp.width,sp.height,sp.content_width,sp.content_height);
		if (sp.content_width == 0){
			// We don't know the content size yet, but a requested refresh will tell us.
			// So we enter a default value for now.
			sp.content_width = sp.width/2;
			sp.content_height = sp.height/2;
		}
		sp.content_width-=4;
		index_setgameid(string_f("\"%s\" %u %u %u %u %d %u",glocal.path.c_str(),sp.width,sp.height,sp.content_width,sp.content_height,sp.mobile,sp.fontsize));
		<call bod_client_playstep>(glocal.con,w_session.c_str(),"",glocal.path,docnum,steps,sp);
		<f ok>
			if (!success){
				htmlprintf ("<p>%s\n",msg);
			}else{
				string error,result;
				glocal bool more = more;
				glocal function<void(const vector<VARVAL_receive>&res)> fres;
				glocal.fres = [&](const vector<VARVAL_receive> &res){
					for (auto &r:res){
						if (strcmp(r.var,VAR_CONTENT)==0){
							htmlout (r.val);
						}else if (strcmp(r.var,VAR_SCRIPT)==0){
							htmlout("<script>\n");
							htmlout (r.val);
							htmlout("</script>\n");
						}else if (strcmp(r.var,VAR_ERROR)==0){
							error = r.val;
						}else if (strcmp(r.var,VAR_RESULT)==0){
							result = r.val;
						}else if (strcmp(r.var,VAR_FIELDS)==0){
							// r.val is a list of fields. Each field has a name and a value on a single text line.
							// name:value\nname:value\n
							auto tb = str_splitline (r.val,'\n');
							for (auto &l:tb){
								const char *start = l.c_str();
								const char *pt = strchr(start,':');
								if (pt != nullptr){
									glocal.fields.emplace_back(string(start,pt-start),pt+1);
								}
							}
						}
					}
				};
				glocal.fres(res);
				while (glocal.more){
					glocal.more = false;
					<call bod_client_playstep_more>(glocal.con,w_session.c_str(),"",glocal.path,handle);
					<f ok>
						if (!success){
							tlmp_error ("playstep_more msg=%s",msg);
						}else{
							glocal.more = more;
							glocal.fres(res);
						}
					</f>
					</call>
				}
				if (error.size() > 0){
					htmlprintf ("<font color=red>%s</font>\n",error.c_str());
				}
				if (result.size() > 0){
					htmlprintf ("<font color=blue>%s</font>\n",result.c_str());
				}
			}
		</f>
		</call>
		if (w_dialog.isset()){
			//for (auto &f:glocal.fields) tlmp_warning ("fields :%s: :%s:",f.name.c_str(),f.value.c_str());
			if (is_any_of(info.file_type,FILE_DOC_CHESS,FILE_DOC_WHITEBOARD,FILE_DOC_WORDPROC,FILE_DOC_CALC)){
				projects_dialogs (glocal.con,w_dialog.c_str(),glocal.fields,w_session.c_str(),glocal.path,docnum,sp);	
			}
		}
	}else if (info.type != ENTRY_NONE){
		tlmp_error ("No rule to display document filename=%s name=%s type %d\n",glocal.filename,info.name.c_str(),info.file_type);
	}
}
</mod>
/*
	Use to present a document in its own browser tab
*/
void projects_documents(
	CONNECT_INFO &con,
	CONNECT_INFO &con_sess,
	const char *formid,
	const char *id,
	unsigned tab_width,
	unsigned tab_height)
{
	string extraargs = string_f("&document=%s",id);
	projects_documents(con,con_sess,formid,id,tab_width,tab_height,nullptr,step_fullscreen,true,extraargs.c_str(),"full");
}
