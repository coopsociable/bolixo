/*
	websocket client using CONNECT_HTTP_INFO, test.
	Learn how to work with TCPSERVER (so we can handle other connections)
*/
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>
#include <dialog.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <memory>
#include <trlitool.h>
#include <openssl/ssl.h>
#include "instrument.h"
#include "helper.h"

using namespace std;

#define webapi_test_NOTNEED
#define webapi_addfile_NOTNEED
#define webapi_addfile_bob_NOTNEED
#define webapi_appendfile_NOTNEED
#define webapi_delfile_NOTNEED
#define webapi_undelete_NOTNEED
#define webapi_modifyfile_NOTNEED
#define webapi_modifyfile_bob_NOTNEED
#define webapi_rename_NOTNEED
#define webapi_copy_NOTNEED
#define webapi_readfile_NOTNEED
#define webapi_readfile_bob_NOTNEED
#define webapi_readmore_NOTNEED
#define webapi_mkdir_NOTNEED
#define webapi_rmdir_NOTNEED
#define webapi_listdir_NOTNEED
#define webapi_stat_NOTNEED
#define webapi_set_access_NOTNEED
#define webapi_markview_NOTNEED
#define webapi_list_inboxes_NOTNEED
#define webapi_list_msgs_NOTNEED
#define webapi_sendmsg_NOTNEED
#define webapi_sendmsg_project_NOTNEED
#define webapi_replymsg_NOTNEED
#define webapi_replymsg_project_NOTNEED
#define webapi_sendattach_NOTNEED
#define webapi_sendtalk_NOTNEED
#define webapi_sendtalk_file_NOTNEED
#define webapi_list_talk_NOTNEED
#define webapi_public_listdir_NOTNEED
#define webapi_public_readfile_NOTNEED
#define webapi_public_list_talk_NOTNEED
#define webapi_systempubkey_NOTNEED
#define webapi_verifysign_NOTNEED
#define webapi_getpubkey_NOTNEED
#define webapi_registernode_NOTNEED
#define webapi_remotelogin_NOTNEED
#define webapi_remotepass_NOTNEED
#define webapi_remote_interest_set_NOTNEED
#define webapi_remote_interest_unset_NOTNEED
#define webapi_nodelogin_NOTNEED
#define webapi_nodepass_NOTNEED
#define webapi_config_read_NOTNEED
#define webapi_config_write_NOTNEED
#define webapi_contact_request_NOTNEED
#define webapi_contact_manage_NOTNEED
#define webapi_contact_list_NOTNEED
#define webapi_list_contacts_NOTNEED
#define webapi_list_lists_NOTNEED
#define webapi_list_groups_NOTNEED
#define webapi_create_group_NOTNEED
#define webapi_delete_group_NOTNEED
#define webapi_delete_list_NOTNEED
#define webapi_set_member_NOTNEED
#define webapi_contact_remove_NOTNEED
#define webapi_list_members_NOTNEED
#define webapi_create_group_list_NOTNEED
#define webapi_set_group_NOTNEED
#define webapi_playstep_NOTNEED
#define webapi_logout_NOTNEED
#include "proto/webapi.protoch"
#include "websocket-client.h"

static DEBUG_KEY D_HEADER("header","Print request header");
static DEBUG_KEY D_PROTO("proto","HTTP protocol");


using HANDLE_WSS_P = shared_ptr<HANDLE_WSS>;


struct HANDLE_INFO: public ARRAY_OBJ{
	HANDLE_WSS_P wss=nullptr;
};

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *bindaddr = "0.0.0.0";
	glocal const char *host = "http://test1.bolixo.org";
	glocal const char *file = "/wss";
	glocal bool keepcookie = false;
	glocal bool verbose = false;
	glocal const char *email = "jacques-A@bolixo.org";
	glocal const char *passwd = "pass-A";
	glocal bool nonstrict = false;
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("testsock",VERSION,"websocket client prototype");
		setgrouparg ("Connection");
		setarg ('h',"host","Web server url )(https://...)",glocal.host,false);
		setarg ('E',"email","Email for login",glocal.email,false);
		setarg ('P',"password","Password for login",glocal.passwd,false);
		setarg (' ',"nonstrict","Relaxed rules for SSL connections (certificate and hostname validation)",glocal.nonstrict,false);
		setgrouparg ("Misc.");
		setarg ('v',"verbose","Print the result",glocal.verbose,false);
	</f>
	<f main_noarg>
		glocal long long start = fdpass_getnow();
		glocal string session;
		signal(SIGPIPE,SIG_IGN);
		signal(SIGCHLD,SIG_IGN);
		if (glocal.email == NULL) glocal.email = getenv("WEBTEST_EMAIL");
		if (glocal.passwd == NULL) glocal.passwd = getenv("WEBTEST_PASSWORD");
		if (glocal.email == NULL || glocal.passwd == NULL){
			tlmp_error ("missing email and/or password, can't continue\n");
			exit (-1);
		}
		// Used to receive the stats of the child processes
		<obj TCPSERVER o>();
		<f newclient>
		</f>
		<f endclient>
			if (getnbclients() <= 1){
				endserver = true;
			}
		</f>
		<f receive>
			glocal no;
			glocal HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			glocal HANDLE_WSS_P wss = glocal.c->wss;
			printf ("linelen=%d no=%d c=%p\n",info.linelen,no,glocal.c);
			if (!glocal.wss){
				endserver = true;
			}else{
				bool now_running = false;
				glocal.wss->process(endclient,now_running,1);
				printf ("now_running=%d\n",now_running);
			}
		</f>
		</obj>
		CONNECT_HTTP_INFO con;
		if (glocal.nonstrict) con.setnonstrictmode();
		if (con.init (glocal.host)==-1){
			tlmp_error ("Invalid host url: %s\n",glocal.host);
			exit(-1);
		}
		<call webapi_login>(con,glocal.email,glocal.passwd);
		<f ok>
			if (!success){
				tlmp_error ("login failed\n");
				exit (-1);
			}else{
				glocal.session = sessionid;
			}
		</f>
		</call>
		printf ("con.ssl=%p con.bio=%p\n",con.ssl,con.bio);
		int fd;
		BIO_get_fd(con.bio,&fd);
		printf ("fd=%d\n",fd);
		HANDLE_INFO *h = new HANDLE_INFO;
		h->wss = make_shared<HANDLE_WSS>();
		h->wss->session = glocal.session;
		h->wss->con = move(con);
		h->wss->addinitmsg ("sequence=0");
		const char *pt;
		if (is_start_any_ofnc(glocal.host,pt,"http://","https://")){
			h->wss->sendheader (pt);
		}
		o.inject (fd,h);
		o.setmonitormode(fd,true);
		o.inject (0,new HANDLE_INFO);
		o.loop();
		return 0;
	</f>
	</call>
	return glocal.ret;
}
</mod>

