#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;

#include "proto/documentd_sudoku.protoh"
#define documentd_sudoku_cell_NOTNEED
#define documentd_sudoku_cell2_NOTNEED
#define documentd_sudoku_header_NOTNEED
#include "proto/documentd_sudoku.protoch"

static DEBUG_KEY D_SUDOKU("sudoku","sudoku game");

void SUDOKU::save (DOC_WRITER &w, bool save_session_info)
{
	documentd_sudoku_header2(&w,revision,difficulty);
	if (save_session_info){
		for (auto &s:seldigs){
			documentd_sudoku_select(&w,s.first,s.second);
		}
	}
	vector<USERAVATAR> users;
	for (auto &a:prefs){
		USERAVATAR u;
		u.name = a.first;
		u.avatar = a.second.color;
		u.last_column = a.second.last_column;
		u.last_line = a.second.last_line;
		users.emplace_back(u);
	}
	documentd_sudoku_userpref (&w,users);
	vector<CELL3> cells;
	for (auto &g:grid){
		for (auto &gg:g){
			CELL3 c;
			c.visible = gg.visible;
			c.value = gg.value;
			c.user_value = gg.user_value;
			c.username = gg.username;
			c.user_guess = gg.user_guess;
			c.guess_color = gg.guess_color;
			cells.emplace_back(c);
		}
	}
	documentd_sudoku_cell3(&w,cells);
}
<mod>
void SUDOKU::load (DOC_READER &r, string &msg)
{
	glocal grid;
	glocal msg;
	glocal unsigned x=0;
	glocal unsigned y=0;
	glocal seldigs;
	glocal revision;
	glocal difficulty;
	glocal prefs;
	resetgame();
	<call documentd_sudoku>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f header2>
		glocal.revision = revision;
		glocal.difficulty = difficulty;
	</f>
	<f cell>
		if (glocal.x > 8){
			glocal.msg = "Too many cells in the sodoku files";
			end  = true;
		}else{
			SUDOKU_CELL &gg = glocal.grid[glocal.x][glocal.y];
			gg.visible = visible;
			gg.value = value;
			gg.user_value = user_value;
			glocal.y = (glocal.y+1)%9;
			if (glocal.y == 0) glocal.x++;
		}
	</f>
	<f cell2>
		if (glocal.x > 8){
			glocal.msg = "Too many cells in the sodoku file";
			end  = true;
		}else{
			SUDOKU_CELL &gg = glocal.grid[glocal.x][glocal.y];
			gg.visible = visible;
			gg.value = value;
			gg.user_value = user_value;
			gg.username = username;
			glocal.y = (glocal.y+1)%9;
			if (glocal.y == 0) glocal.x++;
		}
	</f>
	<f cell3>
		if (cells.size() != 81){
			glocal.msg = "Invalid number of cells in the sodoku file";
			end  = true;
		}else{
			unsigned line=0;
			unsigned col=0;
			for (auto &c:cells){
				SUDOKU_CELL &gg = glocal.grid[line][col];
				gg.visible = c.visible;
				gg.value = c.value;
				gg.user_value = c.user_value;
				gg.username = c.username;
				gg.user_guess = c.user_guess;
				gg.guess_color = c.guess_color;
				col++;
				if (col==9){
					col = 0;
					line++;
				}
			}
		}
	</f>
	<f select>
		glocal.seldigs[session] = value;
	</f>
	<f userpref>
		for (auto &u:prefs){
			auto &p = glocal.prefs[u.name];
			p.color = u.avatar;
			p.last_column = u.last_column;
			p.last_line = u.last_line;
		}
	</f>
	<f invalid>
		glocal.msg = "Invalid format for sudoku file";
	</f>
	</call>
	compute_grid_full();
}
void SUDOKU::compute_grid_full()
{
	unsigned stats[9];
	for (auto &s:stats) s = 0;
	for (auto &g:grid) for (auto &gg:g){
		if (gg.visible || gg.value == gg.user_value){
			stats[gg.value-1]++;
		}
	}
	for (unsigned i=0; i<9; i++) grid_full[i] = stats[i] == 9;
}
void SUDOKU::resetgame()
{
	//line = column = 0;
	seldigs.clear();
	prefs.clear();
	for (auto &g:grid){
		for (auto &gg:g){
			gg.reset();
		}
	}
	for (auto &g:grid_full) g=false;
}
void SUDOKU::update_msg(
	bool to_all,	// The message will be shown to all player or not
	PARAM_STRING msg,
	const char *color,
	vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	js_find_set (mvar.val,"msg","style.color",color,"innerHTML",documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void SUDOKU::testwin(vector<VARVAL> &res)
{
	unsigned nbok = 0;
	for (auto &g:grid){
		for (auto &gg:g){
			if (gg.visible || (gg.value != 0 && gg.value == gg.user_value)) nbok++;
		}
	}
	if (nbok == 9*9){
		update_msg (true,MSG_U(I_COMPLETE,"Congratulation! You completed the puzzle"),"blue",res);
	}
}
const unsigned nbcolor=6;
static const char *colors[nbcolor]={"black","green","blue","orange","lightblue","lightgreen"};
/*
	Redraw the grid content using javascript.
*/
void SUDOKU::redraw_notify(vector<VARVAL> &res)
{
	VARVAL var;
	var.var = VAR_NOTIFY;
	var.val = string_f ("var frm = document.getElementById('form-%s');\n",gameid.c_str());
	var.val += "if (frm != null){\n";
	var.val += "\tvar buttons = frm.getElementsByTagName('input');\n";
	for (unsigned i=0; i<4; i++){
		var.val += string_f("\tbuttons[%i].style.background='%s';\n",i,i==difficulty ? "lightblue" : "lightgray");
	}
	var.val += "}\n";
	var.val += string_f ("var doc = document.getElementById('grid-%s');\n",gameid.c_str());
	var.val += "if (doc != null){\n";
	var.val += "\tvar circles = doc.getElementsByTagName('circle');\n";
	var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
	// We have to skip the a,b,c...i and then the A
	unsigned txt_item = 9+1;
	unsigned circle_item = 0;
	unsigned line=0;
	for (auto &g:grid){
		unsigned col = 0;
		for (auto &&gg:g){
			const char *color = "none";
			const char *circle_color = "none";
			const char *guess_color = "none";
			unsigned value = gg.value;
			if (gg.visible){
				color = "gray";
			}else if (gg.user_value != 0){
				value = gg.user_value;
				if (gg.user_value != gg.value){
					color = "red";
				}else{
					color = "black";
					auto a = prefs.find(gg.username);
					if (a != prefs.end()){
						color = colors[a->second.color];
						if (a->second.last_column == col && a->second.last_line == line){
							circle_color = color;
						}
					}
				}
			}else if (gg.user_guess != 0){
				guess_color = colors[gg.guess_color];
			}
			// We draw the guess
			var.val += string_f("\tvar e = txts[%u];\n",txt_item);
			var.val += string_f("\te.style.fill = '%s';\n",guess_color);
			var.val += string_f("\te.style.stroke = '%s';\n",guess_color);
			var.val += string_f("\te.textContent = '%u';\n",gg.user_guess);
			txt_item++;		// We draw the value
			var.val += string_f ("\tvar e = txts[%u];\n",txt_item);
			var.val += string_f("\te.style.fill = '%s';\n",color);
			var.val += string_f("\te.style.stroke = '%s';\n",color);
			var.val += string_f("\te.textContent = '%u';\n",value);
			txt_item++;
			var.val += string_f ("\tvar e = circles[%u];\n",circle_item);
			var.val += string_f("\t\t\te.style.stroke = '%s';\n",circle_color);
			circle_item++;
			col++;
		}
		// We skip the letter on the side
		txt_item++;
		line++;
	}
	var.val += "}\n";
	// Draw the user ids under their color
	var.val += string_f ("var doc = document.getElementById('avatar-%s');\n",gameid.c_str());
	var.val += "if (doc != null){\n";
	var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
	const char *tbusers[nbcolor]={nullptr,nullptr,nullptr,nullptr,nullptr,nullptr};
	for (auto &a:prefs) tbusers[a.second.color] = a.first.c_str();
	for (unsigned i=0; i<nbcolor; i++){
		const char *user = tbusers[i];
		const char *color = "black";
		if (user == nullptr){
			color = "none";
			user = "";
		}
		var.val += string_f ("\tvar e = txts[%u];\n",i);
		var.val += string_f("\te.style.fill = '%s';\n",color);
		var.val += string_f("\te.style.stroke = '%s';\n",color);
		var.val += string_f("\te.textContent = '%s';\n",user);
	}
	var.val += "}\n";
	res.push_back(var);
}

<mod>
void SUDOKU::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	string error;
	setactivity();
	//tlmp_error ("SUDOKU var %s val%s username %s maywrite %d",var,val,username,maywrite);
	/*
		We check if the user has selected a color. If not, we assign the first available
	*/
	{
		auto a = prefs.find(username);
		if (a == prefs.end()){
			bool takens[nbcolor] = {false,false,false,false,false,false};
			for (auto &a:prefs) takens[a.second.color] = true;
			for (unsigned i=0; i<nbcolor; i++){
				if (!takens[i]){
					prefs[username].color = i;
					break;
				}
			}
		}
	}
			
	if (strcmp(var,"print")==0){
		string lines;
		if (strcmp(val,"console")==0){
			static const char *dashes = "\t+---+---+---+---+---+---+---+---+---+\n";	
			unsigned nol = 0;
			static const char *white = "\033[01;37m";
			static const char *green = "\033[01;32m";
			static const char *blue = "\033[01;34m";
			static const char *red = "\033[01;31m";
			//	static const char *bgblue = "\033[01;44m";
			static const char *normal = "\033[00m";
			for (auto &g:grid){
				if (nol % 3 == 0){
					lines += blue;
					lines += dashes;
					lines += normal;
				}else{
					lines += '\t';
					for (unsigned i=0; i<9; i++){
						if (i % 3 == 0){
							lines += blue;
						}else{
							lines += green;
						}
						lines += '+';
						lines += green;
						lines += "---";
					}
					lines += blue;
					lines += '+';
					lines += normal;
					lines += '\n';
				}
				lines += "\t";
				unsigned pos = 0;
				for (auto &gg:g){
					if (pos % 3 == 0){
						lines += blue;
						lines += '|';
					}else{
						lines += green;
						lines += '|';
					}
					lines += normal;
					//if (nol / 3 == line && pos / 3 == column) lines += bgblue;
					if (gg.visible){
						lines += string_f("%s %c %s",white,gg.value+'0',normal);
					}else if (gg.user_value != 0){
						if (gg.user_value != gg.value){
							lines += red;
						}
						lines += string_f(" %c ",gg.user_value+'0');
						lines += normal;
					}else{
						lines += "   ";
					}
					lines += normal;
					pos++;
				}
				lines += blue;
				lines += "|\n";
				lines += normal;
				nol++;
			}
			lines += blue;
			lines += dashes;
			lines += normal;
		}else{
			// The layout is a square, constrained by the width
			unsigned dim = sp.content_width < sp.content_height ? sp.content_width : sp.content_height;
			unsigned width = dim - dim % 10;
			unsigned g_offx=17;
			unsigned g_offy=20;
			unsigned w9 = (width-g_offy)/10;
			unsigned h9 = w9; 
			unsigned grid_width = w9*9+g_offx;
			unsigned grid_height = w9*9+g_offy;
			unsigned avatarw = w9*10;
			unsigned avatarcw = avatarw/6;
			
			lines += "<script>\n";
			lines += "function gameselect(event){\n";
			lines += string_f("\tvar elm = document.getElementById('sudosel-%s');\n",gameid.c_str());
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('select:'+Math.floor((event.clientY-rect.top-%u)/%u+1));\n",g_offy,h9);
			lines += "}\n";
			lines += "function avatarselect(event){\n";
			lines += string_f("\tvar elm = document.getElementById('avatar-%s');\n",gameid.c_str());
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('avatar:'+Math.floor((event.clientX-rect.left)/%u));\n",avatarcw);
			lines += "}\n";
			lines += "function gameplace(event){\n";
			lines += "\tif(event.which==1 || event.which==2){\n";
			lines += string_f("\t\tvar elm = document.getElementById('grid-%s');\n",gameid.c_str());
			lines += "\t\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\t\tgameaction('place:'+Math.floor((event.clientY-rect.top-%u)/%u)+','+Math.floor((event.clientX-rect.left-%u)/%u) + ','+event.which);\n",g_offy,h9,g_offx,w9);
			lines += "\t\tevent.stopPropagation();\n";
			lines += "\t}\n";
			lines += "}\n";
			lines += "</script>\n";
			
			// Strange UI bug here if we remove the border style (instead of using solid white), scroll bars
			// are showing. Odd.
			lines += "<div id=tab_form style='margin-top:5; border: 1px solid white;'>\n";
			//lines += "<div id=tab_form style='margin-top:5;'>\n";
			lines += string_f("<form id='form-%s'>\n",gameid.c_str());
			lines += MSG_U(I_NEWGAME,"New game");
			documentd_button (lines,0,MSG_U(I_SIMPLE,"Simple"),difficulty==0);
			documentd_button (lines,1,MSG_U(I_EASY,"Easy"),difficulty==1);
			documentd_button (lines,2,MSG_U(I_INTERMEDIATE,"Intermediate"),difficulty==2);
			documentd_button (lines,3,MSG_U(I_EXPERT,"Expert"),difficulty==3);
			lines += "</form>\n";
			lines += "</div>\n";
			//lines += "<div class=webtable id=doc_sudoku style='display:flex; flex-flow:row; border: 1px solid black;'>\n";
			lines += "<div class=webtable id=doc_sudoku style='display:flex; flex-flow:row;'>\n";
			lines += "<div style='flex:1 1 auto; overflow: hidden;'>\n";
			lines += string_f("<svg onclick=gameselect(event) id='sudosel-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",gameid.c_str(),w9,grid_height,w9,grid_height);
			unsigned font_base = h9*7/10;
			unsigned font_base_guess = h9*9/10;
			unsigned font_size = h9*6/10;
			unsigned w9_3 = w9/3;
			unsigned seldig = seldigs[session];
			for (unsigned i=0; i<9; i++){
				unsigned offy = g_offy + i*h9;
				lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M1,%u H%u v%u H1 Z'/>\n",i==seldig ? "pink" : "white"
					,offy,w9,h9);
				const char *color = grid_full[i] ? "lightgray" : "black";
				lines += string_f("<text x='%u' y='%u' style='stroke:%s;fill:%s;font-size:%u;font-family: Times New Roman;'>%u</text>\n"
					,w9_3,offy+font_base,color,color,font_size,i+1);
			}
			lines += "</svg>\n";
			lines += "</div>\n";
			lines += "<div style='flex:1 1 auto; overflow: hidden;' onmousedown='gameplace(event); return false;' style=color:blue;cursor:pointer>\n";
			lines += string_f("<svg id='grid-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",gameid.c_str(),grid_width,grid_height,grid_width,grid_height);
			unsigned line = 0;
			unsigned w9_2 = w9/2;
			unsigned h9_2 = h9/2;
			unsigned circle_radius = h9_2 - h9/10;
			lines += string_f("<path stroke='green' stroke-width='2' fill='white' d='M%u %u H %u V %u H %u Z'/>\n"
				,g_offx,g_offy,grid_width-1,grid_height-1,g_offx);
			for (unsigned i=0; i<9; i++){
				lines += string_f("<text x=%u y=15 style='stroke:black;fill:black;font-size:20;font-family: Times New Roman;'>%c</text>\n"
					,w9*i+w9_2+g_offx,'a'+i);
			}
			for (auto &g:grid){
				lines += string_f("<text x=0 y=%u style='stroke:black;fill:black;font-size:20;font-family: Times New Roman;'>%c</text>\n"
					,g_offy+h9*line+h9_2,'A'+line);
				lines += string_f("<path stroke=%s stroke-width=1 d='M%u,%u H %u'/>\n",line%3==0 ? "green" : "lightgray"
					,g_offx,g_offy+h9*line,grid_width);
				unsigned col = 0;
				for (auto &&gg:g){
					lines += string_f("<path stroke=%s stroke-width=1 d='M%u,%u V %u'/>\n",col%3==0 ? "green" : "lightgray"
						,g_offx+w9*col,g_offy,grid_height);
					const char *color = "white";
					const char *circle_color = "none";
					unsigned value = gg.value;
					if (gg.visible){
						color = "gray";
					}else if(gg.user_value != 0){
						color = "black";
						value = gg.user_value;
						auto a = prefs.find(gg.username);
						if (a != prefs.end()){
							color = colors[a->second.color];
							if (a->second.last_column == col && a->second.last_line == line){
								circle_color = color;
							}
						}
						if (gg.user_value != gg.value) color = "red";
					}
					unsigned w9_col = w9*col+g_offx;
					unsigned h9_line = h9*line+g_offy;
					// We always display the guess, so it can be manipulated later using notifications
					const char *guess_color = gg.user_guess == 0 ? "none" : colors[gg.guess_color];
					lines += string_f("<text id='g%u,%u' X='%u' Y='%u' style='stroke:%s;fill:%s;font-size:%u;font-family: Times New Roman;'>%u</text>\n"
						,line,col
						,w9_col+w9_3,h9_line+font_base_guess
						,guess_color,guess_color,font_size/2,gg.user_guess);
					// We always draw a circle around the number so it is easy to change its attribute later
					// By default, the circle is white.
					lines += string_f("<circle id='c%u,%u' cx=%u cy=%u r=%u stroke='%s' stroke-width=2 fill='none'/>\n"
						,line,col,w9_col+w9_2,h9_line+h9_2,circle_radius,circle_color);
					lines += string_f("<text id='%u,%u' X='%u' Y='%u' style='stroke:%s;fill:%s;font-size:%u;font-family: Times New Roman;'>%u</text>\n"
						,line,col
						,w9_col+w9_3,h9_line+font_base
						,color,color,font_size,value);
					col++;
				}
				line++;
			}
			lines += "</svg>\n";
			lines += "</div>\n";
			lines += "</div>\n";
			/*
				Colored rectangle. Each user can pick one. His name will show under the selected rectangle.
				When the user place a digit on the grid, the selected rectangle color will be used.
			*/
			//lines += "<div id=tab_form style='border: 1px solid black;'>\n";
			lines += "<div id=tab_form>\n";
			unsigned av_height=w9/2;
			unsigned av_vheight=30;
			unsigned av_fontheight=17;
			if (sp.mobile){
				av_height = w9;
				av_vheight = 60;
				av_fontheight=34;
			}
			lines += string_f("<svg onclick=avatarselect(event) id='avatar-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n"
				,gameid.c_str(),avatarw,av_height,avatarw,av_vheight);
			const char *tbusers[nbcolor]={"","","","","",""};
			for (auto &a:prefs) tbusers[a.second.color] = a.first.c_str();
			for (unsigned i=0; i<nbcolor; i++){
				unsigned x = i*avatarcw;
				lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M%u,1 h%u V%u H%u Z'/>\n",colors[i]
					,x,avatarcw-5,av_vheight/2,x);
				lines += string_f("<clipPath id='clip%u'><rect x=%u y=0 width=%u height=%u /></clipPath>\n",i,x,avatarcw-5,av_height+5);
				lines += string_f("<text x='%u' y='%u' clip-path='url(#clip%u)' style='stroke:%s;fill:%s;font-size:%u;font-family: arial;font-weight:normal;'>%s</text>\n"
					,x+5,av_vheight,i,"black","black",av_fontheight,tbusers[i]);
			}
			lines += "</svg>\n";
			lines += string_f("<div id=msg-%s style=color:white>This is a messageCeci est un message</div>\n",gameid.c_str());
			lines += "</div>\n";
		}
		VARVAL v;
		v.var = VAR_CONTENT;
		v.val = lines;
		res.push_back(v);
	}else if (maywrite){
		if (strcmp(var,"place")==0){
			unsigned lo,co,guess;
			int n = sscanf(val,"%u,%u,%u",&lo,&co,&guess);
			if (n == 3 && lo < 9 && co < 9 && (guess == 1 || guess == 2)){
				auto &gg = grid[lo][co];
				if (gg.visible){
					error = MSG_U(E_CANTSELTHISCELL,"You can't set this cell");
				}else{
					// We can set a value. If it is wrong, it will show in red.
					// If you click over again, it will erase itself.
					unsigned newval = seldigs[session]+1;
					const char *color = "black";
					const char *gcolor = "none";
					unsigned gnewval = 0;
					VARVAL var;
					var.var = VAR_NOTIFY;
					var.val = string_f ("var doc = document.getElementById('grid-%s');\n",gameid.c_str());
					var.val += "if (doc != null){\n";
					if (gg.user_value == 0){
						auto a = prefs.find(username);
						if (guess == 2){
							if (a != prefs.end()){
								if (gg.user_guess == newval && gg.guess_color == a->second.color){
									// The user erased is guess
									gg.user_guess = 0;
									gg.guess_color = 0;
									gcolor = "none";
									gnewval = 0;
								}else{
									gg.user_guess = newval;
									gg.guess_color = a->second.color;
									gcolor = colors[a->second.color];
									gnewval = newval;
								}
								color="none";
							}
						}else{
							gg.user_value = newval;
							gg.username = username;
							gg.user_guess = 0;
							gg.guess_color = 0;
							if (gg.user_value != gg.value){
								color = "red";
							}else{
								auto a = prefs.find(username);
								if (a != prefs.end()){
									color = colors[a->second.color];
									var.val += "\tvar circles = doc.getElementsByTagName('circle');\n";
									var.val += "\tfor(var i = 0; i< circles.length;i++){\n";
									var.val += "\t\tvar e = circles[i];\n";
									if (a->second.last_line != lo || a->second.last_column != co){
										// Erase the last solved cell circle
										var.val += string_f("\t\tif (e.getAttribute('id') == 'c%u,%u'){\n"
											,a->second.last_line,a->second.last_column);
										var.val += string_f("\t\t\te.style.stroke = 'none';\n");
										var.val += "\t\t}else";
									}
									// Draw the new solved cell circle
									var.val += string_f(" if (e.getAttribute('id') == 'c%u,%u'){\n",lo,co);
									var.val += string_f("\t\t\te.style.stroke = '%s';\n",color);
									var.val += "\t\t}\n";
									var.val += "\t}\n";
									a->second.last_column = co;
									a->second.last_line = lo;
								}
							}
						}
					}else if (gg.user_value == newval){
						gg.user_value = 0;
						color = "white";
					}
					setmodified(username);
					var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
					var.val += "\tfor(var i = 0; i< txts.length;i++){\n";
					var.val += "\t\tvar e = txts[i];\n";
					var.val += string_f("\t\tif (e.getAttribute('id') == 'g%u,%u'){\n",lo,co);
					var.val += string_f("\t\t\te.style.fill = '%s';\n",gcolor);
					var.val += string_f("\t\t\te.style.stroke = '%s';\n",gcolor);
					var.val += string_f("\t\t\te.textContent = '%u';\n",gnewval);
					var.val += string_f("\t\t}else if (e.getAttribute('id') == '%u,%u'){\n",lo,co);
					var.val += string_f("\t\t\te.style.fill = '%s';\n",color);
					var.val += string_f("\t\t\te.style.stroke = '%s';\n",color);
					var.val += string_f("\t\t\te.textContent = '%u';\n",newval);
					var.val += "\t\t\tbreak;\n";
					var.val += "\t\t}\n";
					var.val += "\t}\n";
					var.val += "}\n";
					// Update the digit selector on the side to tell which digits have been solved (all 9 has been found)
					compute_grid_full();
					var.val += string_f ("var doc = document.getElementById('sudosel-%s');\n",gameid.c_str());
					var.val += "if (doc != null){\n";
					var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
					for (unsigned i=0; i<9; i++){
						if (grid_full[i]){
							var.val += string_f("\ttxts[%u].style.stroke='lightgray';\n",i);
							var.val += string_f("\ttxts[%u].style.fill='lightgray';\n",i);
						}
					}
					var.val += "}\n";
					res.push_back(var);
				}
			}else{
				error = MSG_U(E_IVLDPLACESUD,"Invalid place command (need 2 value)");
			}
		}else if (strcmp(var,"select")==0){
			unsigned sel = atoi(val);
			if (sel > 0 && sel < 10){
				sel--;
				if (grid_full[sel]){
					error = MSG_U(E_ALLDIGITFOUND,"The nine positions are known for this digit");
				}else{
					seldigs[session] = sel;
					setmodified(username);
					VARVAL var;
					var.var = VAR_SCRIPT;
					var.val = string_f ("var doc = document.getElementById('sudosel-%s');\n",gameid.c_str());
					var.val += "if (doc != null){\n";
					var.val += "\tvar paths = doc.getElementsByTagName('path');\n";
					for (unsigned i=0; i<9; i++){
						var.val += string_f("\tpaths[%u].style.fill='%s';\n",i,i==sel ? "pink" : "white");
					}
					var.val += "}\n";
					res.push_back(var);
				}
			}
		}else if (strcmp(var,"avatar")==0){
			unsigned avatar = atoi(val);
			if (avatar < nbcolor){
				// User is not allowed to pick an avatar used by another user
				bool fail = false;
				for (auto &a:prefs){
					if (a.second.color == avatar && a.first != username){
						error = MSG_U(E_USEDAVATAR,"This color is already used!");
						fail = true;
						break;
					}
				}
				if (!fail){
					auto &u = prefs[username];
					unsigned old_avatar = u.color;
					u.color = avatar;
					// Change all the guess color
					for (auto &g:grid){
						for (auto &gg:g){
							if (gg.user_guess != 0 && gg.guess_color == old_avatar){
								gg.guess_color = avatar;
							}
						}
					}
					redraw_notify(res);
				}
			}else{
				documentd_error (res,"Color selection from 0 to 5");
			}
		}else if (strcmp(var,"newgame")==0){
			glocal grid;
			unsigned uval = atoi(val);
			if (uval > 3){
				documentd_error (res,"Difficulty from 0 to 3");
			}else{
				difficulty = uval;
				static const char *tbdiff[]={"simple", "easy", "intermediate", "expert"};
				<call walkpopen>(string_f("qqwing --generate 1 --compact --solution --difficulty %s",tbdiff[difficulty]),10);
				<f oneline>
					debug_printf (D_SUDOKU,"read qqwing %s\n",line);
					if (noline < 9){
						auto &g = glocal.grid[noline];
						for (unsigned i=0; i<9; i++){
							char car = line[i];
							auto &gg = g[i];
							gg.reset();
							if (car != '.'){
								gg.visible = 1;
								gg.value = car - '0';
							}
						}
					}
					if (noline >= 10 && noline < 19){
						auto &g = glocal.grid[noline-10];
						for (unsigned i=0; i<9; i++){
							g[i].value = line[i]-'0';
						}				
					}
					return 0;
				</f>
				<f oneerr>
					tlmp_error ("sudoku command=%s line=%s\n",command,line);
					return 0;
				</f>
				</call>
				setmodified(username);
				redraw_notify(res);
			}
		}else{
			tlmp_error ("sudoku invalid command %s\n",var);
		}
	}else{
		error = MSG_U(E_READONLY,"You do not have write access to this game");
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else{
		update_msg(false,"","white",res);
	}
		
}
</mod>

