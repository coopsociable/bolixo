#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;

#include "proto/documentd_sudoku.protoh"
#define documentd_sudoku_cell_NOTNEED
#define documentd_sudoku_header_NOTNEED
#include "proto/documentd_sudoku.protoch"

static DEBUG_KEY D_SUDOKU("sudoku","sudoku game");

void SUDOKU::save (DOC_WRITER &w, bool save_session_info)
{
	documentd_sudoku_header2(&w,revision,difficulty);
	if (save_session_info){
		for (auto &s:seldigs){
			documentd_sudoku_select(&w,s.first,s.second);
		}
	}
	vector<USERAVATAR> users;
	for (auto &a:prefs){
		USERAVATAR u;
		u.name = a.first;
		u.avatar = a.second.color;
		u.last_column = a.second.last_column;
		u.last_line = a.second.last_line;
		users.emplace_back(u);
	}
	documentd_sudoku_userpref (&w,users);
	for (auto &g:grid){
		for (auto &gg:g) documentd_sudoku_cell2(&w,gg.visible,gg.value,gg.user_value,gg.username);
	}
}
<mod>
void SUDOKU::load (DOC_READER &r, string &msg)
{
	glocal grid;
	glocal msg;
	glocal unsigned x=0;
	glocal unsigned y=0;
	glocal seldigs;
	glocal revision;
	glocal difficulty;
	glocal prefs;
	resetgame();
	<call documentd_sudoku>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f header2>
		glocal.revision = revision;
		glocal.difficulty = difficulty;
	</f>
	<f cell>
		if (glocal.x > 8){
			glocal.msg = "Too many cells in the sodoku files";
			end  = true;
		}else{
			SUDOKU_CELL &gg = glocal.grid[glocal.x][glocal.y];
			gg.visible = visible;
			gg.value = value;
			gg.user_value = user_value;
			glocal.y = (glocal.y+1)%9;
			if (glocal.y == 0) glocal.x++;
		}
	</f>
	<f cell2>
		if (glocal.x > 8){
			glocal.msg = "Too many cells in the sodoku files";
			end  = true;
		}else{
			SUDOKU_CELL &gg = glocal.grid[glocal.x][glocal.y];
			gg.visible = visible;
			gg.value = value;
			gg.user_value = user_value;
			gg.username = username;
			glocal.y = (glocal.y+1)%9;
			if (glocal.y == 0) glocal.x++;
		}
	</f>
	<f select>
		glocal.seldigs[session] = value;
	</f>
	<f userpref>
		for (auto &u:prefs){
			auto &p = glocal.prefs[u.name];
			p.color = u.avatar;
			p.last_column = u.last_column;
			p.last_line = u.last_line;
		}
	</f>
	<f invalid>
		glocal.msg = "Invalid format for sudoku file";
	</f>
	</call>
}
void SUDOKU::resetgame()
{
	//line = column = 0;
	seldigs.clear();
	prefs.clear();
	for (auto &g:grid){
		for (auto &gg:g){
			gg.reset();
		}
	}
}
void SUDOKU::testwin(vector<VARVAL> &res)
{
	unsigned nbok = 0;
	for (auto &g:grid){
		for (auto &gg:g){
			if (gg.visible || (gg.value != 0 && gg.value == gg.user_value)) nbok++;
		}
	}
	if (nbok == 9*9){
		VARVAL v;
		v.var = VAR_RESULT;
		v.val = MSG_U(I_COMPLETE,"Congratulation! You completed the puzzle");
		res.push_back(v);
	}
}
<mod>
void SUDOKU::exec (const char *var, const char *val, const char *session, const char *username, bool maywrite, unsigned win_width, unsigned win_height, vector<VARVAL> &res)
{
	const unsigned nbcolor=6;
	static const char *colors[nbcolor]={"black","green","blue","orange","lightblue","lightgreen"};
	setactivity();
	//tlmp_error ("SUDOKU var %s val %s username %s maywrite %d",var,val,username,maywrite);
	/*
		We check if the user has selected a color. If not, we assign the first available
	*/
	{
		auto a = prefs.find(username);
		if (a == prefs.end()){
			bool takens[nbcolor] = {false,false,false,false,false,false};
			for (auto &a:prefs) takens[a.second.color] = true;
			for (unsigned i=0; i<nbcolor; i++){
				if (!takens[i]){
					prefs[username].color = i;
					break;
				}
			}
		}
	}
			
	if (strcmp(var,"print")==0){
		string lines;
		if (strcmp(val,"console")==0){
			static const char *dashes = "\t+---+---+---+---+---+---+---+---+---+\n";	
			unsigned nol = 0;
			static const char *white = "\033[01;37m";
			static const char *green = "\033[01;32m";
			static const char *blue = "\033[01;34m";
			static const char *red = "\033[01;31m";
			//	static const char *bgblue = "\033[01;44m";
			static const char *normal = "\033[00m";
			for (auto &g:grid){
				if (nol % 3 == 0){
					lines += blue;
					lines += dashes;
					lines += normal;
				}else{
					lines += '\t';
					for (unsigned i=0; i<9; i++){
						if (i % 3 == 0){
							lines += blue;
						}else{
							lines += green;
						}
						lines += '+';
						lines += green;
						lines += "---";
					}
					lines += blue;
					lines += '+';
					lines += normal;
					lines += '\n';
				}
				lines += "\t";
				unsigned pos = 0;
				for (auto &gg:g){
					if (pos % 3 == 0){
						lines += blue;
						lines += '|';
					}else{
						lines += green;
						lines += '|';
					}
					lines += normal;
					//if (nol / 3 == line && pos / 3 == column) lines += bgblue;
					if (gg.visible){
						lines += string_f("%s %c %s",white,gg.value+'0',normal);
					}else if (gg.user_value != 0){
						if (gg.user_value != gg.value){
							lines += red;
						}
						lines += string_f(" %c ",gg.user_value+'0');
						lines += normal;
					}else{
						lines += "   ";
					}
					lines += normal;
					pos++;
				}
				lines += blue;
				lines += "|\n";
				lines += normal;
				nol++;
			}
			lines += blue;
			lines += dashes;
			lines += normal;
		}else{
			// The layout is a square, constrained by the width
			unsigned dim = win_width < win_height ? win_width : win_height;
			unsigned width = dim - dim % 11;
			unsigned w9 = width/11;
			unsigned h9 = w9; 
			unsigned grid_width = w9*9;
			unsigned grid_height = grid_width;
			unsigned avatarw = w9*10;
			unsigned avatarcw = avatarw/6;
			
			lines += "<script>\n";
			lines += "function gameselect(event){\n";
			lines += "\tvar elm = document.getElementById('gamesudosel');\n";
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('select='+Math.floor((event.clientY-rect.top)/%u+1));\n",h9);
			lines += "}\n";
			lines += "function avatarselect(event){\n";
			lines += "\tvar elm = document.getElementById('avatarsudosel');\n";
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('avatar='+Math.floor((event.clientX-rect.left)/%u));\n",avatarcw);
			lines += "}\n";
			lines += "function gameplace(event){\n";
			lines += string_f("\tvar elm = document.getElementById('%s');\n",gameid.c_str());
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('place='+Math.floor((event.clientY-rect.top)/%u)+','+Math.floor((event.clientX-rect.left)/%u));\n",h9,w9);
			lines += "\tevent.stopPropagation();\n";
			lines += "}\n";
			lines += "</script>\n";
			
			lines += "<p>\n";
			lines += "<form>\n";
			lines += MSG_U(I_NEWGAME,"New game");
			documentd_button (lines,0,MSG_U(I_SIMPLE,"Simple"),difficulty==0);
			documentd_button (lines,1,MSG_U(I_EASY,"Easy"),difficulty==1);
			documentd_button (lines,2,MSG_U(I_INTERMEDIATE,"Intermediate"),difficulty==2);
			documentd_button (lines,3,MSG_U(I_EXPERT,"Expert"),difficulty==3);
			lines += "</form>\n";
			lines += "<p>";
			lines += "<div style='display:flex; flex-flow:row;'>\n";
			lines += "<div style='flex:1 1 auto; overflow: hidden;'>\n";
			lines += "<a href='#' onclick=gameselect(event)>\n";
			lines += string_f("<svg id='gamesudosel' width='%upx' height='%upx' viewbox='0 0 30 270'>\n",w9,grid_height);
			unsigned seldig = seldigs[session];
			for (unsigned i=0; i<9; i++){
				lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M1,%u H29 v29 H1 Z'/>\n",i==seldig ? "pink" : "white"
					,i*30);
				lines += string_f("<text x='10' y='%u' style='stroke:%s;fill:%s;font-size:20;font-family: Times New Roman;'>%u</text>\n",i*30+20,"black","black",i+1);
			}
			lines += "</svg>\n";
			lines += "</a>";
			lines += "</div>\n";
			lines += "<div style='flex:1 1 auto; overflow: hidden;'>\n";
			lines += "<a href='#' onclick=gameplace(event)>\n";
			lines += string_f("<svg id='%s' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",gameid.c_str(),grid_width,grid_height,grid_width,grid_height);
			lines += string_f("<path stroke='green' stroke-width='2' fill='white' d='M1 1 H %u V %u H 1 Z'/>\n",grid_width-1,grid_height-1);
			unsigned line = 0;
			unsigned font_size = h9*6/10;
			unsigned font_base = h9*7/10;
			unsigned w9_3 = w9/3;
			unsigned w9_2 = w9/2;
			unsigned h9_2 = h9/2;
			unsigned circle_radius = h9_2 - h9/10;
			for (auto &g:grid){
				lines += string_f("<path stroke=%s stroke-width=1 d='M0,%u H %u'/>\n",line%3==0 ? "green" : "lightgray"
					,h9*line,grid_width);
				unsigned col = 0;
				for (auto &&gg:g){
					lines += string_f("<path stroke=%s stroke-width=1 d='M%u,0 V %u'/>\n",col%3==0 ? "green" : "lightgray"
						,w9*col,grid_height);
					const char *color = "white";
					const char *circle_color = "none";
					unsigned value = gg.value;
					if (gg.visible){
						color = "gray";
					}else if(gg.user_value != 0){
						color = "black";
						value = gg.user_value;
						auto a = prefs.find(gg.username);
						if (a != prefs.end()){
							color = colors[a->second.color];
							if (a->second.last_column == col && a->second.last_line == line){
								circle_color = color;
							}
						}
						if (gg.user_value != gg.value) color = "red";
					}
					// We always draw a circle around the number so it is easy to change its attribute later
					// By default, the circle is white.
					unsigned w9_col = w9*col;
					unsigned h9_line = h9*line;
					lines += string_f("<circle id='c%u,%u' cx=%u cy=%u r=%u stroke='%s' stroke-width=2 fill='none'/>\n"
						,line,col,w9_col+w9_2,h9_line+h9_2,circle_radius,circle_color);
					lines += string_f("<text id='%u,%u' X='%u' Y='%u' style='stroke:%s;fill:%s;font-size:%u;font-family: Times New Roman;'>%u</text>\n"
						,line,col
						,w9_col+w9_3,h9_line+font_base
						,color,color,font_size,value);
					col++;
				}
				line++;
			}
			lines += "</svg>\n";
			lines += "</a>\n";
			lines += "</div>\n";
			lines += "</div>\n";
			/*
				Colored rectangle. Each user can pick one. His name will show under the selected rectangle.
				When the user place a digit on the grid, the selected rectangle color will be used.
			*/
			lines += "<div>\n";
			lines += "<a href='#' onclick=avatarselect(event)>\n";
			lines += string_f("<svg id='avatarsudosel' width='%upx' height='%upx' viewbox='0 0 %u 30'>\n",avatarw,w9/2,avatarw);
			const char *tbusers[nbcolor]={"","","","","",""};
			for (auto &a:prefs) tbusers[a.second.color] = a.first.c_str();
			for (unsigned i=0; i<nbcolor; i++){
				unsigned x = i*avatarcw;
				lines += string_f("<path stroke='black' stroke-width='2' fill='%s' d='M%u,1 h%u V%u H%u Z'/>\n",colors[i]
					,x,avatarcw-5,15,x);
				lines += string_f("<clipPath id='clip%u'><rect x=%u y=0 width=%u height=35 /></clipPath>\n",i,x,avatarcw-5);
				lines += string_f("<text x='%u' y='30' clip-path='url(#clip%u)' style='stroke:%s;fill:%s;font-size:17;font-family: arial;font-weight:normal;'>%s</text>\n"
					,x+5,i,"black","black",tbusers[i]);
			}
			lines += "</svg>\n";
			lines += "</a>";
			lines += "</div>\n";
		}
		VARVAL v;
		v.var = VAR_CONTENT;
		v.val = lines;
		res.push_back(v);
	}else if (maywrite){
		if (strcmp(var,"place")==0){
			unsigned lo,co,v;
			int n = sscanf(val,"%u,%u,%u",&lo,&co,&v);
			if (n == 2){
				auto &gg = grid[lo][co];
				if (gg.visible){
					documentd_error (res,MSG_U(E_CANTSELTHISCELL,"You can't set this cell"));
				}else{
					// We can set a value. If it is wrong, it will show in red.
					// If you click over again, it will erase itself.
					unsigned newval = seldigs[session]+1;
					const char *color = "black";
					VARVAL var;
					var.var = VAR_NOTIFY;
					var.val = string_f ("var doc = document.getElementById('%s');\n",gameid.c_str());
					var.val += "if (doc != null){\n";
					if (gg.user_value == 0){
						gg.user_value = newval;
						gg.username = username;
						if (gg.user_value != gg.value){
							color = "red";
						}else{
							auto a = prefs.find(username);
							if (a != prefs.end()){
								color = colors[a->second.color];
								var.val += "\tvar circles = doc.getElementsByTagName('circle');\n";
								var.val += "\tfor(var i = 0; i< circles.length;i++){\n";
								var.val += "\t\tvar e = circles[i];\n";
								if (a->second.last_line != lo || a->second.last_column != co){
									// Erase the last solved cell circle
									var.val += string_f("\t\tif (e.getAttribute('id') == 'c%u,%u'){\n"
										,a->second.last_line,a->second.last_column);
									var.val += string_f("\t\t\te.style.stroke = 'none';\n");
									var.val += "\t\t}else";
								}
								// Draw the new solved cell circle
								var.val += string_f(" if (e.getAttribute('id') == 'c%u,%u'){\n",lo,co);
								var.val += string_f("\t\t\te.style.stroke = '%s';\n",color);
								var.val += "\t\t}\n";
								var.val += "\t}\n";
								a->second.last_column = co;
								a->second.last_line = lo;
							}
						}
					}else if (gg.user_value == newval){
						gg.user_value = 0;
						color = "white";
					}
					setmodified(username);
					var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
					var.val += "\tfor(var i = 0; i< txts.length;i++){\n";
					var.val += "\t\tvar e = txts[i];\n";
					var.val += string_f("\t\tif (e.getAttribute('id') == '%u,%u'){\n",lo,co);
					var.val += string_f("\t\t\te.style.fill = '%s';\n",color);
					var.val += string_f("\t\t\te.style.stroke = '%s';\n",color);
					var.val += string_f("\t\t\te.textContent = '%u';\n",newval);
					var.val += "\t\t\tbreak;\n";
					var.val += "\t\t}\n";
					var.val += "\t}\n";
					var.val += "}\n";
					res.push_back(var);
				}
			}else{
				documentd_error (res,MSG_U(E_IVLDPLACESUD,"Invalid place command (need 2 value)"));
			}
		}else if (strcmp(var,"select")==0){
			unsigned sel = atoi(val);
			if (sel > 0 && sel < 10){
				seldigs[session] = sel-1;
				setmodified(username);
			}
		}else if (strcmp(var,"avatar")==0){
			unsigned avatar = atoi(val);
			if (avatar < nbcolor){
				// User is not allowed to pick an avatar used by another user
				bool fail = false;
				for (auto &a:prefs){
					if (a.second.color == avatar && a.first != username){
						documentd_error (res,MSG_U(E_USEDAVATAR,"This color is already used!"));
						fail = true;
						break;
					}
				}
				if (!fail) prefs[username].color = avatar;
			}else{
				documentd_error (res,"Color selection from 0 to 5");
			}
		}else if (strcmp(var,"newgame")==0){
			glocal SUDOKU_CELL (*grid)[9][9] = &grid;
			unsigned uval = atoi(val);
			if (uval > 3){
				documentd_error (res,"Difficulty from 0 to 3");
			}else{
				difficulty = uval;
				static const char *tbdiff[]={"simple", "easy", "intermediate", "expert"};
				<call walkpopen>(string_f("qqwing --generate 1 --compact --solution --difficulty %s",tbdiff[difficulty]),10);
				<f oneline>
					debug_printf (D_SUDOKU,"read qqwing %s\n",line);
					if (noline < 9){
						auto &g = (*glocal.grid)[noline];
						for (unsigned i=0; i<9; i++){
							char car = line[i];
							auto &gg = g[i];
							gg.reset();
							if (car != '.'){
								gg.visible = 1;
								gg.value = car - '0';
							}
						}
					}
					if (noline >= 10 && noline < 19){
						auto &g = (*glocal.grid)[noline-10];
						for (unsigned i=0; i<9; i++){
							g[i].value = line[i]-'0';
						}				
					}
					return 0;
				</f>
				<f oneerr>
					tlmp_error ("sudoku command=%s line=%s\n",command,line);
					return 0;
				</f>
				</call>
				setmodified(username);
				VARVAL var;
				var.var = VAR_NOTIFY;
				var.val = string_f ("var doc = document.getElementById('%s');\n",gameid.c_str());
				var.val += "if (doc != null){\n";
				var.val += "\tvar circles = doc.getElementsByTagName('circle');\n";
				var.val += "\tfor(var i = 0; i< circles.length;i++){\n";
				var.val += "\t\tvar e = circles[i];\n";
				var.val += string_f("\t\t\te.style.stroke = 'none';\n");
				var.val += "\t}\n";
				var.val += "\tvar txts = doc.getElementsByTagName('text');\n";
				unsigned item = 0;
				for (auto &g:grid){
					for (auto &&gg:g){
						var.val += string_f ("\tvar e = txts[%u];\n",item);
						const char *color = gg.visible ? "gray" : "white";
						var.val += string_f("\te.style.fill = '%s';\n",color);
						var.val += string_f("\te.style.stroke = '%s';\n",color);
						var.val += string_f("\te.textContent = '%u';\n",gg.value);
						item++;
					}
				}
				var.val += "}\n";
				res.push_back(var);
			}
		}else{
			tlmp_error ("sudoku invalid command %s\n",var);
		}
	}else{
		documentd_error (res,MSG_U(E_READONLY,"You do not have write access to this game"));
	}
		
}
</mod>

