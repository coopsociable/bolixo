/*
	Sample shell like interpretor to test BOLIBFS
*/
#include <string.h>
#include <misc.h>
#include <tlmplib.h>
#include "bolibfs.h"
#include "bolixo.h"
#include "bolixo.m"

/*
	Help build a path from a current working directory and an argument.
	The argument be be an absolute path or not.
*/
class BOFSPATH: public SSTRING{
public:
	BOFSPATH (const SSTRING  &cwd, const SSTRING &sub);
};

PUBLIC BOFSPATH::BOFSPATH (const SSTRING  &cwd, const SSTRING &sub)
{
	const char *dir = sub.get();
	SSTRING tmp;
	if (dir[0] != '/'){
		const char *p = cwd.get();
		p = ::strrchr(p,'/');
		if (p != NULL && p[1] == '\0'){
			// The path ends with /
			tmp.setfromf ("%s%s",cwd.get(),sub.get());
		}else{
			tmp.setfromf ("%s/%s",cwd.get(),sub.get());
		}
		dir = tmp.get();
	}
	setfrom (dir);
}


<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal SSTRING user;
	glocal SSTRING passwd;
	glocal SSTRING server;
	glocal SSTRING port;
	glocal SSTRING document;
	glocal bool connect=false;
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("boshell",version
			,MSG_U(I_BOSHELL
				,"Interprèteur de commande pour documents bolixo"));
		setdbconfname ("bolixo");
		glocal.server = linuxconf_getval(D_DEFAULT,D_SERVER,"localhost");
		glocal.port = linuxconf_getval(D_DEFAULT,D_PORT,"9876");
		glocal.user = linuxconf_getval(D_DEFAULT,D_USER,"");
		glocal.passwd = linuxconf_getval(D_DEFAULT,D_PASSWORD,"");

		setarg ('c',"connect",MSG_U(I_CONNECT,"Établie la connexion"),glocal.connect,false);
		setarg ('d',"document",MSG_R(I_DOCUMENT),glocal.document,false);
		setarg ('p',"password",MSG_R(I_PASSWD),glocal.passwd,false);
		setarg ('P',"port",MSG_U(I_PORT,"Port TCP"),glocal.port,false);
		setarg ('s',"server",MSG_U(I_SERVER,"Serveur"),glocal.server,false);
		setarg ('u',"user",MSG_U(I_USER,"Usager"),glocal.user,false);
	</f>
	<f main_noarg>
		glocal int ret = -1;
		char line[1000];
		SSTRING cwd = "/";
		BOLIBFS bofs;
		bofs.setserver (glocal.server.get());
		bofs.setport (glocal.port.get());
		bofs.setuser (glocal.user.get());
		bofs.setpasswd (glocal.passwd.get());
		bofs.setdocument (glocal.document.get());
		if (glocal.connect){
			SSTRING errmsg;
			if (bofs.connect(errmsg)!=-1){
				fprintf (stderr,MSG_R(I_CONOK));
			}else{
				fprintf (stderr,MSG_R(E_ERRCON),errmsg.get());
			}
		}
		while (1){
			printf ("bolixo> "); fflush (stdout);
			if (fgets(line,sizeof(line)-1,stdin)==NULL) break;
			SSTRING word,arg1;
			const char *pt = str_copyword (word,line);
			pt = str_skip(pt);
			if (pt[0] == '"'){
				pt = str_copyquote (arg1,pt);
			}else{
				pt = str_copyword (arg1,pt);
			}
			if (word.cmp("quit")==0){
				break;
			}else if (word.cmp("help")==0){
				printf (
					"cat document\n"
					"cd dir\n"
					"ls [ dir ]\n"
					"connect\n"
					"help\n"
					"pwd\n"
					"set document document-name\n"
					"set user user-id\n"
					"set passwd password\n"
					"set server server-name or IP number\n"
					"set port TCP-port name or number\n"
					"status\n"
					);
			}else if (word.cmp("status")==0){
				printf ("document=%s\n",glocal.document.get());
				printf ("user=%s\n",glocal.user.get());
				printf ("password=%s\n"
					,glocal.passwd.is_filled() ? "****"
						: MSG_U(I_NOPWDSET,"Pas de mot de passe"));
				printf ("server=%s\n",glocal.server.get());
				printf ("port=%s\n",glocal.port.get());
				printf ("%s\n"
					,bofs.is_connected()
						? MSG_U(I_CONNECTON,"Connexion active")
						: MSG_U(I_CONNECTOFF,"Pas connecté au serveur"));
			}else if (word.cmp("set")==0){
				SSTRING arg2;
				pt = str_copyword (arg2,pt);
				if (arg2.is_empty()){
					fprintf (stderr,MSG_U(E_SETNEEDARG,"\"set %s\" demande un argument supplémentaire\n")
						,arg1.get());
				}else if (arg1.cmp("document")==0){
					glocal.document = arg2;
					bofs.setdocument (arg2.get());
				}else if (arg1.cmp("user")==0){
					glocal.user = arg2;
					bofs.setuser (arg2.get());
				}else if (arg1.cmp("passwd")==0){
					glocal.passwd = arg2;
					bofs.setpasswd (arg2.get());
				}else if (arg1.cmp("server")==0){
					glocal.server = arg2;
					bofs.setserver (arg2.get());
				}else if (arg1.cmp("port")==0){
					glocal.port = arg2;
					bofs.setport (arg2.get());
				}else{
					fprintf (stderr,MSG_U(E_IVLDSETCMD,"Commande \"set\" invalide: %s\n")
						,arg1.get());
				}
			}else if (word.cmp("connect")==0){
				if (glocal.server.is_empty()){
					fprintf (stderr,MSG_U(E_NOSERVER,"Le serveur n'est pas précisé\n"));
				}else if (glocal.port.is_empty()){
					fprintf (stderr,MSG_U(E_NOPORT,"Le port TCP n'est pas précisé\n"));
				}else if (glocal.user.is_empty()){
					fprintf (stderr,MSG_U(E_NOUSERDEF,"Le code usager n'est pas précisé\n"));
				}else if (glocal.passwd.is_empty()){
					fprintf (stderr,MSG_U(E_NOPASSWDDEF,"Le mot de passe n'est pas précisé\n"));
				}else if (glocal.document.is_empty()){
					fprintf (stderr,MSG_U(E_NODOCUMENT,"Le document n'est pas précisé\n"));
				}else{
					SSTRING errmsg;
					if (bofs.connect(errmsg)!=-1){
						fprintf (stderr,MSG_U(I_CONOK,"La connexion est établie\n"));
					}else{
						fprintf (stderr,MSG_U(E_ERRCON,"La connexion a échoué: %s\n")
							,errmsg.get());
					}
				}
			}else if (word.cmp("pwd")==0 && arg1.is_empty()){
				printf ("%s\n",cwd.get());
			}else if (word.cmp("cd")==0 && arg1.is_filled()){
				BOFSPATH p (cwd,arg1);
				if (!bofs.maycd(p.get())){
					fprintf (stderr,MSG_U(E_NODIR,"Pas de répertoire %s\n"),p.get());
				}else{
					cwd = p;
				}
			}else if (word.cmp("ls")==0){
				BOFSPATH p (cwd,arg1);
				BOLIBNODES tb;
				bofs.ls (p.get(),tb);
				tb.sort_by_name();
				for (int i=0; i<tb.size(); i++){
					BOLIBNODE *n = tb.getitem(i);
					printf ("  %s %s %s\t%s\n",n->uuid.get()
						,n->type.get(),n->modif.get(),n->name.get());
				}
			}else if (word.cmp("cat")==0){
				BOFSPATH p (cwd,arg1);
				SSTRING tmp;
				bofs.read (p.get(),tmp);
				printf ("%s\n",tmp.get());
			}else if (word.is_filled()){
				fprintf (stderr,MSG_U(E_IVLDCOMMAND,"Commande invalide: %s\n")
					,line);
			}
		}
		return glocal.ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>


