/*
	This program update databases. It also the only one which can read the users database.
	This program was copied from the truelies project. This explains the trli_ strings here
	and there.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <syslog.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <tlmplib.h>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <tlmpnet.h>
#include <tlmpsql.h>
#include <trlitool.h>
#include "filesystem.h"

static DEBUG_KEY D_PROTO ("proto","Protocol information");
enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT };

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	int no;
	std::string host;
	REQUEST_INFO req;
	HANDLE_INFO(){
		no = -1;
		type = TYPE_NONE;
	}
};

#include "proto/bo-writed_control.protoh"
#include "proto/bo-writed_client.protoh"

using namespace std;

#define bo_sessiond_admin_getsessioninfo_NOTNEED
#include "proto/bo-sessiond_admin.protoch"
#include "proto/bo-log.protoch"
//#include "proto/bo-log-admin.protoch"

/*
	Get the userid associated with the sessionid
*/
<mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, string &userid_str, bool &is_admin)
{
	glocal unsigned userid = 0;
	glocal string *userid_str = &userid_str;
	glocal bool is_admin = false;
	<call bo_sessiond_admin_getsession>(con,sessionid);
	<f ok>
		glocal.userid = userid;
		(*glocal.userid_str) = userid_str;
		glocal.is_admin = admin;
	</f>
	</call>
	is_admin = glocal.is_admin;
	return glocal.userid;
}
</mod>
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, bool &is_admin)
{
	string tmp;
	return trli_getsessionuser (con,sessionid,tmp,is_admin);
}
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid, string &userid_str)
{
	bool is_admin;
	return trli_getsessionuser (con,sessionid,userid_str,is_admin);
}
static unsigned trli_getsessionuser (CONNECT_INFO &con, const char *sessionid)
{
	string tmp;
	bool is_admin;
	return trli_getsessionuser (con,sessionid,tmp,is_admin);
}

#if 0
<mod>
static bool trli_isadmin (NSQL *sq, unsigned userid)
{
	glocal bool ret = false;
	<call sql_query>(*sq,"select admin from users where userid=%u",userid);
	<f onerow>
		if (strcmp(row[0],"1")==0) glocal.ret = true;
	</f>
	</call>
	return glocal.ret;
}
</mod>
#endif

static int writed_mail_newaccount(
	const char *mailserver,
	const char *mailport,
	const char *mailfrom,
	const char *nickname,
	const char *email,
	PARAM_STRING id_str)
{
	string tmp = string_f(
		"Hello!\r\n"
		"\r\n"
		"You just created an account using nickname %s on bolixo.org\r\n"
		"Just click on the link below to confirm the account.\r\n"
		"<a href=https://%s/index.hc?webstep=10&confirm=%s>confirm</a>\r\n"
		"\r\n"
		"Once done, you will be allowed to fully participate in the validation\r\n"
		"of all the news out there.\r\n"
		"\r\n"
		"Thanks for joining!\r\n"
		,nickname
		,"bolixo.org",id_str.ptr);
	return fdpass_sendmail (mailserver,mailport,mailfrom,email
		,"Account confirmation on bolixo.org"
		,tmp);
};
static int bo_writed_findentry (CONNECT_INFO &con, const char *sessionid, const char *name, ENTRY &entry, bool expect_exist)
{
	int ret = -1;
	entry.userid = trli_getsessionuser(con,sessionid,entry.is_admin);
	if (entry.userid == 0){
		entry.msg = "Invalid session";
	}else{
		ret = fs_findentry(name,entry,expect_exist,"");
	}
	return ret;
}
struct DIRENTRY{
	int itemid;
	std::string modified;
	ENTRY_TYPE type;
	DIRENTRY (int _itemid, const char *_modified, ENTRY_TYPE _type){
		itemid = _itemid;
		modified = _modified;
		type = _type;
	}
	DIRENTRY(){
		itemid = -1;
		type = ENTRY_NONE;
	}
};
struct DIR_2_CREATE{
	string name;
	int parent_dirid;
	int dirid_2_copy;
	DIR_2_CREATE(PARAM_STRING _name, int _parent_dirid, int _dirid_2_copy){
		name = _name.ptr;
		parent_dirid = _parent_dirid;
		dirid_2_copy = _dirid_2_copy;
	}
};
<mod>
static int bo_writed_copydir (
	int dirid,		// Directory to copy
	int target_dirid,	// parent directory which will receive the new directory
	const string &dirname,	// Name of the directory to create in the target_dirid
	unsigned userid,
	string &msg)
{
	int ret = 0;
	vector<DIR_2_CREATE> todo;		// Sub-directories to copy
	todo.push_back(DIR_2_CREATE(dirname,target_dirid,dirid));
	while (todo.size() > 0){
		DIR_2_CREATE &d = todo[0];
		glocal map<string,DIRENTRY> res;
		<call sql_query>("select name,itemid,modified,type from dirs_content where dirid=%d order by eventtime",d.dirid_2_copy);
		<f onerow>
			glocal.res[row[0]] = DIRENTRY(atoi(row[1]),row[2],(ENTRY_TYPE)atoi(row[3]));
		</f>
		</call>
		int newdirid = fs_newid (userid,msg);
		if (newdirid == -1){
			ret = -1;
			break;
		}else{
			if (fs_insert_dir (d.parent_dirid,newdirid,d.name)==-1){
				msg = "Internal error (dirs_content table)";
			}else{
				for (auto &r:glocal.res){
					if (bolixo_isdir(r.second.type)){
						todo.push_back(DIR_2_CREATE(r.first,newdirid,r.second.itemid));
					}else if (bolixo_isfile(r.second.type)){
						if (fs_insert_entry (newdirid,r.second.itemid,r.second.modified,r.first,r.second.type)==-1){
							msg = "Internal error (dirs_content table)";
							ret = -1;
							todo.clear();
							break;
						}
					}
				}	
			}
		}
		if (todo.size() > 0) todo.erase (todo.begin());
	}
	return ret;
}
</mod>
/*
	Identify the userid who will perform some group administration.
	Normally, user are only allowed to work on list they own.
	But administrator can work on behalf of another user. The parameter "owner" is the other user.
	For normal user, this parameter is ignored.

	Return 0 if not a valid userid (sessionid is invalid)
*/
<mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &username, string &msg)
{
	glocal string *username = &username;
	glocal string *msg = &msg;
	bool is_admin;
	glocal unsigned userid = trli_getsessionuser (con,sessionid,is_admin);
	if (is_admin && owner[0] != '\0'){
		<call sql_query>("select userid from id2name where name='%s'",owner);
		<f onerow>
			glocal.userid = atoi(row[0]);
		</f>
		<f empty>
			glocal.userid = 0;
		</f>
		</call>
		if (glocal.userid == 0) msg = "Unknown owner";
		username = owner;
	}else if (glocal.userid != 0){
		<call sql_query>("select name from id2name where userid=%u",glocal.userid);
		<f onerow>
			(*glocal.username) = row[0];
		</f>
		<f empty>
			(*glocal.msg) = "Can't find username";
			glocal.userid = 0;
		</f>
		</call>
	}
	return glocal.userid;
}
</mod>
static unsigned bo_writed_get_group_owner (CONNECT_INFO &con, const char *sessionid, const char *owner, string &msg)
{
	string username;
	return bo_writed_get_group_owner (con,sessionid,owner,username,msg);
}

static void bo_writed_set_msgid(string &msgid, const char *replyto)
{
	// replyto may be the original message, or a reply to the original messages
	// So it may be xxxx or xxxx:yyyy
	if (replyto != NULL){
		const char *pt = strchr(replyto,':');
		string tmp;
		if (pt != NULL){
			tmp = string(replyto,pt-replyto);
			replyto = tmp.c_str();
		}
		msgid = string_f("%s:%s",replyto,msgid.c_str());
	}
}

/*
	Send a message to a project or reply to a message of a project
*/
<mod>
static int bo_writed_project_msg(
	CONNECT_INFO &con,
	const char *sessionid,
	const char *owner,
	const char *manager,
	const char *project,
	const char *role,
	const char *replyto,		// Message ID or NULL
	const char *title,
	const char *content,
	string &msg,
	string &msgid)
{
	/*
		We send a message this way
		-We write the message in the outbox as en ENTRY_FILE
		-We copy it to destination inbox as ENTRY_MSG
		Any copy of the message elsewhere will do done as ENTRY_FILE.
		So when replying to a message ID, we can locate the inbox using a single select
	*/
	int ret = -1;
	msg = "Invalid session";
	string username;
	glocal unsigned userid = bo_writed_get_group_owner (con, sessionid, owner, username,msg);
	if (glocal.userid != 0){
		int ownerid = fs_rec_getid ("select userid from id2name where name='%s'",manager);
		if (ownerid == -1){
			msg = "Unkown user";
		}else{
			vector<INBOX> inboxes;
			vector<unsigned> listids;
			fs_list_inboxes(glocal.userid,inboxes,listids);
			int dirid = -1;
			int listid = -1;
			msg = "Invalid destination/inbox";
			for (unsigned i=0; i<inboxes.size(); i++){
				INBOX &inb = inboxes[i];
				if (inb.manager.compare(manager)==0
					&& inb.project.compare(project)==0
					&& (role[0] == '\0' || inb.role.compare(role)==0)){
					// Now we can write the message
					listid = listids[i];
					int project_dirid = fs_find_project_inbox (ownerid, listid,manager, project, role, true,msg);
					if (project_dirid != -1){
						if (replyto != NULL && fs_rec_getid ("select itemid from dirs_content where dirid=%d and name='%s'"
                                                	,project_dirid,replyto)==-1){
                                        		msg = "replyto: Unknown message";
						}else{
							dirid = project_dirid;
						}
						/*
							We tought about puting replies into a sub-directories (msgid.dir)
							and decided otherwise. Instead we put it in the same directory
							but using the replyto as a prefix for the file name
						*/
						#if 0
						if (replyto == NULL){
							dirid = project_dirid;
						}else{
							int subdir_id = fs_rec_getid ("select itemid from dirs_content where dirid=%d and name='%s.dir'",project_dirid,replyto);
							if (subdir_id != -1){
								dirid = subdir_id;
							}else{
								// The msg.dir directory does not exist, we must create it.
								// But first, check if the replyto message is there
								int replyto_id = fs_rec_getid ("select itemid from dirs_content where dirid=%d and name='%s'",project_dirid,replyto);		
								if (replyto_id == -1){
									msg = "Message not found in project inbox";
								}else{
									string uuid;
									subdir_id = fs_newid (glocal.userid,listid,'r',msg,uuid);
									if (subdir_id != -1){
										string dirname = string_f ("%s.dir",replyto);
										if (fs_insert_dir (project_dirid,subdir_id,dirname)==-1){
											msg = string_f ("Can't create %s",dirname.c_str());
										}else{
											dirid = subdir_id;
										}
									}
								}
							}
						}
						#endif
					}
					break;
				}
			}
			if (dirid != -1){
				int outbox_id = fs_find_outbox(glocal.userid,username,msg);
				if (outbox_id != -1){
					int fileid = fs_newid (glocal.userid,listid,'r',msg,msgid);
					if (fileid != -1){
						char now[20];
						fs_set_now(now);
						bo_writed_set_msgid (msgid,replyto);
						if (fs_insert_file(outbox_id,fileid,now,msgid)==-1){
							msg = "Outbox internal error (dirs_content table)";
						}else if (sql_action("insert into files (id,modified,title,content,filetype) values (%d,'%s','%s','%s',%u)"
							,fileid,now,title,content,FILE_TEXT)==-1){
							msg = "Internal error (files table)";
						}else if (fs_insert_entry(dirid,fileid,now,msgid,ENTRY_MSG)==-1){
							msg = "Project inbox internal error (dirs_content table)";
						}else{
							msg = "";
							ret = 0;
						}
					}
				}
			}
		}
	}
	return ret;
}
</mod>

<mod>
static void bo_writed_sendmsg (
	CONNECT_INFO &con,
	const char *sessionid,
	const char *owner,
	const vector<const char*> &recipients,
	const char *replyto,		// Message ID or NULL
	const char *title,
	const char *content,
	string &msg,
	string &msgid)
{
	msg = "Invalid session";
	string username;
	glocal unsigned userid = bo_writed_get_group_owner (con, sessionid, owner, username, msg);
	if (recipients.size() == 0){
		msg = "No recipient";
	}else if (glocal.userid != 0){
		// Check that all recipients do exist
		glocal vector<pair<string,unsigned>> r_userids;
		string req = "select name,userid from id2name";
		const char *sep = "where";
		NSQL_ENCODE enc;
		for (auto r:recipients){
			req += string_f(" %s name='%s'",sep,enc.enc(r));
			sep = "or";
		}
		<call sql_query>(req.c_str());
		<f onerow>
			glocal.r_userids.push_back(pair<string,unsigned>(row[0],atoi(row[1])));
		</f>
		</call>
		if (glocal.r_userids.size() != recipients.size()){
			msg = "Some recipient(s) invalid:";
			for (auto r:recipients){
				bool found = false;
				for (auto &i:glocal.r_userids){
					if (strcmp(r,i.first.c_str())==0){
						found = true;
						break;
					}
				}
				if (!found) msg += string(" ") + r;
			}
		}else{
			msg = "";
			if (replyto != NULL){
				int inbox_id = fs_find_inbox(glocal.userid,username,false,msg);
				if (inbox_id == -1
					|| fs_rec_getid ("select itemid from dirs_content where dirid=%d and name='%s'"
						,inbox_id,replyto)==-1){
					msg = "replyto: Unknown message";
				}
					
			}
			if (msg.size() == 0){
				int outbox_id = fs_find_outbox(glocal.userid,username,msg);
				if (outbox_id != -1){
					// All messages are member of group #all, with listmode='r'
					// But access is controlled by the parent directory
					int fileid = fs_newid (glocal.userid,0,'r',msg,msgid);
					if (fileid != -1){
						char now[20];
						fs_set_now(now);
						bo_writed_set_msgid (msgid,replyto);
						if (fs_insert_file(outbox_id,fileid,now,msgid)==-1){
							msg = "Internal error (dirs_content table)";
						}else if (sql_action("insert into files (id,modified,filetype,title,content) values (%d,'%s',%u,'%s','%s')"
							,fileid,now,FILE_TEXT,title,content)==-1){
							msg = "Internal error (files table)";
						}else{
							for (unsigned i=0; i<glocal.r_userids.size(); i++){
								const char *r = glocal.r_userids[i].first.c_str();
								unsigned r_id = glocal.r_userids[i].second;
								int inbox_id = fs_find_inbox (r_id,r,true,msg);
								if (inbox_id == -1) break;
								if (fs_insert_entry(inbox_id,fileid,now,msgid,ENTRY_MSG)==-1){
									msg = string_f ("Can't write to user %s inbox",r);
									break;
								}
							}
						} 
					}
				}
			}
		}
	}
}
</mod>

static FILE_TYPE bo_writed_file_type (PARAM_STRING name)
{
	FILE_TYPE file_type = FILE_UNKNOWN;
	const char *ext = strrchr(name.ptr,'.');
	if (ext != NULL){
		if (strcasecmp(ext,".mp3")==0 || strcasecmp(ext,".wav")==0 || strcasecmp(ext,".ogg")==0){
			file_type = FILE_SOUND;
		}else if (strcasecmp(ext,".mp4")==0){
			file_type = FILE_VIDEO;
		}else if (strcasecmp(ext,".gif")==0 || strcasecmp(ext,".png")==0 || strcasecmp(ext,".jpeg")==0){
			file_type = FILE_IMAGE;
		}
	}
	return file_type;
}
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal int noproc = 1;
	glocal const char *secretfile = "/etc/bolixo/secrets.client";
	glocal const char *bind = "0.0.0.0";
	glocal const char *port = "9100";
	glocal const char *control = "/var/run/bo-writed.sock";
	glocal const char *user = "bolixo";
	glocal const char *logfile = "/var/log/bolixo/bo-writed.log";
	glocal const char *data_dbserv = "localhost";
	glocal const char *data_dbname = "files";
	glocal const char *data_dbuser = NULL;
	glocal const char *users_dbserv = "localhost";
	glocal const char *users_dbname = "users";
	glocal const char *users_dbuser = NULL;
	glocal const char *mysecret = NULL;
	glocal const char *sessionhost = "127.0.0.4";
	glocal const char *sessionport = "9200";
	glocal const char *sessionbind = "";
	glocal const char *computeport = "/dev/compute.sock";
	glocal const char *sql_tcpport = NULL;
	glocal const char *mailserver = "unix:";
	glocal const char *mailport = "/dev/smtp.sock";
	glocal const char *mailfrom = NULL;
	glocal bool daemon = false;
	glocal const char *pidfile = "/var/run/bo-writed.pid";
	glocal bool writeonce_proof = false;
	glocal bool writeonce_comment = false;
	glocal const char *force_addr = NULL;
	glocal const char *bob_dir = "/var/lib/bolixo";

	glocal.ret = <call tlmpprogram>(argc,argv,"tlmpsql");
	<f init>
		setproginfo ("bo-writed",VERSION,"...");
		setgrouparg ("Networking");
		setarg ('b',"bindaddr","Bind to this address (TCP)",glocal.bind,false);
		setarg ('p',"tcpport","Listen for command on this TCP port",glocal.port,false);
		setarg ('c',"control","Unix socket for trlid-control",glocal.control,false);
		setgrouparg ("Session server");
		setarg (' ',"sessionhost","Host running the bo-sessiond server",glocal.sessionhost,false);
		setarg (' ',"sessionport","Port to reach the bo-sessiond server",glocal.sessionport,false);
		setarg (' ',"sessionbind","Bind to this IP to talk to bo-sessiond",glocal.sessionbind,false);
		setarg (' ',"mysecret","Secret used to talk to sessiond",glocal.mysecret,true);
		setgrouparg ("Compute server");
		setarg (' ',"computeport","Port to reach the bo-log compute server",glocal.computeport,false);
		setgrouparg ("Misc.");
		setarg (' ',"secrets","File holding secrets for communication",glocal.secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"logfile","Log file to record request",glocal.logfile,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","FIle holding the PID of the process",glocal.pidfile,false);
		setarg (' ',"noproc","Identity of this process (UUID)",glocal.noproc,false);
		setarg (' ',"bob_dir","Binary file directory",glocal.bob_dir,false);
		setgrouparg ("Mail");
		setarg (' ',"mailserver","Mail relay to use",glocal.mailserver,false);
		setarg (' ',"mailport","TCP port of the relay (or unix socket)",glocal.mailport,false);
		setarg (' ',"forceaddr","Force email address",glocal.force_addr,false);
		setarg ( ' ',"mailfrom","Mail sender",glocal.mailfrom,true);
		setgrouparg ("Database");
		setarg (' ',"data_dbserv","Database server",glocal.data_dbserv,false);
		setarg (' ',"data_dbname","Database name",glocal.data_dbname,false);
		setarg (' ',"data_dbuser","Database user",glocal.data_dbuser,true);
		setarg (' ',"users_dbserv","Database server for users",glocal.users_dbserv,false);
		setarg (' ',"users_dbname","Database name for users",glocal.users_dbname,false);
		setarg (' ',"users_dbuser","Database user for users",glocal.users_dbuser,true);
		setarg (' ',"sqltcpport","Database TCP port",glocal.sql_tcpport,false);
	</f>
	<f showerror>
		glocal const char *msg = msg;
		<call savefile>("/tmp/err.log",true);
		<f dowrite>
			fprintf (fout,"%s\n",glocal.msg);
			return 0;
		</f>
		</call>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		glocal bool mailon = true;	// Send confirmation mails (for testing)
		glocal unsigned long nbrequest_client = 0;
		glocal FILE *flog = NULL;
		glocal NSQL *usq;		// SQL handle for the users database
		glocal CONNECT_INFO con;	// Connection to the session manager
		glocal CONNECT_INFO con_comp;	// Connection to the bo-log compute server
		glocal map<string,string> secrets;
		const char *passwd = getenv("BO_WRITED_PWD");
		fs_set_noproc (glocal.noproc);
		if (passwd == NULL){
			tlmp_error ("Can't get database password from environment, aborting\n");
			exit (-1);
		} 
		if (glocal.force_addr != NULL) fdpass_set_force_addr(glocal.force_addr);
		if (glocal.sql_tcpport != NULL) nsql_settcpport (atoi(glocal.sql_tcpport));
		query_setdefaultdb (glocal.data_dbserv,glocal.data_dbname,glocal.data_dbuser,passwd);
		query_getdefaultdb()->showerrormode(true);
		NSQL nsql_sq (glocal.users_dbserv,glocal.users_dbname,glocal.users_dbuser,passwd);
		nsql_sq.showerrormode (true);
		nsql_sq.setunixpath ("/var/lib/mysql/mysql-users.sock");
		glocal.usq = &nsql_sq;
		fdpass_readsecrets (glocal.secretfile,glocal.secrets);
		glocal.con.port = glocal.sessionport;
		glocal.con.bind = glocal.sessionbind;
		glocal.con.secret = glocal.mysecret;
		glocal.con_comp.port = glocal.computeport;
		glocal.con_comp.secret = glocal.mysecret;
		glocal string clientport = string_f ("unix:/tmp/writed-%s.sock",glocal.port);
		glocal string controlport = string_f ("unix:%s",glocal.control);
		glocal.con.fd = -1;
		int ret = -1;
		<obj TCPSERVER s>(glocal.bind,glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else{
				settcpnodelay(true);
				n->type = TYPE_CLIENT;
				char addr[20];
				const char *addrstr = addr;
				if (strncmp(info.port,"unix:",5)==0){
					addrstr = info.port;
				}else{
					ipnum_ip2a (from,addr);
				}
				n->host = addrstr;
				n->req.secret = fdpass_findsecret (glocal.secrets,addrstr);
				debug_printf (D_PROTO,"newclient addr=%s secret=%s\n",addrstr,n->req.secret.c_str());
				if (n->req.secret.empty()){
					endclient = true;
					tlmp_error ("No secret for client %s\n",addrstr);
				}
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			debug_printf (D_PROTO,"receive line: %s\n",line);
			if (c->type == TYPE_CONTROL){
				<call bo_writed_control>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
				<f status>
					vector<string> tb;
					tb.push_back(string_f("version %s",VERSION));	
					tb.push_back(string_f("nbrequest %lu",glocal.nbrequest_client));
					tb.push_back(string_f("mailctrl %d \"%s\"",glocal.mailon,fdpass_get_force_addr()));
					tb.push_back(string_f("filehandle %u\n",fs_getnbhandle()));
					rep_status (tb);
				</f>
				<f quit>
					endserver = true;
				</f>
				<f syncbd>
				</f>
				<f reload>
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f makeadmin>
					glocal bool on = on;
					glocal const char *email = email;
					<call sql_query>(*glocal.usq,"select userid,admin from users where email='%s'",email);
					<f onerow>
						if (strcmp(row[1],"0")==0){
							if (!glocal.on){
								glocal.bo_writed_control.rep_makeadmin(false,"already not admin");
							}else if (sql_action(*glocal.usq,"update users set admin=1 where userid=%s",row[0])==-1){
								glocal.bo_writed_control.rep_makeadmin(false,"sql error");
							}else{
								glocal.bo_writed_control.rep_makeadmin(true,"");
								bo_log_makeadmin (glocal.flog,glocal.email,glocal.on);
							}
						}else if (glocal.on){
							glocal.bo_writed_control.rep_makeadmin(false,"already admin");
						}else{
							if (sql_action(*glocal.usq,"update users set admin=0 where userid=%s",row[0])==-1){
								glocal.bo_writed_control.rep_makeadmin(false,"sql error");
							}else{
								glocal.bo_writed_control.rep_makeadmin(true,"");
								bo_log_makeadmin (glocal.flog,glocal.email,glocal.on);
							}
						}
					</f>
					<f empty>
						glocal.bo_writed_control.rep_makeadmin(false,"user unknown");
					</f>
					</call>
				</f>
				<f rotatelog>
					bool success = false;
					fclose (glocal.flog);
					glocal.flog = fopen (glocal.logfile,"a");
					if (glocal.flog == NULL){
						glocal.TCPSERVER.sendf ("Can't open logfile %s (%s)\n",glocal.logfile,strerror(errno));
						tlmp_error ("Can't open logfile %s (%s)\n",glocal.logfile,strerror(errno));
						exit (-1);
					}else{
						success = true;
					}
					rep_rotatelog (success);
				</f>
				<f truncatelog>
					bool success = false;
					fclose (glocal.flog);
					glocal.flog = fopen (glocal.logfile,"w");
					if (glocal.flog == NULL){
						glocal.TCPSERVER.sendf ("Can't open logfile %s (%s)\n",glocal.logfile,strerror(errno));
						tlmp_error ("Can't open logfile %s (%s)\n",glocal.logfile,strerror(errno));
						exit (-1);
					}else{
						success = true;
					}
					rep_truncatelog (success);
				</f>
				<f del_incomplete>
					glocal vector<string> emails;
					time_t ti = time(NULL)-nbseconds;
					struct tm *tt = localtime(&ti);
					char date[100];
					snprintf (date,sizeof(date)-1,"%04d-%02d-%02d %02d:%02d:%02d"
						,tt->tm_year+1900,tt->tm_mon+1,tt->tm_mday
						,tt->tm_hour,tt->tm_min,tt->tm_sec);
					<call sql_query>(*glocal.usq,"select userid,userid_str,email from users where confirmed is null and created <= '%s'",date);
					<f onerow>
						if (sql_action(*glocal.usq,"delete from users where userid=%s",row[0])!=-1){
							bo_log_del_incomplete(glocal.flog,row[1]);
							glocal.emails.push_back(row[2]);
							
						}
					</f>
					</call>	
					rep_del_incomplete(glocal.emails);
				</f>
				<f sendmail>
					// Test sending mail
					int success = fdpass_sendmail (glocal.mailserver,glocal.mailport,glocal.mailfrom,addr,subject,body);
					rep_sendmail (success);
				</f>
				<f newacctresend>
					glocal bool success = false;
					<call sql_query>(*glocal.usq,"select name,email,userid_str from users where email='%s' and confirmed is null",email);
					<f onerow>
						if (writed_mail_newaccount (glocal.mailserver,glocal.mailport,glocal.mailfrom,row[0],row[1],row[2]) != -1){
							glocal.success = true;
						}
					</f>
					</call>
					rep_newacctresend (glocal.success);
				</f>
				<f mailctrl>
					glocal.mailon = on;
					if (strcmp(forceaddr,"keep")!=0) fdpass_set_force_addr (forceaddr);
				</f>
				<f invalid>
					tlmp_error ("Control: Invalid command: %s\n",line);
					glocal.TCPSERVER.sendf ("Invalid command %s\n",line);
					endclient = true;
				</f>
				</call>

			}else if (c->type == TYPE_CLIENT){
				glocal.nbrequest_client++;
				<call bo_writed_client>(this,c->req,line, info.linelen,endserver, endclient, no,c,c->host.c_str());
				<f adduser>
					glocal const char *name = name;
					glocal const char *email = email;
					glocal const char *password = password;
					<call sql_query>(*glocal.usq,"select email from users where email='%s'",email);
					<f onerow>
						// Email already exist
						glocal.bo_writed_client.rep_adduser ("","An account using this email already exists");
					</f>
					<f empty>
						<call sql_query>(*glocal.usq,"select name from users where name='%s'",glocal.name);
						<f onerow>
							glocal.bo_writed_client.rep_adduser ("","An account is already using this nickname");
						</f>
						<f empty>
							glocal string id_str = fs_makeid ();
							if (sql_action(*glocal.usq,"insert into users (name,email,password,userid_str) values ('%s','%s',password('%s'),'%s')"
								,glocal.name,glocal.email,glocal.password,glocal.id_str.c_str())==-1){
								glocal.bo_writed_client.rep_adduser ("","can't create");
							}else if (sql_action("insert into id2name (userid,name) values (%d,'%s')",glocal.usq->getlastid(),glocal.name)==-1){
								glocal.bo_writed_client.rep_adduser ("","can't create2");
							}else{
								glocal.bo_writed_client.rep_adduser (glocal.id_str,"");
								// Retrieve the password hashed by MySQL
								<call sql_query>(*glocal.usq,"select password from users where email='%s'",glocal.email);
								<f onerow>
									bo_log_adduser (glocal.flog,glocal.id_str,glocal.name,glocal.email,row[0],time(NULL));
								</f>
								</call>
								if (glocal.mailon){
									writed_mail_newaccount(glocal.mailserver,glocal.mailport,glocal.mailfrom
										,glocal.name,glocal.email,glocal.id_str);
								}
							}
						</f>
						</call>
					</f>
					</call>
				</f>
				<f confirmuser>
					glocal const char *confirmid = confirmid;
					<call sql_query>(*glocal.usq,"select userid from users where userid_str='%s' and confirmed is null and disabled is null"
						,confirmid);
					<f onerow>
						if (sql_action(*glocal.usq,"update users set confirmed=now() where userid=%s",row[0])!=-1){
							glocal.bo_writed_client.rep_confirmuser(true,"New user confirmed");
							bo_log_confirmuser (glocal.flog,glocal.confirmid,time(NULL));
						}else{
							glocal.bo_writed_client.rep_confirmuser(false,"Error, can't confirm new user");
						}
					</f>
					<f empty>
						printf ("Confirm unknown users: %s\n",glocal.confirmid);
						glocal.bo_writed_client.rep_confirmuser(false,"Error, unknown confirmation ID");
					</f>
					</call>
				</f>
				<f deleteuser>
					// User is deleting his own account
					glocal const char *sessionid=sessionid;
					glocal string userid_str;
					glocal unsigned userid = trli_getsessionuser(glocal.con,sessionid,glocal.userid_str);
					if (glocal.userid != 0){
						glocal string deleteid = fs_makeid();
						if (sql_action(*glocal.usq,"update users set deleteid='%s' where userid=%u",glocal.deleteid.c_str()
							,glocal.userid)!=-1){
							<call sql_query>(*glocal.usq,"select email from users where userid=%u",glocal.userid);
							<f onerow>
								glocal.bo_writed_client.rep_deleteuser (row[0],glocal.deleteid.c_str());
							</f>
							</call>
							bo_log_deleteuser (glocal.flog,glocal.userid_str,glocal.deleteid);
						}
					}
				</f>
				<f confirmdelete>
					glocal const char *confirmid = confirmid;
					<call sql_query>(*glocal.usq,"select userid,userid_str from users where deleteid='%s' and deleted is null and disabled is null"
						,confirmid);
					<f onerow>
						unsigned userid = atoi(row[0]);
						const char *userid_str = row[1];
						if (sql_action(*glocal.usq,"update users set deleted=now() where userid=%u",userid)!=-1){
							// And we terminated all sessions for this user
							<call bo_sessiond_admin_deletesessions>(glocal.con,userid);
							<f ok>
							</f>
							</call>
							bo_log_confirmdelete (glocal.flog,userid_str,glocal.confirmid);
							glocal.bo_writed_client.rep_confirmdelete (true,"");
						}
					</f>
					<f empty>
						glocal.bo_writed_client.rep_confirmdelete (false,"no user");
					</f>
					</call>
				</f>
				<f login>
					glocal const char *email = email;
					glocal const char *sessionid = sessionid;
					<call sql_query>(*glocal.usq,"select userid,userid_str,name,email,lang,admin from users where email='%s' and password=password('%s')"
						" and disabled is null and deleted is null and confirmed is not null and nbfail < 3",email,password);
					<f onerow>
						debug_printf (D_PROTO,"login ok\n");
						int userid = atoi(row[0]);
						<call bo_sessiond_admin_setsession>(glocal.con,glocal.sessionid,userid,row[1],row[2],row[3],atoi(row[4]),atoi(row[5]));
						<f ok>
							if (internal_error){
								glocal.bo_writed_client.rep_login (false);
							}else{
								debug_printf (D_PROTO,"login session ok %s\n",glocal.sessionid);
								sql_action (*glocal.usq,"update users set lastaccess=now() where email='%s'",glocal.email);
								glocal.bo_writed_client.rep_login (true);
							}
						</f>
						</call>
					</f>
					<f empty>
						// It fails, why ?
						debug_printf (D_PROTO,"login failed\n");
						<call sql_query>(*glocal.usq,"select userid,email,disabled,deleted,confirmed,nbfail from users where email='%s'"
							,glocal.email);
						<f onerow>
							if (row[2] != NULL || row[3] !=  NULL || row[4] == NULL){
								// disabled or deleted or not confirmed, nothing to do
							}else if (atoi(row[5]) < 3){
								sql_action (*glocal.usq,"update users set nbfail=nbfail+1 where email='%s'",glocal.email);
							}
						</f>
						</call>
						glocal.bo_writed_client.rep_login (false);
					</f>
					</call>
				</f>
				<f logout>
					glocal const char *sessionid=sessionid;
					glocal unsigned userid = trli_getsessionuser(glocal.con,sessionid);
					if (glocal.userid != 0){
						<call bo_sessiond_admin_deletesession>(glocal.con,glocal.sessionid);
						<f ok>
						</f>
						</call>
					}
				</f>
				<f createsession>
					// Create a web session, not associated with any user
					glocal string sessionid = fs_makeid ();
					<call bo_sessiond_admin_createsession>(glocal.con,glocal.sessionid.c_str());
					<f ok>
						if (internal_error){
							glocal.bo_writed_client.rep_createsession ("");
						}else{
							debug_printf (D_PROTO,"create session ok %s\n",glocal.sessionid.c_str());
							glocal.bo_writed_client.rep_createsession (glocal.sessionid.c_str());
						}
					</f>
					</call>
				</f>
				<f mkdir>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,false)==-1){
						rep_mkdir (false,entry.msg);
					}else if (!entry.may_add){
						rep_mkdir (false,"Not allowed");
					}else{
						string msg;
						int subdirid = fs_newid (entry.userid,msg);
						if (subdirid == -1){
							rep_mkdir (false,msg);
						}else{
							if (fs_insert_dir (entry.dirid,subdirid,entry.basename)==-1){
								rep_mkdir (false,"Internal error (dirs_subdirs table)");
							}else{
								rep_mkdir (true,"Ok");
							}
						}
					}
				</f>
				<f rmdir>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,true)==-1){
						rep_rmdir (false,entry.msg);
					}else{
						if (!bolixo_isdir(entry.type)){
							rep_rmdir (false,"Not a directory, can't delete");
						}else{
							if (fs_insert_deleted(entry.dirid,entry.entryid,entry.basename)==-1){
								rep_rmdir (false,"Internal error (dirs_files table)");
							}else{
								rep_rmdir (true,"Ok");
							}
						}
					}
				</f>
				<f addfile>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,false)==-1){
						rep_addfile (false,entry.msg);
					}else{
						string msg;
						int fileid = fs_newid (entry.userid,msg);
						if (fileid == -1){
							rep_addfile (false,msg);
						}else{
							char now[20];
							fs_set_now(now);
							if (fs_insert_file(entry.dirid,fileid,now,entry.basename)==-1){
								rep_addfile (false,"Internal error (dirs_files table)");
							}else if (sql_action("insert into files (id,modified,filetype,content) values (%d,'%s',%u,'%s')"
								,fileid,now,FILE_TEXT,content)==-1){
								rep_addfile (false,"Internal error (files table)");
							}else{
								rep_addfile (true,"Ok");
							}
						}
					}
				</f>
				<f addfile_bob>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,false)==-1){
						rep_addfile_bob (false,"",entry.msg);
					}else{
						string msg;
						string handle;
						int fileid = fs_newid (entry.userid,msg);
						if (fileid != -1){
							char now[20];
							fs_set_now(now);
							FILE_TYPE file_type = bo_writed_file_type (entry.basename);
							if (fs_insert_file(entry.dirid,fileid,now,entry.basename)==-1){
								msg = "Internal error (dirs_files table)";
							}else if (sql_action("insert into files (id,modified,filetype,content) values (%d,'%s',%u,NULL)"
								,fileid,now,file_type)==-1){
								msg = "Internal error (files table)";
							}else{
								FILE *fout = fs_alloc_file_handle (fileid,now,"w",handle,sessionid);
								if (fout == NULL){
									tlmp_error ("Can't open file (%s)\n",strerror(errno));
									msg = "Internal error (1-writing data)";
								}else{
									size_t size = content.getsize();
									if (fwrite (content.getbuffer(),1,size,fout)!=size){
										msg = "Internal error (2-writing data)";
									}
								}
							}
						}
						if (msg.size() > 0){
							rep_addfile_bob (false,"",msg);
							fs_delete_handle(handle);
						}else{
							if (!more){
								fs_delete_handle(handle);
								handle.clear();
							}
							rep_addfile_bob (true,handle,"Ok");
						}
						
					}
				</f>
				<f appendfile>
					if (trli_getsessionuser(glocal.con,sessionid)==0){
						rep_appendfile (false,"Invalid session");
					}else{
						FILE *fout = fs_get_file (handle,sessionid);
						if (fout == NULL){
							tlmp_error ("Can't open file (%s)\n",strerror(errno));
							rep_appendfile (false,"Internal error (3-writing data)");
						}else{
							size_t size = content.getsize();
							if (fwrite (content.getbuffer(),1,size,fout)!=size){
								rep_appendfile (false,"Internal error (4-writing data)");
							}else{
								rep_appendfile (true,"Ok");
							}
							if (!more) fs_delete_handle(handle);
						}
					}
				</f>
				<f delfile>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,true)==-1){
						rep_delfile (false,entry.msg);
					}else{
						if (!bolixo_isfile(entry.type)){
							rep_delfile (false,"Not a file, can't delete");
						}else{
							if (fs_insert_deleted(entry.dirid,entry.entryid,entry.basename)==-1){
								rep_delfile (false,"Internal error (dirs_files table)");
							}else{
								rep_delfile (true,"Ok");
							}
						}
					}
				</f>
				<f modifyfile>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,true)==-1){
						rep_modifyfile (false,entry.msg);
					}else{
						if (!bolixo_isfile(entry.type)){
							rep_modifyfile (false,"Not a file, can't modify");
						}else{
							char now[20];
							fs_set_now(now);
							if (fs_insert_file (entry.dirid,entry.entryid,now,entry.basename)==-1){
								rep_modifyfile (false,"Internal error (dirs_files table)");
							}else if (sql_action("insert into files (id,modified,filetype,content) values (%d,'%s',%u,'%s')"
								,entry.entryid,now,FILE_TEXT,content)==-1){
								rep_modifyfile (false,"Internal error (files table)");
							}else{
								rep_modifyfile (true,"Ok");
							}
						}
					}
				</f>
				<f markview>
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,true)!=-1){
						if (sql_action("insert into marks (userid,itemid,modified) values (%u,%u,'%s') on duplicate key update modified='%s'"
							,entry.userid,entry.entryid,entry.modified.c_str(),entry.modified.c_str())==-1){
							entry.msg = "internal error (table marks)";
						}else{
							entry.msg = "";
						}
					}
					if (entry.msg.size() == 0){
						rep_markview (true,"");
					}else{
						rep_markview (false,entry.msg);
					}
				</f>
				<f set_access>	//  sessionid name listname listmode = success:b msg
					glocal ENTRY entry;
					glocal const char *listmode = listmode;
					if (bo_writed_findentry (glocal.con,sessionid,name,glocal.entry,true)!=-1){
						if (glocal.entry.userid != glocal.entry.ownerid && !glocal.entry.is_admin){
							glocal.entry.msg = "Only owner may assign access";
						}else if (username[0] != '\0' && !glocal.entry.is_admin){
							glocal.entry.msg = "Only admin may assign ownership of a file/directory";
						}else{
							if (strcmp(listname,"-")==0){
								if (sql_action("update ids set group_list_id=NULL,listmode='%s' where id=%u",listmode,glocal.entry.entryid)==-1){
									glocal.entry.msg = "Internal error (ids table)";
								}else{
									glocal.entry.msg = "";
								}
							}else if (strcmp(listname,ALL_MAY_READ)==0){
								if (sql_action("update ids set group_list_id=0,listmode='%s' where id=%u",listmode,glocal.entry.entryid)==-1){
									glocal.entry.msg = "Internal error (ids table)";
								}else{
									glocal.entry.msg = "";
								}
							}else if (listname[0] != '\0'){
								int group_list_id = fs_rec_getid ("select id from group_lists where ownerid=%u and name='%s'",glocal.entry.userid,listname);
								if (group_list_id == -1){
									glocal.entry.msg = "Invalid list name";
								}else if (sql_action("update ids set group_list_id=%d,listmode='%s' where id=%u",group_list_id,glocal.listmode,glocal.entry.entryid)==-1){
									glocal.entry.msg = "Internal error (ids table)";
								}else{
									glocal.entry.msg = "";
								}
							}
							if (glocal.entry.msg.size() == 0 && username[0] != '\0'){
								int username_id = fs_rec_getid ("select userid from id2name where name='%s'",username);
								if (username_id == -1){
									glocal.entry.msg = "Invalid user name";
								}else if (sql_action("update ids set ownerid=%d where id=%u",username_id,glocal.entry.entryid)==-1){
									glocal.entry.msg = "Internal error (ids table)";
								}else{
									glocal.entry.msg = "";
								}
							}
						}
					}
					if (glocal.entry.msg.size() > 0){
						rep_set_access (false,glocal.entry.msg);
					}else{
						rep_set_access (true,"");
					}
				</f>
				<f modifyfile_bob> // sessionid name content:o more:b = success:b handle msg
					ENTRY entry;
					if (bo_writed_findentry (glocal.con,sessionid,name,entry,true)==-1){
						rep_modifyfile_bob (false,"",entry.msg);
					}else{
						string msg;
						string handle;
						if (!bolixo_isfile(entry.type)){
							msg = "Not a file, can't modify";
						}else{
							char now[20];
							fs_set_now(now);
							FILE_TYPE file_type = bo_writed_file_type (entry.basename);
							if (fs_insert_file (entry.dirid,entry.entryid,now,entry.basename)==-1){
								msg = "Internal error (dirs_files table)";
							}else if (sql_action("insert into files (id,modified,filetype,content) values (%d,'%s',%u,NULL)"
								,entry.entryid,now,file_type)==-1){
								msg = "Internal error (files table)";
							}else{
								FILE *fout = fs_alloc_file_handle (entry.entryid,now,"w",handle,sessionid);
								if (fout == NULL){
									tlmp_error ("Can't open file (%s)\n",strerror(errno));
									msg = "Internal error (1-writing data)";
								}else{
									size_t size = content.getsize();
									if (fwrite (content.getbuffer(),1,size,fout)!=size){
										msg = "Internal error (2-writing data)";
									}
								}
							}
						}
						if (msg.size() > 0){
							rep_modifyfile_bob (false,"",msg);
							fs_delete_handle(handle);
						}else{
							if (!more){
								fs_delete_handle(handle);
								handle.clear();
							}
							rep_modifyfile_bob (true,handle,"Ok");
						}
					}
				</f>
				<f rename> // sessionid oldname newname
					// oldname is a path, newname is just a name inside the same directory
					ENTRY oldentry,newentry;
					if (bo_writed_findentry (glocal.con,sessionid,oldname,oldentry,true)==-1){
						rep_rename (false,oldentry.msg);
					}else if (bo_writed_findentry (glocal.con,sessionid,newname,newentry,false)==-1){
						rep_rename (false,newentry.msg);
					}else{
						char now[20];
						fs_set_now(now);
						// We insert a deletion of the oldname, followed by a creation of the newname with the same
						// modified date (pointing to the same data)
						if (sql_action("insert into dirs_content (dirid,itemid,modified,type,name) values (%d,%d,'%s',%u,'%s'), (%d,%d,'%s',%u,'%s')"
							,oldentry.dirid,oldentry.entryid,now,ENTRY_DELETED,oldentry.basename.c_str()
							,newentry.dirid,oldentry.entryid,oldentry.modified.c_str(),oldentry.type,newentry.basename.c_str())==-1){
							rep_rename (false,"Internal error (dirs_content table)");
						}else{
							rep_rename (true,"Ok");
						}
					}
					
				</f>
				<f copy> // sessionid srcname dstname
					// oldname is a path, newname is just a name inside the same directory
					ENTRY srcentry,dstentry;
					if (bo_writed_findentry (glocal.con,sessionid,srcname,srcentry,true)==-1){
						rep_copy (false,srcentry.msg);
					}else if (bo_writed_findentry (glocal.con,sessionid,dstname,dstentry,false)==-1){
						rep_copy (false,dstentry.msg);
					}else if (bolixo_isdir(srcentry.type)){
						string msg;
						if (bo_writed_copydir (srcentry.entryid,dstentry.dirid,dstentry.basename,srcentry.userid,msg)==-1){
							rep_copy (false,msg);
						}else{
							rep_copy (true,"Ok");
						}
					}else if (!bolixo_isfile(srcentry.type)){
						rep_copy (false,"Copy only works on files and directories for now");
					}else{
						// We insert a row so the new name still points to the same entryid and same date.
						// It means that the new file will always be associated with the same entryid.
						// The solution would be to allocate a new id and copy the data.
						if (fs_insert_entry(dstentry.dirid,srcentry.entryid,srcentry.modified,dstentry.basename,srcentry.type)==-1){
							rep_copy (false,"Internal error (dirs_content table)");
						}else{
							rep_copy (true,"Ok");
						}
					}
					
				</f>
				<f create_project_dir> // sessionid listname owner = success:b msg
					string msg = "Invalid session";
					string username;
					unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, username, msg);
					if (userid != 0){
						int listid = fs_rec_getid ("select id from group_lists where ownerid=%u and name='%s'"
							,userid,listname);
						if (listid == -1){
							msg = "List does not exist";
						}else{
							vector<string> dirs = {"projects",username,listname};
							vector<unsigned> listids = {0,0,(unsigned)listid};
							vector<char> listmodes = {'p','p','w'};
							bool may_add;
							msg = "";
							fs_locate_dir (dirs,userid,true,msg,END_OF_TIME,may_add,true,&listids,&listmodes);
						}
					}
					if (msg.size()==0){
						rep_create_project_dir(true,"");
					}else{
						rep_create_project_dir(false,msg);
					}
				</f>
				<f create_group_list>	// sessionid listname owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *listname = listname;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (glocal.userid != 0){
						<call sql_query>("select id from group_lists where ownerid=%u and name='%s'"
							,glocal.userid,listname);
						<f onerow>
							glocal.msg = "Group list alreay exist";
						</f>
						<f empty>
							if (sql_action("insert into group_lists (ownerid,name) values (%u,'%s')"
								,glocal.userid,glocal.listname)==-1){
								glocal.msg = "Internal error (group_lists table)";
							}else{
								glocal.msg = "";
							}
						</f>
						</call> 
					}
					if (glocal.msg.size()==0){
						rep_create_group_list (true,"");
					}else{
						rep_create_group_list (false,glocal.msg);
					}
				</f>
				<f create_group>	// sessionid groupname owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *groupname = groupname;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (glocal.userid != 0){
						<call sql_query>("select id from groups where ownerid=%u and name='%s'"
							,glocal.userid,groupname);
						<f onerow>
							glocal.msg = "Group alreay exist";
						</f>
						<f empty>
							if (sql_action("insert into groups (ownerid,name) values (%u,'%s')"
								,glocal.userid,glocal.groupname)==-1){
								glocal.msg = "Internal error (group_lists table)";
							}else{
								glocal.msg = "";
							}
						</f>
						</call> 
					}
					if (glocal.msg.size()==0){
						rep_create_group (true,"");
					}else{
						rep_create_group (false,glocal.msg);
					}
				</f>
				<f set_group>		// sessionid listname groupname defaultaccess owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *listname = listname;
					glocal const char *groupname = groupname;
					glocal const char *access = defaultaccess;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (strcmp(defaultaccess," ")!=0
						&& strcmp(defaultaccess,"R")!=0
						&& strcmp(defaultaccess,"W")!=0
						&& strcmp(defaultaccess,"A")!=0
						&& strcmp(defaultaccess,"-")!=0){
						glocal.msg = "Invalid default access (' ','R','W','A','-')";
					}else if (glocal.userid != 0){
						<call sql_query>("select id from group_lists where ownerid=%u and name='%s'",glocal.userid,glocal.listname);
						<f empty>
							glocal.msg = "Group list does not exist";
						</f>
						<f onerow>
							glocal unsigned group_list_id = atoi(row[0]);
							<call sql_query>("select id from groups where ownerid=%u and name='%s'",glocal.userid,glocal.groupname);
							<f empty>
								glocal.msg = "Group does not exist";
							</f>
							<f onerow>
								glocal unsigned groupid = atoi(row[0]);
								<call sql_query>("select 1 from group_list_members"
									" where group_list_id=%u and groupid=%u"
									,glocal.group_list_id,glocal.groupid);
								<f onerow>
									if (glocal.access[0] == '-'){
										if (sql_action("delete from group_list_members"
											" where group_list_id=%u and groupid=%u"
											,glocal.group_list_id,glocal.groupid)==-1){
											glocal.msg = "Internal error (group_list_members table)";
										}else{
											glocal.msg = "";
										}
									}else if (sql_action("update group_list_members set defaultaccess='%s'"
										" where group_list_id=%u and groupid=%u"
										,glocal.access,glocal.group_list_id,glocal.groupid)==-1){
										glocal.msg = "Internal error (group_list_members table)";
									}else{
										glocal.msg = "";
									}
								</f>
								<f empty>
									if (glocal.access[0] == '-'){
										glocal.msg = "Group was not a member of that list";
									}else if (sql_action("insert into group_list_members (group_list_id,groupid,defaultaccess) values (%u,%u,'%s')"
										,glocal.group_list_id,glocal.groupid,glocal.access)==-1){
										glocal.msg = "Internal error (group_list_members table)";
									}else{
										glocal.msg = "";
									}
								</f>
								</call>
							</f>
							</call>
						</f>
						</call> 
					}
					if (glocal.msg.size()==0){
						rep_create_group (true,"");
					}else{
						rep_create_group (false,glocal.msg);
					}
				</f>
				<f set_member>		// sessionid groupname user defaultaccess role owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *groupname = groupname;
					glocal const char *user = user;
					//if (role[0] == '\0') role = NULL;
					glocal const char *role = role;
					glocal const char *access = access;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (strcmp(access," ")!=0
						&& strcmp(access,"R")!=0
						&& strcmp(access,"W")!=0
						&& strcmp(access,"A")!=0
						&& strcmp(access,"-")!=0){
						glocal.msg = "Invalid default access (' ','R','W','A','-')";
					}else if (glocal.userid != 0){
						<call sql_query>("select id from groups where ownerid=%u and name='%s'",glocal.userid,glocal.groupname);
						<f empty>
							glocal.msg = "Group does not exist";
						</f>
						<f onerow>
							glocal unsigned groupid = atoi(row[0]);
							<call sql_query>("select userid from id2name where name='%s'",glocal.user);
							<f empty>
								glocal.msg = "User does not exist";
							</f>
							<f onerow>
								glocal unsigned member_userid = atoi(row[0]);
								<call sql_query>("select 1 from group_members"
									" where groupid=%u and userid=%u"
									,glocal.groupid,glocal.member_userid);
								<f onerow>
									if (glocal.access[0] == '-'){
										if (sql_action("delete from group_members"
											" where groupid=%u and userid=%u"
											,glocal.groupid,glocal.member_userid)==-1){
											glocal.msg = "Internal error (group_members table)";
										}else{
											glocal.msg = "";
										}
									}else if (sql_action("update group_members set access='%s',role='%s'"
										" where groupid=%u and userid=%u"
										,glocal.access,glocal.role,glocal.groupid,glocal.member_userid)==-1){
										glocal.msg = "Internal error (group_members table)";
									}else{
										glocal.msg = "";
									}
								</f>
								<f empty>
									if (glocal.access[0] == '-'){
										glocal.msg = "User was not a member of that group";
									}else if (sql_action("insert into group_members (groupid,userid,access,role) values (%u,%u,'%s','%s')"
										,glocal.groupid,glocal.member_userid,glocal.access,glocal.role)==-1){
										glocal.msg = "Internal error (group_members table)";
									}else{
										glocal.msg = "";
									}
								</f>
								</call>
							</f>
							</call>
						</f>
						</call> 
					}
					if (glocal.msg.size()==0){
						rep_create_group (true,"");
					}else{
						rep_create_group (false,glocal.msg);
					}
				</f>
				<f delete_list>		// sessionid listname owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *listname = listname;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (glocal.userid != 0)
						<call sql_query>("select 1 from group_lists where ownerid=%u and name='%s'",glocal.userid,listname);
						<f onerow>
							if (sql_action("delete from group_lists where ownerid=%u and name='%s'",glocal.userid,glocal.listname)==-1){
								glocal.msg = "Internal error (Table group_lists)";
							}else{
								glocal.msg = "";
							}
						</f>
						<f empty>
							glocal.msg = "No list with that name";
						</f>
						</call>{
					}
					if (glocal.msg.size()==0){
						rep_delete_list (true,"");
					}else{
						rep_delete_list (false,glocal.msg);
					}
				</f>
				<f delete_group>	// sessionid groupname owner = success:b msg
					glocal string msg = "Invalid session";
					glocal const char *groupname = groupname;
					glocal unsigned userid = bo_writed_get_group_owner (glocal.con, sessionid, owner, glocal.msg);
					if (glocal.userid != 0)
						// Find if the group exists
						<call sql_query>("select id from groups where ownerid=%u and name='%s'",glocal.userid,groupname);
						<f onerow>
							glocal unsigned groupid = atoi(row[0]);
							// Is this group part of any list
							<call sql_query>("select 1 from group_list_members where groupid=%u limit 1",glocal.groupid);
							<f onerow>
								glocal.msg = "This group is a member of at least one list";
							</f>
							<f empty>
								if (sql_action("delete from group_members where groupid=%u",glocal.groupid)==-1){
									glocal.msg = "Internal error (Table group_members)";
								}else if (sql_action("delete from groups where ownerid=%u and name='%s'",glocal.userid,glocal.groupname)==-1){
									glocal.msg = "Internal error (Table groups)";
								}else{
									glocal.msg = "";
								}
							</f>
							</call>
						</f>
						<f empty>
							glocal.msg = "No group with that name";
						</f>
						</call>{
					}
					if (glocal.msg.size()==0){
						rep_delete_list (true,"");
					}else{
						rep_delete_list (false,glocal.msg);
					}
				</f>
				<f sendmsg> // sessionid owner recipients:v title content = success:b msg msgid
					string msg;
					string rep_msgid;
					bo_writed_sendmsg (glocal.con,sessionid,owner,recipients,NULL,title,content,msg,rep_msgid);
					if (msg.size()==0){
						rep_sendmsg (true,"",rep_msgid);
					}else{
						rep_sendmsg (false,msg,"");
					}		
				</f>
				<f sendmsg_project> // sessionid owner manager project role title content = success:b msg msgid
					string msg;
					string rep_msgid;
					if (bo_writed_project_msg(glocal.con,sessionid,owner,manager,project,role,NULL,title,content,msg,rep_msgid)!=-1){
						rep_sendmsg_project (true,"",rep_msgid);
					}else{
						rep_sendmsg_project (false,msg,"");
					}
				</f>
				<f replymsg> // sessionid owner msgid recipients:v title content = success:b msg replyid
					string msg;
					string rep_msgid;
					bo_writed_sendmsg (glocal.con,sessionid,owner,recipients,msgid,title,content,msg,rep_msgid);
					if (msg.size()==0){
						rep_replymsg (true,"",rep_msgid);
					}else{
						rep_replymsg (false,msg,"");
					}		
				</f>
				<f replymsg_project> // sessionid owner manager project role msgid title content = success:b msg replyid
					string msg;
					string rep_msgid;
					if (bo_writed_project_msg(glocal.con,sessionid,owner,manager,project,role,msgid,title,content,msg,rep_msgid)!=-1){
						rep_replymsg_project (true,"",rep_msgid);
					}else{
						rep_replymsg_project (false,msg,"");
					}
				</f>
				<f sendattach> // sessionid owner msgid content:o more:b = success:b msg handle
				</f>
				<f test>
					glocal bool bdtrli=false;
					glocal bool bdusers=false;
					glocal bool sessiond=false;
					<call sql_query>(*glocal.usq,"select count(*) from users");
					<f onerow>
						glocal.bdusers=true;
					</f>
					</call>
					<call sql_query>("select count(*) from id2name");
					<f onerow>
						glocal.bdtrli=true;
					</f>
					</call>
					<call bo_sessiond_admin_test>(glocal.con);
					<f ok>
						if (success) glocal.sessiond = true;
					</f>
					</call>
					rep_test (glocal.bdtrli,glocal.bdusers,glocal.sessiond);
				</f>
				<f invalid>
					tlmp_error ("Client: Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
				fflush (glocal.flog);
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			s.setrawmode(true);
			chmod (glocal.clientport.c_str()+5,0666);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			glocal.flog = fopen (glocal.logfile,"a");
			if (glocal.flog == NULL){
				tlmp_error ("Can't open logfile %s (%s)\n",glocal.logfile,strerror(errno));
				exit (-1);
			}
			s.loop();
			ret = 0;
		}
		fclose (glocal.flog);
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

