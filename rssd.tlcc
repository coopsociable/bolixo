/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Get RSS feed from site and inject that as public message in bolixo rss account for this site.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <string>
#include <set>
#include "xmlflat.h"
#include "bolixo.h"
#include "bolixo.m"
#include "instrument.h"


using namespace std;
static DEBUG_KEY D_GETRSS ("getrss","Protocol to retrieve RSS");
static DEBUG_KEY D_PROTO ("proto","Protocol information");
static DEBUG_KEY D_HEADER ("header","http header");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
#include "proto/rssd_control.protoh"

#include "proto/bod_client.protodef"
#define bod_client_login_NOTNEED
#define bod_client_logout_NOTNEED
#define bod_client_createsession_NOTNEED
#define bod_client_adduser_NOTNEED
#define bod_client_confirmuser_NOTNEED
#define bod_client_deleteuser_NOTNEED
#define bod_client_confirmdelete_NOTNEED
#define bod_client_addfile_NOTNEED
#define bod_client_addfile_bob_NOTNEED
#define bod_client_appendfile_NOTNEED
#define bod_client_delfile_NOTNEED
#define bod_client_undelete_NOTNEED
#define bod_client_modifyfile_NOTNEED
#define bod_client_modifyfile_bob_NOTNEED
#define bod_client_rename_NOTNEED
#define bod_client_copy_NOTNEED
#define bod_client_readfile_NOTNEED
#define bod_client_readfile_bob_NOTNEED
#define bod_client_readmore_NOTNEED
#define bod_client_mkdir_NOTNEED
#define bod_client_rmdir_NOTNEED
#define bod_client_listdir_NOTNEED
#define bod_client_stat_NOTNEED
#define bod_client_set_access_NOTNEED
#define bod_client_markview_NOTNEED
#define bod_client_create_group_list_NOTNEED
#define bod_client_create_group_NOTNEED
#define bod_client_set_group_NOTNEED
#define bod_client_set_member_NOTNEED
#define bod_client_set_list_desc_NOTNEED
#define bod_client_set_group_desc_NOTNEED
#define bod_client_delete_list_NOTNEED
#define bod_client_delete_group_NOTNEED
#define bod_client_list_lists_NOTNEED
#define bod_client_list_groups_NOTNEED
#define bod_client_create_project_dir_NOTNEED
#define bod_client_list_contacts_NOTNEED
#define bod_client_list_inboxes_NOTNEED
#define bod_client_list_msgs_NOTNEED
#define bod_client_sendmsg_NOTNEED
#define bod_client_sendmsg_project_NOTNEED
#define bod_client_replymsg_NOTNEED
#define bod_client_replymsg_project_NOTNEED
#define bod_client_sendattach_NOTNEED
#define bod_client_verifysign_NOTNEED
#define bod_client_getpubkey_NOTNEED
#define bod_client_registernode_NOTNEED
#define bod_client_remotelogin_NOTNEED
#define bod_client_remotepass_NOTNEED
#define bod_client_remote_interest_set_NOTNEED
#define bod_client_remote_interest_unset_NOTNEED
#define bod_client_nodelogin_NOTNEED
#define bod_client_nodepass_NOTNEED
#define bod_client_sendtalk_anon_NOTNEED
#define bod_client_sendtalk_file_NOTNEED
#define bod_client_list_talk_NOTNEED
#define bod_client_contact_request_NOTNEED
#define bod_client_contact_manage_NOTNEED
#define bod_client_contact_list_NOTNEED
#define bod_client_config_read_NOTNEED
#define bod_client_config_write_NOTNEED
#define bod_client_public_checkuser_NOTNEED
#define bod_client_public_listdir_NOTNEED
#define bod_client_public_readfile_NOTNEED
#define bod_client_public_list_talk_NOTNEED
#define bod_client_form_savevar_NOTNEED
#define bod_client_form_readvar_NOTNEED
#define bod_client_form_deletevar_NOTNEED
#define bod_client_form_deleteall_NOTNEED
#define bod_client_interest_set_NOTNEED
#define bod_client_interest_unset_NOTNEED
#define bod_client_interest_list_NOTNEED
#define bod_client_interest_check_NOTNEED
#define bod_client_systempubkey_NOTNEED
#define bod_client_systemsign_NOTNEED
#define bod_client_info_read_NOTNEED
#define bod_client_info_write_NOTNEED
#include "proto/bod_client.protoch"


struct WEBSITE{
	string account;		// Bolixo account
	string url;		// Url to retrieve the RSS
	string session;		// Pre-logged session
};

struct RSSD_CONFIG{
	vector<WEBSITE> websites;
	void reset(){
		websites.clear();
	}
	void read(PARAM_STRING file);
	void readsessions(PARAM_STRING file);
};

static constexpr unsigned length(const char *s)
{
	return *s == '\0' ? 0 : 1+length(s+1);
}

<mod>
void RSSD_CONFIG::read (PARAM_STRING configfile)
{
	glocal RSSD_CONFIG *config = this;
	glocal WEBSITE website;
	reset();
	<call loadfile>(configfile,true);
	<f oneline>
		constexpr unsigned len_account  = length("account:");
		if (strncmp(line,"account:",len_account)==0){
			if (glocal.website.account.size() > 0){
				glocal.config->websites.push_back(move(glocal.website));
			}
			glocal.website.account = str_skip(line+len_account);
		}else if (strncmp(line,"url:",4)==0){
			glocal.website.url = str_skip(line+4);
		}
		return 0;
	</f>
	</call>
	if (glocal.website.account.size() > 0){
		websites.push_back(move(glocal.website));
	}
}
</mod>
// Read the session ID allocated to each account
<mod>
void RSSD_CONFIG::readsessions (PARAM_STRING file)
{
	glocal RSSD_CONFIG *config = this;
	<call loadfile>(file,true);
	<f oneline>
		vector<string> tb;
		if (str_splitline(line,' ',tb)==2){
			for (auto &w:glocal.config->websites){
				if (w.account == tb[0]){
					w.session = tb[1];
					break;
				}
			}
		}
		return 0;
	</f>
	</call>
}
</mod>

static int rssd_parseurl (PARAM_STRING purl, string &baseurl, string &hostname, string &file)
{
	int ret = -1;
	const char *url = purl.ptr;
	const char *pthost = NULL;
	if (strncasecmp(url,"http://",7)==0){
		pthost = url+7;
	}else if (strncasecmp(url,"https://",8)==0){
		pthost = url+8;
	}
	if (pthost != NULL){
		const char *ptfile = strchr(pthost,'/');
		if (ptfile == NULL){
			baseurl = url;
			hostname = pthost;
		}else{
			file = ptfile;
			baseurl = string(url,ptfile-url);
			hostname = string(pthost,ptfile-pthost);
		}
		ret = 0;
	}
	return ret;
}


<mod>
static int rssd_getrss(PARAM_STRING url, string &rss)
{
	glocal string *rss = &rss;
	glocal unsigned received = 0;
	glocal bool header_seen = false;
	glocal int ret = -1;
	glocal CONNECT_HTTP_INFO con;
	string baseurl,hostname,file;
	if (rssd_parseurl(url,baseurl,hostname,file)==-1) return -1;
	glocal.con.init (baseurl);
	debug_printf (D_GETRSS,"host=%s\n",glocal.con.host.c_str());
	string buf = string_f ("GET %s HTTP/1.0\r\nhost: %s\r\nUser-Agent: bolixo rssd\r\n",file.c_str(),hostname.c_str());
	buf += string_f ("Content-Type: text/html; charset=UTF-8\r\n\r\n");
	glocal.con.send (buf.c_str());
	debug_printf (D_HEADER,"%s-----\n",buf.c_str());
	<call streamp>();
	<f fill>
		int ret = glocal.con.receive (buf,size);
		if (ret <= 0){
			debug_printf (D_GETRSS,"fill received=%u ret=%d size=%u %d(%s)\n",glocal.received,ret,size,errno,strerror(errno));
			ret = 0;
		}else{
			glocal.received += ret;
		}
		return ret; 
	</f>
	<f process>
		int ret = 0;
		const char *line = (const char *)buf;
		const char *endbuf = line+len;
		const char *pt = line;
		while (pt < endbuf && *pt != '\n') pt++;
		//debug_printf (D_GETRSS,"process len=%u %lu %d\n",len,pt-line,pt<endbuf);
		if (pt < endbuf){
			ret = (pt-line)+1;
			string tmp = string(line,pt-line);
			debug_printf (D_GETRSS,"line[%lu]=%s\n",tmp.size(),tmp.c_str());
			if (tmp == "\r" && !glocal.header_seen){
				glocal.header_seen = true;
			}else if (glocal.header_seen){
				(*glocal.rss) += tmp + "\n";
				line = tmp.c_str();
				if (strcasecmp(line,"</rss>")==0){
					glocal.ret = 0;
					end = true;
				}
			}
		}
		return ret;
	</f>
	</call>
	if (rss.size() > 0 && glocal.ret == -1){
		// Some sites produces bad XML. We patch it here
		auto end_pos = rss.find("</rss>");
		if (end_pos == string::npos){
			auto rss_pos = rss.find("<rss");
			if (rss_pos != string::npos){
				rss += "</rss>\n";
			}
		}
		glocal.ret = 0;
	}
	return glocal.ret;
}
</mod>

#define _TLMP_rssd_processxml
struct _F_rssd_processxml{
	#define _F_rssd_processxml_onepage(x) void x onepage(const string &title, const string &link, const string &pubdate, const string &guid, const string &description, const string &content)
	virtual _F_rssd_processxml_onepage( )=0;
};

<mod>
static void rssd_processxml(_F_rssd_processxml &c, const string &rss)
{
	xmlDoc *doc = xmlParseDoc((const xmlChar*)rss.c_str());
	if (doc != NULL){
		xmlNode *cur = xmlDocGetRootElement(doc);
		glocal string title;
		glocal string link;
		glocal string pubdate;
		glocal string guid;
		glocal string description;
		glocal string content;
		glocal _F_rssd_processxml *c = &c;
		<call xmlflat>(cur->xmlChildrenNode,"");
		<f tag>
			//printf ("parent=%s name=%s path=%s\n",parent,name,path);
			const char *val = (const char*)xmlNodeGetContent(node);
			if (strcmp(name,"title")==0){
				glocal.title = val;
			}else if (strcmp(name,"link")==0){
				glocal.link = val;
			}else if (strcmp(name,"pubDate")==0){
				glocal.pubdate = val;
			}else if (strcmp(name,"guid")==0){
				glocal.guid = val;
			}else if (strcmp(name,"description")==0){
				glocal.description = val;
			}else if (strcmp(name,"content")==0){
				glocal.content = val;
			}
		</f>
		<f end>
			if (strcmp(name,"item")==0){
				glocal.c->onepage(glocal.title,glocal.link,glocal.pubdate,glocal.guid,glocal.description,glocal.content);
			}
		</f>
		</call>
	}
}
</mod>
static const char *savexmldir = "/tmp/savexml";
static const char *savelinkdir = "/tmp/savelink";
static const char *tmp_dir = "/tmp";
static const char *force_account = NULL;	// For testing, all messages are sent to this account
<mod>
static int rssd_process (CONNECT_INFO &con, RSSD_CONFIG &config, PARAM_STRING name, string &msg)
{
	glocal CONNECT_INFO *con = &con;
	int ret = -1;
	bool found = false;
	for (auto &r:config.websites){
		if (r.account == name.ptr){
			found = true;
			glocal WEBSITE *r = &r;
			glocal string rss;
			if (r.session.empty()){
				tlmp_error (MSG_U(E_NOSESSSION,"Session not set for account %s\n"),name.ptr);
				break;
			}
			if (rssd_getrss(r.url,glocal.rss)!=-1){
				if (savexmldir != NULL){
					mkdir (savexmldir,0755);
					<call savefile>(string_f("%s/%s.xml",savexmldir,name.ptr),false);
					<f dowrite>
						fprintf (fout,"%s",glocal.rss.c_str());
						return 0;
					</f>
					</call>
				}
				// Load the link already process for that site
				mkdir (savelinkdir,0755);
				glocal set<string> links;
				string fname = string_f("%s/%s.links",savelinkdir,name.ptr);
				<call loadfile>(fname,true);
				<f missing>
					// Not a problem. this files is created on the fly
				</f>
				<f oneline>
					glocal.links.insert(line);
					return 0;
				</f>
				</call>
				<call rssd_processxml>(glocal.rss);
				<f onepage>
					string datelink = pubdate + " " + link;
					if (glocal.links.count(datelink) == 0){
						printf ("Genere message pour link=%s\n",datelink.c_str());
						glocal string content;
						glocal.content = string_f("%s\n\n%s\n\n%s",title.c_str(),link.c_str(),description.c_str());
						glocal bool success = false;
						vector<string> empty;
						BOB_TYPE content(glocal.content.c_str(),glocal.content.size(),false);
						const char *groupowner = force_account != NULL ? force_account : glocal.r->account.c_str();
						<call bod_client_sendtalk>(*glocal.con,glocal.r->session,"",empty,"public",groupowner,content,false,"","","");
						<f ok>
							if (!success) tlmp_error (MSG_U(E_RSSSENDFAIL,"Can't publish the RSS message: %s\n"),msg);
							glocal.success = success;
						</f>
						</call>
						if (glocal.success) glocal.links.insert(datelink);
						string textfile = string_f("%s/rss.txt",tmp_dir);
						<call savefile>(textfile,false);
						<f dowrite>
							fprintf (fout,"%s",glocal.content.c_str());
							return 0;
						</f>
						</call>
					}
				</f>
				</call>
				// Save the links
				<call savefile>(fname,false);
				<f dowrite>
					for (auto const &s:glocal.links) fprintf (fout,"%s\n",s.c_str());
					return 0;
				</f>
				</call>
				ret = 0;
			}
			break;
		}
	}
	if (!found) msg = "Website not found in configuration";
	return ret;
}
</mod>

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *configfile = "/etc/bolixo/rssd.conf";
	glocal const char *sessionsfile = "/var/run/sssd-sessions";
	glocal const char *control = "/var/run/rssd.sock";
	glocal const char *bod_sock = "/dev/bod.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal bool testmode = false;
	glocal bool process = false;
	glocal const char *mysecret = "";
	glocal const char *pidfile = "/var/run/rssd.pid";

	static const char *tbdic[]={"bolixo",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("rssd",VERSION,"Convert RSS feeds into bolixo messages");
		setarg (' ',"config",MSG_U(O_CONFIGPATH,"Configuration file path"),glocal.configfile,false);
		setarg (' ',"sessions",MSG_U(O_SESSIONS,"Session file"),glocal.sessionsfile,false);
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for rssd-control",glocal.control,false);
		setarg (' ',"bod_sock","Unix socket to reach the bod server",glocal.bod_sock,false);
		setarg (' ',"mysecret","Secret used to talk with bod",glocal.mysecret,false);
		setgrouparg ("Directories");
		setarg (' ',"savexml","Save retrieved XML file (for review/debug)",savexmldir,false);
		setarg (' ',"savelink","Save known link about a site",savelinkdir,false);
		setgrouparg ("Misc.");
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","File holding the PID of the process",glocal.pidfile,false);
		setgrouparg ("Tests");
		setarg (' ',"testmode","Execution inline of some part of the rssd server",glocal.testmode,false);
		setarg (' ',"process","Process some websites",glocal.process,false);
		setarg (' ',"force_account","Send all messages to this account",force_account,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main>
		// Test mode.
		int ret = -1;
		if (!glocal.testmode && !glocal.process){
			usage();
		}else if (glocal.process){
			CONNECT_INFO con;	// Connection to bod
			con.port = glocal.bod_sock;
			con.secret = glocal.mysecret;
			RSSD_CONFIG config;
			config.read(glocal.configfile);
			config.readsessions (glocal.sessionsfile);
			for (int i=0; i<argc; i++){
				string msg;
				if (rssd_process(con,config,argv[i],msg)!=-1){
					ret = 0;
				}else{
					tlmp_error ("%s\n",msg.c_str());
					break;
				}
			}
		}else if (glocal.testmode){
			for (int i=0; i<argc; i++){
				const char *arg = argv[i];
				if (strncmp(arg,"http://",7)==0 || strncmp(arg,"https://",8)==0){
					string rss;
					ret = rssd_getrss (arg,rss);
					printf ("%s\n",rss.c_str());
				}else{
					glocal string rss;
					<call loadfile>(arg,false);
					<f oneline>
						glocal.rss += line;
						return 0;
					</f>
					</call>
					<call rssd_processxml> (glocal.rss);
					<f onepage>
						printf ("title=%s\nlink=%s\npubdate=%s\nguid=%s\ndescription=%s\ncontent=%s\n"
						,title.c_str(),link.c_str(),pubdate.c_str(),guid.c_str(),description.c_str(),content.c_str());
					</f>
					</call>
				}
			}
		}
		return ret;
	</f>
	<f main_noarg>
		int ret = -1;
		glocal RSSD_CONFIG config;
		glocal CONNECT_INFO con;	// Connection to bod
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal.con.port = glocal.bod_sock;
		glocal.con.secret = glocal.mysecret;
		<obj TCPSERVER s>();
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}
		</f>
		<f endclient>
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request", "worker request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call rssd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					rep_status(tb);
				</f>
				<f quit>
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f help_connect> // connectto port send = lines:v
					glocal const char *send = send;
					glocal vector<string> lines;
					// We want to test publishd connectivity to the outside
					<call tcpconnect>(connectto,port,5);
					<f init>
						sendf ("%s\n",glocal.send);
					</f>
					<f oneline>
						glocal.lines.push_back(line);
						end = true;
					</f>
					<f fail>
						glocal.lines.emplace_back(string_f("fail: %s\n",strerror(errno)));
					</f>
					<f end>
					</f>
					</call>
					rep_help_connect (glocal.lines);
				</f>
				<f process>
					bool success = true;
					string msg;
					glocal.config.read (glocal.configfile);
					glocal.config.readsessions (glocal.sessionsfile);
					if (websites.size() == 0){
						for (auto const &r:glocal.config.websites){
							if (rssd_process(glocal.con,glocal.config,r.account,msg)==-1){
								success = false;
								break;
							}
						} 
					}else{
						for (auto r:websites){
							if (rssd_process(glocal.con,glocal.config,r,msg)==-1){
								success = false;
								break;
							}
						} 
					}
					rep_process (success,msg);
				</f>
				<f test>
					glocal bool bod = false;
					rep_test (glocal.bod);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

