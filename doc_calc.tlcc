/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	calc is a spreadsheet program.
*/
#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <stdlib.h>
#include <math.h>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <stack>
#include <algorithm>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "documentd_menu.h"
#include "bolixo.m"
#include "doc_calc.h"

using namespace std;

#include "proto/documentd_calc.protoch"
#include "proto/documentd_calc.protoh"

string CELL_COOR::tostring() const
{
	if (col < 26){
		return string_f("%c%u",'A'+col,line+1);
	}else{
		unsigned letter1 = col / 26;
		unsigned letter2 = col % 26;
		return string_f("%c%c%u",'A'+letter1,'A'+letter2,line+1);
	}
}

GAME_P make_CALC()
{
	return make_shared<CALC>();
}

CALC::CALC()
{
}
void CALC::update_msg (bool to_all, PARAM_STRING msg, const char *color, std::vector<VARVAL> &res)
{
	VARVAL mvar;
	mvar.var = to_all ? VAR_NOTIFY : VAR_SCRIPT;
	mvar.val += string_f("calc_updmsg('%s','%s');\n",color,documentd_escape(msg).c_str());
	res.emplace_back(mvar);
}
void CALC::save(DOC_WRITER &w, bool)
{
	documentd_calc_header(&w,revision);
	vector<CELL> cells;
	for (auto &g:grid){
		CELL c;
		c.l = g.first.line;
		c.c = g.first.col;
		c.text = g.second.text;
		cells.emplace_back(move(c));
	}
	documentd_calc_cells(&w,cells);
	vector<COLFORMAT> formats;
	for (auto &f:col_formats){
		COLFORMAT cf;
		cf.col = f.first;
		cf.width = f.second.width;
		cf.precision = f.second.precision;
		cf.align = f.second.align;
		formats.push_back(cf);
	}
	documentd_calc_col_formats(&w,formats);
	vector<CALCPREF> sprefs;
	for (auto &p:prefs){
		CALCPREF s;
		s.session = p.first;
		s.curline = p.second.cursor.line;
		s.curcol  = p.second.cursor.col;
		s.offline = p.second.offset_line;
		s.offcol  = p.second.offset_col;
		sprefs.emplace_back(s);
	}
	documentd_calc_prefs(&w,sprefs);
	vector<CALC_CHAT> schat;
	documentd_copychat (schat,chat);
	documentd_calc_chat(&w,schat);
}
<mod>
void CALC::load(DOC_READER &r, std::string &msg)
{
	resetgame();
	glocal revision;
	glocal grid;
	glocal col_formats;
	glocal chat;
	glocal prefs;
	prefs.clear();
	chat.clear();
	<call documentd_calc>(&r);
	<f header>
		glocal.revision = revision;
	</f>
	<f cells>
		for (auto &c:cells){
			auto &cc = glocal.grid[CELL_COOR(c.l,c.c)];
			cc.text =  c.text;
			cc.eval0();
		}
	</f>
	<f col_formats>
		for (auto &f:formats){
			auto &lf = glocal.col_formats[f.col];
			lf.width = f.width;
			lf.precision = f.precision;
			lf.align = f.align;
		}
	</f>
	<f prefs>
		for (auto &p:prefs){
			auto &pp = glocal.prefs[p.session];
			pp.cursor.line = p.curline;
			pp.cursor.col  = p.curcol;
			pp.offset_line = p.offline;
			pp.offset_col  = p.offcol;
		}
	</f>
	<f chat>
		for (auto l:lines) glocal.chat.emplace_back(l.time,l.line);
	</f>
	<f invalid>
		tlmp_error ("Invalid record while reading whiteboard file: %s",msg);
	</f>
	</call>
	set<CELL_COOR> ids;
	string error;
	eval(ids,error);
}
</mod>
	
void CALC::resetgame()
{
	grid.clear();
	col_formats.clear();
}
const char *CALC::getclass() const
{
	return "CALC";
}
void CALC::testwin(std::vector<VARVAL> &res)
{
}

void CALC::exec (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	std::vector<VARVAL> &res)
{
	tlmp_error ("CALC::exec called");
}
const unsigned TBL_FIXED_LINES=40;
const unsigned TBL_FIXED_COLUMNS=26;
const unsigned DEFAULT_COL_WIDTH=100;
<mod>
string CALC::draw_board (
	const DOC_CONTEXT &ctx,
	CALC_PREF &pref,
	unsigned board_width,
	unsigned board_height,
	unsigned fontsize,
	unsigned docnum,
	bool editmode,		// Enable onXXXX function
	const CELL_COOR &area,	// Show only the cells defined by pref.offset_line/col and area.line/col if area.line>0
	string &script)
{
	glocal fontsize;
	glocal string val;
	glocal script;
		
	unsigned draw_lines = TBL_FIXED_LINES;
	unsigned draw_columns = TBL_FIXED_COLUMNS;
	bool draw_headings = true;
	if (area.line != 0){
		draw_lines = area.line;
		draw_columns = area.col;
		draw_headings = false;
	}
	script += string_f("calc_cur_gameid='%s';\n",gameid.c_str());
	// Generate JS objects
	script += string_f(
		"var calc_%u={\n"
		"\tgameid:'%s',docnum:%u,offline:%u,offcol:%u,lines:%u,columns:%u,heading:%u"
		"};\n"
		"calc_%u.gameselect=function(event){\n"
		"\tcalc_gameselect(this.gameid,this.docnum,event);\n"
		"};\n"
		"calc_%u.gamemove=function(event){\n"
		"\tcalc_gamemove(this.gameid,this.docnum,event);\n"
		"};\n"
		,docnum
		,gameid.c_str(),docnum,pref.offset_line,pref.offset_col,draw_lines,draw_columns,draw_headings
		,docnum
		,docnum);
	// This function helps update a cell. We pass an absolute cell coordinate and function f is called (or not)
	// with the proper td object.
	script += string_f("calc_%u.selcell=function(tds,absline,abscol,f){\n",docnum);
	script += "\tvar line = absline-this.offline;\n"
		"\tvar col = abscol-this.offcol;\n";
	script += "\tif(line >= 0 && line < this.lines && col >= 0 && col < this.columns){\n";
	script += "\t\tvar td=tds[(line+this.heading)*(this.columns+this.heading)+col+this.heading];\n";
	script += "\t\tf(td);\n"
		"\t}\n"
		"};\n";
	script += string_f("calc_%u.updoff=function(offline,offcol){\n",ctx.docnum);
	script += "\tthis.offline=offline;\n"
		"\tthis.offcol=offcol;\n"
		"\tvar tbl=document.getElementById('tbl-'+this.gameid+','+this.docnum);\n"
		"\tvar tds=tbl.getElementsByTagName('td');\n";
	script += string_f("\tfor (var i=1; i<=%u; i++){\n",TBL_FIXED_LINES);
	script += string_f("\t\ttds[i*%u].innerHTML=i+this.offline;\n",TBL_FIXED_COLUMNS+1);
	script += "\t}\n";
	script += string_f("\tfor (var i=0; i<%u; i++){\n",TBL_FIXED_COLUMNS);
	script += "\t\tvar col=i+this.offcol;\n"
		"\t\tif(col < 26){\n"
		"\t\t\ttds[i+1].innerHTML=String.fromCharCode(col+65);\n"
		"\t\t}else{\n"
		"\t\t\ttds[i+1].innerHTML=String.fromCharCode(col/26+65)+String.fromCharCode(col%26+65);\n"
		"\t\t}\n"
		"\t}\n"
		"};\n";

	script += "if (typeof calc_lst == 'undefined') var calc_lst=[];\n";
	script += string_f("calc_lst.push(calc_%u);\n",docnum);
	string onfuncs;
	if (editmode){
		onfuncs = string_f(" onmousedown='calc_%u.gameselect(event);'"
			" onmouseup='calc_gamemouseup(event); return false;'"
			" onwheel='calc_gamewheel(event); return false;'"
			" onmousemove='calc_%u.gamemove(event); return false;'"
			,docnum,docnum);
	}
	glocal.val += string_f("<div style='width:%u;height:%u; overflow:hidden;'>\n",board_width,board_height);
	glocal.val += string_f("<table width=100%% class=calc id='tbl-%s,%d' border=1 %s>\n",gameid.c_str(),docnum,onfuncs.c_str());
	if (draw_headings){
		glocal.val += "<col style='width:50px;min-width:50px;max-width:50px;'>\n";	// This is for the line number column
	}
	for (unsigned col=0; col < draw_columns; col++){
		unsigned width = DEFAULT_COL_WIDTH;
		auto c = col_formats.find(col);
		if (c != col_formats.end()) width = c->second.width;
		glocal.val += string_f("<col style='width:%upx;min-width:%upx;max-width:%upx;'>\n",width,width,width);
	}
	// column names (letters)
	if (draw_headings){
		glocal.val += "<tr><td>";
		for (unsigned i=0; i<26; i++){
			const char *color = pref.cursor.col == i ? "lightblue" : "#E8E8E8";
			unsigned col = i+pref.offset_col;
			string coltxt;
			if (col < 26){
				coltxt = 'A'+col;
			}else{
				unsigned letter1 = col / 26;
				unsigned letter2 = col % 26;
				coltxt = "  ";
				coltxt[0] = 'A' + letter1;
				coltxt[1] = 'A' + letter2;
			}
			glocal.val += string_f("<td style='text-align:center;background-color:%s;' >%s",color,coltxt.c_str());
		}
	}
	for (unsigned i=0; i < draw_lines; i++){
		unsigned line = i+pref.offset_line;
		const char *color = pref.cursor.line == line ? "lightblue" : "#E8E8E8";
		glocal.val += "<tr>";
		if (draw_headings) glocal.val += string_f("<td style='text-align:center; background-color:%s;'>%d",color,line+1);
		for (unsigned j=0; j < draw_columns; j++){
			unsigned col = j+pref.offset_col;
			auto c = grid.find(CELL_COOR(line,col));
			const char *bgcol = "white";
			if (editmode){
				for (auto &p:prefs){
					if (p.second.cursor.line == line && p.second.cursor.col == col){
						if (p.first == ctx.session){
							bgcol = "lightblue";
						}else{
							bgcol = "lightgray";
						}
						break;
					}
				}
			}
			if (c != grid.end()){
				const char *color = c->second.getcolor();
				const char *align = c->second.getalign();
				if (strcmp(bgcol,"white")!=0 || strcmp(color,"black")!=0 || strcmp(align,"left")!=0){
					glocal.val += string_f("<td style='background-color:%s;color:%s;text-align:%s;'>%s"
						,bgcol,color,align,c->second.gettext().c_str());
				}else{
					glocal.val += string_f("<td>%s",c->second.gettext().c_str());
				}
			}else if (strcmp(bgcol,"white")!=0){
				glocal.val += string_f("<td style='background-color:%s;'>",bgcol);
			}else{
				glocal.val += "<td>";
			}
		}
		glocal.val += "\n";
	}
	glocal.val += "</table>\n";
	glocal.val += "</div>\n";
	return glocal.val;
}
</mod>
/*
	Create the javascript functions
*/
string CALC::define_functions(
	const DOC_CONTEXT &ctx,
	const CALC_PREF &pref,
	unsigned board_width,
	unsigned board_height)
{
	string val;
	wordproc_set_gamepress(val,"calc_gamepress");
	// Dummy needed by gamepress, shared with doc_wordproc
	val += "function getlastline(){\n";
	val += "\treturn 0;\n";
	val += "}\n";

	// Update the message field
	val += "function calc_updmsg(color,msg){\n";
	val += string_f("\tvar elm = document.getElementById('msg-%s');\n",gameid.c_str());
	val += "\tif (elm != null){\n";
	val += "\t\telm.style.color=color;\n";
	val += "\t\telm.innerHTML=msg;\n";
	val += "\t}\n";
	val += "}\n";

	// Set the background color of a cell to indicate that it is current.
	// Use #E8E8E8 for cells current for other sessions, use lightblue for the current session
	val += "function set_td_bg(td,sessions){\n";
	val += "\tvar color='#E8E8E8';\n";
	val += "\tfor (var i=0; i<sessions.length; i++){\n";
	val += string_f("\t\tif (sessions[i]=='%s'){\n",ctx.session);
	val += "\t\t\tcolor='lightblue';\n";
	val += "\t\t\tbreak;\n";
	val += "\t\t}\n";
	val += "\t}\n";
	val += "\ttd.style.background=color;\n";
	val += "}\n";


	// Check for enter on the edit field and transfer the content to the grid
	val += "function calc_editpress(event){\n";
	val += string_f("\tvar elm = document.getElementById('edit-%s');\n",gameid.c_str());
	val += "if (elm != null){\n";
	val += "\t\tgameaction(event,'edit:'+event.key+','+elm.value);\n";
	val += "\t}\n";
	val += "}\n";

	// Select one cell using the mouse
	// We walk all the TD in the table and report the one selected and the relative cursor position
	val += "function calc_gameselect(gameid,docnum,event){\n";
	val += "\tvar tbl = document.getElementById('tbl-'+gameid+','+docnum);\n";
	val += "console.log('tbl='+tbl);\n";
	val += "\tif (tbl != null){\n";
	val += "\t\tvar tds = tbl.getElementsByTagName('td');\n";
	val += "\t\tfor (var i=0; i<tds.length; i++){\n";
	val += "\t\t\tvar rect = tds[i].getBoundingClientRect();\n";
	val += "\t\t\tif (event.clientX >= rect.left && event.clientX < rect.right && event.clientY >= rect.top && event.clientY < rect.bottom){\n";
	val += "\t\t\t\tgameaction(event,'select:'+i+','+(event.clientX-rect.left)+','+(event.clientY-rect.top)+ ','+event.which+','+event.shiftKey+','+event.ctrlKey);\n";
	val += "\t\t\t\tbreak;\n";	
	val += "\t\t\t}\n";	
	val += "\t\t}\n";	
	val += "\t}\n";	
	val += "}\n";	

	val += "function calc_gamemove(gameid,docnum,event){\n";
	val += "}\n";
	val += "function calc_gamemouseup(event){\n";
	val += "}\n";
	val += "function calc_gamewheel(event){\n";
	val += "}\n";

	val += documentd_js_loop_function("tbl","calc");
	return val;
}
string CALC::define_styles(const DOC_CONTEXT &ctx, const DOC_UI_SPECS_receive &sp)
{
	string val;
	val += ".calc{\n"
		"\ttable-layout: fixed;\n"
		"}\n";
	#if 0
	val += ".calc ttd{\n"
		"\tmin-width:50px;\n"
		"\tmax-width:50px;\n"
		"\toverflow: hidden;\n"
		"}\n";
	#endif
	return val;
}
void CALC::setfocus(VARVAL &script_var)
{
	documentd_setfocus(script_var,string_f("text-%s",gameid.c_str()));
}

/*
	Update the background color of the column and line, matching the new cursor position
*/
void CALC::update_lines_cols(CALC_PREF &pref, const CELL_COOR &old, const CELL_COOR &new_pos, VARVAL &var)
{
	var.val += "calc_loop_board(function(e,calc){\n";
	var.val += "\tvar tds=e.getElementsByTagName('td');\n";
	if (old.line != new_pos.line){
		var.val += string_f("\tvar td=tds[%u];\n",(old.line-pref.offset_line+1)*(TBL_FIXED_COLUMNS+1));
		var.val += "\ttd.style.background='#E8E8E8';\n";
		var.val += string_f("\tvar td=tds[%u];\n",(new_pos.line-pref.offset_line+1)*(TBL_FIXED_COLUMNS+1));
		var.val += "\ttd.style.background='lightblue';\n";
	}
	if (old.col != new_pos.col){
		var.val += string_f("\tvar td=tds[%u];\n",old.col-pref.offset_col+1);
		var.val += "\ttd.style.background='#E8E8E8';\n";
		var.val += string_f("\tvar td=tds[%u];\n",new_pos.col-pref.offset_col+1);
		var.val += "\ttd.style.background='lightblue';\n";
	}
	var.val += "});\n";
}
/*
	Send update about some cells to all users
*/
void CALC::update_cells(set<CELL_COOR> &cells, VARVAL &var)
{
	if (cells.size() > 0){
		// We always draw a fixed number of lines and columns. There is no ids for td tag.
		// So we count them
		var.val += "calc_loop_board(function(e,calc){\n";
		var.val += "\tvar tds=e.getElementsByTagName('td');\n";
		var.val += "\tconsole.log('calc='+calc);\n";
		for (auto &c:cells){
			var.val += string_f("\tcalc.selcell(tds,%u,%u,function(td){\n",c.line,c.col);
			auto g = grid.find(c);
			if (g != grid.end()){
				const char *color = g->second.getcolor();
				const char *align = g->second.getalign();
				var.val += string_f("\t\ttd.innerHTML='%s';\n",g->second.gettext().c_str());
				var.val += string_f("\t\ttd.style.color='%s';\n",color);
				var.val += string_f("\t\ttd.style.textAlign='%s';\n",align);
			}else{
				var.val += "\t\ttd.innerHTML='';\n";
			}
			string sessions;
			for (auto &p:prefs){
				if (p.second.cursor == c){
					if (sessions.size() > 0) sessions += ',';
					sessions += "'" + p.first + "'";
				}
			}
			if (sessions.size() > 0){
				var.val += string_f("\t\tset_td_bg(td,[%s]);\n",sessions.c_str());
			}else{
				var.val += "\t\ttd.style.background='white';\n";
			}
			var.val += "\t});\n";
		}
		var.val += "});\n";
	}
}
/*
	Change the name of the current cell in the top status line.
*/
void CALC::update_cellname(CALC_PREF &pref, VARVAL &var)
{
	var.val += string_f("var elm = document.getElementById('cell-%s');\n",gameid.c_str());
	var.val += "if (elm != null){\n";
	var.val += string_f("\telm.innerHTML='%s';\n",pref.cursor.tostring().c_str());
	var.val += "}\n";
}
/*
	Change the content of the edit field.
*/
void CALC::update_celledit(CALC_PREF &pref, VARVAL &var)
{
	var.val += string_f("var elm = document.getElementById('edit-%s');\n",gameid.c_str());
	var.val += "if (elm != null){\n";
	const char *celltext = "";
	auto c = grid.find(pref.cursor);
	if (c != grid.end()) celltext = c->second.text.c_str();
	var.val += string_f("\telm.value='%s';\n",celltext);
	var.val += "}\n";
}

/*
	Update the content of one cell. If the content is empty, the cell is removed from the grid map.
*/
void CALC::update_onecell (CALC_PREF &pref, PARAM_STRING buf)
{
	if (buf.ptr[0] != '\0'){
		auto &c = grid[pref.cursor];
		c.text = buf.ptr;
		c.state = CELL_STATE_UNKNOWN;
		c.eval0();
	}else{
		auto g = grid.find(pref.cursor);
		if (g != grid.end()){
			grid.erase(g);
		}
	}
}
void CALC::update_col_width(VARVAL &var, unsigned col, unsigned width)
{
	var.val += "calc_loop_board(function(e,calc){\n";
	var.val += "\tvar cols=e.getElementsByTagName('col');\n";
	col++;
	var.val += string_f("\tcols[%u].style.minWidth='%upx';\n",col,width);
	var.val += string_f("\tcols[%u].style.width='%upx';\n",col,width);
	var.val += string_f("\tcols[%u].style.maxWidth='%upx';\n",col,width);
	var.val += "});\n";
}
void CALC::update_offsets(VARVAL &var, const DOC_CONTEXT &ctx, CALC_PREF &pref)
{
	var.val += string_f("calc_%u.updoff(%u,%u);\n",ctx.docnum,pref.offset_line,pref.offset_col);
}

/*
	Insert a line or a column in the grid.
	This is done by copying the grid into a vector, updating the coordinate
	and rebuilding the grid.
	We update the formula as well.
*/
void CALC::insert_line_col(unsigned line, unsigned col, int offline, int offcol)
{
	struct KEYVAL {
		CELL_COOR coor;
		CALC_CELL cell;
		KEYVAL(const CELL_COOR &_coor, const CALC_CELL &_cell):coor(_coor),cell(_cell){}
	};
	vector<KEYVAL> vec;
	CELL_COOR ref (line,col);
	for (auto &g:grid){
		CELL_COOR coor(g.first);
		if (coor.line >= line) coor.line++;
		if (coor.col >= col) coor.col++;
		g.second.applyoffset(ref,offline,offcol);
		vec.emplace_back(coor,g.second);
	}
	grid.clear();
	for (auto &v:vec) grid[v.coor] = v.cell;
	struct KEYFORMAT{
		unsigned col;
		CALC_COL_FORMAT format;
		KEYFORMAT (unsigned _col, const CALC_COL_FORMAT &_format)
			:col(_col),format(_format){}
	};
	vector<KEYFORMAT> vecf;
	for (auto &f:col_formats){
		unsigned first = f.first;
		if (first >= col) first++;
		vecf.emplace_back(first,f.second);
	}
	col_formats.clear();
	for (auto &v:vecf) col_formats[v.col] = v.format;
}
void CALC::delete_line_col(unsigned line, unsigned col, int offline, int offcol)
{
	struct KEYVAL {
		CELL_COOR coor;
		CALC_CELL cell;
		KEYVAL(const CELL_COOR &_coor, const CALC_CELL &_cell):coor(_coor),cell(_cell){}
	};
	vector<KEYVAL> vec;
	CELL_COOR ref (line,col);
	for (auto &g:grid){
		CELL_COOR coor(g.first);
		if (coor.line != line && coor.col != col){
			if (coor.line > line) coor.line--;
			if (coor.col > col) coor.col--;
			g.second.applyoffset(ref,offline,offcol);
			vec.emplace_back(coor,g.second);
		}
	}
	grid.clear();
	for (auto &v:vec) grid[v.coor] = v.cell;
	struct KEYFORMAT{
		unsigned col;
		CALC_COL_FORMAT format;
		KEYFORMAT (unsigned _col, const CALC_COL_FORMAT &_format)
			:col(_col),format(_format){}
	};
	vector<KEYFORMAT> vecf;
	for (auto &f:col_formats){
		unsigned first = f.first;
		if (first != col){
			if (first > col) first--;
			vecf.emplace_back(first,f.second);
		}
	}
	col_formats.clear();
	for (auto &v:vecf) col_formats[v.col] = v.format;
}
/*
	Insert one line in the grid.
	Generate the javascript code.
*/
void CALC::insert_line(VARVAL &var, unsigned line)
{
	insert_line_col(line,(unsigned)-1,1,0);
	// For each listener, we must remove the last <tr> and insert a new one, it it applies
	// The first <tr> contains the heading.
	var.val += "calc_loop_board(function(tbl,calc){\n";
	var.val += string_f("\tvar offl=%u-calc.offline;\n",line);
	var.val += "console.log('offl='+offl);\n";
	var.val += string_f("\tif (offl >= 0 && offl < %u){\n",TBL_FIXED_LINES);
	var.val += "\t\tvar trs = tbl.getElementsByTagName('tr');\n";
	var.val += string_f("\t\ttrs[%u].parentNode.removeChild(trs[%u]);\n",TBL_FIXED_LINES,TBL_FIXED_LINES);
	var.val += "\t\tvar newtr = document.createElement('tr');\n";
	var.val += "\t\ttrs[0].parentNode.insertBefore(newtr,trs[offl+1]);\n";
	var.val += "\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\tnewtd.style.textAlign='center';\n";
	var.val += "\t\tnewtr.appendChild(newtd);\n";
	var.val += string_f("\t\tfor (var i=0; i<%u; i++){\n",TBL_FIXED_COLUMNS);
	var.val += "\t\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\t\tnewtr.appendChild(newtd);\n";
	var.val += "\t\t}\n";
	var.val += "\t\tcalc.updoff(calc.offline,calc.offcol);\n";
	// Clear the cursor for all users on this line
	map<unsigned,string> sessions;	// Sessions associated with one column on that line
	for (auto &p:prefs){
		if (p.second.cursor.line == line){
			auto &s = sessions[p.second.cursor.col];
			if (s.size() > 0) s += ',';
			s += "'" + p.first + "'";
		}
	}
	for (auto &s:sessions){
		var.val += string_f("\t\tvar offc = %u - calc.offcol;\n",s.first);
		var.val += string_f("\t\tif(offc >= 0 && offc < %u){\n",TBL_FIXED_COLUMNS);
		var.val += "\t\t\tvar tds=trs[offl+2].getElementsByTagName('td');\n";
		var.val += "\t\t\ttds[0].style.background='#E8E8E8';\n";
		var.val += "\t\t\ttds[offc+1].style.background='white';\n";
		var.val += "\t\t\tvar tds=trs[offl+1].getElementsByTagName('td');\n";
		var.val += string_f("\t\t\tset_td_bg(tds[0],[%s]);\n",s.second.c_str());
		var.val += string_f("\t\t\tset_td_bg(tds[offc+1],[%s]);\n",s.second.c_str());
		var.val += "\t\t}\n";
	}
	var.val += "\t}\n";
	var.val += "});\n";
}
void CALC::insert_col(VARVAL &var, unsigned col)
{
	insert_line_col((unsigned)-1,col,0,1);
	// For each listener, we must remove the last <td> of a line and insert a new one, if it applies
	var.val += "calc_loop_board(function(tbl,calc){\n";
	var.val += string_f("\tvar offc=%u-calc.offcol;\n",col);
	var.val += "console.log('offc='+offc);\n";
	var.val += string_f("\tif (offc >= 0 && offc < %u){\n",TBL_FIXED_COLUMNS);
	// Remove last col, insert one
	var.val += "\t\tvar cols = tbl.getElementsByTagName('col');\n";
	var.val += string_f("\t\tcols[0].parentNode.removeChild(cols[%u]);\n",TBL_FIXED_COLUMNS);
	var.val += "\t\tvar newcol = document.createElement('col');\n";
	var.val += string_f("\t\tnewcol.style.minWidth='%upx';\n",DEFAULT_COL_WIDTH);
	var.val += string_f("\t\tnewcol.style.maxWidth='%upx';\n",DEFAULT_COL_WIDTH);
	var.val += "\t\tcols[0].parentNode.insertBefore(newcol,cols[offc+1]);\n";
	// Remote last td and insert one for each tr
	var.val += "\t\tvar trs = tbl.getElementsByTagName('tr');\n";
	var.val += string_f("\t\tfor (var i=0; i<=%u; i++){\n",TBL_FIXED_LINES);
	var.val += "\t\t\tvar tds = trs[i].getElementsByTagName('td');\n";
	var.val += string_f("\t\t\ttds[0].parentNode.removeChild(tds[%u]);\n",TBL_FIXED_COLUMNS);
	var.val += "\t\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\t\tif (i==0){\n";
	var.val += "\t\t\t\tnewtd.style.textAlign='center';\n";
	var.val += "\t\t\t\tnewtd.style.background='#E8E8E8';\n";
	var.val += "\t\t\t}\n";
	var.val += "\t\t\ttds[0].parentNode.insertBefore(newtd,tds[offc+1]);\n";
	var.val += "\t\t}\n";
	var.val += "\t\tcalc.updoff(calc.offline,calc.offcol);\n";
	// Clear the cursor for all users on this column
	// Clear and set the background on the column header
	var.val += "\t\tvar defcol='#E8E8E8';\n";
	var.val += string_f("\t\tfor (var i=0; i<=%u; i++){\n",TBL_FIXED_LINES);
	var.val += "\t\t\tvar tds=trs[i].getElementsByTagName('td');\n";
	var.val += "\t\t\tvar bgcol = window.getComputedStyle(tds[offc+2], null).getPropertyValue('background-color');\n";
	var.val += "console.log('bgcol='+bgcol);\n";
	var.val += "\t\t\tif(bgcol!=defcol){\n";
	var.val += "\t\t\t\ttds[offc+1].style.background=bgcol;\n";
	var.val += "\t\t\t\ttds[offc+2].style.background=defcol;\n";
	var.val += "\t\t\t}else{\n";
	var.val += "\t\t\t\ttds[offc+1].style.background=defcol;\n";
	var.val += "\t\t\t}\n";
	var.val += "\t\t\tdefcol='white';\n";
	var.val += "\t\t}\n";
	var.val += "\t}\n";
	var.val += "});\n";
}
void CALC::delete_line(VARVAL &var, unsigned line)
{
	delete_line_col (line,(unsigned)-1,-1,0);
	// For each listener, we must remove the line <tr> and append a new one at the end, if it applies
	var.val += "calc_loop_board(function(tbl,calc){\n";
	var.val += string_f("\tvar offl=%u-calc.offline;\n",line);
	var.val += "console.log('offl='+offl);\n";
	var.val += string_f("\tif (offl >= 0 && offl < %u){\n",TBL_FIXED_LINES);
	var.val += "\t\tvar trs = tbl.getElementsByTagName('tr');\n";
	var.val += "\t\ttrs[0].parentNode.removeChild(trs[offl+1]);\n";
	var.val += "\t\tvar newtr = document.createElement('tr');\n";
	var.val += "\t\ttrs[0].parentNode.appendChild(newtr);\n";
	var.val += "\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\tnewtd.style.textAlign='center';\n";
	var.val += "\t\tnewtr.appendChild(newtd);\n";
	var.val += string_f("\t\tfor (var i=0; i<%u; i++){\n",TBL_FIXED_COLUMNS);
	var.val += "\t\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\t\tnewtr.appendChild(newtd);\n";
	var.val += "\t\t}\n";
	var.val += "\t\tcalc.updoff(calc.offline,calc.offcol);\n";
	// Set the cursor for all users on this line
	map<unsigned,string> sessions;	// Sessions associated with one column on that line
	for (auto &p:prefs){
		if (p.second.cursor.line == line){
			auto &s = sessions[p.second.cursor.col];
			if (s.size() > 0) s += ',';
			s += "'" + p.first + "'";
		}
	}
	for (auto &s:sessions){
		var.val += string_f("\t\tvar offc = %u - calc.offcol;\n",s.first);
		var.val += string_f("\t\tif(offc >= 0 && offc < %u){\n",TBL_FIXED_COLUMNS);
		var.val += "\t\t\tvar tds=trs[offl+1].getElementsByTagName('td');\n";
		var.val += string_f("\t\t\tset_td_bg(tds[0],[%s]);\n",s.second.c_str());
		var.val += string_f("\t\t\tset_td_bg(tds[offc+1],[%s]);\n",s.second.c_str());
		var.val += "\t\t}\n";
	}
	var.val += "\t}\n";
	var.val += "});\n";
}
void CALC::delete_col(VARVAL &var, unsigned col)
{
	delete_line_col ((unsigned)-1,col,0,-1);
	// For each listener, we must remove the col <td> of each line and append a new one, if it applies
	var.val += "calc_loop_board(function(tbl,calc){\n";
	var.val += string_f("\tvar offc=%u-calc.offcol;\n",col);
	var.val += "console.log('offc='+offc);\n";
	var.val += string_f("\tif (offc >= 0 && offc < %u){\n",TBL_FIXED_COLUMNS);
	// move  the cursor for all users on this column to the next
	var.val += "\t\tvar trs = tbl.getElementsByTagName('tr');\n";
	// Clear and set the background on the column header
	var.val += "\t\tvar defcol='#E8E8E8';\n";
	var.val += string_f("\t\tfor (var i=0; i<%u; i++){\n",TBL_FIXED_LINES);
	var.val += "\t\t\tvar tds=trs[i].getElementsByTagName('td');\n";
	var.val += "\t\t\tif(tds[offc+1].style.background!=defcol){\n";
	var.val += "\t\t\t\ttds[offc+2].style.background=tds[offc+1].style.background;\n";
	var.val += "\t\t\t}else{\n";
	var.val += "\t\t\t\ttds[offc+2].style.background=defcol;\n";
	var.val += "\t\t\t}\n";
	var.val += "\t\t\tdefcol='white';\n";
	var.val += "\t\t}\n";
	// Remove current col, append one
	var.val += "\t\tvar cols = tbl.getElementsByTagName('col');\n";
	var.val += "\t\tcols[0].parentNode.removeChild(cols[offc+1]);\n";
	var.val += "\t\tvar newcol = document.createElement('col');\n";
	var.val += string_f("\t\tnewcol.style.minWidth='%upx';\n",DEFAULT_COL_WIDTH);
	var.val += string_f("\t\tnewcol.style.maxWidth='%upx';\n",DEFAULT_COL_WIDTH);
	var.val += "\t\tcols[0].parentNode.appendChild(newcol);\n";
	// Remote cur td and append one for each tr
	var.val += string_f("\t\tfor (var i=0; i<=%u; i++){\n",TBL_FIXED_LINES);
	var.val += "\t\t\tvar tds = trs[i].getElementsByTagName('td');\n";
	var.val += "\t\t\ttds[0].parentNode.removeChild(tds[offc+1]);\n";
	var.val += "\t\t\tvar newtd = document.createElement('td');\n";
	var.val += "\t\t\tif (i==0){\n";
	var.val += "\t\t\t\tnewtd.style.textAlign='center';\n";
	var.val += "\t\t\t\tnewtd.style.background='#E8E8E8';\n";
	var.val += "\t\t\t}\n";
	var.val += "\t\t\ttds[0].parentNode.appendChild(newtd);\n";
	var.val += "\t\t}\n";
	var.val += "\t\tcalc.updoff(calc.offline,calc.offcol);\n";
	var.val += "\t}\n";
	var.val += "});\n";
}
<mod>
void CALC::execstep (
	const char *var,
	const char *val,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	VARVAL &script_var,
	VARVAL &notify_var,
	set<CELL_COOR> &notify_ids,
	std::vector<VARVAL> &res,
	string &error,
	string &status)
{
	auto &pref = prefs[ctx.session];
	unsigned waiting_users_width = sp.mobile ? 62 : 42;
	unsigned board_width = sp.content_width - waiting_users_width;	// Space for user list
	const unsigned scroll_thick = sp.mobile ? 12 : 6;
	board_width -= scroll_thick;
	unsigned board_height = sp.content_height-scroll_thick;
	string api_error;
	setactivity();
	string tmpvar,tmpval;
	if (strcmp(var,"kbd")==0){
		unsigned lastline = 1000;
		wordproc_kbd(val,pref.mod,tmpvar,tmpval,lastline);
		var = tmpvar.c_str();
		val = tmpval.c_str();
		//tlmp_warning ("var=%s val=%s",var,val);		
	}
	if (strcmp(var,REQ_PRINT)==0){
		if (is_any_of(val,"","full")){
			VARVAL v;
			v.var = VAR_CONTENT;
			v.val += "<style>\n";
			v.val += define_styles(ctx,sp);
			v.val += "</style>\n";
			v.val += "<script>\n";
			v.val += define_functions(ctx,pref,board_width,board_height);
			v.val += "</script>\n";
			// Buttons line
			if (ctx.maywrite){
				#define BUTTON_NEWDOC	0
				#define BUTTON_COLSTYLE	1
				#define BUTTON_INSCOLLINE 2
				v.val += "<div id=tab_form style='display:flex; flex-flow:column;'>\n";
				v.val += "<div style='flex:0 0 auto; width:100%;margin-top:5; background-color: lightgray;'>\n";
				DOC_BUTTON_SPECS specs;
				if (sp.mobile){
					specs.width = 60;
					specs.radius = 6;
					specs.margin_left = 10;
					specs.margin_top = 4;
					specs.margin_bottom = 4;
				}
				CALC_MENU menu(specs);
				documentd_button_start(v.val,gameid);
				documentd_bar_button (v.val,BUTTON_NEWDOC,menu.svg_clear,specs,false,MSG_U(I_RESETDOC,"Reset document"));
				//documentd_bar_button (v.val,BUTTON_COLSTYLE,"S",specs,false);
				documentd_bar_button (v.val,BUTTON_INSCOLLINE,"+",specs,false,MSG_U(I_INSCOLLINE,"Insert/Delete lines or columns"));
				documentd_button_space(v.val);
				documentd_button_end(v.val);
				v.val += "</div>\n";
				v.val += "<div style='flex:0 0 auto; margin-bottom:5;'>\n";
				v.val += string_f("<span id='page-%s'>page 1</span>\n",gameid.c_str());
				v.val += string_f("<span id='cell-%s'>%s</span>\n",gameid.c_str(),pref.cursor.tostring().c_str());
				const char *content = "";
				auto g = grid.find(pref.cursor);
				if (g != grid.end()) content = g->second.text.c_str();
				v.val += string_f("<input type=text id='edit-%s' style='width:400;' onkeyup='calc_editpress(event);' value='%s'/>\n"
					,gameid.c_str(),documentd_escape(content).c_str());

				v.val += "</div>\n";
			}else{
				v.val += "<div id=tab_form style='margin-top:5; margin-bottom:5; background-color: lightgray;'>\n";
				v.val += MSG_R(M_READONLY);
			}
			v.val += "</div>\n";
			// Board
			v.val += string_f("<div class=webtable id=%sdoc_calc style='display:flex; flex-flow:row;' >\n",val);
			v.val += string_f("<div id='text-%s' style='flex:0 0 auto;width:%u;height:%u;border:1px solid black;"
				" margin-left: auto;'"
				" onkeydown='calc_gamepress(event);return false;'"
				" tabindex=0 >\n",gameid.c_str(),board_width,board_height);
			string script;
			v.val += draw_board(ctx,pref,board_width,board_height,sp.fontsize,ctx.docnum,true,CELL_COOR(),script);
			if (script.size() > 0){
				v.val += "<script>\n";
				v.val += script;
				v.val += "</script>\n";
			}
			v.val += "<div style='background-color:ghostwhite;'>\n";
			v.val += string_f("<svg width=%u height=%u>\n",board_width,scroll_thick);
			v.val += string_f("<rect id='hscroll-%s' x=%u y=0 rx=3 ry=3 width=%u height=%u fill=lightgray />\n"
				,gameid.c_str(),pref.offset_col*board_width/(4*board_width),board_width/4,scroll_thick);
			v.val += "</svg>\n";
			v.val += "</div>\n";
			v.val += "</div>\n";
			v.val += string_f("<div style='flex:0 0 auto; margin-right:auto; background-color: ghostwhite; width:%u;height:%u;'>",scroll_thick,board_height);
			v.val += "<svg width=100% height=100%>\n";
			v.val += string_f("<rect id='vscroll-%s' x=0 y=%u rx=3 ry=3 width=%u height=%u fill=lightgray />\n"
				,gameid.c_str(),pref.offset_line*board_height/(4*board_height),scroll_thick,board_height/4);
			v.val += "</svg>\n";
			v.val += "</div>\n";
			draw_waiting_users(v.val,waiting_users_width,board_height,"flex:0 0 auto;");
			v.val += "</div>\n";
			// Status line
			v.val += "<div id=tab_form>\n";
			v.val += string_f("<div id=msg-%s style=color:black>&nbsp;</div>\n",gameid.c_str());
			documentd_chat (v.val,ctx.username,chat,sp.width-20,sp.mobile ? 200 : 100);
			v.val += "</div>\n";
			res.emplace_back(move(v));
		}
	}else if (strcmp(var,REQ_FOCUS)==0){
		setfocus(script_var);
	}else if (strcmp(var,REQ_FUNCTIONS)==0){
		VARVAL var;
		var.var = VAR_DEFSCRIPT;
		var.val = define_functions (ctx,pref,board_width,board_height);
		res.emplace_back(move(var));
	}else if (strcmp(var,REQ_STYLES)==0){
		VARVAL var;
		var.var = VAR_STYLES;
		var.val += define_styles(ctx,sp);
		res.emplace_back(move(var));
	}else if (strcmp(var,REQ_REGION)==0){
		// For embedding
		// A region is either a range (a1:c3) or a name (not done yet)
		CELL_COOR start,end;
		if (calc_parserange(val,start,end)){
			CALC_PREF p;
			p.offset_line = start.line;
			p.offset_col  = start.col;
			CELL_COOR area;
			area.line = end.line - start.line+1;
			area.col  = end.col - start.col+1;
			VARVAL var,var_script;
			var.var = VAR_CONTENT;
			var_script.var = VAR_DEFSCRIPT;
			var.val += draw_board(ctx,p,board_width,board_height,sp.fontsize,ctx.docnum,false,area,var_script.val);
			res.emplace_back(move(var));
			res.emplace_back(move(var_script));
		}
	}else if (strcmp(var,"chat")==0){
		appendchat(val,notify_var.val,res);
	}else if (strcmp(var,REQ_GETFIELDS)==0){
		VARVAL var;
		var.var = VAR_FIELDS;
		res.emplace_back(var);
	}else if (strcmp(var,"dump")==0){
		VARVAL var;
		var.var = "elements";
		var.val += "\n";
		res.emplace_back(var);
	}else if (is_any_of(var,"pageup","pagedown")){
		if (strcmp(var,"pageup")==0){
			if (pref.offset_line < 25){
				if (pref.cursor.line >= 25) pref.cursor.line -= pref.offset_line;
				pref.offset_line = 0;
			}else{
				pref.offset_line -= 25;
				pref.cursor.line -= 25;
			}
		}else{
			pref.offset_line += 25;
			pref.cursor.line += 25;
		}
		update_offsets(script_var,ctx,pref);
		set<CELL_COOR> ids;
		for (unsigned line=0; line<TBL_FIXED_LINES; line++){
			for (unsigned col=0; col<TBL_FIXED_COLUMNS; col++){
				CELL_COOR coor(line+pref.offset_line,col+pref.offset_col);
				ids.insert (coor);
			}
		}
		update_cells(ids,script_var);
		//documentd_forcerefresh(res);
		//setfocus(script_var);
	}else if (ctx.maywrite){
		auto old_cursor = pref.cursor;
		if (strcmp(var,"break")==0 && pref.mod.shift){
			insert_line (notify_var,pref.cursor.line);
			update_celledit (pref,script_var);
		}else if (strcmp(var,"break")==0 && pref.mod.ctrl){
			insert_col (notify_var,pref.cursor.col);
			update_celledit (pref,script_var);
		}else if (strcmp(var,"deletechar")==0 && pref.mod.shift){
			delete_line (notify_var,pref.cursor.line);
			update_celledit (pref,script_var);
		}else if (strcmp(var,"deletechar")==0 && pref.mod.ctrl){
			delete_col (notify_var,pref.cursor.col);
			update_celledit (pref,script_var);
		}else if (is_any_of(var,"deletechar","backspace","insertchar")){
			string buf;
			auto c = grid.find(pref.cursor);
			bool filled_cell = c != grid.end();
			if (filled_cell){
				buf = c->second.text;
			}
			if (strcmp(var,"deletechar")==0){
				buf.clear();
			}else if (strcmp(var,"backspace")==0){
				documentd_eraselast(buf);
			}else{
				buf += val;
			}
			update_onecell (pref,buf);
			update_celledit (pref,script_var);
			notify_ids.insert(pref.cursor);
		}else if (is_any_of(var,"vmove","break")){
			int move;
			if (strcmp(var,"break")==0){
				move = 1;
			}else{
				move = atoi(val);
			}
			if (move > 0){
				pref.cursor.line += move;
			}else if (-move <= pref.cursor.line){
				pref.cursor.line += move;
			}
		}else if (is_any_of(var,"hmove","tab")){
			int move;
			bool shift = pref.mod.shift;
			if (strcmp(var,"tab")==0){
				move = shift ? -1 : 1;
				shift = false;
			}else{
				move = atoi(val);
			}
			if (shift){
				unsigned width = DEFAULT_COL_WIDTH;
				auto c = col_formats.find(pref.cursor.col);
				if (c != col_formats.end()) width = c->second.width;
				width += move*5;
				if (width != DEFAULT_COL_WIDTH){
					col_formats[pref.cursor.col].width = width;
				}else if (c != col_formats.end()){
					col_formats.erase(c);
				}
				update_col_width(notify_var,pref.cursor.col,width);
			}else{
				if (move > 0){
					pref.cursor.col += move;
				}else if (-move <= pref.cursor.col){
					pref.cursor.col += move;
				}
			}
		}else if (strcmp(var,"select")==0){
			auto tb = str_splitline(val,',');
			if (tb.size() == 6){
				unsigned cell = atoi(tb[0].c_str());
				#if 0
				unsigned x = atoi(tb[1].c_str());
				unsigned y = atoi(tb[2].c_str());
				unsigned button = atoi(tb[3].c_str());
				bool shiftkey = tb[4] == "true";
				bool ctrlkey = tb[5] == "true";
				#endif
				unsigned line = pref.offset_line + cell/(TBL_FIXED_COLUMNS+1);
				unsigned col  = pref.offset_col + cell%(TBL_FIXED_COLUMNS+1);
				if (line > 0 && col > 0){
					pref.cursor.line = line-1;
					pref.cursor.col = col-1;
				}else if (line == 0){
					// Select one column
				}else if (col == 0){
					// Select one line
				}
			}
		}else if (strcmp(var,"mousemove")==0){
		}else if (strcmp(var,"wheel")==0){
		}else if (strcmp(var,"newgame")==0){
			int uval = atoi(val);
			if (uval == BUTTON_NEWDOC){
				VARVAL var;
				var.var = VAR_DIALOG;
				var.val = DIALOG_CALC_NEW;
				res.emplace_back(var);
			}else if (uval == BUTTON_COLSTYLE){
			}else if (uval == BUTTON_INSCOLLINE){
				VARVAL var;
				var.var = VAR_DIALOG;
				var.val = DIALOG_CALC_INSCOLLINE;
				res.emplace_back(var);
			}else{
				tlmp_error ("calc newgame=%d",uval);
			}
			setfocus(script_var);
		}else if (strcmp(var,"edit")==0){
			const char *pt = strchr(val,',');
			if (pt != nullptr){
				// we only care about the key transfered if it is a Enter, so we change cell
				// tlmp_warning ("edit val=%s",val);
				string key = string(val,pt-val);
				pt++;
				update_onecell(pref,pt);
				notify_ids.insert (pref.cursor);
				if (key=="Enter"){
					pref.cursor.line++;
					notify_ids.insert (pref.cursor);
					setfocus(script_var);
				}else if (key=="Tab"){
					pref.cursor.col++;
					notify_ids.insert (pref.cursor);
					setfocus(script_var);
				}
			}
		// The other actions are Used to script modification of the document
		}else if (strcmp(var,"resetgame")==0){
			resetgame();
			// We erased all the td tag in the table except the first line and the first column
			notify_var.val += "calc_loop_board(function(tbl){\n";
			notify_var.val += "\tvar tds = tbl.getElementsByTagName('td');\n";
			notify_var.val += string_f("\tfor (var i=1; i<=%u; i++){\n",TBL_FIXED_LINES);
			notify_var.val += string_f("\t\tfor (var j=1; j<=%u; j++){\n",TBL_FIXED_COLUMNS);
			notify_var.val += string_f("\t\t\ttds[i*%u+j].innerHTML = '';\n",TBL_FIXED_COLUMNS+1);
			notify_var.val += "\t\t}\n";
			notify_var.val += "\t}\n";
			notify_var.val += "\tvar cols = tbl.getElementsByTagName('col');\n";
			notify_var.val += string_f("\tfor (var j=1; j<=%u; j++){\n",TBL_FIXED_COLUMNS);
			notify_var.val += string_f("\t\tcols[j].style.minWidth='%upx';\n",DEFAULT_COL_WIDTH);
			notify_var.val += string_f("\t\tcols[j].style.maxWidth='%upx';\n",DEFAULT_COL_WIDTH);
			notify_var.val += "\t}\n";
			notify_var.val += "});\n";
			// Reset position of all users
			for (auto &p:prefs){
				p.second.offset_line = 0;
				p.second.offset_col = 0;
				p.second.cursor.line = 0;
				p.second.cursor.col = 0;
			}
			update_offsets (notify_var,ctx,pref);
			setmodified(ctx.username);
		}else if (strcmp(var,"inscolline")==0){
			if (strcmp(val,"inslines")==0){
				insert_line (notify_var,pref.cursor.line);
			}else if (strcmp(val,"inscolumns")==0){
				insert_col (notify_var,pref.cursor.col);
			}else if (strcmp(val,"dellines")==0){
				delete_line (notify_var,pref.cursor.line);
			}else if (strcmp(val,"delcolumns")==0){
				delete_col (notify_var,pref.cursor.col);
			}
			update_celledit (pref,script_var);
			setmodified(ctx.username);
			setfocus (script_var);
		}
		if (old_cursor != pref.cursor){
			notify_ids.insert(old_cursor);
			notify_ids.insert(pref.cursor);
			update_cellname (pref,script_var);
			update_celledit (pref,script_var);
			update_lines_cols (pref,old_cursor,pref.cursor,script_var);
		}
	}else{
		error = MSG_U(E_READONLYDOC,"You do not have write access to this document");
	}
	if (api_error.size() > 0){
		VARVAL var;
		var.var = VAR_ERROR;
		var.val = move(api_error);
		res.emplace_back(move(var));
	}
}
</mod>
void CALC::manyexec (
	const vector<VARVAL_receive> &steps,
	const DOC_CONTEXT &ctx,
	const DOC_UI_SPECS_receive &sp,
	vector<VARVAL> &res)
{
	string cur_whi = string_f("calc_cur_gameid='%s';\n",gameid.c_str());
	VARVAL script_var;
	script_var.var = VAR_SCRIPT;
	script_var.val = cur_whi;
	VARVAL notify_var;
	notify_var.var = VAR_NOTIFY;
	notify_var.val = cur_whi;
	set<CELL_COOR> notify_ids;	// Lines to update using SCRIPT
	string error,status;
	for (auto &v:steps){
		execstep (v.var,v.val,ctx,sp,script_var,notify_var,notify_ids,res,error,status);
	}
	if (error.size() == 0){
		reset_eval();
		eval (notify_ids,error);
	}
	if (error.size() > 0){
		update_msg(false,error,"red",res);
	}else if (status.size() > 0){
		update_msg(true,status,"red",res);
	}else{
		update_msg(false,"&nbsp;","white",res);
	}
	update_cells(notify_ids,notify_var);
	if (notify_var.val != cur_whi) res.emplace_back(move(notify_var));
	if (script_var.val != cur_whi) res.emplace_back(move(script_var));
}
