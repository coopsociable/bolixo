/*
	Publish content to other bolixo nodes
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <errno.h>
#include <syslog.h>
#include <unistd.h>
#include <tlmpsql.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <trlitool.h>
#include <deque>
#include <memory>
#include <string>
#include "bolixo.h"
#include "bolixo.m"


using namespace std;
static DEBUG_KEY D_PROTO ("proto","Protocol information");

enum CONNECT_TYPE { TYPE_NONE, TYPE_CONTROL, TYPE_CLIENT, TYPE_WORKER};

struct HANDLE_INFO: public ARRAY_OBJ{
	CONNECT_TYPE type;
	REQUEST_INFO req;
	HANDLE_INFO(){
		type = TYPE_NONE;
	}
};
#include "proto/publishd_control.protoh"
#include "proto/publishd_client.protoh"

struct MESSAGE{
	string user;
	unsigned userid;
	unsigned dirid;
	unsigned fileid;
	string modified;
	MESSAGE(const char *_user, unsigned _userid, unsigned _dirid, unsigned _fileid, const char *_modified){
		user = _user;
		userid = _userid;
		dirid = _dirid;
		fileid = _fileid;
		modified = _modified;
	}
	MESSAGE(){
		userid = (unsigned)-1;
		dirid  = (unsigned)-1;
		fileid = (unsigned)-1;
	}
};

<mod>
static void publishd_doone (
	_F_TCPSERVER_V1 &c,
	pid_t &pid,
	deque<MESSAGE> &messages)
{
	if (messages.size() > 0){
		int tb[2];
		if (pipe(tb)==-1){
			tlmp_error ("Can't setup pipe (%s)\n",strerror(errno));
		}else{
			glocal MESSAGE todo = messages.front();
			messages.pop_front();
			pid = fork();
			if (pid == (pid_t)0){
				// Do the job
				close (tb[0]);
				<call sql_query>("select nodename from interests_remote where userid=%u",glocal.todo.userid);
				<f onerow>
					tlmp_error ("nodename=%s\n",row[0]);
				</f>
				</call>
				_exit (0);
			}else if (pid == (pid_t)-1){
				tlmp_error ("Can't fork (%s)\n",strerror(errno));
			}else{
				HANDLE_INFO *n = new HANDLE_INFO;
				n->type = TYPE_WORKER;
				c.inject (tb[0],n);
				close (tb[1]);
			}
		}
	}
}
</mod>
<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *data_dbserv = "localhost";
	glocal const char *data_dbname = "files";
	glocal const char *data_dbuser = NULL;
	glocal const char *control = "/var/run/publishd.sock";
	glocal const char *clientsock = "/tmp/publishd_client.sock";
	glocal const char *user = "bolixo";
	glocal bool daemon = false;
	glocal const char *admin_secretfile = "/etc/bolixo/secrets.admin";
	glocal const char *pidfile = "/var/run/publishd.pid";
	static const char *tbdic[]={"bolixo","tlmpsql",NULL};
	glocal.ret = <call tlmpprogram>(argc,argv,tbdic);
	<f init>
		setproginfo ("publishd",VERSION,"Spread user messages to other bolixo nodes");
		setgrouparg ("Networking");
		setarg ('c',"control","Unix socket for publishd-control",glocal.control,false);
		setarg ('C',"clientsock","Unix socket for publishd-client",glocal.clientsock,false);
		setgrouparg ("Database");
		setarg (' ',"dbserv","Database server",glocal.data_dbserv,false);
		setarg (' ',"dbname","Database name",glocal.data_dbname,false);
		setarg (' ',"dbuser","Database user",glocal.data_dbuser,true);
		setgrouparg ("Misc.");
		setarg (' ',"admin_secrets",MSG_R(O_ADMINSECRETS),glocal.admin_secretfile,false);
		setarg (' ',"user","Run the program as this user",glocal.user,false);
		setarg (' ',"daemon","Run in background",glocal.daemon,false);
		setarg (' ',"pidfile","FIle holding the PID of the process",glocal.pidfile,false);
	</f>
	<f showerror>
		if (glocal.daemon){
			syslog (LOG_ERR,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f showwarn>
		if (glocal.daemon){
			syslog (LOG_WARNING,"%s",msg);
		}else{
			fprintf (stderr,"%s",msg);
		}
	</f>
	<f main_noarg>
		int ret = -1;
		glocal string controlport = string_f("unix:%s",glocal.control);
		glocal string clientport = string_f("unix:%s",glocal.clientsock);
		glocal deque<MESSAGE> messages;
		glocal map<string,string> admin_secrets;
		glocal pid_t pid = (pid_t)-1;
		const char *passwd = getenv("PUBLISHD_PWD");
		if (passwd == NULL){
			tlmp_error ("Can't get database password from environment, aborting\n");
			exit (-1);
		} 
		fdpass_readsecrets (glocal.admin_secretfile,glocal.admin_secrets);
		query_setdefaultdb (glocal.data_dbserv,glocal.data_dbname,glocal.data_dbuser,passwd);
		query_getdefaultdb()->showerrormode(true);
		<obj TCPSERVER s>(glocal.clientport,5);
		<f newclient>
			HANDLE_INFO *n = new HANDLE_INFO;
			info.data = n;
			// tlmp_error ("port=%s control=%s client=%s\n",info.port,glocal.controlport.c_str(),glocal.clientport.c_str());
			if (string_cmp(info.port,glocal.controlport)==0){
				n->type = TYPE_CONTROL;
			}else if (string_cmp(info.port,glocal.clientport)==0){
				n->req.secret = fdpass_findsecret (glocal.admin_secrets,info.port);
				n->type = TYPE_CLIENT;
			}
		</f>
		<f endclient>
			HANDLE_INFO *n = (HANDLE_INFO*)info.data;
			if (n->type == TYPE_WORKER){
				glocal.pid = (pid_t)-1;
				publishd_doone(*this,glocal.pid,glocal.messages);
			}
		</f>
		<f receive>
			debug_printf (D_PROTO,"receive line: %s\n",line);
			HANDLE_INFO *c = (HANDLE_INFO*)info.data;
			static const char *tbtype[]={"none","control request","client request", "worker request"};
			ERROR_PREFIX prefix ("%s: ",tbtype[c->type]);
			if (c->type == TYPE_CONTROL){
				<call publishd_control>(this,c->req,line, info.linelen,endserver, endclient, no,c);
				<f status>
					vector<string> tb;
					tb.push_back(string_f ("Version %s",VERSION));
					tb.push_back(string_f("messages size: %lu",glocal.messages.size()));
					tb.push_back(string_f("sub-process: %s",glocal.pid == (pid_t)-1 ? "not running" : "running"));
					rep_status(tb);
				</f>
				<f quit>
					endserver = true;
				</f>
				<f debug>
					if (on){
						debug_seton();
					}else{
						debug_setoff();
					}
				</f>
				<f debugfile>
					debug_setfdebug (filename);
				</f>
				<f help_connect> // connectto port send = lines:v
					glocal const char *send = send;
					glocal vector<string> lines;
					// We want to test publishd connectivity to the outside
					<call tcpconnect>(connectto,port,5);
					<f init>
						sendf ("%s\n",glocal.send);
					</f>
					<f oneline>
						glocal.lines.push_back(line);
						end = true;
					</f>
					<f fail>
						glocal.lines.emplace_back(string_f("fail: %s\n",strerror(errno)));
					</f>
					<f end>
					</f>
					</call>
					rep_help_connect (glocal.lines);
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}else if (c->type == TYPE_CLIENT){
				<call publishd_client>(this,c->req,line,info.linelen, endserver, endclient,no,c);
				<f test>
					glocal bool dbfiles = false;
					glocal bool fsok = file_type(testfile)==0;
					if (glocal.fsok && unlink(testfile)!= -1) glocal.fsok = false;
					<call sql_query>("select count(*) from id2name");
					<f onerow>
						glocal.dbfiles=true;
					</f>
					</call>
					rep_test (glocal.dbfiles,glocal.fsok);
				</f>
				<f sendmessage>
					glocal bool public_view = false;
					tlmp_error ("sendmessage userid=%u dirid=%u fileid=%u modified=%s\n",userid,dirid,fileid,modified);
					<call sql_query>("select public_view from config where userid=%u",userid);
					<f onerow>
						glocal.public_view = atoi(row[0]);
					</f>
					</call>
					if (glocal.public_view){
						glocal string user;
						<call sql_query>("select name from id2name where userid=%u",userid);
						<f onerow>
							glocal.user = row[0];
						</f>
						</call>
						if (glocal.user.size()==0){
							tlmp_error ("No user for userid=%u\n",userid);
						}else{
							glocal.messages.emplace_back(MESSAGE(glocal.user.c_str(),userid,dirid,fileid,modified));
							if (glocal.pid == (pid_t)-1){
								publishd_doone (glocal.TCPSERVER,glocal.pid,glocal.messages);
							}
						}
					}	
					rep_sendmessage (false,"not done");
				</f>
				<f invalid>
					tlmp_error ("Invalid command: %s\n",line);
					endclient = true;
				</f>
				</call>
			}
		</f>
		</obj>
		bool some_errors = false;
		if (fdpass_setcontrol(s,glocal.control,glocal.user)==-1){
			some_errors = true;
		}

		if (!some_errors && s.is_ok()){
			chmod (glocal.clientsock,0666);
			s.setrawmode(true);
			if (glocal.daemon){
				daemon_init(glocal.pidfile,glocal.user);
			}
			s.loop();
			ret = 0;
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

