/*
	This file is part of Bolixo.

	Bolixo is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Bolixo is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Bolixo.  If not, see <https://www.gnu.org/licenses/>.
*/
/*
	Command line tool to control bo-sessiond
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlmplib.h>
#include <tlmpnet.h>
#include <string>
#include <trlitool.h>
#include "bolixo.m"

using namespace std;

#include "proto/bo-sessiond_control.protoch"

<mod>
int main (int argc, char *argv[])
{
	glocal int ret = -1;
	glocal const char *control = "/var/run/bo-sessiond.sock";
	glocal.ret = <call tlmpprogram>(argc,argv,"bolixo");
	<f init>
		setproginfo ("bo-sessiond-control",VERSION
			,"Command line tool to control bo-sessiond\n"
			 "\n"
			 "\tdebug 0/1\n"
			 "\tdebugfile filename\n"
			 "\teraseold time anonymous normaluser adminuser\n"
			 "\t\ttime is a number followed by d for days, h for hours, m for minutes, s for seconds\n"
			 "\tinstrument 0|1\n"
			 "\tlistsessions offset nb\n"
			 "\tresetnotifies\n"
			 "\tstuffsessions nb\n"
			 "\tquit\n"
			 "\tstatus\n"
			);
		setarg ('p',"control","Unix socket to reach sessiond",glocal.control,false);
	</f>
	<f main>
		int ret = -1;
		CONNECT_INFO con;
		con.port = glocal.control;
		if (strcmp(argv[0],"status")==0 && argc==1){
			<call bo_sessiond_control_status>(con);
			<f ok>
				for (auto x:lines) printf ("%s\n",x);
			</f>
			</call>
		}else if (strcmp(argv[0],"quit")==0 && argc==1){
			<call bo_sessiond_control_quit>(con);
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"listsessions")==0 && argc==3){
			<call bo_sessiond_control_listsessions>(con,atoi(argv[1]),atoi(argv[2]));
			<f ok>
				for (auto x:lines) printf ("%s\n",x);
			</f>
			</call>
		}else if (strcmp(argv[0],"resetnotifies")==0 && argc==1){
			<call bo_sessiond_control_resetnotifies>(con);
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"stuffsessions")==0 && argc==2){
			<call bo_sessiond_control_stuffsessions>(con,atoi(argv[1]));
			<f ok>
				printf ("total=%u\n",total);
			</f>
			</call>
		}else if (strcmp(argv[0],"eraseold")==0 && argc==5){
			unsigned old = atoi(argv[1]);
			const char *pt = str_skipdig(argv[1]);
			char letter = tolower(*pt);
			if (letter == 'd'){
				old *= 24*60*60;
			}else if (letter == 'h'){
				old *= 60*60;
			}else if (letter == 'm'){
				old *= 60;
			}else if (letter != 's'){
				tlmp_error (MSG_U(E_EXPECTDHMS,"Expect suffix d h m or s for duration, aborting\n"));
				exit (-1);
			}
			<call bo_sessiond_control_eraseold>(con,old,atoi(argv[2]),atoi(argv[3]),atoi(argv[4]));
			<f ok>
				printf ("deletedanon=%u deleteduser=%u deletedadmin=%u\n",deletedanon,deleteduser,deletedadmin);
			</f>
			</call>
		}else if (strcmp(argv[0],"debug")==0 && argc==2){
			<call bo_sessiond_control_debug>(con,atoi(argv[1]));
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"debugfile")==0 && argc==2){
			<call bo_sessiond_control_debugfile>(con,argv[1]);
			<f ok>
			</f>
			</call>
		}else if (strcmp(argv[0],"instrument")==0 && argc==2){
			<call bo_sessiond_control_instrument>(con,atoi(argv[1]));
			<f ok>
			</f>
			</call>
		}else{
			tlmp_error ("Invalid command: %s\n",argv[0]);
			usage();
		}
		return ret;
	</f>
	</call>
	return glocal.ret;
}
</mod>

