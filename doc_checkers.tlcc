#include <string.h>
#include <stdio.h>
#include <trlitool.h>
#include <string>
#include <vector>
#include <map>
#include <tlmplib.h>
#include "bolixo.h"
#include "proto/bod_client.protodef"
#include "documentd.h"
#include "bolixo.m"

using namespace std;

#include "proto/documentd_checkers.protoh"
#include "proto/documentd_checkers.protoch"


void CHECKERS::save(DOC_WRITER &w, bool save_session_info)
{
	documentd_checkers_header (&w,revision,player1_playing,nbcol);
	PLAYER p1,p2;
	p1.name = player1.name;
	p1.line = player1.line;
	p1.col  = player1.col;
	p1.onemove = player1.onemove;
	p2.name = player2.name;
	p2.line = player2.line;
	p2.col  = player2.col;
	p2.onemove = player2.onemove;
	documentd_checkers_players(&w,p1,p2);
	vector<unsigned> cells;
	for (auto &g:grid) for (auto &gg:g) cells.push_back(gg);
	documentd_checkers_cells(&w,cells);
	if (save_session_info){
		for (auto &s:sessions){
			documentd_checkers_session (&w,s.first,s.second);
		}
	}
}
<mod>
void CHECKERS::load(DOC_READER &r, string &msg)
{
	glocal msg;
	glocal revision;
	glocal nbcol;
	glocal player1_playing;
	glocal grid;
	glocal player1;
	glocal player2;
	glocal sessions;
	glocal unsigned max_grid_size = MAX_GRID_SIZE;
	resetgame();
	sessions.clear();
	<call documentd_checkers>(&r);
	<f header>
		glocal.revision = revision;
		glocal.nbcol = nbcol;
		glocal.player1_playing = player1_playing;
	</f>
	<f players>
		glocal.player1.name = player1.name;
		glocal.player1.line = player1.line;
		glocal.player1.col = player1.col;
		glocal.player1.onemove = player1.onemove;
		glocal.player2.name = player2.name;
		glocal.player2.line = player2.line;
		glocal.player2.col = player2.col;
		glocal.player2.onemove = player2.onemove;
	</f>
	<f cells>
		unsigned line = 0;
		unsigned col = 0;
		for (auto &c:cells){
			glocal.grid[line][col] = c;
			col++;
			if (col == glocal.max_grid_size){
				line++;
				col = 0;
			}
		}
	</f>
	<f session>
		glocal.sessions[session] = reverse;
	</f>
	<f invalid>
		glocal.msg = "Invalid format for sudoku file";
	</f>
	</call>
}
</mod>
enum CELLSTATE { NOTUSED,PLAYER1,PLAYER2,WHITE};
void CHECKERS::resetgame()
{
	player1_playing = true;
	player1.line = player1.col = 10;
	player2.line = player2.col = 10;
	for (auto &g:grid) for (auto &gg:g) gg=NOTUSED;
	// We block the white cells
	for (unsigned i=0; i<MAX_GRID_SIZE; i++){
		for (unsigned j=(i&1); j<MAX_GRID_SIZE; j+=2){
			grid[i][j] = WHITE;
		}
	}
	// We populate the first 3 rows on each side
	unsigned nbrows = 3;
	unsigned offy = 5;
	if (nbcol == 10){
		nbrows = 4;
		offy = 6;
	}
	for (unsigned i=0; i<nbrows; i++){
		unsigned start = (i+1)&1;
		for (unsigned j=start; j<MAX_GRID_SIZE; j+=2){
			grid[i][j] = PLAYER1;
		}
		unsigned ii=offy+i;
		if (nbcol == 8) start = i&1;
		for (unsigned j=start; j<MAX_GRID_SIZE; j+=2){
			grid[ii][j] = PLAYER2;
		}
	}
}
void CHECKERS::testwin(vector<VARVAL> &res)
{
	unsigned nbcell1=0,nbcell2=0;
	for (auto &g:grid) for (auto &gg:g){
		if (gg == PLAYER1){
			nbcell1++;
		}else if (gg == PLAYER2){
			nbcell2++;
		}
	}
	if (nbcell1 == 0 || nbcell2 == 0){
		message = MSG_R(I_WON);
	}
}

void CHECKERS::update_msg (PARAM_STRING msg, const char *color, vector<VARVAL> &res)
{
	message = msg.ptr;
}
		
static void print_player(string &lines, PARAM_STRING gameid, PARAM_STRING name, unsigned playernum, const char *player_color, bool playing, bool mobile)
{
	const char *color = playing ? "lightblue" : "white";
	unsigned margin = 5;
	unsigned width=150;
	if (mobile){
		width = 250;
		margin = 10;
	}
	lines += string_f("<div id=player%u-%s onmousedown=playersel(event,%u)"
		" style='flex:0 0 %upx; overflow: hidden; background-color:%s; border: 2px solid %s; margin-bottom:%upx; margin-top:%upx; margin-left:%upx; padding: 10px'>\n"
		,playernum,gameid.ptr,playernum,width,color,player_color,margin,margin,margin);
	lines += string_f("%s\n",name.ptr);
	lines += "</div>\n";
}
void CHECKERS::exec (
	const char *var,
	const char *val,
	const char *session,
	const char *username,
	bool maywrite,
	unsigned win_width,
	unsigned win_height,
	bool mobile,
	vector<VARVAL> &res)
{
	string error;
	setactivity();
	if (player1.name.size() == 0){
		player1.name = username;
	}else if (player2.name.size() == 0){
		player2.name = username;
	}	
	bool reverse = sessions[session];
	tlmp_warning ("var=%s val=%s",var,val);
	if (strcmp(var,"print")==0){
		string lines;
		if (strcmp(val,"console")==0){
			//static const char *white = "\033[01;37m";
			//static const char *green = "\033[01;32m";
			//static const char *blue = "\033[01;34m";
			//static const char *red = "\033[01;31m";
			static const char *bgblue = "\033[01;44m";
			static const char *bggreen = "\033[01;42m";
			static const char *bgred = "\033[01;41m";
			static const char *bgblack = "\033[01;40m";
			static const char *normal = "\033[00m";
			static const char *tbcolor[]={bgblack,bgblue};
			unsigned nol = 0;
			for (auto &g:grid){
				static const char *tbl[]={
					"%s    %s  %s    ",
					"%s  %s      %s  ",
					"%s %s        %s ",
					"%s  %s      %s  ",
					"%s    %s  %s    ",
					//"%s          ",
				};
				for (unsigned i=0; i<5; i++){
					unsigned color = nol & 1;
					if (i == 2){
						lines += string_f("\t%d ",8-nol);
					}else{
						lines += "\t  ";
					}
					for (auto &gg:g){
						const char *bg = tbcolor[color];
						color = (color+1)&1;
						const char *bg1 = "";
						if (gg == 0){
							bg1 = bg;
						}else if (gg == 1){
							bg1 = bgred;
						}else if (gg == 2){
							bg1 = bggreen;
						}
						lines += string_f(tbl[i],bg,bg1,bg);
					}
					lines += normal;
					lines += '\n';
				}
				nol++;
			}	
			lines += "\t  ";
			for (unsigned i=0; i<8; i++) lines += string_f("    %c     ",i+'A');
			lines += '\n';
		}else{
			// The layout is a square, constrained by the width
			unsigned dim = win_width < win_height ? win_width : win_height;
			unsigned width = dim - dim % nbcol -20;
			unsigned w8 = width/(nbcol+1);
			unsigned h8 = w8; 
			unsigned grid_width = w8*nbcol;
			unsigned grid_height = w8*nbcol;
			
			lines += "<script>\n";
			lines += "function gameplace(event){\n";
			lines += string_f("\tvar elm = document.getElementById('grid-%s');\n",gameid.c_str());
			lines += "\tvar rect = elm.getBoundingClientRect();\n";
			lines += string_f("\tgameaction('place:'+Math.floor((event.clientY-rect.top)/%u)+','+Math.floor((event.clientX-rect.left)/%u)+ ','+event.which);\n",h8,w8);
			lines += "\tevent.stopPropagation();\n";
			lines += "}\n";
			lines += "function playersel(event,num){\n";
			lines += "\tgameaction('playersel:'+num);\n";
			lines += "\tevent.stopPropagation();\n";
			lines += "}\n";
			lines += "function gamereverse(event){\n";
			lines += "\tgameaction('reverse:');\n";
			lines += "\tevent.stopPropagation();\n";
			lines += "}\n";
			lines += "</script>\n";
			
			lines += "<div style='display:flex; flex-flow:row;'>\n";
			lines += "<div style='flex:0 0 250px; overflow: hidden; margin-top:10px;'>\n";
			lines += string_f("<form id='form-%s'>\n",gameid.c_str());
			if (!mobile) lines += MSG_R(I_NEWGAME);
			documentd_button (lines,0,MSG_U(I_8_8,"8 X 8"),nbcol==8);
			documentd_button (lines,1,MSG_U(I_10_10,"10 X 10"),nbcol==10);
			lines += "</form>\n";
			lines += "</div>\n";
			print_player(lines,gameid,player1.name,0,"black",player1_playing,mobile);
			print_player(lines,gameid,player2.name,1,"red",!player1_playing,mobile);
			lines += "</div>\n";
			lines += "<div style='display:flex; flex-flow:row;'>\n";
			lines += "<div style='flex:0 0 25px; overflow: hidden; color:blue;cursor:pointer; border: 1px solid black; background-color: lightgray;'"
				" onmousedown='gamereverse(event); return false;'>\n";
			lines += "RR";
			lines += "</div>\n";
			lines += "<div style='flex:1 1 auto; overflow: hidden;' onmousedown='gameplace(event); return false;' style=color:blue;cursor:pointer>\n";
			lines += "&nbsp;&nbsp;\n";
			lines += string_f("<svg id='grid-%s' width='%upx' height='%upx' viewbox='0 0 %u %u'>\n",gameid.c_str(),grid_width,grid_height,grid_width,grid_height);
			unsigned w8_2 = w8/2;
			unsigned h8_2 = h8/2;
			unsigned circle_radius = h8_2 - h8/10;
			lines += string_f("<path stroke='green' stroke-width='2' fill='white' d='M%u %u H %u V %u H %u Z'/>\n"
				,0,0,grid_width-1,grid_height-1,0);
			for (unsigned vline=0; vline<nbcol; vline++){
				lines += string_f("<path stroke=%s stroke-width=1 d='M%u,%u H %u'/>\n","lightgray"
					,0,h8*vline,grid_width);
				unsigned line = reverse ? (nbcol-1-vline) : vline;
				unsigned l1 = line & 1;
				for (unsigned col=0; col<nbcol; col++){
					unsigned w8_col = w8*col;
					unsigned h8_line = h8*vline;
					lines += string_f("<path stroke=%s stroke-width=1 d='M%u,%u V %u'/>\n","lightgray"
						,w8*col,0,grid_height);
					if ((l1+col)&1){
						lines += string_f("<path stroke='black' stroke-width=1 d='M%u,%u h %u v %u h -%u Z' fill='lightgray'/>\n"
							,w8*col,h8*vline,w8,h8,w8);
					}
					unsigned cell = grid[line][col];
					const char *fill_color = "none";
					const char *stroke_color = "none";
					const char *select_color = "none";
					if (cell == PLAYER1 || cell == PLAYER2){
						fill_color = cell==PLAYER1 ? "black" : "red";
						stroke_color = "black";
						if (player1.col == col && player1.line == line){
							select_color = "blue";
						}else if (player2.col == col && player2.line == line){
							select_color = "yellow";
						}
					}
					lines += string_f("<circle id='c%u,%u' cx=%u cy=%u r=%u stroke='%s' stroke-width=2 fill='%s'/>\n"
						,line,col,w8_col+w8_2,h8_line+h8_2,circle_radius,stroke_color,fill_color);
					lines += string_f("<circle id='cs%u,%u' cx=%u cy=%u r=%u stroke='%s' stroke-width=2 fill='%s'/>\n"
						,line,col,w8_col+w8_2,h8_line+h8_2,circle_radius-4,select_color,select_color);
				}
			}
			lines += "</svg>\n";
			lines += "</div>\n";
			lines += "</div>\n";
			lines += string_f("<div id=msg-%s style=color:blue>%s</div>\n",gameid.c_str(),message.c_str());
		}
		VARVAL v;
		v.var = VAR_CONTENT;
		v.val = lines;
		res.push_back(v);
	}else if (maywrite){
		VARVAL notify_var;
		notify_var.var = VAR_NOTIFY;
		if (strcmp(var,"place")==0){
			unsigned lo,co;
			int button;
			int n = sscanf(val,"%u,%u,%d",&lo,&co,&button);
			if (n == 3 && lo < nbcol && co < nbcol && is_any_of(button,1,2)){
				if (reverse) lo = nbcol -1 - lo;
				CHECKER_PLAYER *player = &player2;
				unsigned cell_val = PLAYER2;
				unsigned other_player = PLAYER1;
				int vmove = -1;
				if (player1_playing){
					player = &player1;
					cell_val = PLAYER1;
					other_player = PLAYER2;
					vmove = 1;
				}
				if (player->has_selected()){
					if (player->line == lo && player->col == co){
						// The player is unselecting the cell
						if (player->onemove){
							player1_playing = !player1_playing;
							js_find_set(notify_var.val,"player0","style.backgroundColor",player1_playing ? "lightblue" : "white");
							js_find_set(notify_var.val,"player1","style.backgroundColor",!player1_playing ? "lightblue" : "white");
						}
						string id = string_f("cs%u,%u",lo,co);
						js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill","none","style.stroke","none");
						player->reset();
					}else{
						int left_col = player->col - 1;
						int right_col = player->col + 1;
						int next_line = player->line + vmove;
						int left_col2 = player->col - 2;
						int right_col2 = player->col + 2;
						int next_line2 = player->line + vmove + vmove;
						unsigned char &cell = grid[lo][co];
						bool move_ok = false;
						bool keep_playing = false;
						if (cell != 0){
							if (cell == WHITE){
								error = MSG_U(E_CANTGOTHERE,"You are not allowed to move to white cell");
							}else if (cell == cell_val){
								error = MSG_U(E_NOJUMPONYOU,"You can't stack coins");
							}else{
								error = MSG_U(E_NOJUMPONOTHER,"You can't jump on the other player coin");
							}
						}else if ((int)lo == next_line && ((int)co == left_col || (int)co == right_col)){	
							// Move the an available next cell
							move_ok = true;
						}else if ((int)lo == next_line2){
							// Move over a player coin
							unsigned erase_col = 0;
							if ((int)co == left_col2 && grid[next_line][left_col] == other_player){
								move_ok = true;
								grid[next_line][left_col] = NOTUSED;
								erase_col = left_col;
							}else if ((int)co == right_col2 && grid[next_line][right_col] == other_player){	
								move_ok = true;
								grid[next_line][right_col] = NOTUSED;
								erase_col = right_col;
							}
							if (move_ok){	// && (mobile || button == 2)){
								string id = string_f("c%u,%u",next_line,erase_col);
								js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill","none","style.stroke","none");
								keep_playing = true;
							}
						}
						if (move_ok){
							string id = string_f("c%u,%u",player->line,player->col);
							js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill","none","style.stroke","none");
							id = string_f("cs%u,%u",player->line,player->col);
							js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill","none","style.stroke","none");
							id = string_f("c%u,%u",lo,co);
							js_find_loop_set (notify_var.val,"grid","circle",id
								,"style.fill",player1_playing ? "black" : "red","style.stroke","black");
							grid[player->line][player->col] = NOTUSED;
							cell = cell_val;
							setmodified (username);
							if (keep_playing){
								player->line = lo;
								player->col = co;
								player->onemove = true;
								id = string_f("cs%u,%u",lo,co);
								const char *color = player1_playing ? "blue" : "yellow";
								js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill",color,"style.stroke",color);
							}else{
								player->reset();
								player1_playing = !player1_playing;
								js_find_set(notify_var.val,"player0","style.backgroundColor",player1_playing ? "lightblue" : "white");
								js_find_set(notify_var.val,"player1","style.backgroundColor",!player1_playing ? "lightblue" : "white");
							}
						}else if (error.size() == 0){
							error = MSG_U(E_IVLDMOVE,"Invalid move");
						}
					}
				}else if (grid[lo][co] == cell_val){
					// The player is about to move that piece
					player->col = co;
					player->line = lo;
					const char *color = player1_playing ? "blue" : "yellow";
					string id = string_f("cs%u,%u",lo,co);
					js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill",color,"style.stroke",color);
				}else{
					documentd_error (res,"Can't select this cell");
				}
			}else{
				tlmp_error ("checkers, invalid place command: %s",val);
			}
		}else if (strcmp(var,"newgame")==0){
			int uval = atoi(val);
			if (is_any_of(uval,0,1)){
				nbcol = uval == 0 ? 8 : 10;
				resetgame();
				for (unsigned i=0; i<nbcol; i++){
					for (unsigned j=0; j<nbcol; j++){
						unsigned char cell = grid[i][j];
						string id = string_f("c%u,%u",i,j);
						const char *fill_color = "none";
						const char *stroke_color = "none";
						if (cell == PLAYER1){
							fill_color = "black";
							stroke_color = "black";
						}else if (cell == PLAYER2){
							fill_color = "red";
							stroke_color = "black";
						}
						js_find_loop_set (notify_var.val,"grid","circle",id,"style.fill",fill_color,"style.stroke",stroke_color);
					}
				}
				js_find_loop_set (notify_var.val,"form","input","button0","style.background",nbcol==8 ? "lightblue" : "lightgray");
				js_find_loop_set (notify_var.val,"form","input","button1","style.background",nbcol==10 ? "lightblue" : "lightgray");
				js_find_set(notify_var.val,"player0","style.backgroundColor","lightblue");
				js_find_set(notify_var.val,"player1","style.backgroundColor","white");
				documentd_forcerefresh(res);
			}else{
				tlmp_error ("checkers newgame=%d",uval);
			}
		}else if (strcmp(var,"playersel")==0){
			CHECKER_PLAYER *player = &player1;
			if (strcmp(val,"1")==0){
				player = &player2;
			}
			player->name = username;
			js_find_set(notify_var.val,"player0","innerHTML",player1.name.c_str());
			js_find_set(notify_var.val,"player1","innerHTML",player2.name.c_str());
		}else if (strcmp(var,"reverse")==0){
			sessions[session] = !reverse;
			documentd_forcerefresh(res);
		}
		res.emplace_back(notify_var);
	}else{
	}
	if (error.size() > 0){
		update_msg(error,"red",res);
	}else{
		update_msg("","white",res);
	}
}


